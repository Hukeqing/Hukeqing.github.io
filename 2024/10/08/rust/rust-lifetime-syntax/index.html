<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/image/default/favicon.ico"><link rel="icon" href="/image/default/favicon.ico"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Shiroha"><meta name="keywords" content="ACM,算法,计算机,程序"><meta name="description" content="Rust 中常见的有关生命周期的误解"><meta property="og:type" content="article"><meta property="og:title" content="【转载】Rust 中常见的有关生命周期的误解"><meta property="og:url" content="https://blog.mauve.icu/2024/10/08/rust/rust-lifetime-syntax/"><meta property="og:site_name" content="Shiroha白羽的博客"><meta property="og:description" content="Rust 中常见的有关生命周期的误解"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2024-10-08T15:15:49.000Z"><meta property="article:modified_time" content="2024-10-08T15:15:49.000Z"><meta property="article:author" content="Shiroha"><meta property="article:tag" content="Rust"><meta name="twitter:card" content="summary_large_image"><meta name="referrer" content="no-referrer-when-downgrade"><title>【转载】Rust 中常见的有关生命周期的误解 - Shiroha白羽的博客</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4225917_qrl3b9uej4.css"><link rel="stylesheet" href="/font/Blueaka/Blueaka.css"><link rel="stylesheet" href="/font/Blueaka_Bold/Blueaka_Bold.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"blog.mauve.icu",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:70,cursorChar:"|",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:"§"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/image/default/mona-loading-dark.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:"G-N2HYL7N8TD",tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},gtag:"G-N2HYL7N8TD"},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=",(function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","")}))</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/rss.xml" title="Shiroha白羽的博客" type="application/atom+xml">
</head><body><header><div class="header-inner" style="height:80vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Mauve</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>Home</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-category-fill"></i> <span>分类</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/categories/ACM-%E7%AE%97%E6%B3%95/" target="_self"><span>ACM-算法</span> </a><a class="dropdown-item" href="/categories/%E5%AD%A6%E4%B9%A0-%E5%BC%80%E5%8F%91-%E5%AE%9E%E7%8E%B0" target="_self"><span>学习-开发-实现</span> </a><a class="dropdown-item" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0" target="_self"><span>学习笔记</span> </a><a class="dropdown-item" href="/categories/%E6%9D%82%E9%A1%B9" target="_self"><span>杂项</span></a></div></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>好友</span></a></li><li class="nav-item"><a class="nav-link" href="/rss.xml" target="_self"><i class="iconfont icon-rss"></i> <span>RSS</span></a></li><li class="nav-item"><a class="nav-link" href="https://www.travellings.cn/go.html" target="_self"><i class="iconfont icon-train"></i> <span>开往</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item"><a class="nav-link" href="/last/page" target="_self"><i class="iconfont icon-jieshu"></i> <span>终页</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/image/default/bg/BA_CG_View_Kivotos2.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="【转载】Rust 中常见的有关生命周期的误解"></span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> Shiroha </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2024-10-08 23:15" pubdate>2024年10月8日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i>9.5k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i>80 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> 浏览 <span id="busuanzi_value_page_pv"></span> 次</span></div></div><div class="scroll-down-bar"><i class="iconfont icon-arrowdown"></i></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">【转载】Rust 中常见的有关生命周期的误解</h1><div class="markdown-body"><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>Rust学习中最难的部分就是⽣命周期，很多⽣命周期规则衍⽣的复杂情况并没有在 TRPL 中得到介绍，因此本⽂的⽬的是想帮助Rust程序员打通⽣命周期的问题，同时也希望能为 modern C++ 程序员带来⼀些思考和启发。</p><p>本⽂中使⽤的术语可能并不那么官⽅，因此下⾯列出了⼀个表格，记录使⽤的短语及其想表达的含义。</p><div class="table-container"><table><thead><tr><th style="text-align:center">短语</th><th style="text-align:center">意义</th></tr></thead><tbody><tr><td style="text-align:center"><code>T</code></td><td style="text-align:center">1)所有可能类型的集合 <em>或</em> 2)上述集合中的某一个具体类型</td></tr><tr><td style="text-align:center">所有权类型</td><td style="text-align:center">某些非引用类型，其自身拥有所有权 例如 <code>i32</code>, <code>String</code>, <code>Vec</code> 等</td></tr><tr><td style="text-align:center">1)借用类型 <em>或</em> 2) 引用类型</td><td style="text-align:center">引用类型，不考虑可变性 例如 <code>&amp;i32</code>, <code>&amp;mut i32</code></td></tr><tr><td style="text-align:center">1)可变引用 <em>或</em> 2) 独占引用</td><td style="text-align:center">独占可变引用，即 <code>&amp;mut T</code></td></tr><tr><td style="text-align:center">1) 不可变引用 <em>或</em> 2) 共享引用</td><td style="text-align:center">可共享不可变引用，即 <code>&amp;T</code></td></tr></tbody></table></div><h1 id="2-误解"><a href="#2-误解" class="headerlink" title="2. 误解"></a>2. 误解</h1><p>简单来讲，⼀个变量的⽣命周期是指⼀段时期，在这段时期内，该变量所指向的内存地址中的数据是有效的，这段时期是由编译器静态分析得出的，有效性由编译器保证。接下来我将探讨这些常⻅误解的细节。</p><h2 id="1-T-只包含所有权类型"><a href="#1-T-只包含所有权类型" class="headerlink" title="1) T 只包含所有权类型"></a>1) <code>T</code> 只包含所有权类型</h2><p>这更像是对泛型的误解⽽⾮对⽣命周期的误解，但在 Rust 中，泛型与⽣命周期的关系是如此紧密，以⾄于不可能只讨论其中⼀个⽽忽视另外⼀个。当我刚开始学习 Rust 时，我知道 <code>i32</code> , <code>&amp;i32</code> , 和 <code>&amp;mut i32</code> 是不同的类型，同时我也知泛型 <code>T</code> 表示所有可能类型的集合。然⽽，尽管能分别理解这两个概念，但我却没能将⼆者结合起来。在当时我这位 Rust 初学者的眼⾥，泛型是这样运作的：</p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center"><code>T</code></th><th style="text-align:center"><code>&amp;T</code></th><th style="text-align:center"><code>&amp;mut T</code></th></tr></thead><tbody><tr><td style="text-align:center">例子</td><td style="text-align:center"><code>i32</code></td><td style="text-align:center"><code>&amp;i32</code></td><td style="text-align:center"><code>&amp;mut i32</code></td></tr></tbody></table></div><p>其中 <code>T</code> 包全体所有权类型；<code>&amp;T</code> 包括全体不可变引⽤； <code>&amp;mut T</code> 包括全体可变引⽤；<code>T</code>, <code>&amp;T</code>, 和 <code>&amp;mut T</code> 是不相交的有限集。简洁明了，符合直觉，却完全错误。事实上泛型是这样运作的：</p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center"><code>T</code></th><th style="text-align:center"><code>&amp;T</code></th><th style="text-align:center"><code>&amp;mut T</code></th></tr></thead><tbody><tr><td style="text-align:center">例子</td><td style="text-align:center"><code>i32</code>, <code>&amp;i32</code>, <code>&amp;mut i32</code>, <code>&amp;&amp;i32</code>, <code>&amp;mut &amp;mut i32</code></td><td style="text-align:center"><code>&amp;i32</code>, <code>&amp;&amp;i32</code>, <code>&amp;&amp;mut i32</code></td><td style="text-align:center"><code>&amp;mut i32</code>, <code>&amp;mut &amp;mut i32</code>, <code>&amp;mut &amp;i32</code></td></tr></tbody></table></div><p><code>T</code> , <code>&amp;T</code> , 和 <code>&amp;mut T</code> 都是⽆限集，因为你可以借⽤⼀个类型⽆限次。<code>T</code> 是 <code>&amp;T</code> 和 <code>&amp;mut T</code> 的超集。<code>&amp;T</code> 和 <code>&amp;mut T</code> 是不相交的集合. 下⾯有⼀些例⼦来验证这些概念：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Trait</span> &#123;&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Trait <span class="hljs-keyword">for</span> <span class="hljs-title class_">T</span> &#123;&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Trait <span class="hljs-keyword">for</span> &amp;T &#123;&#125; <span class="hljs-comment">// 编译错误</span><br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Trait <span class="hljs-keyword">for</span> &amp;<span class="hljs-keyword">mut</span> T &#123;&#125; <span class="hljs-comment">// 编译错误</span><br></code></pre></td></tr></table></figure><p>上述代码不能编译通过：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs text">error[E0119]: conflicting implementations of trait `Trait` for type `&amp;_`:<br> --&gt; src/lib.rs:5:1<br>  |<br>3 | impl&lt;T&gt; Trait for T &#123;&#125;<br>  | ------------------- first implementation here<br>4 |<br>5 | impl&lt;T&gt; Trait for &amp;T &#123;&#125;<br>  | ^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `&amp;_`<br><br>error[E0119]: conflicting implementations of trait `Trait` for type `&amp;mut _`:<br> --&gt; src/lib.rs:7:1<br>  |<br>3 | impl&lt;T&gt; Trait for T &#123;&#125;<br>  | ------------------- first implementation here<br>...<br>7 | impl&lt;T&gt; Trait for &amp;mut T &#123;&#125;<br>  | ^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `&amp;mut _`<br></code></pre></td></tr></table></figure><p>编译器不允许我们为 <code>&amp;T</code> 和 <code>&amp;mut T</code> 实现 Trait ，因为这与我们为 <code>T</code> 实现的 Trait 发⽣了冲突，⽽ <code>T</code> 已经包括了 <code>&amp;T</code> 和 <code>&amp;mut T</code>. 因为 <code>&amp;T</code> 和 <code>&amp;mut T</code> 是不相交的，所以下⾯的代码可以通过编译：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Trait</span> &#123;&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Trait <span class="hljs-keyword">for</span> &amp;T &#123;&#125; <span class="hljs-comment">// 编译通过</span><br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Trait <span class="hljs-keyword">for</span> &amp;<span class="hljs-keyword">mut</span> T &#123;&#125; <span class="hljs-comment">// 编译通过</span><br></code></pre></td></tr></table></figure><p>关键点回顾</p><ul><li><code>T</code> 是 <code>&amp;T</code> 和 <code>&amp;mut T</code> 的超集</li><li><code>&amp;T</code> 和 <code>&amp;mut T</code> 是不相交的集合</li></ul><h2 id="2-如果-T-39-static-那么-T-直到程序结束为⽌都⼀定是有效的"><a href="#2-如果-T-39-static-那么-T-直到程序结束为⽌都⼀定是有效的" class="headerlink" title="2) 如果 T: &#39;static 那么 T 直到程序结束为⽌都⼀定是有效的"></a>2) 如果 <code>T: &#39;static</code> 那么 <code>T</code> 直到程序结束为⽌都⼀定是有效的</h2><p>错误的推论</p><ul><li><code>T: &#39;static</code> 应该视为 “ <code>T</code> 有着 <code>&#39;static</code> ⽣命周期”</li><li><code>&amp;&#39;static T</code> 和 <code>T: &#39;static</code> 是⼀回事</li><li>若 <code>T: &#39;static</code> 则 <code>T</code> ⼀定是不可变的</li><li>若 <code>T: &#39;static</code> 则 <code>T</code> 只能在编译期创建</li></ul><p>让⼤多数 Rust 初学者第⼀次接触 <code>&#39;static</code> ⽣命周期注解的代码示例⼤概是这样的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">str_literal</span>: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span> = <span class="hljs-string">&quot;字符串字⾯量&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>他们被告知说 <code>&quot;字符串字⾯量&quot;</code> 是被硬编码到编译出来的⼆进制⽂件当中去的，并在运⾏时被加载到只读内存中，所以它不可变且在程序的整个运⾏期间都有效，这也使其⽣命周期为 <code>&#39;static</code>. 在了解到 Rust 使⽤ <code>static</code> 来定义静态变量这⼀语法后，这⼀观点还会被进⼀步加强。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> BYTES: [<span class="hljs-type">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> MUT_BYTES: [<span class="hljs-type">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    MUT_BYTES[<span class="hljs-number">0</span>] = <span class="hljs-number">99</span>; <span class="hljs-comment">// 编译错误，修改静态变量是 unsafe 的</span><br><br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        MUT_BYTES[<span class="hljs-number">0</span>] = <span class="hljs-number">99</span>;<br>        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">99</span>, MUT_BYTES[<span class="hljs-number">0</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于静态变量</p><ul><li>它们只能在编译期创建</li><li>它们应当是不可变的，修改静态变量是 unsafe 的</li><li>它们在整个程序运⾏期间有效</li></ul><p>静态变量的默认⽣命周期很有可能是 <code>&#39;static</code>, 对吧？所以可以合理推测 <code>&#39;static</code> ⽣命周期也要遵循同样的规则，对吧？</p><p>确实，但 持有 <code>&#39;static</code> ⽣命周期注解的类型和⼀个满⾜ <code>&#39;static</code> 约束 的类型是不⼀样的。后者可以于<strong>运⾏时被动态分配</strong>，能被安全⾃由地修改，也可以被 drop, 还能存活任意的时⻓。区分 <code>&amp;&#39;static T</code> 和 <code>T: &#39;static</code> 是⾮常重要的⼀点。<code>&amp;&#39;static T</code> 是⼀个指向 <code>T</code> 的不可变引⽤，其中 <code>T</code> 可以被安全地⽆期限地持有，甚⾄可以直到程序结束。这只有在 <code>T</code> ⾃身不可变且保证 在引⽤创建后 不会被 move 时才有可能。<code>T</code> 并不需要在编译时创建。我们可以以内存泄漏为代价，在运⾏时动态创建随机数据，并返回其 <code>&#39;static</code> 引⽤，⽐如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> rand;<br><br><span class="hljs-comment">// 在运⾏时⽣成随机 &amp;&#x27;static str</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">rand_str_generator</span>() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rand_string</span> = rand::random::&lt;<span class="hljs-type">u64</span>&gt;().<span class="hljs-title function_ invoke__">to_string</span>();<br>    <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">leak</span>(rand_string.<span class="hljs-title function_ invoke__">into_boxed_str</span>())<br>&#125;<br></code></pre></td></tr></table></figure><p><code>T: &#39;static</code> 是指 <code>T</code> 可以被安全地⽆期限地持有，甚⾄可以直到程序结束。 <code>T: &#39;static</code> 在包括了全部 <code>&amp;&#39;static T</code> 的同时，还包括了全部所有权类型， ⽐如 <code>String</code>, <code>Vec</code> 等等。 数据的所有者保证，只要⾃身还持有数据的所有权，数据就不会失效，因此所有者能够安全地⽆期限地持有其数据，甚⾄可以直到程序结束。 <code>T: &#39;static</code> 应当视为 “ <code>T</code> 满⾜ <code>&#39;static</code> ⽣命周期约束” ⽽⾮ “ <code>T</code> 有着 <code>&#39;static</code> ⽣命周期”。 ⼀个程序可以帮助阐述这些概念：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop_static</span>&lt;T: <span class="hljs-symbol">&#x27;static</span>&gt;(t: T) &#123;<br>    std::mem::<span class="hljs-title function_ invoke__">drop</span>(t);<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">strings</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt; = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">10</span> &#123; <br>        <span class="hljs-keyword">if</span> rand::<span class="hljs-title function_ invoke__">random</span>() &#123;<br>            <span class="hljs-comment">// 所有字符串都是随机⽣成的</span><br>            <span class="hljs-comment">// 并且在运⾏时动态分配</span><br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">string</span> = rand::random::&lt;<span class="hljs-type">u64</span>&gt;().<span class="hljs-title function_ invoke__">to_string</span>();<br>            <span class="hljs-comment">// strings获取了string的所有权</span><br>            strings.<span class="hljs-title function_ invoke__">push</span>(string);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 这些字符串是所有权类型，所以他们满⾜ &#x27;static ⽣命周期约束</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-title class_">mut</span> string <span class="hljs-keyword">in</span> strings &#123;<br>        <span class="hljs-comment">// 这些字符串是可变的</span><br>        string.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot;a mutation&quot;</span>);<br>        <span class="hljs-comment">// 这些字符串都可以被 drop</span><br>        <span class="hljs-title function_ invoke__">drop_static</span>(string); <span class="hljs-comment">// 编译通过</span><br>    &#125;<br><br>    <span class="hljs-comment">// 这些字符串在程序结束之前就已经全部失效了</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;i am the end of the program&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>关键点回顾</p><ul><li><code>T: &#39;static</code> 应当视为 “ <code>T</code> 满⾜ <code>&#39;static</code> ⽣命周期约束”</li><li>若 <code>T: &#39;static</code> 则 T 可以是⼀个有 <code>&#39;static</code> ⽣命周期的引⽤类型 <em>或</em> 是⼀个所有权类型</li><li>因为 <code>T: &#39;static</code> 包括了所有权类型，所以 <code>T</code><ul><li>可以在运⾏时动态分配</li><li>不需要在整个程序运⾏期间都有效</li><li>可以安全，⾃由地修改</li><li>可以在运⾏时被动态的 drop</li><li>可以有不同⻓度的⽣命周期</li></ul></li></ul><h2 id="3-amp-39-a-T-和-T-39-a-是⼀回事"><a href="#3-amp-39-a-T-和-T-39-a-是⼀回事" class="headerlink" title="3) &amp;&#39;a T 和 T: &#39;a 是⼀回事"></a>3) <code>&amp;&#39;a T</code> 和 <code>T: &#39;a</code> 是⼀回事</h2><p>这个误解是前⼀个误解的泛化版本。<code>&amp;&#39;a T</code> 要求并隐含了 <code>T: &#39;a</code> ，因为如果 <code>T</code> 本身不能在 <code>&#39;a</code> 范围内保证有效，那么其引⽤也不能在 ‘a 范围内保证有效。例如，Rust 编译器不会运⾏构造⼀个 <code>&amp;&#39;static Ref&lt;&#39;a, T&gt;</code> ，因为如果 <code>Ref</code> 只在 <code>&#39;a</code> 范围内有效，我们就不能给它 <code>&#39;static</code> ⽣命周期。<code>T: &#39;a</code> 包括了全体 <code>&amp;&#39;a T</code> ，但反之不成⽴。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 只接受带有 &#x27;a ⽣命周期注解的引⽤类型</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">t_ref</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T: <span class="hljs-symbol">&#x27;a</span>&gt;(t: &amp;<span class="hljs-symbol">&#x27;a</span> T) &#123;&#125;<br><br><span class="hljs-comment">// 接受满⾜ &#x27;a ⽣命周期约束的任何类型</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">t_bound</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T: <span class="hljs-symbol">&#x27;a</span>&gt;(t: T) &#123;&#125;<br><br><span class="hljs-comment">// 内部含有引⽤的所有权类型</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Ref</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T: <span class="hljs-symbol">&#x27;a</span>&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> T);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">string</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;string&quot;</span>);<br><br>    <span class="hljs-title function_ invoke__">t_bound</span>(&amp;string); <span class="hljs-comment">// 编译通过</span><br>    <span class="hljs-title function_ invoke__">t_bound</span>(<span class="hljs-title function_ invoke__">Ref</span>(&amp;string)); <span class="hljs-comment">// 编译通过</span><br>    <span class="hljs-title function_ invoke__">t_bound</span>(&amp;<span class="hljs-title function_ invoke__">Ref</span>(&amp;string)); <span class="hljs-comment">// 编译通过</span><br>    <span class="hljs-title function_ invoke__">t_ref</span>(&amp;string); <span class="hljs-comment">// 编译通过</span><br>    <span class="hljs-title function_ invoke__">t_ref</span>(<span class="hljs-title function_ invoke__">Ref</span>(&amp;string)); <span class="hljs-comment">// 编译失败，期望得到引⽤，实际得到 struct</span><br>    <span class="hljs-title function_ invoke__">t_ref</span>(&amp;<span class="hljs-title function_ invoke__">Ref</span>(&amp;string)); <span class="hljs-comment">// 编译通过</span><br><br>    <span class="hljs-comment">// 满⾜ &#x27;static 约束的字符串变量可以转换为 &#x27;a 约束</span><br>    <span class="hljs-title function_ invoke__">t_bound</span>(string); <span class="hljs-comment">// 编译通过</span><br>&#125;<br></code></pre></td></tr></table></figure><p>关键点回顾</p><ul><li><code>T: &#39;a</code> ⽐ <code>&amp;&#39;a T</code> 更泛化，更灵活</li><li><code>T: &#39;a</code> 接受所有权类型，内部含有引⽤的所有权类型，和引⽤</li><li><code>&amp;&#39;a T</code> 只接受引⽤</li><li>若 <code>T: &#39;static</code> 则 <code>T: &#39;a</code> 因为对于所有 <code>&#39;a</code> 都有 <code>&#39;static &gt;= &#39;a</code></li></ul><h2 id="4-我的代码⾥不含泛型也不含⽣命周期注解"><a href="#4-我的代码⾥不含泛型也不含⽣命周期注解" class="headerlink" title="4) 我的代码⾥不含泛型也不含⽣命周期注解"></a>4) 我的代码⾥不含泛型也不含⽣命周期注解</h2><p>错误的推论</p><ul><li>避免使⽤泛型和⽣命周期注解是可能的</li></ul><p>这个让⼈爽到的误解之所以能存在，要得益于 Rust 的⽣命周期省略规则，这个规则能允许你在函数<br>定义以及 impl 块中省略掉显式的⽣命周期注解，⽽由借⽤检查器来根据以下规则对⽣命周期进⾏<br>隐式推导。</p><ul><li>第⼀条规则是每⼀个是引⽤的参数都有它⾃⼰的⽣命周期参数</li><li>第⼆条规则是如果只有⼀个输⼊⽣命周期参数，那么它被赋予所有输出⽣命周期参数</li><li>第三条规则是如果是有多个输⼊⽣命周期参数的⽅法，⽽其中⼀个参数是 <code>&amp;self</code> 或 <code>&amp;mut self</code>, 那么所有输出⽣命周期参数被赋予 <code>self</code> 的⽣命周期。</li><li>其他情况下，⽣命周期必须有明确的注解</li></ul><p>这⾥有不少值得讲的东⻄，让我们来看⼀些例⼦：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 显式标注的⽅案</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_str</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>; <span class="hljs-comment">// 泛型版本</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_str</span>() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span>; <span class="hljs-comment">// &#x27;static 版本</span><br><br><span class="hljs-comment">// ⾮法，多个输⼊，不能确定返回值的⽣命周期</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">overlap</span>(s: &amp;<span class="hljs-type">str</span>, t: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span>;<br><br><span class="hljs-comment">// 显式标注（但仍有部分标注被省略）的⽅案</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">overlap</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(s: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, t: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>; <span class="hljs-comment">// 返回值的⽣命周期不⻓于 s</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">overlap</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(s: &amp;<span class="hljs-type">str</span>, t: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>; <span class="hljs-comment">// 返回值的⽣命周期不⻓于 t</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">overlap</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(s: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, t: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>; <span class="hljs-comment">// 返回值的⽣命周期不⻓于 s 且不⻓于 t</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">overlap</span>(s: &amp;<span class="hljs-type">str</span>, t: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span>; <span class="hljs-comment">// 返回值的⽣命周期可以⻓于 s 或者 t</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">overlap</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(s: &amp;<span class="hljs-type">str</span>, t: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>; <span class="hljs-comment">// 返回值的⽣命周期与输⼊⽆关</span><br><br><span class="hljs-comment">// 展开后</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">overlap</span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>&gt;(s: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, t: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">overlap</span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>&gt;(s: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, t: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">str</span>;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">overlap</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(s: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, t: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">overlap</span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>&gt;(s: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, t: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span>;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">overlap</span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>, <span class="hljs-symbol">&#x27;c</span>&gt;(s: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, t: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;c</span> <span class="hljs-type">str</span>;<br><br><span class="hljs-comment">// 展开前</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">compare</span>(&amp;<span class="hljs-keyword">self</span>, s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span>;<br><br><span class="hljs-comment">// 展开后</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">compare</span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">self</span>, &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>;<br></code></pre></td></tr></table></figure><p>如果你写过</p><ul><li>结构体⽅法</li><li>接收参数中有引⽤的函数</li><li>返回值是引⽤的函数</li><li>泛型函数</li><li>trait object(后⾯将讨论)</li><li>闭包（后⾯将讨论）</li></ul><p>那么对于上⾯这些，你的代码中都有被省略的泛型⽣命周期注解。</p><p><strong>关键点回顾</strong></p><ul><li>⼏乎所有的 Rust 代码都是泛型代码，并且到处都带有被省略掉的泛型⽣命周期注解</li></ul><h2 id="5-如果编译通过了，那么我标注的⽣命周期就是正确的"><a href="#5-如果编译通过了，那么我标注的⽣命周期就是正确的" class="headerlink" title="5) 如果编译通过了，那么我标注的⽣命周期就是正确的"></a>5) 如果编译通过了，那么我标注的⽣命周期就是正确的</h2><p>错误的推论</p><ul><li>Rust 对函数的⽣命周期省略规则总是对的</li><li>Rust 的借⽤检查器总是正确的，⽆论是技巧上还是语义上</li><li>Rust ⽐我更懂我程序的语义</li></ul><p>让⼀个 Rust 程序通过编译但语义上不正确是有可能的。来看看这个例⼦：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ByteIter</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    remainder: &amp;<span class="hljs-symbol">&#x27;a</span> [<span class="hljs-type">u8</span>]<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; ByteIter&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-type">u8</span>&gt; &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.remainder.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>            <span class="hljs-literal">None</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">byte</span> = &amp;<span class="hljs-keyword">self</span>.remainder[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">self</span>.remainder = &amp;<span class="hljs-keyword">self</span>.remainder[<span class="hljs-number">1</span>..];<br>            <span class="hljs-title function_ invoke__">Some</span>(byte)<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">bytes</span> = ByteIter &#123; remainder: <span class="hljs-string">b&quot;1&quot;</span> &#125;;<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">Some</span>(&amp;<span class="hljs-string">b&#x27;1&#x27;</span>), bytes.<span class="hljs-title function_ invoke__">next</span>());<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-literal">None</span>, bytes.<span class="hljs-title function_ invoke__">next</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ByteIter</code> 是⼀个 <code>byte</code> 切⽚上的迭代器，简洁起⻅，我这⾥省略了 Iterator trait 的具体实现。这看起来没什么问题，但如果我们想同时检查多个 <code>byte</code> 呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">bytes</span> = ByteIter &#123; remainder: <span class="hljs-string">b&quot;1123&quot;</span> &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">byte_1</span> = bytes.<span class="hljs-title function_ invoke__">next</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">byte_2</span> = bytes.<span class="hljs-title function_ invoke__">next</span>();<br>    <span class="hljs-keyword">if</span> byte_1 == byte_2 &#123;<br>        <span class="hljs-comment">// ⼀些代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Compiler Error:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust">error[E0499]: cannot borrow `bytes` <span class="hljs-keyword">as</span> mutable more than once at a time<br>  -<span class="hljs-punctuation">-&gt;</span> src/main.rs:<span class="hljs-number">20</span>:<span class="hljs-number">18</span><br>   |<br><span class="hljs-number">19</span> | <span class="hljs-keyword">let</span> <span class="hljs-variable">byte_1</span> = bytes.<span class="hljs-title function_ invoke__">next</span>();<br>   |              ----- first mutable borrow occurs here<br><span class="hljs-number">20</span> | <span class="hljs-keyword">let</span> <span class="hljs-variable">byte_2</span> = bytes.<span class="hljs-title function_ invoke__">next</span>();<br>   |              ^^^^^ second mutable borrow occurs here<br><span class="hljs-number">21</span> | <span class="hljs-keyword">if</span> byte_1 == byte_2 &#123;<br>   |    ------ first borrow later used here<br></code></pre></td></tr></table></figure><p>如果你说可以通过逐 byte 拷⻉来避免编译错误，那么确实。当迭代⼀个 byte 数组上时，我们的确可以通过拷⻉每个 byte 来达成⽬的。但是如果我想要将 <code>ByteIter</code> 改写成⼀个泛型的切⽚迭代器，使得我们能够对任意 <code>&amp;&#39;a [T]</code> 进⾏迭代，⽽此时如果有⼀个 <code>T</code>，其 copy 和 clone 的代价⼗分昂贵，那么我们该怎么避免这种昂贵的操作呢？哦，我想我们不能，毕竟代码都通过编译了，那么⽣命周期注解肯定也是对的，对吧？错，事实上现有的⽣命周期就是 bug 的源头！这个错误的⽣命周期被省略掉了以⾄于难以被发现。现在让我们展开这些被省略掉的⽣命周期来暴露出这个问题。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ByteIter</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    remainder: &amp;<span class="hljs-symbol">&#x27;a</span> [<span class="hljs-type">u8</span>]<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; ByteIter&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>&lt;<span class="hljs-symbol">&#x27;b</span>&gt;(&amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">u8</span>&gt; &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.remainder.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>            <span class="hljs-literal">None</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">byte</span> = &amp;<span class="hljs-keyword">self</span>.remainder[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">self</span>.remainder = &amp;<span class="hljs-keyword">self</span>.remainder[<span class="hljs-number">1</span>..];<br>            <span class="hljs-title function_ invoke__">Some</span>(byte)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>感觉好像没啥⽤，我还是搞不清楚问题出在哪。这⾥有个 Rust 专家才知道的⼩技巧：给你的⽣命周期注解起⼀个更有含义的名字，让我们试⼀下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ByteIter</span>&lt;<span class="hljs-symbol">&#x27;remainder</span>&gt; &#123;<br>    remainder: &amp;<span class="hljs-symbol">&#x27;remainder</span> [<span class="hljs-type">u8</span>]<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;remainder</span>&gt; ByteIter&lt;<span class="hljs-symbol">&#x27;remainder</span>&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>&lt;<span class="hljs-symbol">&#x27;mut_self</span>&gt;(&amp;<span class="hljs-symbol">&#x27;mut_self</span> <span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-symbol">&#x27;mut_self</span> <span class="hljs-type">u8</span>&gt; &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.remainder.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>            <span class="hljs-literal">None</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">byte</span> = &amp;<span class="hljs-keyword">self</span>.remainder[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">self</span>.remainder = &amp;<span class="hljs-keyword">self</span>.remainder[<span class="hljs-number">1</span>..];<br>            <span class="hljs-title function_ invoke__">Some</span>(byte)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个返回的 byte 都被标注为 <code>&#39;mut_self</code>, 但是显然这些 byte 都源于 <code>&#39;remainder</code>! 让我们来修复⼀下这段代码。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ByteIter</span>&lt;<span class="hljs-symbol">&#x27;remainder</span>&gt; &#123;<br>    remainder: &amp;<span class="hljs-symbol">&#x27;remainder</span> [<span class="hljs-type">u8</span>]<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;remainder</span>&gt; ByteIter&lt;<span class="hljs-symbol">&#x27;remainder</span>&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-symbol">&#x27;remainder</span> <span class="hljs-type">u8</span>&gt; &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.remainder.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>            <span class="hljs-literal">None</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">byte</span> = &amp;<span class="hljs-keyword">self</span>.remainder[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">self</span>.remainder = &amp;<span class="hljs-keyword">self</span>.remainder[<span class="hljs-number">1</span>..];<br>            <span class="hljs-title function_ invoke__">Some</span>(byte)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">bytes</span> = ByteIter &#123; remainder: <span class="hljs-string">b&quot;1123&quot;</span> &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">byte_1</span> = bytes.<span class="hljs-title function_ invoke__">next</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">byte_2</span> = bytes.<span class="hljs-title function_ invoke__">next</span>();<br>    std::mem::<span class="hljs-title function_ invoke__">drop</span>(bytes); <span class="hljs-comment">// 我们现在甚⾄可以把这个迭代器给 drop 掉！</span><br>    <span class="hljs-keyword">if</span> byte_1 == byte_2 &#123; <span class="hljs-comment">// 编译通过</span><br>        <span class="hljs-comment">// ⼀些代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们再回过头来看看我们上⼀版的实现，就能看出它是错的了，那么为什么 Rust 会编译通过呢？答案很简单：因为这是内存安全的。Rust 借⽤检查器对⽣命周期注解的要求只到能静态验证程序的内存安全为⽌。即便⽣命周期注解有语义上的错误，Rust 也能让程序编译通过，哪怕这样做为程序带来不必要的限制。这⼉有⼀个和之前相反的例⼦：在这个例⼦中，Rust ⽣命周期省略规则标注的⽣命周期是语义正确的，但是我们却在⽆意间使⽤了不必要的显式注解，导致写出了⼀个限制极其严格的⽅法。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NumRef</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span>);<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; NumRef&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-comment">// 我定义的泛型结构体以 &#x27;a 为参数，这意味着我也需要给⽅法的参数</span><br>    <span class="hljs-comment">// 标注为 &#x27;a ⽣命周期，对吗？（答案：错）</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">some_method</span>(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num_ref</span> = <span class="hljs-title function_ invoke__">NumRef</span>(&amp;<span class="hljs-number">5</span>);<br>    num_ref.<span class="hljs-title function_ invoke__">some_method</span>(); <span class="hljs-comment">// 可变借⽤ num_ref 直⾄其⽣命周期结束</span><br>    num_ref.<span class="hljs-title function_ invoke__">some_method</span>(); <span class="hljs-comment">// 编译错误</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, num_ref); <span class="hljs-comment">// 同样编译错误</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们有⼀个带 <code>&#39;a</code> 泛型参数的结构体，我们⼏乎不可能去写⼀个带 <code>&amp;&#39;a mut self</code> 参数的⽅法。因为这相当于告诉 Rust “这个⽅法将独占借⽤该对象，直到对象⽣命周期结束”。实际上，这意味着 Rust 的借⽤检查器只会允许在该对象上调⽤⾄多⼀次 <code>some_method</code>, 此后该对象将⼀直被独占借⽤并会因此变得不再可⽤。这种⽤例极其罕⻅，但是因为这种代码能够通过编译，所以那些对⽣命周期还感到困惑的初学者们很容易写出这种 bug. 修复这种 bug 的⽅式是去除掉不必要的显式⽣命周期注解，让 Rust ⽣命周期省略规则来处理它：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NumRef</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span>);<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; NumRef&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-comment">// 不再给 mut self 添加 &#x27;a 注解</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">some_method</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// 上⼀⾏去掉语法糖后：</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">some_method_desugared</span>&lt;<span class="hljs-symbol">&#x27;b</span>&gt;(&amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>)&#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num_ref</span> = <span class="hljs-title function_ invoke__">NumRef</span>(&amp;<span class="hljs-number">5</span>);<br>    num_ref.<span class="hljs-title function_ invoke__">some_method</span>();<br>    num_ref.<span class="hljs-title function_ invoke__">some_method</span>(); <span class="hljs-comment">// 编译通过</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, num_ref); <span class="hljs-comment">// 编译通过</span><br>&#125;<br></code></pre></td></tr></table></figure><p>关键点回顾</p><ul><li>Rust 对函数的⽣命周期省略规则并不保证在任何情况下都正确</li><li>在程序的语义⽅⾯，Rust 并不⽐你懂</li><li>可以试试给你的⽣命周期注解起⼀个有意义的名字</li><li>试着记住你在哪⾥添加了显式⽣命周期注解，以及为什么要加</li></ul><h2 id="6-Boxed-Trait-Object对象不含⽣命周期注解"><a href="#6-Boxed-Trait-Object对象不含⽣命周期注解" class="headerlink" title="6) Boxed Trait Object对象不含⽣命周期注解"></a>6) Boxed Trait Object对象不含⽣命周期注解</h2><p>之前我们讨论了 Rust 对函数 的⽣命周期省略规则。Rust 对 trait 对象也存在⽣命周期省略规则，它<br>们是：</p><ul><li>如果 trait 对象被⽤作泛型类型的⼀个类型参数，那么 trait 对象的⽣命周期约束会依据该类型参数<br>的定义进⾏推导<ul><li>若该类型参数有唯⼀的⽣命周期约束，则将这个约束赋给 trait 对象</li><li>若该类型参数不⽌⼀个⽣命周期约束，则 trait 对象的⽣命周期约束需要显式标注</li></ul></li><li>如果上⾯不成⽴，也就是说该类型参数没有⽣命周期约束，那么<ul><li>若 trait 定义时有且仅有⼀个⽣命周期约束，则将这个约束赋给 trait 对象</li><li>若 trait 定义时⽣命周期约束中存在⼀个 <code>&#39;static</code> , 则将 <code>&#39;static</code> 赋给 trait 对象</li><li>若 trait 定义时没有⽣命周期约束，则当 trait 对象是表达式的⼀部分时，⽣命周期从表达式中推导⽽出，否则赋予 <code>&#39;static</code></li></ul></li></ul><p>以上这些听起来特别复杂，但是可以简单地总结为⼀句话“⼀个 trait 对象的⽣命周期约束从上下⽂推导⽽出。”看下⾯这些例⼦后，我们会看到⽣命周期约束的推导其实很符合直觉，因此我们没必要去记忆上⾯的规则：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">type</span> <span class="hljs-title class_">T2</span> = <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Trait + <span class="hljs-symbol">&#x27;static</span>&gt;;<br><br><span class="hljs-comment">// 展开前</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">dyn</span> Trait &#123;&#125;<br><span class="hljs-comment">// 展开后</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">dyn</span> Trait + <span class="hljs-symbol">&#x27;static</span> &#123;&#125;<br><br><span class="hljs-comment">// 展开前</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">T3</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; = &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">dyn</span> Trait;<br><span class="hljs-comment">// 展开后，&amp;&#x27;a T 要求 T: &#x27;a, 所以推导为 &#x27;a</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">T4</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; = &amp;<span class="hljs-symbol">&#x27;a</span> (<span class="hljs-keyword">dyn</span> Trait + <span class="hljs-symbol">&#x27;a</span>);<br><br><span class="hljs-comment">// 展开前</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">T5</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; = Ref&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-keyword">dyn</span> Trait&gt;;<br><span class="hljs-comment">// 展开后，Ref&lt;&#x27;a, T&gt; 要求 T: &#x27;a, 所以推导为 &#x27;a</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">T6</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; = Ref&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-keyword">dyn</span> Trait + <span class="hljs-symbol">&#x27;a</span>&gt;;<br><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">GenericTrait</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;: <span class="hljs-symbol">&#x27;a</span> &#123;&#125;<br><br><span class="hljs-comment">// 展开前</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">T7</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; = <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> GenericTrait&lt;<span class="hljs-symbol">&#x27;a</span>&gt;&gt;;<br><span class="hljs-comment">// 展开后</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">T8</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; = <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> GenericTrait&lt;<span class="hljs-symbol">&#x27;a</span>&gt; + <span class="hljs-symbol">&#x27;a</span>&gt;;<br><br><span class="hljs-comment">// 展开前</span><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; <span class="hljs-keyword">dyn</span> GenericTrait&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;&#125;<br><span class="hljs-comment">// 展开后</span><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; <span class="hljs-keyword">dyn</span> GenericTrait&lt;<span class="hljs-symbol">&#x27;a</span>&gt; + <span class="hljs-symbol">&#x27;a</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>⼀个实现了 trait 的具体类型可以被引⽤，因此它们也会有⽣命周期约束，同样其对应的 trait 对象也有⽣命周期约束。你也可以直接对引⽤实现 trait, 引⽤显然是有⽣命周期约束的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Trait</span> &#123;&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Struct</span> &#123;&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Ref</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> T);<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Trait</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Struct</span> &#123;&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Trait</span> <span class="hljs-keyword">for</span> &amp;Struct &#123;&#125; <span class="hljs-comment">// 直接为引⽤类型实现 Trait</span><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; Trait <span class="hljs-keyword">for</span> <span class="hljs-title class_">Ref</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; &#123;&#125; <span class="hljs-comment">// 为包含引⽤的类型实现 Trait</span><br></code></pre></td></tr></table></figure><p>总之，这个知识点值得反复理解，新⼿在重构⼀个使⽤ trait 对象的函数到⼀个泛型的函数或者反过来时，常常会因为这个知识点⽽感到困惑。来看看这个示例程序：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::Display;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">dynamic_thread_print</span>(t: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Display + <span class="hljs-built_in">Send</span>&gt;) &#123;<br>    std::thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, t);<br>    &#125;).<span class="hljs-title function_ invoke__">join</span>();<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">static_thread_print</span>&lt;T: Display + <span class="hljs-built_in">Send</span>&gt;(t: T) &#123;<br>    std::thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, t);<br>    &#125;).<span class="hljs-title function_ invoke__">join</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这⾥编译器报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">error[E0310]: the parameter type `T` may not live long enough<br>  --&gt; src/lib.rs:10:5<br>   |<br>9  | fn static_thread_print&lt;T: Display + Send&gt;(t: T) &#123;<br>   |                        -- help: consider adding an explicit lifetime bound...: `T: &#x27;static +`<br>10 |     std::thread::spawn(move || &#123;<br>   |     ^^^^^^^^^^^^^^^^^^<br>   |<br>note: ...so that the type `[closure@src/lib.rs:10:24: 12:6 t:T]` will meet its required lifetime bounds<br>  --&gt; src/lib.rs:10:5<br>   |<br>10 |     std::thread::spawn(move || &#123;<br>   |     ^^^^^^^^^^^^^^^^^^<br></code></pre></td></tr></table></figure><p>很好，编译器告诉了我们怎样修复这个问题，让我们修复⼀下。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::Display;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">dynamic_thread_print</span>(t: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Display + <span class="hljs-built_in">Send</span>&gt;) &#123;<br>    std::thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, t);<br>    &#125;).<span class="hljs-title function_ invoke__">join</span>();<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">static_thread_print</span>&lt;T: Display + <span class="hljs-built_in">Send</span> + <span class="hljs-symbol">&#x27;static</span>&gt;(t: T) &#123;<br>    std::thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, t);<br>    &#125;).<span class="hljs-title function_ invoke__">join</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>现在它编译通过了，但是这两个函数对⽐起来看起来挺奇怪的，为什么第⼆个函数要求 <code>T</code> 满⾜ <code>&#39;static</code> 约束⽽第⼀个函数不⽤呢？这是个刁钻的问题。事实上，通过⽣命周期省略规则，Rust ⾃动在第⼀个函数⾥推导并添加了⼀个 <code>&#39;static</code> 约束，所以其实两个函数都含有 <code>&#39;static</code> 约束。Rust 编译器实际看到的是这个样⼦的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::Display;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">dynamic_thread_print</span>(t: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Display + <span class="hljs-built_in">Send</span> + <span class="hljs-symbol">&#x27;static</span>&gt;) &#123;<br>    std::thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, t);<br>    &#125;).<span class="hljs-title function_ invoke__">join</span>();<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">static_thread_print</span>&lt;T: Display + <span class="hljs-built_in">Send</span> + <span class="hljs-symbol">&#x27;static</span>&gt;(t: T) &#123;<br>    std::thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, t);<br>    &#125;).<span class="hljs-title function_ invoke__">join</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>关键点回顾</p><ul><li>所有 trait 对象都含有⾃动推导的⽣命周期</li></ul><h2 id="7-编译器的报错信息会告诉我怎样修复我的程序"><a href="#7-编译器的报错信息会告诉我怎样修复我的程序" class="headerlink" title="7) 编译器的报错信息会告诉我怎样修复我的程序"></a>7) 编译器的报错信息会告诉我怎样修复我的程序</h2><p><strong>错误的推论</strong></p><ul><li>Rust 对 trait 对象的⽣命周期省略规则总是正确的</li><li>Rust ⽐我更懂我程序的语义</li></ul><p>这个误解是前两个误解的结合，来看⼀个例⼦：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::Display;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">box_displayable</span>&lt;T: Display&gt;(t: T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Display&gt; &#123;<br>    <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(t)<br>&#125;<br></code></pre></td></tr></table></figure><p>报错如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">error[E0310]: the parameter type `T` may not live long enough<br> --&gt; src/lib.rs:4:5<br>  |<br>3 | fn box_displayable&lt;T: Display&gt;(t: T) -&gt; Box&lt;dyn Display&gt; &#123;<br>  |                    -- help: consider adding an explicit lifetime bound...: `T: &#x27;static +`<br>4 |     Box::new(t)<br>  |     ^^^^^^^^^^^<br>  |<br>note: ...so that the type `T` will meet its required lifetime bounds<br> --&gt; src/lib.rs:4:5<br>  |<br>4 | Box::new(t)<br>  | ^^^^^^^^^^^<br></code></pre></td></tr></table></figure><p>好，让我们按照编译器的提示进⾏修复。这⾥我们先忽略⼀个事实：返回值中装箱的 trait 对象有⼀个⾃动推导的 <code>&#39;static</code> 约束，⽽编译器是基于这个没有显式说明的事实给出的修复建议。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::Display;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">box_displayable</span>&lt;T: Display + <span class="hljs-symbol">&#x27;static</span>&gt;(t: T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Display&gt; &#123;<br>    <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(t)<br>&#125;<br></code></pre></td></tr></table></figure><p>现在可以编译通过了，但这真的是我们想要的吗？可能是，也可能不是，编译器并没有提到其他修复⽅案，但下⾯这个也是⼀个合适的修复⽅案。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::Display;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">box_displayable</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T: Display + <span class="hljs-symbol">&#x27;a</span>&gt;(t: T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Display + <span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(t)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数所能接受的实际参数⽐前⼀个函数多了不少！这个函数是不是更好？确实，但不⼀定必要，这取决于我们对程序的要求与约束。上⾯这个例⼦有点抽象，所以让我们看⼀个更简单明了的例⼦：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">return_first</span>(a: &amp;<span class="hljs-type">str</span>, b: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span> &#123;<br>    a<br>&#125;<br></code></pre></td></tr></table></figure><p>报错</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">error[E0106]: missing lifetime specifier<br> --&gt; src/lib.rs:1:38<br>1 | fn return_first(a: &amp;str, b: &amp;str) -&gt; &amp;str &#123;<br>  |                    ----     ----     ^ expected named lifetime parameter<br>  = help: this function&#x27;s return type contains a borrowed value, but the<br>signature does not say whether it is borrowed from `a` or `b`<br>help: consider introducing a named lifetime parameter<br>  |<br>  |<br>  |<br>1 | fn return_first&lt;&#x27;a&gt;(a: &amp;&#x27;a str, b: &amp;&#x27;a str) -&gt; &amp;&#x27;a str &#123;<br>  |                ^^^^    ^^^^^^^     ^^^^^^^     ^^^<br></code></pre></td></tr></table></figure><p>这个错误信息推荐我们给所有输⼊输出都标注上同样的⽣命周期注解。如果我们这么做了，那么程序将通过编译，但是这样写出的函数过度限制了返回类型。我们真正想要的是这个：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">return_first</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(a: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, b: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span> &#123;<br>    a<br>&#125;<br></code></pre></td></tr></table></figure><p>关键点回顾</p><ul><li>Rust 对 trait 对象的⽣命周期省略规则并不保证在任何情况下都正确</li><li>在程序的语义⽅⾯，Rust 并不⽐你懂</li><li>Rust 编译错误的提示信息所提出的修复⽅案并不⼀定能满⾜你对程序的需求</li></ul><h2 id="8-⽣命周期可以在运⾏时动态变⻓或变短"><a href="#8-⽣命周期可以在运⾏时动态变⻓或变短" class="headerlink" title="8) ⽣命周期可以在运⾏时动态变⻓或变短"></a>8) ⽣命周期可以在运⾏时动态变⻓或变短</h2><p>错误的推论</p><ul><li>容器类可以在运⾏时交换其内部的引⽤，从⽽改变⾃身的⽣命周期</li><li>Rust 借⽤检查器能进⾏⾼级的控制流分析</li></ul><p>这个编译不通过：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Has</span>&lt;<span class="hljs-symbol">&#x27;lifetime</span>&gt; &#123;<br>    lifetime: &amp;<span class="hljs-symbol">&#x27;lifetime</span> <span class="hljs-type">str</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">long</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;long&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">has</span> = Has &#123; lifetime: &amp;long &#125;;<br>    <span class="hljs-built_in">assert_eq!</span>(has.lifetime, <span class="hljs-string">&quot;long&quot;</span>);<br><br>    &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">short</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;short&quot;</span>);<br>        <span class="hljs-comment">// “转换到” 短的⽣命周期</span><br>        has.lifetime = &amp;short;<br>        <span class="hljs-built_in">assert_eq!</span>(has.lifetime, <span class="hljs-string">&quot;short&quot;</span>);<br><br>        <span class="hljs-comment">// “转换回” ⻓的⽣命周期（实际是并不是）</span><br>        has.lifetime = &amp;long;<br>        <span class="hljs-built_in">assert_eq!</span>(has.lifetime, <span class="hljs-string">&quot;long&quot;</span>);<br>        <span class="hljs-comment">// `short` 变量在这⾥ drop</span><br>    &#125;<br><br>    <span class="hljs-comment">// 编译失败， `short` 在 drop 后仍旧处于 “借⽤” 状态</span><br>    <span class="hljs-built_in">assert_eq!</span>(has.lifetime, <span class="hljs-string">&quot;long&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">error[E0597]: `short` does not live long enough<br> --&gt; src/main.rs:11:24<br>   |<br>11 | has.lifetime = &amp;short;<br>   |                ^^^^^^ borrowed value does not live long enough<br>...<br>15 | &#125;<br>   | - `short` dropped here while still borrowed<br>16 | assert_eq!(has.lifetime, &quot;long&quot;);<br>   | --------------------------------- borrow later used here<br></code></pre></td></tr></table></figure><p>下⾯这个还是报错，报错信息也和上⾯⼀样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Has</span>&lt;<span class="hljs-symbol">&#x27;lifetime</span>&gt; &#123;<br>    lifetime: &amp;<span class="hljs-symbol">&#x27;lifetime</span> <span class="hljs-type">str</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">long</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;long&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">has</span> = Has &#123; lifetime: &amp;long &#125;;<br>    <span class="hljs-built_in">assert_eq!</span>(has.lifetime, <span class="hljs-string">&quot;long&quot;</span>);<br><br>    <span class="hljs-comment">// 这个代码块逻辑上永远不会被执⾏</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-literal">false</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">short</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;short&quot;</span>);<br>        <span class="hljs-comment">// “转换到” 短的⽣命周期</span><br>        has.lifetime = &amp;short;<br>        <span class="hljs-built_in">assert_eq!</span>(has.lifetime, <span class="hljs-string">&quot;short&quot;</span>);<br><br>        <span class="hljs-comment">// “转换回” ⻓的⽣命周期（实际是并不是）</span><br>        has.lifetime = &amp;long;<br>        <span class="hljs-built_in">assert_eq!</span>(has.lifetime, <span class="hljs-string">&quot;long&quot;</span>);<br>        <span class="hljs-comment">// `short` 变量在这⾥ drop</span><br>    &#125;<br><br>    <span class="hljs-comment">// 还是编译失败， `short` 在 drop 后仍旧处于 “借⽤” 状态</span><br>    <span class="hljs-built_in">assert_eq!</span>(has.lifetime, <span class="hljs-string">&quot;long&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>⽣命周期必须在编译时被静态确定，⽽且 Rust 借⽤检查器只会做基本的控制流分析，所以它假设每个 <code>if-else</code> 块和 <code>match</code> 块的每个分⽀都能被执⾏，然后<strong>选出⼀个最短的⽣命周期赋给块中的变量</strong>。⼀旦⼀个变量被⼀个⽣命周期约束了，那么它将 永远 被这个⽣命周期所约束。<strong>⼀个变量的⽣命周期只能缩短，⽽且所有的缩短时机都在编译时确定。</strong></p><h2 id="9-将独占引⽤-amp-mut-降级为共享引⽤-amp-是-safe-的"><a href="#9-将独占引⽤-amp-mut-降级为共享引⽤-amp-是-safe-的" class="headerlink" title="9) 将独占引⽤(&amp;mut)降级为共享引⽤(&amp;)是 safe 的"></a>9) 将独占引⽤(<code>&amp;mut</code>)降级为共享引⽤(<code>&amp;</code>)是 safe 的</h2><p>错误的推论</p><ul><li>通过重借⽤引⽤内部的数据，能抹掉其原有的⽣命周期，然后赋⼀个新的上去</li></ul><p>你可以将⼀个独占引⽤作为参数传给⼀个接收共享引⽤的函数，因为 Rust 将隐式地重借⽤独占引⽤内部的数据，⽣成⼀个共享引⽤：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">takes_shared_ref</span>(n: &amp;<span class="hljs-type">i32</span>) &#123;&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">a</span> = <span class="hljs-number">10</span>;<br>    <span class="hljs-title function_ invoke__">takes_shared_ref</span>(&amp;<span class="hljs-keyword">mut</span> a); <span class="hljs-comment">// 编译通过</span><br>    <span class="hljs-title function_ invoke__">takes_shared_ref</span>(&amp;*(&amp;<span class="hljs-keyword">mut</span> a)); <span class="hljs-comment">// 上⾯那⾏去掉语法糖</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这在直觉上是合理的，因为将⼀个独占引⽤转换为共享引⽤显然是⽆害的，对吗？令⼈讶异的是，这并不对，下⾯的这段程序不能通过编译：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">a</span> = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span>: &amp;<span class="hljs-type">i32</span> = &amp;*(&amp;<span class="hljs-keyword">mut</span> a); <span class="hljs-comment">// 重借⽤为不可变引⽤</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span>: &amp;<span class="hljs-type">i32</span> = &amp;a;<br>    dbg!(b, c); <span class="hljs-comment">// 编译失败</span><br>&#125;<br></code></pre></td></tr></table></figure><p>报错如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">error[E0502]: cannot borrow `a` as immutable because it is also borrowed as mutable<br> --&gt; src/main.rs:4:19<br>  |<br>3 |     let b: &amp;i32 = &amp;*(&amp;mut a);<br>  |                     -------- mutable borrow occurs here<br>4 |     let c: &amp;i32 = &amp;a;<br>  |                   ^^ immutable borrow occurs here<br>5 | dbg!(b, c);<br>  |      - mutable borrow later used here<br></code></pre></td></tr></table></figure><p>代码⾥确实有⼀个独占引⽤，但是它⽴即重借⽤变成了⼀个共享引⽤，然后⾃身就被 drop 掉了。但是为什么 Rust 好像把这个重借⽤出来的共享引⽤看作是有⼀个独占的⽣命周期呢？上⾯这个例⼦中，允许独占引⽤直接降级为共享引⽤是没有问题的，但是这个允许确实会导致潜在的内存安全问题。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::Mutex;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Struct</span> &#123;<br>    mutex: Mutex&lt;<span class="hljs-type">String</span>&gt;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Struct</span> &#123;<br>    <span class="hljs-comment">// 将 self 的独占引⽤降级为 str 的共享引⽤</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_string</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span> &#123;<br>        <span class="hljs-keyword">self</span>.mutex.<span class="hljs-title function_ invoke__">get_mut</span>().<span class="hljs-title function_ invoke__">unwrap</span>()<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">mutate_string</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-comment">// 如果 Rust 允许独占引⽤降级为共享引⽤，那么下⾯这⼀⾏代码执⾏后，</span><br>        <span class="hljs-comment">// 所有通过 get_string ⽅法返回的 &amp;str 都将变为⾮法引⽤</span><br>        *<span class="hljs-keyword">self</span>.mutex.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>() = <span class="hljs-string">&quot;surprise!&quot;</span>.<span class="hljs-title function_ invoke__">to_owned</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = Struct &#123;<br>        mutex: Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;string&quot;</span>.<span class="hljs-title function_ invoke__">to_owned</span>())<br>    &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">str_ref</span> = s.<span class="hljs-title function_ invoke__">get_string</span>(); <span class="hljs-comment">// 独占引⽤降级为共享引⽤</span><br>    s.<span class="hljs-title function_ invoke__">mutate_string</span>(); <span class="hljs-comment">// str_ref 失效，变成⾮法引⽤，现在是⼀个悬垂指针</span><br>    dbg!(str_ref); <span class="hljs-comment">// 当然，实际上会编译错误</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这⾥的关键点在于，你在重借⽤⼀个独占引⽤为共享引⽤时，就已经落⼊了⼀个陷阱：为了保证重借⽤得到的共享引⽤在其⽣命周期内有效，被重借⽤的独占引⽤也必须保证在这段时期有效，这延⻓了独占引⽤的⽣命周期！哪怕独占引⽤⾃身已经被 drop 掉了，但独占引⽤的⽣命周期却⼀直延续到共享引⽤的⽣命周期结束。使⽤重借⽤得到的共享引⽤是很难受的，因为它明明是⼀个共享引⽤但是却不能和其他共享引⽤共存。重借⽤得到的共享引⽤有着独占引⽤和共享引⽤的缺点，却没有⼆者的优点。我认为重借⽤⼀个独占引⽤为共享引⽤的⾏为应当被视为 Rust 的⼀种反模式。知道这种反模式是很重要的，当你看到这样的代码时，你就能轻易地发现错误了</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 将独占引⽤降级为共享引⽤</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">some_function</span>&lt;T&gt;(some_arg: &amp;<span class="hljs-keyword">mut</span> T) <span class="hljs-punctuation">-&gt;</span> &amp;T;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Struct</span>;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Struct</span> &#123;<br>    <span class="hljs-comment">// 将独占的 self 引⽤降级为共享的 self 引⽤</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">some_method</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-keyword">self</span>;<br><br>    <span class="hljs-comment">// 将独占的 self 引⽤降级为共享的 T 引⽤</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">other_method</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;T;<br>&#125;<br></code></pre></td></tr></table></figure><p>尽管你可以在函数和⽅法的声明⾥避免重借⽤，但是由于 Rust 会⾃动做隐式重借⽤，所以很容易⽆意识地遇到这种情况</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">PlayerID</span> = <span class="hljs-type">i32</span>;<br><br><span class="hljs-meta">#[derive(Debug, Default)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Player</span> &#123;<br>    score: <span class="hljs-type">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_game</span>(player_a: PlayerID, player_b: PlayerID, server: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;PlayerID, Player&gt;) &#123;<br>    <span class="hljs-comment">// 从 server 中得到 player, 如果不存在就创建⼀个默认的 player 并得到这个新创建的。</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">player_a</span>: &amp;Player = server.<span class="hljs-title function_ invoke__">entry</span>(player_a).<span class="hljs-title function_ invoke__">or_default</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">player_b</span>: &amp;Player = server.<span class="hljs-title function_ invoke__">entry</span>(player_b).<span class="hljs-title function_ invoke__">or_default</span>();<br><br>    <span class="hljs-comment">// 对得到的 player 做⼀些操作</span><br>    dbg!(player_a, player_b); <span class="hljs-comment">// 编译错误</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上⾯这段代码会编译失败。这⾥ <code>or_default()</code> 会返回⼀个 <code>&amp;mut Player</code>，但是由于我们添加了⼀个显式的类型标注，它会被隐式重借⽤成 <code>&amp;Player</code>。⽽为了达成我们真正的⽬的，我们不得不这样做：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">PlayerID</span> = <span class="hljs-type">i32</span>;<br><br><span class="hljs-meta">#[derive(Debug, Default)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Player</span> &#123;<br>    score: <span class="hljs-type">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_game</span>(player_a: PlayerID, player_b: PlayerID, server: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;PlayerID, Player&gt;) &#123;<br>    <span class="hljs-comment">// 因为编译器不允许这两个返回值共存，所有这⾥直接丢弃这两个 &amp;mut Player</span><br>    server.<span class="hljs-title function_ invoke__">entry</span>(player_a).<span class="hljs-title function_ invoke__">or_default</span>();<br>    server.<span class="hljs-title function_ invoke__">entry</span>(player_b).<span class="hljs-title function_ invoke__">or_default</span>();<br><br>    <span class="hljs-comment">// 再次获取 player, 这次我们直接拿到共享引⽤，避免隐式的重借⽤</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">player_a</span> = server.<span class="hljs-title function_ invoke__">get</span>(&amp;player_a);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">player_b</span> = server.<span class="hljs-title function_ invoke__">get</span>(&amp;player_b);<br><br>    <span class="hljs-comment">// 对得到的 player 做⼀些操作</span><br>    dbg!(player_a, player_b); <span class="hljs-comment">// 现在能编译通过了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>难⽤，⽽且很蠢，但这是我们为了内存安全这⼀信条所做出的牺牲。</p><p><strong>关键点回顾</strong></p><ul><li>尽量避免重借⽤⼀个独占引⽤为共享引⽤，不然你会遇到很多麻烦</li><li>重借⽤⼀个独占引⽤并不会结束其⽣命周期，哪怕它⾃身已经被 drop 掉了</li></ul><h2 id="10-对闭包的⽣命周期省略规则和函数⼀样"><a href="#10-对闭包的⽣命周期省略规则和函数⼀样" class="headerlink" title="10) 对闭包的⽣命周期省略规则和函数⼀样"></a>10) 对闭包的⽣命周期省略规则和函数⼀样</h2><p>这更像是 Rust 的陷阱⽽⾮误解尽管闭包可以被当作是⼀个函数，但是并不遵循和函数同样的⽣命周期省略规则。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">function</span>(x: &amp;<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">i32</span> &#123;<br>    x<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">closure</span> = |x: &amp;<span class="hljs-type">i32</span>| x;<br>&#125;<br></code></pre></td></tr></table></figure><p>报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">error: lifetime may not live long enough<br> --&gt; src/main.rs:6:29<br>  |<br>6 | let closure = |x: &amp;i32| x;<br>  |                   -   - ^ returning this value requires that `&#x27;1` must outlive `&#x27;2`<br>  |                   |   |<br>  |                   |   return type of closure is &amp;&#x27;2 i32<br>  |                   let&#x27;s call the lifetime of this reference `&#x27;1`<br></code></pre></td></tr></table></figure><p>去掉语法糖后，我们得到的是：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 输⼊的⽣命周期应⽤到了输出上</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">function</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span> &#123;<br>    x<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// 输⼊和输出有它们⾃⼰各⾃的⽣命周期</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">closure</span> = <span class="hljs-keyword">for</span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>&gt; |x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span>| <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">i32</span> &#123; x &#125;;<br>    <span class="hljs-comment">// 注意：上⼀⾏并不是合法的语句，但是我们需要它来描述我们⽬的</span><br>&#125;<br></code></pre></td></tr></table></figure><p>出现这种差异并没有什么好处。只是在闭包最初的实现中，使⽤的类型推断语义与函数不同，⽽现在将⼆者做⼀个统⼀将是⼀个 breaking change, 因此现在已经没法改了。那么我们怎么显式地标注⼀个闭包的类型呢？我们有以下⼏种⽅案：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// 转换成 trait 对象，但这样是不定长的，所以会编译错误</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">identity</span>: <span class="hljs-keyword">dyn</span> <span class="hljs-title function_ invoke__">Fn</span>(&amp;<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">i32</span> = |x: &amp;<span class="hljs-type">i32</span>| x;<br>    <br>    <span class="hljs-comment">// 可以分配到堆上作为代替方案，但是在这里堆分配感觉有点蠢</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">identity</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> <span class="hljs-title function_ invoke__">Fn</span>(&amp;<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">i32</span>&gt; = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(|x: &amp;<span class="hljs-type">i32</span>| x);<br><br>    <span class="hljs-comment">// 可以不⽤堆分配⽽直接创建⼀个 &#x27;static 引⽤</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">identity</span>: &amp;<span class="hljs-keyword">dyn</span> <span class="hljs-title function_ invoke__">Fn</span>(&amp;<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">i32</span> = &amp;|x: &amp;<span class="hljs-type">i32</span>| x;<br><br>    <span class="hljs-comment">// 上⼀⾏去掉语法糖 :)</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">identity</span>: &amp;<span class="hljs-symbol">&#x27;static</span> (<span class="hljs-keyword">dyn</span> <span class="hljs-keyword">for</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; <span class="hljs-title function_ invoke__">Fn</span>(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span> + <span class="hljs-symbol">&#x27;static</span>) = &amp;|x: &amp;<span class="hljs-type">i32</span>| <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">i32</span> &#123; x &#125;;<br><br>    <span class="hljs-comment">// 这看起来很完美，但可惜不符合语法</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">identity</span>: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Fn</span>(&amp;<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">i32</span> = |x: &amp;<span class="hljs-type">i32</span>| x;<br><br>    <span class="hljs-comment">// 这个也⾏，但也不符合语法</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">identity</span> = <span class="hljs-keyword">for</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; |x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span>| <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span> &#123; x &#125;;<br><br>    <span class="hljs-comment">// 但是 &quot;impl trait&quot; 可以作为函数的返回值类型</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">return_identity</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Fn</span>(&amp;<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">i32</span> &#123;<br>        |x| x<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">identity</span> = <span class="hljs-title function_ invoke__">return_identity</span>();<br><br>    <span class="hljs-comment">// 上⼀个解决⽅案的泛化版本</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">annotate</span>&lt;T, F&gt;(f: F) <span class="hljs-punctuation">-&gt;</span> F <span class="hljs-keyword">where</span> F: <span class="hljs-title function_ invoke__">Fn</span>(&amp;T) <span class="hljs-punctuation">-&gt;</span> &amp;T &#123;<br>        f<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">identity</span> = <span class="hljs-title function_ invoke__">annotate</span>(|x: &amp;<span class="hljs-type">i32</span>| x);<br>&#125;<br></code></pre></td></tr></table></figure><p>我想你应该注意到了，在上⾯的例⼦中，如果对闭包应⽤ trait 约束，闭包会和函数遵循同样的⽣命周期省略规则。这⾥没有什么现实的教训或⻅解，只是说明⼀下闭包是这样的。</p><p><strong>关键点回顾</strong></p><ul><li>每个语⾔都有其陷阱</li><li>避免在闭包中使⽤⽣命周期！</li></ul><h2 id="11-39-static-引⽤总能被强制转换为-39-a-引⽤"><a href="#11-39-static-引⽤总能被强制转换为-39-a-引⽤" class="headerlink" title="11) &#39;static 引⽤总能被强制转换为 &#39;a 引⽤"></a>11) <code>&#39;static</code> 引⽤总能被强制转换为 <code>&#39;a</code> 引⽤</h2><p>我之前有过这样的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_str</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>; <span class="hljs-comment">// 泛型版本</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_str</span>() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span>; <span class="hljs-comment">// &#x27;static 版本</span><br></code></pre></td></tr></table></figure><p>两者之间是否有实际的差异。我⼀开始并不确定，但⼀番研究过后遗憾地发现，是的，这⼆者确实有差异。通常在使⽤值时，我们能⽤ <code>&#39;static</code> 引⽤直接代替⼀个 <code>&#39;a</code> 引⽤，因为 Rust 会⾃动把 <code>&#39;static</code> 引⽤强制转换为 <code>&#39;a</code> 引⽤。直觉上这很合理，因为在⼀个对⽣命周期要求⽐较短的地⽅⽤⼀个⽣命周期⽐较⻓的引⽤绝不会导致任何内存安全问题。下⾯的这段代码通过编译，和预期⼀致：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> rand;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">generic_str_fn</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span> &#123;<br>    <span class="hljs-string">&quot;str&quot;</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">static_str_fn</span>() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span> &#123;<br>    <span class="hljs-string">&quot;str&quot;</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">a_or_b</span>&lt;T&gt;(a: T, b: T) <span class="hljs-punctuation">-&gt;</span> T &#123;<br>    <span class="hljs-keyword">if</span> rand::<span class="hljs-title function_ invoke__">random</span>() &#123;<br>        a<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        b<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">some_string</span> = <span class="hljs-string">&quot;string&quot;</span>.<span class="hljs-title function_ invoke__">to_owned</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">some_str</span> = &amp;some_string[..];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">str_ref</span> = <span class="hljs-title function_ invoke__">a_or_b</span>(some_str, <span class="hljs-title function_ invoke__">generic_str_fn</span>()); <span class="hljs-comment">// 编译通过</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">str_ref</span> = <span class="hljs-title function_ invoke__">a_or_b</span>(some_str, <span class="hljs-title function_ invoke__">static_str_fn</span>()); <span class="hljs-comment">// 编译通过</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然⽽当引⽤作为函数类型签名的⼀部分时，强制类型转换并不⽣效。所以下⾯这段代码不能通过编译：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> rand;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">generic_str_fn</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span> &#123;<br>    <span class="hljs-string">&quot;str&quot;</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">static_str_fn</span>() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span> &#123;<br>    <span class="hljs-string">&quot;str&quot;</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">a_or_b_fn</span>&lt;T, F&gt;(a: T, b_fn: F) <span class="hljs-punctuation">-&gt;</span> T<br>    <span class="hljs-keyword">where</span> F: <span class="hljs-title function_ invoke__">Fn</span>() <span class="hljs-punctuation">-&gt;</span> T<br>&#123;<br>    <span class="hljs-keyword">if</span> rand::<span class="hljs-title function_ invoke__">random</span>() &#123;<br>        a<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_ invoke__">b_fn</span>()<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">some_string</span> = <span class="hljs-string">&quot;string&quot;</span>.<span class="hljs-title function_ invoke__">to_owned</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">some_str</span> = &amp;some_string[..];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">str_ref</span> = <span class="hljs-title function_ invoke__">a_or_b_fn</span>(some_str, generic_str_fn); <span class="hljs-comment">// 编译通过</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">str_ref</span> = <span class="hljs-title function_ invoke__">a_or_b_fn</span>(some_str, static_str_fn); <span class="hljs-comment">// 编译错误</span><br>&#125;<br></code></pre></td></tr></table></figure><p>报错如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">error[E0597]: `some_string` does not live long enough<br> --&gt; src/main.rs:23:21<br>   |<br>23 | let some_str = &amp;some_string[..];<br>   |                 ^^^^^^^^^^^ borrowed value does not live long enough<br>...<br>25 | let str_ref = a_or_b_fn(some_str, static_str_fn);<br>   |               ---------------------------------- argument requires that `some_string` is borrowed for `&#x27;static`<br>26 | &#125;<br>   | - `some_string` dropped here while still borrowed<br></code></pre></td></tr></table></figure><p>很难说这是不是 Rust 的⼀个陷阱，把 <code>for&lt;T&gt; Fn() -&gt; &amp;&#39;static T</code> 强制转换为 <code>for&lt;&#39;a, T&gt; Fn() -&gt; &amp;&#39;a T</code> 并不是⼀个像把 <code>&amp;&#39;static str</code> 强制转换为 <code>&amp;&#39;a str</code> 这样简单直⽩的情况。前者是类型之间的转换，后者是值之间的转换。</p><p><strong>关键点回顾</strong></p><ul><li><code>for &lt;&#39;a，T&gt; fn（）-&gt;＆&#39;a T</code> 签名的函数⽐ <code>for &lt;T&gt; fn（）-&gt;＆&#39;static T</code> 签名的函数要更灵活，并且泛⽤于更多场景</li></ul><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>因为静态分析技术的局限以及 Rust 的保守性，可以看到 Rust 在内存安全做了很多看似很傻的实现（对于 C++ ⾼⼿来说实际上也很傻的）。对于恼羞成怒的 Rust 新⼿（包括作者本⼈），可以会⼀怒之下就 <code>unsafe&#123;&#125;</code> 就开始像写 C ⼀样写 Rust 了，但这显然违背了 Rust 这⻔语⾔的初衷。同时这⾥⾯提到的基于⽣命周期可能发⽣的内存安全问题，也能给 modern C++ 的程序员带来启发，并不是懂点指针和⾯向对象就能说⾃⼰会 C++ 的，⼀个资深的 C++ 程序员要时刻考虑内存安全问题。safe Rust 的好处就是，通过看似很傻的⽣命周期机制，尽可能的去帮程序员规避内存安全问题。</p><ul><li><code>T</code> 是 <code>&amp;T</code> 和 <code>&amp;mut T</code> 的超集</li><li><code>&amp;T</code> 和 <code>&amp;mut T</code> 是不相交的集合</li><li><code>T: &#39;static</code> 应当视为 “ <code>T</code> 满⾜ <code>&#39;static</code> ⽣命周期约束”</li><li>若 <code>T: &#39;static</code> 则 <code>T</code> 可以是⼀个有 <code>&#39;static</code> ⽣命周期的引⽤类型 或 是⼀个所有权类型</li><li>因为 <code>T: &#39;static</code> 包括了所有权类型，所以 <code>T</code><ul><li>可以在运⾏时动态分配</li><li>不需要在整个程序运⾏期间都有效</li><li>可以安全，⾃由地修改</li><li>可以在运⾏时被动态的 drop</li><li>可以有不同⻓度的⽣命周期</li></ul></li><li><code>T: &#39;a</code> ⽐ <code>&amp;&#39;a T</code> 更泛化，更灵活</li><li><code>T: &#39;a</code> 接受所有权类型，内部含有引⽤的所有权类型，和引⽤</li><li><code>&amp;&#39;a T</code> 只接受引⽤</li><li>若 <code>T: &#39;static</code> 则 <code>T: &#39;a</code> 因为对于所有 <code>&#39;a</code> 都有 <code>&#39;static &gt;= &#39;a</code></li><li>⼏乎所有的 Rust 代码都是泛型代码，并且到处都带有被省略掉的泛型⽣命周期注解e</li><li>Rust ⽣命周期省略规则并不保证在任何情况下都正确</li><li>在程序的语义⽅⾯，Rust 并不⽐你懂</li><li>可以试试给你的⽣命周期注解起⼀个有意义的名字</li><li>试着记住你在哪⾥添加了显式⽣命周期注解，以及为什么要</li><li>所有 trait 对象都含有⾃动推导的⽣命周期</li><li>Rust 编译错误的提示信息所提出的修复⽅案并不⼀定能满⾜你对程序的需求</li><li>⽣命周期在编译时被静态确定</li><li>⽣命周期在运⾏时不能被改变</li><li>Rust 借⽤检查器假设所有代码路径都能被执⾏，所以总是选择尽可能短的⽣命周期赋给变量</li><li>尽量避免重借⽤⼀个独占引⽤为共享引⽤，不然你会遇到很多麻烦</li><li>重借⽤⼀个独占引⽤并不会结束其⽣命周期，哪怕它⾃身已经被 drop 掉了</li><li>每个语⾔都有其陷阱</li><li><code>for &lt;&#39;a，T&gt; fn（）-&gt;＆&#39;a T</code> 签名的函数⽐ <code>for &lt;T&gt; fn（）-&gt;＆&#39;static T</code> 签名的函数要更灵活，并且泛⽤于更多场合。</li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="category-chain-item">学习笔记</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Rust/" class="print-no-link">#Rust</a></div></div><div class="license-box my-3"><div class="license-title"><div>【转载】Rust 中常见的有关生命周期的误解</div><div>https://blog.mauve.icu/2024/10/08/rust/rust-lifetime-syntax/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Shiroha</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2024年10月8日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i> </span></a><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/"><span class="hint--top hint--rounded" aria-label="SA - 相同方式共享"><i class="iconfont icon-sa"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2024/11/26/tourist/Hongkong-bank-1/" title="香港银行开卡记-1"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">香港银行开卡记-1</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2024/09/16/acm/codeforces/CodeforcesRound972/" title="Codeforces Round 972 (Div. 2)"><span class="hidden-mobile">Codeforces Round 972 (Div. 2)</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="giscus" class="giscus"></div><script type="text/javascript">Fluid.utils.loadComments("#giscus",(function(){var t={repo:"Hukeqing/Hukeqing.github.io","repo-id":"MDEwOlJlcG9zaXRvcnkzMjM2NjU2MzM=",category:"General(讨论贴)","category-id":"DIC_kwDOE0q-4c4CZYMv","theme-light":"light","theme-dark":"dark",mapping:"pathname","reactions-enabled":1,"emit-metadata":0,"input-position":"top",lang:"zh-CN"},e={};for(let i in t){if(!i.startsWith("theme-"))e[i.startsWith("data-")?i:"data-"+i]=t[i]}window.GiscusThemeLight="light",window.GiscusThemeDark="dark",e["data-theme"]="dark"===document.documentElement.getAttribute("data-user-color-scheme")?"dark":"light";for(let t in e){var i=e[t];null!=i&&""!==i||delete e[t]}var a=document.createElement("script");a.setAttribute("src","https://giscus.app/client.js"),a.setAttribute("crossorigin","anonymous");for(let t in e)a.setAttribute(t,e[t]);var n=document.getElementsByTagName("script"),r=n.length>0?n[n.length-1]:document.head||document.documentElement;r.parentNode.insertBefore(a,r.nextSibling)}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://github.com/Hukeqing/" target="_blank" rel="nofollow noopener"><span>Copyright ♡ Mauve</span></a><br><a href="https://icp.gov.moe/?keyword=20240210" target="_blank">萌ICP备20240210号</a></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script>window.MathJax?(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise()):window.MathJax={tex:{inlineMath:{"[+]":[["$","$"]]}},loader:{load:["ui/lazy"]},options:{renderActions:{insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(t=>{let e=t.parentNode;"li"===e.nodeName.toLowerCase()&&e.parentNode.classList.add("has-jax")})},"",!1]}}},Fluid.events.registerRefreshCallback((function(){"MathJax"in window&&MathJax.startup.document&&"function"==typeof MathJax.startup.document.state&&(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise())}))</script><script src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js"></script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>