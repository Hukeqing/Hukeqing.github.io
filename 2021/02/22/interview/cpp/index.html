<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/image/default/favicon.ico"><link rel="icon" href="/image/default/favicon.ico"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Shiroha"><meta name="keywords" content="ACM,算法,计算机,程序"><meta name="description" content="C++的特性与轨迹 C++ 的特性（C++11及以上） 需要在不同的平台上进行编译 编译后的程序可以在操作系统上直接运行 可以面对过程和面对对象两种设计方式 可以直接操作本地的系统库 可以直接使用操作系统提供的接口 编译后仅对变量的类型进行了存储，不可以进行类似反射的操作 支持无符号整型 变量类型的字节长度受操作系统影响 支持指针、引用、值传递 没有默认提供的 GC 系统 由程序员负责管理变量所储"><meta property="og:type" content="article"><meta property="og:title" content="面试复习（C++）"><meta property="og:url" content="https://blog.mauve.icu/2021/02/22/interview/cpp/"><meta property="og:site_name" content="Shiroha白羽的博客"><meta property="og:description" content="C++的特性与轨迹 C++ 的特性（C++11及以上） 需要在不同的平台上进行编译 编译后的程序可以在操作系统上直接运行 可以面对过程和面对对象两种设计方式 可以直接操作本地的系统库 可以直接使用操作系统提供的接口 编译后仅对变量的类型进行了存储，不可以进行类似反射的操作 支持无符号整型 变量类型的字节长度受操作系统影响 支持指针、引用、值传递 没有默认提供的 GC 系统 由程序员负责管理变量所储"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2021-02-22T06:23:24.000Z"><meta property="article:modified_time" content="2025-10-07T16:18:04.023Z"><meta property="article:author" content="Shiroha"><meta property="article:tag" content="面试准备"><meta name="twitter:card" content="summary_large_image"><meta name="referrer" content="no-referrer-when-downgrade"><title>面试复习（C++） - Shiroha白羽的博客</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4225917_qrl3b9uej4.css"><link rel="stylesheet" href="/font/Blueaka/Blueaka.css"><link rel="stylesheet" href="/font/Blueaka_Bold/Blueaka_Bold.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"blog.mauve.icu",root:"/",version:"1.9.7",typing:{enable:!0,typeSpeed:70,cursorChar:"|",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:"§"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/image/default/mona-loading-dark.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!0,baidu:null,google:"G-N2HYL7N8TD",tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1},gtag:"G-N2HYL7N8TD"},search_path:"/local-search.xml",include_content_in_search:!0};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><script async>Fluid.ctx.dnt||Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=",(function(){function a(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],a("js",new Date),a("config","")}))</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css"><meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/rss.xml" title="Shiroha白羽的博客" type="application/atom+xml">
</head><body><header><div class="header-inner" style="height:80vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Mauve</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/" target="_self"><i class="iconfont icon-home-fill"></i> <span>Home</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/" target="_self"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><i class="iconfont icon-category-fill"></i> <span>分类</span></a><div class="dropdown-menu" aria-labelledby="navbarDropdown"><a class="dropdown-item" href="/categories/ACM-%E7%AE%97%E6%B3%95/" target="_self"><span>ACM-算法</span> </a><a class="dropdown-item" href="/categories/%E5%AD%A6%E4%B9%A0-%E5%BC%80%E5%8F%91-%E5%AE%9E%E7%8E%B0" target="_self"><span>学习-开发-实现</span> </a><a class="dropdown-item" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0" target="_self"><span>学习笔记</span> </a><a class="dropdown-item" href="/categories/%E6%9D%82%E9%A1%B9" target="_self"><span>杂项</span></a></div></li><li class="nav-item"><a class="nav-link" href="/tags/" target="_self"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/links/" target="_self"><i class="iconfont icon-link-fill"></i> <span>好友</span></a></li><li class="nav-item"><a class="nav-link" href="/rss.xml" target="_self"><i class="iconfont icon-rss"></i> <span>RSS</span></a></li><li class="nav-item"><a class="nav-link" href="https://www.travellings.cn/go.html" target="_self"><i class="iconfont icon-train"></i> <span>开往</span></a></li><li class="nav-item"><a class="nav-link" href="/about/" target="_self"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item"><a class="nav-link" href="/last/page" target="_self"><i class="iconfont icon-jieshu"></i> <span>终页</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/image/default/bg/BA_CG_View_Kivotos2.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="面试复习（C++）"></span></div><div class="mt-3"><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden="true"></i> Shiroha </span><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2021-02-22 14:23" pubdate>2021年2月22日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i>3.6k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i>30 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> 浏览 <span id="busuanzi_value_page_pv"></span> 次</span></div></div><div class="scroll-down-bar"><i class="iconfont icon-arrowdown"></i></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 id="seo-header">面试复习（C++）</h1><div class="markdown-body"><h1 id="C-的特性与轨迹"><a href="#C-的特性与轨迹" class="headerlink" title="C++的特性与轨迹"></a>C++的特性与轨迹</h1><ul><li>C++ 的特性（C++11及以上）<ul><li>需要在不同的平台上进行编译</li><li>编译后的程序可以在操作系统上直接运行</li><li>可以面对过程和面对对象两种设计方式</li><li>可以直接操作本地的系统库</li><li>可以直接使用操作系统提供的接口</li><li>编译后仅对变量的类型进行了存储，不可以进行类似反射的操作</li><li>支持无符号整型</li><li>变量类型的字节长度受操作系统影响</li><li>支持指针、引用、值传递</li><li>没有默认提供的 GC 系统</li><li>由程序员负责管理变量所储存的位置</li><li>严格的 RAII</li><li>支持重写、重载，包括运算符的重载</li><li>多重继承</li><li>支持预编译，编译宏定义</li><li>支持函数指针，函数对象，lambda 表达式</li></ul></li><li>C++ 11 新增的特性<ul><li><code>foreach</code></li><li><code>auto</code> 自动类型推断</li><li><code>lambda</code> 匿名函数</li><li>后置返回类型</li><li><code>override</code> 关键字</li><li><code>nullptr</code> 代替原来的 NULL<ul><li>当存在 <code>void a(int x);</code> 和 <code>void a(char *x)</code> 时，若使用 <code>a(NULL)</code> 则会调用前者，这与通常的理解不同，而使用 <code>a(nullptr)</code> 则会明确的调用后者</li></ul></li><li>元组 tuple，可以使用 <code>get&lt;&gt;()</code> 取出其中的一个值，或者使用 <code>tie()</code> 装包或解包</li></ul></li></ul><h1 id="struct-和-class"><a href="#struct-和-class" class="headerlink" title="struct 和 class"></a>struct 和 class</h1><ul><li>区别<ul><li>struct 默认使用 public 而 class 默认使用 private</li><li>struct 可以直接使用 <code>&#123;&#125;</code> 进行初始化，而 class 则需要所有成员变量都是 public 的时候才可以使用</li></ul></li></ul><h1 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h1><ul><li>操作系统角度<ul><li>堆是操作系统为进程所分配的空间，在 C、C++ 语言中用来存放全局变量。由程序员管理，主动申请以及释放的空间，可能会出现内存泄漏。在进程结束后，由操作系统回收</li><li>栈是由编译器进行管理，由编译器进行申请，释放的空间，通常比堆要小很多，在 C、C++ 语言中，当调用一个函数时会创建一个栈，当函数结束时则会回收栈的空间</li></ul></li><li>数据结构的角度<ul><li>堆是一棵完全二叉树，常见的有最大堆和最小堆，以最大堆为例，其满足二叉树中的任意一个节点的孩子节点都比此节点小。通常用来实现优先队列的效果，插入和删除的复杂度均为 O(logN)</li><li>栈是一种线性数据结构，满足先进后出的特点，即最先进入的数据最后离开，常见于 DFS 中。也可以通过单调栈的方式求解一些问题。插入和删除的复杂度均为 O(1)</li></ul></li></ul><h1 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h1><ul><li>虚函数<ul><li>虚函数由 virtual 标记</li><li>普通的虚函数仍然需要进行实现，所有继承此类的派生类可以重新实现此函数也可以不实现</li></ul></li><li>纯虚函数<ul><li>纯虚函数在普通的虚函数后，加上 <code>=0</code></li><li>当一个类拥有纯虚函数后，则此类变成抽象类，不可以进行实例化</li><li>纯虚函数不需要实现，且所有继承自此类的派生类必须实现此函数，否则派生类也是抽象类，不可以实例化</li></ul></li><li>虚函数的实现原理<ul><li>在类中保存一张虚函数表，表内保存了函数所在的代码段</li><li>当其他类继承自此类时，复制一份此虚函数表。当其中的虚函数进行实现后，将虚函数表中此函数的指针指向新的函数的地址</li><li>定义类的实例的时候，在类的开头保存了一个指向此虚函数表的指针，当需要调用此函数的时候，通过此指针找到对应的函数地址</li></ul></li></ul><h1 id="静态函数和虚函数"><a href="#静态函数和虚函数" class="headerlink" title="静态函数和虚函数"></a>静态函数和虚函数</h1><ul><li>静态函数和虚函数的区别<ul><li>静态函数在编译时就确定了运行的时机，而虚函数则是在运行的过程中动态的得知虚函数地址</li></ul></li></ul><h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><ul><li>扩容规则<ul><li>当空间不足的时候，vector 会扩容至当前空间的 2(GCC下)/1.5(MSVC)</li></ul></li><li>为什么这样扩容<ul><li>以两倍空间为例，当扩容次数为 30 次左右时，vector 的空间达到 1e9 （十亿）而通常每次扩容，都会需要在堆上重新分配空间，需要重新移动整个数组到新的空间。由此，可以得出重新分配空间的次数越少越好，同时也要节约内存的占用，因为按照此增长，其内存的重复的分配次数始终在常数范围内，所以采用了上述的扩容方式。</li></ul></li><li>MSVC下的 1.5 倍的空间相对于 GCC 下的 2 倍有什么好处和坏处<ul><li>好处：因为 2 倍空间下，任意一个空间都大于之前所有分配过的空间之和，这就意味着每次进行扩容的时候都需要分配一个新的空间。而在 1.5 倍下，可以重复使用之前的空间，1.5 倍相对会节约内存</li><li>坏处： 1.5 倍下的重新分配次数更多，也就意味着需要更多的重新分配空间和重新移动的次数，更加浪费时间</li></ul></li><li>clear 的复杂度<ul><li>复杂度与已有的元素数量成线性，因为每个元素都需要析构</li><li>clear 后，并不会改变 vector 的容量上限，只会更新 vector 内的 size 大小</li></ul></li></ul><h1 id="队列和堆栈的模拟"><a href="#队列和堆栈的模拟" class="headerlink" title="队列和堆栈的模拟"></a>队列和堆栈的模拟</h1><ul><li>用两个堆栈模拟队列<ul><li>将两个堆栈命名为 A、B</li><li>若 B 堆栈为空，则将 A 堆栈的所有值都推入 B 中</li><li>若需要推入，则推入到 A 中</li><li>若需要推出，则从 B 中推出</li></ul></li><li>用两个队列模拟堆栈<ul><li>将两个队列命名为 A、B</li><li>若需要推入，则推入到 A 中</li><li>若需要弹出，则将 A 中的值除了最后一个，其他都推入到 B 中，且仅留下一个值，然后弹出这个值，并将 A、B 队列命名为 B、A 队列</li></ul></li></ul><h1 id="四个类型转换"><a href="#四个类型转换" class="headerlink" title="四个类型转换"></a>四个类型转换</h1><div class="table-container"><table><thead><tr><th style="text-align:center">转换</th><th style="text-align:center">特点</th></tr></thead><tbody><tr><td style="text-align:center">static_cast</td><td style="text-align:center">普通的转换，与普通的 C 语言的强制类型转换相同，在编译期间进行转换，所以会检查转换是否合法</td></tr><tr><td style="text-align:center">const_cast</td><td style="text-align:center">去除 const 属性，但是不能去除其本身的 const 属性</td></tr><tr><td style="text-align:center">reinterpret_cast</td><td style="text-align:center">无条件强制转换</td></tr><tr><td style="text-align:center">dynamic_cast</td><td style="text-align:center">将基类转换为派生类</td></tr></tbody></table></div><h1 id="三个访问限制"><a href="#三个访问限制" class="headerlink" title="三个访问限制"></a>三个访问限制</h1><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">private</td><td style="text-align:center">私有的，仅此类可以访问此属性</td></tr><tr><td style="text-align:center">protect</td><td style="text-align:center">保护的，仅此类已经此类的派生类可以访问此属性</td></tr><tr><td style="text-align:center">public</td><td style="text-align:center">公有的，任意对象和方法可以访问此属性</td></tr></tbody></table></div><h1 id="下面这段代码最终结果是"><a href="#下面这段代码最终结果是" class="headerlink" title="下面这段代码最终结果是"></a>下面这段代码最终结果是</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">main</span> () &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xxx&quot;</span>);<br>    fork();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>为 <code>xxxxxx</code></li><li>由于有输出缓存，实际上在 fork 的时候，并没有输出至屏幕，而是保存在缓存中，当程序结束时，将缓存中的值输出至终端，所以得到 <code>xxxxxx</code></li></ul><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><ul><li>static 变量的特点<ul><li>该变量在全局数据区分配内存</li><li>未经初始化的静态全局变量会被程序自动初始化为0（自动变量的值是随机的，除非它被显式初始化）</li><li>静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的</li></ul></li></ul><h1 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h1><ul><li>指针和引用的区别<ul><li>指针有自己的内存空间，是一个变量类型，而引用没有占用内存空间，只是一个别名</li><li>使用 <code>sizeof</code> 可以求得在 32 位操作系统下，指针的大小为 $4$ 个字节，而引用则为原对象的大小</li><li>指针可以初始化为任意正整数值，而引用必须初始化为一个已经存在的变量</li><li>参数传递时，指针需要先进行指针转为引用然后再使用，而引用可以直接操作原对象</li><li>指针可以有 const 属性，而引用没有 const 属性</li><li>指针可以重新赋值，而引用不可以更改</li><li>指针可以进行多级指针，而引用只有一级</li><li>指针可以引用进行 ++（自增）操作的逻辑和结果都不同</li><li>当需要返回动态内存分配的对象时，需要使用指针而不是引用，因为引用可能会产生内存泄漏</li></ul></li></ul><h1 id="平面几何问题"><a href="#平面几何问题" class="headerlink" title="平面几何问题"></a>平面几何问题</h1><ul><li>判断一个点是否在一个三角形内<ul><li>定义三角形为 $ \vartriangle ABC$，点为 $P$，计算 $ S<em>{\vartriangle ABC} = S</em>{\vartriangle ABP} + S<em>{\vartriangle ACP} + S</em>{\vartriangle BCP}$ 是否成立。而三角形面积可以通过割补法或者叉积求</li></ul></li></ul><h1 id="c-智能指针"><a href="#c-智能指针" class="headerlink" title="c++智能指针"></a>c++智能指针</h1><ul><li><code>auto_ptr</code>（已弃用）<ul><li>采用所有权模式，任何一个 <code>new</code> 的对象只能由一个 <code>auto_ptr</code> 来指向，进行赋值操作会使得原来的指针丢失指向的对象</li></ul></li><li><code>unique_ptr</code><ul><li>与 <code>auto_ptr</code> 相同，但是进行赋值操作时，会直接报错，而 <code>auto_ptr</code> 不会</li></ul></li><li><code>shared_ptr</code><ul><li>共享指针，允许多个指针指向此对象，同时当所有指向此对象的指针都被析构后，此对象将会被删除</li></ul></li><li><code>weak_ptr</code><ul><li>弱共享指针，允许指向其他的 <code>shared_ptr</code> 对象，此指针不会影响 <code>shared_ptr</code> 的析构行为，通常用来避免相互指向问题</li></ul></li></ul><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><ul><li>构造函数有哪些特征<ul><li>名字和类名相同</li><li>没有返回值</li><li>生成类的自动执行，不需要调用</li></ul></li><li>为什么构造函数不可以是虚函数<ul><li>因为虚函数表指针是在构造函数期间创建的，没有虚函数表就没有办法调用虚函数</li></ul></li></ul><h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><ul><li>析构函数的作用<ul><li>如果一个类中有指针，且这个指针指向了一段由此类的实例请求分配的空间，那么需要由析构函数来实现对这块区域的释放，否则会造成内存泄漏</li></ul></li><li>C++ 为什么习惯把析构函数定义为虚函数<ul><li>当这个类需要作为父类派生的时候，如果程序得到的是此父类的指针，那么此时就无法析构子类，出现内存泄漏</li></ul></li><li>C++ 为什么默认的析构函数不是虚函数<ul><li>虚函数需要额外的虚函数表和虚函数表指针，对于不会派生的类而言，浪费空间</li></ul></li></ul><h1 id="重载和覆盖"><a href="#重载和覆盖" class="headerlink" title="重载和覆盖"></a>重载和覆盖</h1><ul><li>重载和覆盖的区别<ul><li>重载：两个相同的函数名，但是参数列表不同</li><li>覆盖：父类创建的虚函数，派生类重新定义</li></ul></li></ul><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><ul><li>C++ 中的锁类型<ul><li>互斥锁：对于同一个变量只允许一个线程进行读写，若不满足时则会进入阻塞，并且 CPU 不会进入忙等</li><li>条件锁：当满足某个条件时，再唤醒此线程，否则一直处于阻塞状态</li><li>自旋锁：不断的检查锁是否满足条件，不释放 CPU，比较耗费 CPU</li><li>读写锁：允许有读锁的时候再加读锁，但是有写锁时不再能加任何锁</li><li>递归锁：允许同一个线程对同一个锁进行多次加锁</li></ul></li></ul><h1 id="new和malloc"><a href="#new和malloc" class="headerlink" title="new和malloc"></a>new和malloc</h1><ul><li>new 和 malloc 的区别<ul><li>new 是一个 c++ 关键字，不需要头文件支持，而 malloc 是一个函数，需要头文件支持</li><li>malloc 需要给出需要的空间大小，而 new 不需要</li><li>new 返回的是对象的指针，而 malloc 返回的是 void* 类型的指针</li><li>new 分配失败时会抛出错误，而 malloc 失败时返回空指针</li><li>new 会调用被构造的类型的构造函数，而 malloc 只是分配内存空间</li><li>可以重载 new 操作，但是不能重载 malloc 操作</li></ul></li><li>delete 和 free 的区别<ul><li>delete 会调用析构函数，而 free 直接回收空间</li></ul></li></ul><h1 id="C-编译"><a href="#C-编译" class="headerlink" title="C++ 编译"></a>C++ 编译</h1><ul><li>从源文件到可执行文件的过程<ul><li>预处理，宏定义替换</li><li>编译，生成汇编代码</li><li>汇编，将汇编代码转为机器代码，生成目标文件</li><li>链接，将多个目标文件连接成最终可执行文件</li></ul></li></ul><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><ul><li>C++ 的内存分布<ul><li>代码段：存储机器代码和字符串常量</li><li>数据段：存储程序中已初始化的全局变量和静态变量</li><li>BSS段：存储未初始化的全局变量和静态变量，以及所有被初始化为 0 的全局变量和静态变量</li><li>堆区：调用 <code>new/malloc</code> 函数时动态管理分配的内存，同时需要用 <code>delete/free</code> 来手动释放</li><li>栈区：使用栈空间存储的函数的变量和返回值等</li><li>映射区：存储动态链接库以及调用 <code>mmap</code> 函数进行的文件映射</li></ul></li><li>C++ 内存泄漏检查<ul><li>通过 valgrind 检查一个调试程序</li><li>valgrind 可以检查出内存泄漏、越界访问、未初始化内存</li></ul></li></ul><h1 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h1><ul><li>静态方法和实例方法有何不同<ul><li>调用时，静态方法既可以用 <code>类名.方法名</code> 和 <code>对象名.方法名</code>，而实例方法只能用后者</li><li>静态方法只能访问静态变量，而实例方法可以访问静态变量和成员变量</li></ul></li></ul><h1 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h1><ul><li>如何确定一个值是左值还是右值<ul><li>提供了地址的为左值，左值可以没有值，但是一定有地址</li><li>提供了值的为右值，右值可以没有地址，但是一定有值</li></ul></li><li>右值引用的功能<ul><li>移动语句</li><li>完美转发</li></ul></li><li>更详细的内容见<a href="/2023/09/03/cpp/lvalue-xvalue-prvalue/">此处</a></li></ul><h1 id="C-hash"><a href="#C-hash" class="headerlink" title="C++ hash"></a>C++ hash</h1><ul><li>C++ 的内置 <code>hash</code> 函数的实现<ul><li>对于基础变量，<code>hash</code> 函数返回值为此变量的值，不做修改</li><li>对于 <code>string</code>，<code>hash</code> 函数对每四个字节(64位操作系统下)进行位运算最终得到结果，实际的内部过程使用了两个特殊的固定值，下面是 C++ 的字符串 <code>hash</code> 函数的实际内部实现（C++11）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> std::<span class="hljs-type">size_t</span> <span class="hljs-title">unaligned_load</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *p)</span> </span>&#123;<br>    std::<span class="hljs-type">size_t</span> result;<br>    __builtin_memcpy(&amp;result, p, <span class="hljs-built_in">sizeof</span>(result));<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-type">size_t</span> _Hash_bytes(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> len, <span class="hljs-type">size_t</span> seed = <span class="hljs-number">0xc70f6907</span>UL) &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> m = <span class="hljs-number">0x5bd1e995</span>;<br>    <span class="hljs-type">size_t</span> hash = seed ^len;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span> *&gt;(ptr);<br><br>    <span class="hljs-comment">// Mix 4 bytes at a time into the hash.</span><br>    <span class="hljs-keyword">while</span> (len &gt;= <span class="hljs-number">4</span>) &#123;<br>        <span class="hljs-type">size_t</span> k = <span class="hljs-built_in">unaligned_load</span>(buf);<br>        k *= m;<br>        k ^= k &gt;&gt; <span class="hljs-number">24</span>;<br>        k *= m;<br>        hash *= m;<br>        hash ^= k;<br>        buf += <span class="hljs-number">4</span>;<br>        len -= <span class="hljs-number">4</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Handle the last few bytes of the input array.</span><br>    <span class="hljs-keyword">switch</span> (len) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>            hash ^= <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;(buf[<span class="hljs-number">2</span>]) &lt;&lt; <span class="hljs-number">16</span>;<br>            [[gnu::fallthrough]];<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            hash ^= <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;(buf[<span class="hljs-number">1</span>]) &lt;&lt; <span class="hljs-number">8</span>;<br>            [[gnu::fallthrough]];<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            hash ^= <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;(buf[<span class="hljs-number">0</span>]);<br>            hash *= m;<br>    &#125;;<br><br>    <span class="hljs-comment">// Do a few final mixes of the hash.</span><br>    hash ^= hash &gt;&gt; <span class="hljs-number">13</span>;<br>    hash *= m;<br>    hash ^= hash &gt;&gt; <span class="hljs-number">15</span>;<br>    <span class="hljs-keyword">return</span> hash;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="category-chain-item">学习笔记</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87/" class="print-no-link">#面试准备</a></div></div><div class="license-box my-3"><div class="license-title"><div>面试复习（C++）</div><div>https://blog.mauve.icu/2021/02/22/interview/cpp/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Shiroha</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2021年2月22日</div></div><div class="license-meta-item"><div>许可协议</div><div><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i> </span></a><a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/"><span class="hint--top hint--rounded" aria-label="SA - 相同方式共享"><i class="iconfont icon-sa"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2021/02/22/interview/operating-system/" title="面试复习（操作系统）"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">面试复习（操作系统）</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/2021/02/06/acm/codeforces/CodeforcesRound699/" title="Codeforces Round#699 (Div. 2)"><span class="hidden-mobile">Codeforces Round#699 (Div. 2)</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id="comments" lazyload><div id="giscus" class="giscus"></div><script type="text/javascript">Fluid.utils.loadComments("#giscus",(function(){var t={repo:"Hukeqing/Hukeqing.github.io","repo-id":"MDEwOlJlcG9zaXRvcnkzMjM2NjU2MzM=",category:"General(讨论贴)","category-id":"DIC_kwDOE0q-4c4CZYMv","theme-light":"light","theme-dark":"dark",mapping:"pathname","reactions-enabled":1,"emit-metadata":0,"input-position":"top",lang:"zh-CN"},e={};for(let i in t){if(!i.startsWith("theme-"))e[i.startsWith("data-")?i:"data-"+i]=t[i]}window.GiscusThemeLight="light",window.GiscusThemeDark="dark",e["data-theme"]="dark"===document.documentElement.getAttribute("data-user-color-scheme")?"dark":"light";for(let t in e){var i=e[t];null!=i&&""!==i||delete e[t]}var a=document.createElement("script");a.setAttribute("src","https://giscus.app/client.js"),a.setAttribute("crossorigin","anonymous");for(let t in e)a.setAttribute(t,e[t]);var n=document.getElementsByTagName("script"),r=n.length>0?n[n.length-1]:document.head||document.documentElement;r.parentNode.insertBefore(a,r.nextSibling)}))</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://github.com/Hukeqing/" target="_blank" rel="nofollow noopener"><span>Copyright ♡ Mauve</span></a><br><a href="https://icp.gov.moe/?keyword=20240210" target="_blank">萌ICP备20240210号</a></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script>window.MathJax?(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise()):window.MathJax={tex:{inlineMath:{"[+]":[["$","$"]]}},loader:{load:["ui/lazy"]},options:{renderActions:{insertedScript:[200,()=>{document.querySelectorAll("mjx-container").forEach(t=>{let e=t.parentNode;"li"===e.nodeName.toLowerCase()&&e.parentNode.classList.add("has-jax")})},"",!1]}}},Fluid.events.registerRefreshCallback((function(){"MathJax"in window&&MathJax.startup.document&&"function"==typeof MathJax.startup.document.state&&(MathJax.startup.document.state(0),MathJax.texReset(),MathJax.typeset(),MathJax.typesetPromise())}))</script><script src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js"></script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>