<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/10/07/bangumi/Summer-Pockets/"/>
    <url>/2025/10/07/bangumi/Summer-Pockets/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>香港银行开卡记-1</title>
    <link href="/2024/11/26/tourist/Hongkong-bank-1/"/>
    <url>/2024/11/26/tourist/Hongkong-bank-1/</url>
    
    <content type="html"><![CDATA[<p><em>本文内嵌了 Google Map，请考虑当前的网络环境是否支持查看</em></p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前段时间前往了香港一趟，主要是因为我妈想要换手机了，所以只能打算把我现在的手机给她，然后我自己再去买个新的。考虑到现在 Apple Intelligence 也没有打算在国内上线，所以打算去一趟香港买手机，顺便办下卡</p><p>由于自己早就有了别的港卡，所以这次去香港主要是想要办一张中国银行的卡。虽然中资银行的服务不咋滴，同时背景也不好，但是给的汇率确实令人欣喜</p><h1 id="安排"><a href="#安排" class="headerlink" title="安排"></a>安排</h1><p>考虑到中国银行周六只上半天班，周日不上班的情况，所以如果要办理的话，推荐周五或者其他工作日去办理，大概办理一次的时间要 1-2 个小时</p><p>我的方案是周四晚就飞到深圳，然后在福田站附近先睡一晚，第二天一大早起来赶火车去火车站，福田站有一条直达的火车线路，虽然一般地图会告诉你需要 1 小时左右，但是实际上过去大概只需要 15 分钟，这里预估的时间应该都是加上了过海关之类的时间</p><p><img src="/image/tourist/Hongkong-bank-1/train-line.png" alt="火车线路"></p><p>如果打算的是 walk-in，由于开户需要很早过去排队，所以推荐尽可能早的火车班次，然后直接去银行门口排队等开门，特别是西九龙这块的银行，比如中港城的</p><iframe src="https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d2406.067654016798!2d114.164766813958!3d22.2998249809393!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x340400ed2c5caca9%3A0x3f1711ae25a645dd!2z5Lit5Zu96ZO26KGM5Lit5riv5Z-O5YiG6KGM!5e0!3m2!1szh-CN!2shk!4v1732667999289!5m2!1szh-CN!2shk" width="600" height="450" style="border:0;" allowfullscreen="" loading="lazy" referrerpolicy="no-referrer-when-downgrade"></iframe><p>这家银行一天只给 25 个开户名额，所以基本上只要超过 9 点到，就赶不上了。这里推荐一家我去开的分行，在九龙城区</p><iframe src="https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d822.9527565549128!2d114.18952191614974!3d22.328459499306053!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x3404072ac8be6b63%3A0x6369dc15cff591a0!2z5Lit5Zu96ZO26KGMIOihmeWJjeWbtOmBk-WIhuihjA!5e0!3m2!1szh-CN!2shk!4v1732582508784!5m2!1szh-CN!2shk" width="600" height="450" style="border:0;" allowfullscreen="" loading="lazy" referrerpolicy="no-referrer-when-downgrade"></iframe><p>这家在西九龙下火车后，直接做地铁就可以直达，非常快，而且人比较少，一般 14 点 walk-in 都能进去开户。特别的一点是，这里附近 100米就有一家图书馆，香港的图书馆提供打印服务，所以如果缺少什么文件的话，就可以来这里打印，虽然开门有点晚</p><p>当然也可以考虑走预约开户，地址是 <a href="https://www.bochk.com/tc/contact/online/hkpaccountopen.html">这里</a>，但是预约其实挺难预约到好的分行，基本上提前一周进去开，还是不一定能抢到西九龙的预约名额。所以如果真的要推荐的话，可以先看看能不能预约上，即使是北区也凑合，然后再 walk-in 这家试试能成就行，不能成再去北区</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>中银香港开户是需要准备纸质材料的，但是最终他们不收材料，只会拿你的材料复印一份存档。我这边推荐带上以上材料</p><ul><li>身份证（原件，无需复印，必须）</li><li>港澳通行证/护照（原件，无需复印，必须）</li><li>过关小票（原件，无需复印，必须）</li><li>最近的信用卡账单，要求上面必须要有一个居住地址，作为地址证明（如果没有的话，那就用身份证上的地址作为居住地址吧）<ul><li>国内的信用卡现在都是用电子账单，不一定有居住地址，很多银行是支持开带有居住地址的信用卡账单的，可以问下客服</li><li>因为国内的信用卡账单填写的实际上是通讯地址，也不怎么检查地址的真实性，所以实际上可以通过国内信用卡地址来把你银行登记的居住地址改为任意地址</li><li>如果给不出信用卡账单之类的东西，那就乖乖填身份证上的地址吧，记得跟柜员说你的通讯地址和居住地址不同，这样后续寄送材料的时候，就可以问问是否会寄送到通讯地址而不是居住地址</li><li>因为很多寄送的卡片都是平邮，如果你的居住地址比较偏僻，可能会导致丢件，所以推荐还是通讯地址填写一个比较可靠一点的地方</li></ul></li><li>公司内提供的收入证明，用来证明你的收入资产，开户会方便很多</li><li>最近半年的银行卡流水，同上，也是为了财产证明，毕竟国外的银行让你来开户都是希望从你身上赚点钱，而不是就白白让你开个户然后里面一分钱都不留</li><li>找一个过去的证券账户的结单，一般不推荐最近的结单，可以早半年甚至一年的结单</li><li>如果希望开通中银香港的美元证券账户的话，需要地址证明是英文的，但好像大家都不会去用他们的美元证券账户，所以好像也没啥用</li><li>另外请务必保证手机号在香港能够正常收到短信，否则开户的手机号你只能临时找别人的手机号顶替了</li></ul>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>港卡</tag>
      
      <tag>香港</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【转载】Rust 中常见的有关生命周期的误解</title>
    <link href="/2024/10/08/rust/rust-lifetime-syntax/"/>
    <url>/2024/10/08/rust/rust-lifetime-syntax/</url>
    
    <content type="html"><![CDATA[<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>Rust学习中最难的部分就是⽣命周期，很多⽣命周期规则衍⽣的复杂情况并没有在 TRPL 中得到介绍，因此本⽂的⽬的是想帮助Rust程序员打通⽣命周期的问题，同时也希望能为 modern C++ 程序员带来⼀些思考和启发。</p><p>本⽂中使⽤的术语可能并不那么官⽅，因此下⾯列出了⼀个表格，记录使⽤的短语及其想表达的含义。</p><div class="table-container"><table><thead><tr><th style="text-align:center">短语</th><th style="text-align:center">意义</th></tr></thead><tbody><tr><td style="text-align:center"><code>T</code></td><td style="text-align:center">1)所有可能类型的集合 <em>或</em> 2)上述集合中的某一个具体类型</td></tr><tr><td style="text-align:center">所有权类型</td><td style="text-align:center">某些非引用类型，其自身拥有所有权 例如 <code>i32</code>, <code>String</code>, <code>Vec</code> 等</td></tr><tr><td style="text-align:center">1)借用类型 <em>或</em> 2) 引用类型</td><td style="text-align:center">引用类型，不考虑可变性 例如 <code>&amp;i32</code>, <code>&amp;mut i32</code></td></tr><tr><td style="text-align:center">1)可变引用 <em>或</em> 2) 独占引用</td><td style="text-align:center">独占可变引用，即 <code>&amp;mut T</code></td></tr><tr><td style="text-align:center">1) 不可变引用 <em>或</em> 2) 共享引用</td><td style="text-align:center">可共享不可变引用，即 <code>&amp;T</code></td></tr></tbody></table></div><h1 id="2-误解"><a href="#2-误解" class="headerlink" title="2. 误解"></a>2. 误解</h1><p>简单来讲，⼀个变量的⽣命周期是指⼀段时期，在这段时期内，该变量所指向的内存地址中的数据是有效的，这段时期是由编译器静态分析得出的，有效性由编译器保证。接下来我将探讨这些常⻅误解的细节。</p><h2 id="1-T-只包含所有权类型"><a href="#1-T-只包含所有权类型" class="headerlink" title="1) T 只包含所有权类型"></a>1) <code>T</code> 只包含所有权类型</h2><p>这更像是对泛型的误解⽽⾮对⽣命周期的误解，但在 Rust 中，泛型与⽣命周期的关系是如此紧密，以⾄于不可能只讨论其中⼀个⽽忽视另外⼀个。当我刚开始学习 Rust 时，我知道 <code>i32</code> , <code>&amp;i32</code> , 和 <code>&amp;mut i32</code> 是不同的类型，同时我也知泛型 <code>T</code> 表示所有可能类型的集合。然⽽，尽管能分别理解这两个概念，但我却没能将⼆者结合起来。在当时我这位 Rust 初学者的眼⾥，泛型是这样运作的：</p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center"><code>T</code></th><th style="text-align:center"><code>&amp;T</code></th><th style="text-align:center"><code>&amp;mut T</code></th></tr></thead><tbody><tr><td style="text-align:center">例子</td><td style="text-align:center"><code>i32</code></td><td style="text-align:center"><code>&amp;i32</code></td><td style="text-align:center"><code>&amp;mut i32</code></td></tr></tbody></table></div><p>其中 <code>T</code> 包全体所有权类型；<code>&amp;T</code> 包括全体不可变引⽤； <code>&amp;mut T</code> 包括全体可变引⽤；<code>T</code>, <code>&amp;T</code>, 和 <code>&amp;mut T</code> 是不相交的有限集。简洁明了，符合直觉，却完全错误。事实上泛型是这样运作的：</p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center"><code>T</code></th><th style="text-align:center"><code>&amp;T</code></th><th style="text-align:center"><code>&amp;mut T</code></th></tr></thead><tbody><tr><td style="text-align:center">例子</td><td style="text-align:center"><code>i32</code>, <code>&amp;i32</code>, <code>&amp;mut i32</code>, <code>&amp;&amp;i32</code>, <code>&amp;mut &amp;mut i32</code></td><td style="text-align:center"><code>&amp;i32</code>, <code>&amp;&amp;i32</code>, <code>&amp;&amp;mut i32</code></td><td style="text-align:center"><code>&amp;mut i32</code>, <code>&amp;mut &amp;mut i32</code>, <code>&amp;mut &amp;i32</code></td></tr></tbody></table></div><p><code>T</code> , <code>&amp;T</code> , 和 <code>&amp;mut T</code> 都是⽆限集，因为你可以借⽤⼀个类型⽆限次。<code>T</code> 是 <code>&amp;T</code> 和 <code>&amp;mut T</code> 的超集。<code>&amp;T</code> 和 <code>&amp;mut T</code> 是不相交的集合. 下⾯有⼀些例⼦来验证这些概念：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Trait</span> &#123;&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Trait <span class="hljs-keyword">for</span> <span class="hljs-title class_">T</span> &#123;&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Trait <span class="hljs-keyword">for</span> &amp;T &#123;&#125; <span class="hljs-comment">// 编译错误</span><br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Trait <span class="hljs-keyword">for</span> &amp;<span class="hljs-keyword">mut</span> T &#123;&#125; <span class="hljs-comment">// 编译错误</span><br></code></pre></td></tr></table></figure><p>上述代码不能编译通过：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs text">error[E0119]: conflicting implementations of trait `Trait` for type `&amp;_`:<br> --&gt; src/lib.rs:5:1<br>  |<br>3 | impl&lt;T&gt; Trait for T &#123;&#125;<br>  | ------------------- first implementation here<br>4 |<br>5 | impl&lt;T&gt; Trait for &amp;T &#123;&#125;<br>  | ^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `&amp;_`<br><br>error[E0119]: conflicting implementations of trait `Trait` for type `&amp;mut _`:<br> --&gt; src/lib.rs:7:1<br>  |<br>3 | impl&lt;T&gt; Trait for T &#123;&#125;<br>  | ------------------- first implementation here<br>...<br>7 | impl&lt;T&gt; Trait for &amp;mut T &#123;&#125;<br>  | ^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `&amp;mut _`<br></code></pre></td></tr></table></figure><p>编译器不允许我们为 <code>&amp;T</code> 和 <code>&amp;mut T</code> 实现 Trait ，因为这与我们为 <code>T</code> 实现的 Trait 发⽣了冲突，⽽ <code>T</code> 已经包括了 <code>&amp;T</code> 和 <code>&amp;mut T</code>. 因为 <code>&amp;T</code> 和 <code>&amp;mut T</code> 是不相交的，所以下⾯的代码可以通过编译：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Trait</span> &#123;&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Trait <span class="hljs-keyword">for</span> &amp;T &#123;&#125; <span class="hljs-comment">// 编译通过</span><br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Trait <span class="hljs-keyword">for</span> &amp;<span class="hljs-keyword">mut</span> T &#123;&#125; <span class="hljs-comment">// 编译通过</span><br></code></pre></td></tr></table></figure><p>关键点回顾</p><ul><li><code>T</code> 是 <code>&amp;T</code> 和 <code>&amp;mut T</code> 的超集</li><li><code>&amp;T</code> 和 <code>&amp;mut T</code> 是不相交的集合</li></ul><h2 id="2-如果-T-39-static-那么-T-直到程序结束为⽌都⼀定是有效的"><a href="#2-如果-T-39-static-那么-T-直到程序结束为⽌都⼀定是有效的" class="headerlink" title="2) 如果 T: &#39;static 那么 T 直到程序结束为⽌都⼀定是有效的"></a>2) 如果 <code>T: &#39;static</code> 那么 <code>T</code> 直到程序结束为⽌都⼀定是有效的</h2><p>错误的推论</p><ul><li><code>T: &#39;static</code> 应该视为 “ <code>T</code> 有着 <code>&#39;static</code> ⽣命周期”</li><li><code>&amp;&#39;static T</code> 和 <code>T: &#39;static</code> 是⼀回事</li><li>若 <code>T: &#39;static</code> 则 <code>T</code> ⼀定是不可变的</li><li>若 <code>T: &#39;static</code> 则 <code>T</code> 只能在编译期创建</li></ul><p>让⼤多数 Rust 初学者第⼀次接触 <code>&#39;static</code> ⽣命周期注解的代码示例⼤概是这样的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">str_literal</span>: &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span> = <span class="hljs-string">&quot;字符串字⾯量&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>他们被告知说 <code>&quot;字符串字⾯量&quot;</code> 是被硬编码到编译出来的⼆进制⽂件当中去的，并在运⾏时被加载到只读内存中，所以它不可变且在程序的整个运⾏期间都有效，这也使其⽣命周期为 <code>&#39;static</code>. 在了解到 Rust 使⽤ <code>static</code> 来定义静态变量这⼀语法后，这⼀观点还会被进⼀步加强。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> BYTES: [<span class="hljs-type">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> MUT_BYTES: [<span class="hljs-type">u8</span>; <span class="hljs-number">3</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    MUT_BYTES[<span class="hljs-number">0</span>] = <span class="hljs-number">99</span>; <span class="hljs-comment">// 编译错误，修改静态变量是 unsafe 的</span><br><br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        MUT_BYTES[<span class="hljs-number">0</span>] = <span class="hljs-number">99</span>;<br>        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">99</span>, MUT_BYTES[<span class="hljs-number">0</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于静态变量</p><ul><li>它们只能在编译期创建</li><li>它们应当是不可变的，修改静态变量是 unsafe 的</li><li>它们在整个程序运⾏期间有效</li></ul><p>静态变量的默认⽣命周期很有可能是 <code>&#39;static</code>, 对吧？所以可以合理推测 <code>&#39;static</code> ⽣命周期也要遵循同样的规则，对吧？</p><p>确实，但 持有 <code>&#39;static</code> ⽣命周期注解的类型和⼀个满⾜ <code>&#39;static</code> 约束 的类型是不⼀样的。后者可以于<strong>运⾏时被动态分配</strong>，能被安全⾃由地修改，也可以被 drop, 还能存活任意的时⻓。区分 <code>&amp;&#39;static T</code> 和 <code>T: &#39;static</code> 是⾮常重要的⼀点。<code>&amp;&#39;static T</code> 是⼀个指向 <code>T</code> 的不可变引⽤，其中 <code>T</code> 可以被安全地⽆期限地持有，甚⾄可以直到程序结束。这只有在 <code>T</code> ⾃身不可变且保证 在引⽤创建后 不会被 move 时才有可能。<code>T</code> 并不需要在编译时创建。我们可以以内存泄漏为代价，在运⾏时动态创建随机数据，并返回其 <code>&#39;static</code> 引⽤，⽐如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> rand;<br><br><span class="hljs-comment">// 在运⾏时⽣成随机 &amp;&#x27;static str</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">rand_str_generator</span>() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">rand_string</span> = rand::random::&lt;<span class="hljs-type">u64</span>&gt;().<span class="hljs-title function_ invoke__">to_string</span>();<br>    <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">leak</span>(rand_string.<span class="hljs-title function_ invoke__">into_boxed_str</span>())<br>&#125;<br></code></pre></td></tr></table></figure><p><code>T: &#39;static</code> 是指 <code>T</code> 可以被安全地⽆期限地持有，甚⾄可以直到程序结束。 <code>T: &#39;static</code> 在包括了全部 <code>&amp;&#39;static T</code> 的同时，还包括了全部所有权类型， ⽐如 <code>String</code>, <code>Vec</code> 等等。 数据的所有者保证，只要⾃身还持有数据的所有权，数据就不会失效，因此所有者能够安全地⽆期限地持有其数据，甚⾄可以直到程序结束。 <code>T: &#39;static</code> 应当视为 “ <code>T</code> 满⾜ <code>&#39;static</code> ⽣命周期约束” ⽽⾮ “ <code>T</code> 有着 <code>&#39;static</code> ⽣命周期”。 ⼀个程序可以帮助阐述这些概念：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop_static</span>&lt;T: <span class="hljs-symbol">&#x27;static</span>&gt;(t: T) &#123;<br>    std::mem::<span class="hljs-title function_ invoke__">drop</span>(t);<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">strings</span>: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">String</span>&gt; = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">for</span> <span class="hljs-variable">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">10</span> &#123; <br>        <span class="hljs-keyword">if</span> rand::<span class="hljs-title function_ invoke__">random</span>() &#123;<br>            <span class="hljs-comment">// 所有字符串都是随机⽣成的</span><br>            <span class="hljs-comment">// 并且在运⾏时动态分配</span><br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">string</span> = rand::random::&lt;<span class="hljs-type">u64</span>&gt;().<span class="hljs-title function_ invoke__">to_string</span>();<br>            <span class="hljs-comment">// strings获取了string的所有权</span><br>            strings.<span class="hljs-title function_ invoke__">push</span>(string);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 这些字符串是所有权类型，所以他们满⾜ &#x27;static ⽣命周期约束</span><br>    <span class="hljs-keyword">for</span> <span class="hljs-title class_">mut</span> string <span class="hljs-keyword">in</span> strings &#123;<br>        <span class="hljs-comment">// 这些字符串是可变的</span><br>        string.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">&quot;a mutation&quot;</span>);<br>        <span class="hljs-comment">// 这些字符串都可以被 drop</span><br>        <span class="hljs-title function_ invoke__">drop_static</span>(string); <span class="hljs-comment">// 编译通过</span><br>    &#125;<br><br>    <span class="hljs-comment">// 这些字符串在程序结束之前就已经全部失效了</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;i am the end of the program&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>关键点回顾</p><ul><li><code>T: &#39;static</code> 应当视为 “ <code>T</code> 满⾜ <code>&#39;static</code> ⽣命周期约束”</li><li>若 <code>T: &#39;static</code> 则 T 可以是⼀个有 <code>&#39;static</code> ⽣命周期的引⽤类型 <em>或</em> 是⼀个所有权类型</li><li>因为 <code>T: &#39;static</code> 包括了所有权类型，所以 <code>T</code><ul><li>可以在运⾏时动态分配</li><li>不需要在整个程序运⾏期间都有效</li><li>可以安全，⾃由地修改</li><li>可以在运⾏时被动态的 drop</li><li>可以有不同⻓度的⽣命周期</li></ul></li></ul><h2 id="3-amp-39-a-T-和-T-39-a-是⼀回事"><a href="#3-amp-39-a-T-和-T-39-a-是⼀回事" class="headerlink" title="3) &amp;&#39;a T 和 T: &#39;a 是⼀回事"></a>3) <code>&amp;&#39;a T</code> 和 <code>T: &#39;a</code> 是⼀回事</h2><p>这个误解是前⼀个误解的泛化版本。<code>&amp;&#39;a T</code> 要求并隐含了 <code>T: &#39;a</code> ，因为如果 <code>T</code> 本身不能在 <code>&#39;a</code> 范围内保证有效，那么其引⽤也不能在 ‘a 范围内保证有效。例如，Rust 编译器不会运⾏构造⼀个 <code>&amp;&#39;static Ref&lt;&#39;a, T&gt;</code> ，因为如果 <code>Ref</code> 只在 <code>&#39;a</code> 范围内有效，我们就不能给它 <code>&#39;static</code> ⽣命周期。<code>T: &#39;a</code> 包括了全体 <code>&amp;&#39;a T</code> ，但反之不成⽴。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 只接受带有 &#x27;a ⽣命周期注解的引⽤类型</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">t_ref</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T: <span class="hljs-symbol">&#x27;a</span>&gt;(t: &amp;<span class="hljs-symbol">&#x27;a</span> T) &#123;&#125;<br><br><span class="hljs-comment">// 接受满⾜ &#x27;a ⽣命周期约束的任何类型</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">t_bound</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T: <span class="hljs-symbol">&#x27;a</span>&gt;(t: T) &#123;&#125;<br><br><span class="hljs-comment">// 内部含有引⽤的所有权类型</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Ref</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T: <span class="hljs-symbol">&#x27;a</span>&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> T);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">string</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;string&quot;</span>);<br><br>    <span class="hljs-title function_ invoke__">t_bound</span>(&amp;string); <span class="hljs-comment">// 编译通过</span><br>    <span class="hljs-title function_ invoke__">t_bound</span>(<span class="hljs-title function_ invoke__">Ref</span>(&amp;string)); <span class="hljs-comment">// 编译通过</span><br>    <span class="hljs-title function_ invoke__">t_bound</span>(&amp;<span class="hljs-title function_ invoke__">Ref</span>(&amp;string)); <span class="hljs-comment">// 编译通过</span><br>    <span class="hljs-title function_ invoke__">t_ref</span>(&amp;string); <span class="hljs-comment">// 编译通过</span><br>    <span class="hljs-title function_ invoke__">t_ref</span>(<span class="hljs-title function_ invoke__">Ref</span>(&amp;string)); <span class="hljs-comment">// 编译失败，期望得到引⽤，实际得到 struct</span><br>    <span class="hljs-title function_ invoke__">t_ref</span>(&amp;<span class="hljs-title function_ invoke__">Ref</span>(&amp;string)); <span class="hljs-comment">// 编译通过</span><br><br>    <span class="hljs-comment">// 满⾜ &#x27;static 约束的字符串变量可以转换为 &#x27;a 约束</span><br>    <span class="hljs-title function_ invoke__">t_bound</span>(string); <span class="hljs-comment">// 编译通过</span><br>&#125;<br></code></pre></td></tr></table></figure><p>关键点回顾</p><ul><li><code>T: &#39;a</code> ⽐ <code>&amp;&#39;a T</code> 更泛化，更灵活</li><li><code>T: &#39;a</code> 接受所有权类型，内部含有引⽤的所有权类型，和引⽤</li><li><code>&amp;&#39;a T</code> 只接受引⽤</li><li>若 <code>T: &#39;static</code> 则 <code>T: &#39;a</code> 因为对于所有 <code>&#39;a</code> 都有 <code>&#39;static &gt;= &#39;a</code></li></ul><h2 id="4-我的代码⾥不含泛型也不含⽣命周期注解"><a href="#4-我的代码⾥不含泛型也不含⽣命周期注解" class="headerlink" title="4) 我的代码⾥不含泛型也不含⽣命周期注解"></a>4) 我的代码⾥不含泛型也不含⽣命周期注解</h2><p>错误的推论</p><ul><li>避免使⽤泛型和⽣命周期注解是可能的</li></ul><p>这个让⼈爽到的误解之所以能存在，要得益于 Rust 的⽣命周期省略规则，这个规则能允许你在函数<br>定义以及 impl 块中省略掉显式的⽣命周期注解，⽽由借⽤检查器来根据以下规则对⽣命周期进⾏<br>隐式推导。</p><ul><li>第⼀条规则是每⼀个是引⽤的参数都有它⾃⼰的⽣命周期参数</li><li>第⼆条规则是如果只有⼀个输⼊⽣命周期参数，那么它被赋予所有输出⽣命周期参数</li><li>第三条规则是如果是有多个输⼊⽣命周期参数的⽅法，⽽其中⼀个参数是 <code>&amp;self</code> 或 <code>&amp;mut self</code>, 那么所有输出⽣命周期参数被赋予 <code>self</code> 的⽣命周期。</li><li>其他情况下，⽣命周期必须有明确的注解</li></ul><p>这⾥有不少值得讲的东⻄，让我们来看⼀些例⼦：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 显式标注的⽅案</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_str</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>; <span class="hljs-comment">// 泛型版本</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_str</span>() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span>; <span class="hljs-comment">// &#x27;static 版本</span><br><br><span class="hljs-comment">// ⾮法，多个输⼊，不能确定返回值的⽣命周期</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">overlap</span>(s: &amp;<span class="hljs-type">str</span>, t: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span>;<br><br><span class="hljs-comment">// 显式标注（但仍有部分标注被省略）的⽅案</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">overlap</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(s: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, t: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>; <span class="hljs-comment">// 返回值的⽣命周期不⻓于 s</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">overlap</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(s: &amp;<span class="hljs-type">str</span>, t: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>; <span class="hljs-comment">// 返回值的⽣命周期不⻓于 t</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">overlap</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(s: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, t: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>; <span class="hljs-comment">// 返回值的⽣命周期不⻓于 s 且不⻓于 t</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">overlap</span>(s: &amp;<span class="hljs-type">str</span>, t: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span>; <span class="hljs-comment">// 返回值的⽣命周期可以⻓于 s 或者 t</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">overlap</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(s: &amp;<span class="hljs-type">str</span>, t: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>; <span class="hljs-comment">// 返回值的⽣命周期与输⼊⽆关</span><br><br><span class="hljs-comment">// 展开后</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">overlap</span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>&gt;(s: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, t: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">overlap</span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>&gt;(s: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, t: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">str</span>;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">overlap</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(s: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, t: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">overlap</span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>&gt;(s: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, t: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span>;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">overlap</span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>, <span class="hljs-symbol">&#x27;c</span>&gt;(s: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, t: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;c</span> <span class="hljs-type">str</span>;<br><br><span class="hljs-comment">// 展开前</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">compare</span>(&amp;<span class="hljs-keyword">self</span>, s: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span>;<br><br><span class="hljs-comment">// 展开后</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">compare</span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">self</span>, &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>;<br></code></pre></td></tr></table></figure><p>如果你写过</p><ul><li>结构体⽅法</li><li>接收参数中有引⽤的函数</li><li>返回值是引⽤的函数</li><li>泛型函数</li><li>trait object(后⾯将讨论)</li><li>闭包（后⾯将讨论）</li></ul><p>那么对于上⾯这些，你的代码中都有被省略的泛型⽣命周期注解。</p><p><strong>关键点回顾</strong></p><ul><li>⼏乎所有的 Rust 代码都是泛型代码，并且到处都带有被省略掉的泛型⽣命周期注解</li></ul><h2 id="5-如果编译通过了，那么我标注的⽣命周期就是正确的"><a href="#5-如果编译通过了，那么我标注的⽣命周期就是正确的" class="headerlink" title="5) 如果编译通过了，那么我标注的⽣命周期就是正确的"></a>5) 如果编译通过了，那么我标注的⽣命周期就是正确的</h2><p>错误的推论</p><ul><li>Rust 对函数的⽣命周期省略规则总是对的</li><li>Rust 的借⽤检查器总是正确的，⽆论是技巧上还是语义上</li><li>Rust ⽐我更懂我程序的语义</li></ul><p>让⼀个 Rust 程序通过编译但语义上不正确是有可能的。来看看这个例⼦：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ByteIter</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    remainder: &amp;<span class="hljs-symbol">&#x27;a</span> [<span class="hljs-type">u8</span>]<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; ByteIter&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-type">u8</span>&gt; &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.remainder.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>            <span class="hljs-literal">None</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">byte</span> = &amp;<span class="hljs-keyword">self</span>.remainder[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">self</span>.remainder = &amp;<span class="hljs-keyword">self</span>.remainder[<span class="hljs-number">1</span>..];<br>            <span class="hljs-title function_ invoke__">Some</span>(byte)<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">bytes</span> = ByteIter &#123; remainder: <span class="hljs-string">b&quot;1&quot;</span> &#125;;<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-title function_ invoke__">Some</span>(&amp;<span class="hljs-string">b&#x27;1&#x27;</span>), bytes.<span class="hljs-title function_ invoke__">next</span>());<br>    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-literal">None</span>, bytes.<span class="hljs-title function_ invoke__">next</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ByteIter</code> 是⼀个 <code>byte</code> 切⽚上的迭代器，简洁起⻅，我这⾥省略了 Iterator trait 的具体实现。这看起来没什么问题，但如果我们想同时检查多个 <code>byte</code> 呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">bytes</span> = ByteIter &#123; remainder: <span class="hljs-string">b&quot;1123&quot;</span> &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">byte_1</span> = bytes.<span class="hljs-title function_ invoke__">next</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">byte_2</span> = bytes.<span class="hljs-title function_ invoke__">next</span>();<br>    <span class="hljs-keyword">if</span> byte_1 == byte_2 &#123;<br>        <span class="hljs-comment">// ⼀些代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Compiler Error:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust">error[E0499]: cannot borrow `bytes` <span class="hljs-keyword">as</span> mutable more than once at a time<br>  -<span class="hljs-punctuation">-&gt;</span> src/main.rs:<span class="hljs-number">20</span>:<span class="hljs-number">18</span><br>   |<br><span class="hljs-number">19</span> | <span class="hljs-keyword">let</span> <span class="hljs-variable">byte_1</span> = bytes.<span class="hljs-title function_ invoke__">next</span>();<br>   |              ----- first mutable borrow occurs here<br><span class="hljs-number">20</span> | <span class="hljs-keyword">let</span> <span class="hljs-variable">byte_2</span> = bytes.<span class="hljs-title function_ invoke__">next</span>();<br>   |              ^^^^^ second mutable borrow occurs here<br><span class="hljs-number">21</span> | <span class="hljs-keyword">if</span> byte_1 == byte_2 &#123;<br>   |    ------ first borrow later used here<br></code></pre></td></tr></table></figure><p>如果你说可以通过逐 byte 拷⻉来避免编译错误，那么确实。当迭代⼀个 byte 数组上时，我们的确可以通过拷⻉每个 byte 来达成⽬的。但是如果我想要将 <code>ByteIter</code> 改写成⼀个泛型的切⽚迭代器，使得我们能够对任意 <code>&amp;&#39;a [T]</code> 进⾏迭代，⽽此时如果有⼀个 <code>T</code>，其 copy 和 clone 的代价⼗分昂贵，那么我们该怎么避免这种昂贵的操作呢？哦，我想我们不能，毕竟代码都通过编译了，那么⽣命周期注解肯定也是对的，对吧？错，事实上现有的⽣命周期就是 bug 的源头！这个错误的⽣命周期被省略掉了以⾄于难以被发现。现在让我们展开这些被省略掉的⽣命周期来暴露出这个问题。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ByteIter</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    remainder: &amp;<span class="hljs-symbol">&#x27;a</span> [<span class="hljs-type">u8</span>]<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; ByteIter&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>&lt;<span class="hljs-symbol">&#x27;b</span>&gt;(&amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">u8</span>&gt; &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.remainder.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>            <span class="hljs-literal">None</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">byte</span> = &amp;<span class="hljs-keyword">self</span>.remainder[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">self</span>.remainder = &amp;<span class="hljs-keyword">self</span>.remainder[<span class="hljs-number">1</span>..];<br>            <span class="hljs-title function_ invoke__">Some</span>(byte)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>感觉好像没啥⽤，我还是搞不清楚问题出在哪。这⾥有个 Rust 专家才知道的⼩技巧：给你的⽣命周期注解起⼀个更有含义的名字，让我们试⼀下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ByteIter</span>&lt;<span class="hljs-symbol">&#x27;remainder</span>&gt; &#123;<br>    remainder: &amp;<span class="hljs-symbol">&#x27;remainder</span> [<span class="hljs-type">u8</span>]<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;remainder</span>&gt; ByteIter&lt;<span class="hljs-symbol">&#x27;remainder</span>&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>&lt;<span class="hljs-symbol">&#x27;mut_self</span>&gt;(&amp;<span class="hljs-symbol">&#x27;mut_self</span> <span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-symbol">&#x27;mut_self</span> <span class="hljs-type">u8</span>&gt; &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.remainder.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>            <span class="hljs-literal">None</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">byte</span> = &amp;<span class="hljs-keyword">self</span>.remainder[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">self</span>.remainder = &amp;<span class="hljs-keyword">self</span>.remainder[<span class="hljs-number">1</span>..];<br>            <span class="hljs-title function_ invoke__">Some</span>(byte)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个返回的 byte 都被标注为 <code>&#39;mut_self</code>, 但是显然这些 byte 都源于 <code>&#39;remainder</code>! 让我们来修复⼀下这段代码。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ByteIter</span>&lt;<span class="hljs-symbol">&#x27;remainder</span>&gt; &#123;<br>    remainder: &amp;<span class="hljs-symbol">&#x27;remainder</span> [<span class="hljs-type">u8</span>]<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;remainder</span>&gt; ByteIter&lt;<span class="hljs-symbol">&#x27;remainder</span>&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-symbol">&#x27;remainder</span> <span class="hljs-type">u8</span>&gt; &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.remainder.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>            <span class="hljs-literal">None</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">byte</span> = &amp;<span class="hljs-keyword">self</span>.remainder[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">self</span>.remainder = &amp;<span class="hljs-keyword">self</span>.remainder[<span class="hljs-number">1</span>..];<br>            <span class="hljs-title function_ invoke__">Some</span>(byte)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">bytes</span> = ByteIter &#123; remainder: <span class="hljs-string">b&quot;1123&quot;</span> &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">byte_1</span> = bytes.<span class="hljs-title function_ invoke__">next</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">byte_2</span> = bytes.<span class="hljs-title function_ invoke__">next</span>();<br>    std::mem::<span class="hljs-title function_ invoke__">drop</span>(bytes); <span class="hljs-comment">// 我们现在甚⾄可以把这个迭代器给 drop 掉！</span><br>    <span class="hljs-keyword">if</span> byte_1 == byte_2 &#123; <span class="hljs-comment">// 编译通过</span><br>        <span class="hljs-comment">// ⼀些代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们再回过头来看看我们上⼀版的实现，就能看出它是错的了，那么为什么 Rust 会编译通过呢？答案很简单：因为这是内存安全的。Rust 借⽤检查器对⽣命周期注解的要求只到能静态验证程序的内存安全为⽌。即便⽣命周期注解有语义上的错误，Rust 也能让程序编译通过，哪怕这样做为程序带来不必要的限制。这⼉有⼀个和之前相反的例⼦：在这个例⼦中，Rust ⽣命周期省略规则标注的⽣命周期是语义正确的，但是我们却在⽆意间使⽤了不必要的显式注解，导致写出了⼀个限制极其严格的⽅法。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NumRef</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span>);<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; NumRef&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-comment">// 我定义的泛型结构体以 &#x27;a 为参数，这意味着我也需要给⽅法的参数</span><br>    <span class="hljs-comment">// 标注为 &#x27;a ⽣命周期，对吗？（答案：错）</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">some_method</span>(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num_ref</span> = <span class="hljs-title function_ invoke__">NumRef</span>(&amp;<span class="hljs-number">5</span>);<br>    num_ref.<span class="hljs-title function_ invoke__">some_method</span>(); <span class="hljs-comment">// 可变借⽤ num_ref 直⾄其⽣命周期结束</span><br>    num_ref.<span class="hljs-title function_ invoke__">some_method</span>(); <span class="hljs-comment">// 编译错误</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, num_ref); <span class="hljs-comment">// 同样编译错误</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们有⼀个带 <code>&#39;a</code> 泛型参数的结构体，我们⼏乎不可能去写⼀个带 <code>&amp;&#39;a mut self</code> 参数的⽅法。因为这相当于告诉 Rust “这个⽅法将独占借⽤该对象，直到对象⽣命周期结束”。实际上，这意味着 Rust 的借⽤检查器只会允许在该对象上调⽤⾄多⼀次 <code>some_method</code>, 此后该对象将⼀直被独占借⽤并会因此变得不再可⽤。这种⽤例极其罕⻅，但是因为这种代码能够通过编译，所以那些对⽣命周期还感到困惑的初学者们很容易写出这种 bug. 修复这种 bug 的⽅式是去除掉不必要的显式⽣命周期注解，让 Rust ⽣命周期省略规则来处理它：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NumRef</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span>);<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; NumRef&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-comment">// 不再给 mut self 添加 &#x27;a 注解</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">some_method</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// 上⼀⾏去掉语法糖后：</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">some_method_desugared</span>&lt;<span class="hljs-symbol">&#x27;b</span>&gt;(&amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>)&#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num_ref</span> = <span class="hljs-title function_ invoke__">NumRef</span>(&amp;<span class="hljs-number">5</span>);<br>    num_ref.<span class="hljs-title function_ invoke__">some_method</span>();<br>    num_ref.<span class="hljs-title function_ invoke__">some_method</span>(); <span class="hljs-comment">// 编译通过</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>, num_ref); <span class="hljs-comment">// 编译通过</span><br>&#125;<br></code></pre></td></tr></table></figure><p>关键点回顾</p><ul><li>Rust 对函数的⽣命周期省略规则并不保证在任何情况下都正确</li><li>在程序的语义⽅⾯，Rust 并不⽐你懂</li><li>可以试试给你的⽣命周期注解起⼀个有意义的名字</li><li>试着记住你在哪⾥添加了显式⽣命周期注解，以及为什么要加</li></ul><h2 id="6-Boxed-Trait-Object对象不含⽣命周期注解"><a href="#6-Boxed-Trait-Object对象不含⽣命周期注解" class="headerlink" title="6) Boxed Trait Object对象不含⽣命周期注解"></a>6) Boxed Trait Object对象不含⽣命周期注解</h2><p>之前我们讨论了 Rust 对函数 的⽣命周期省略规则。Rust 对 trait 对象也存在⽣命周期省略规则，它<br>们是：</p><ul><li>如果 trait 对象被⽤作泛型类型的⼀个类型参数，那么 trait 对象的⽣命周期约束会依据该类型参数<br>的定义进⾏推导<ul><li>若该类型参数有唯⼀的⽣命周期约束，则将这个约束赋给 trait 对象</li><li>若该类型参数不⽌⼀个⽣命周期约束，则 trait 对象的⽣命周期约束需要显式标注</li></ul></li><li>如果上⾯不成⽴，也就是说该类型参数没有⽣命周期约束，那么<ul><li>若 trait 定义时有且仅有⼀个⽣命周期约束，则将这个约束赋给 trait 对象</li><li>若 trait 定义时⽣命周期约束中存在⼀个 <code>&#39;static</code> , 则将 <code>&#39;static</code> 赋给 trait 对象</li><li>若 trait 定义时没有⽣命周期约束，则当 trait 对象是表达式的⼀部分时，⽣命周期从表达式中推导⽽出，否则赋予 <code>&#39;static</code></li></ul></li></ul><p>以上这些听起来特别复杂，但是可以简单地总结为⼀句话“⼀个 trait 对象的⽣命周期约束从上下⽂推导⽽出。”看下⾯这些例⼦后，我们会看到⽣命周期约束的推导其实很符合直觉，因此我们没必要去记忆上⾯的规则：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">type</span> <span class="hljs-title class_">T2</span> = <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Trait + <span class="hljs-symbol">&#x27;static</span>&gt;;<br><br><span class="hljs-comment">// 展开前</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">dyn</span> Trait &#123;&#125;<br><span class="hljs-comment">// 展开后</span><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">dyn</span> Trait + <span class="hljs-symbol">&#x27;static</span> &#123;&#125;<br><br><span class="hljs-comment">// 展开前</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">T3</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; = &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">dyn</span> Trait;<br><span class="hljs-comment">// 展开后，&amp;&#x27;a T 要求 T: &#x27;a, 所以推导为 &#x27;a</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">T4</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; = &amp;<span class="hljs-symbol">&#x27;a</span> (<span class="hljs-keyword">dyn</span> Trait + <span class="hljs-symbol">&#x27;a</span>);<br><br><span class="hljs-comment">// 展开前</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">T5</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; = Ref&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-keyword">dyn</span> Trait&gt;;<br><span class="hljs-comment">// 展开后，Ref&lt;&#x27;a, T&gt; 要求 T: &#x27;a, 所以推导为 &#x27;a</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">T6</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; = Ref&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-keyword">dyn</span> Trait + <span class="hljs-symbol">&#x27;a</span>&gt;;<br><br><span class="hljs-keyword">trait</span> <span class="hljs-title class_">GenericTrait</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;: <span class="hljs-symbol">&#x27;a</span> &#123;&#125;<br><br><span class="hljs-comment">// 展开前</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">T7</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; = <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> GenericTrait&lt;<span class="hljs-symbol">&#x27;a</span>&gt;&gt;;<br><span class="hljs-comment">// 展开后</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">T8</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; = <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> GenericTrait&lt;<span class="hljs-symbol">&#x27;a</span>&gt; + <span class="hljs-symbol">&#x27;a</span>&gt;;<br><br><span class="hljs-comment">// 展开前</span><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; <span class="hljs-keyword">dyn</span> GenericTrait&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;&#125;<br><span class="hljs-comment">// 展开后</span><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; <span class="hljs-keyword">dyn</span> GenericTrait&lt;<span class="hljs-symbol">&#x27;a</span>&gt; + <span class="hljs-symbol">&#x27;a</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>⼀个实现了 trait 的具体类型可以被引⽤，因此它们也会有⽣命周期约束，同样其对应的 trait 对象也有⽣命周期约束。你也可以直接对引⽤实现 trait, 引⽤显然是有⽣命周期约束的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">trait</span> <span class="hljs-title class_">Trait</span> &#123;&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Struct</span> &#123;&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Ref</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt;(&amp;<span class="hljs-symbol">&#x27;a</span> T);<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Trait</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Struct</span> &#123;&#125;<br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Trait</span> <span class="hljs-keyword">for</span> &amp;Struct &#123;&#125; <span class="hljs-comment">// 直接为引⽤类型实现 Trait</span><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; Trait <span class="hljs-keyword">for</span> <span class="hljs-title class_">Ref</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T&gt; &#123;&#125; <span class="hljs-comment">// 为包含引⽤的类型实现 Trait</span><br></code></pre></td></tr></table></figure><p>总之，这个知识点值得反复理解，新⼿在重构⼀个使⽤ trait 对象的函数到⼀个泛型的函数或者反过来时，常常会因为这个知识点⽽感到困惑。来看看这个示例程序：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::Display;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">dynamic_thread_print</span>(t: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Display + <span class="hljs-built_in">Send</span>&gt;) &#123;<br>    std::thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, t);<br>    &#125;).<span class="hljs-title function_ invoke__">join</span>();<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">static_thread_print</span>&lt;T: Display + <span class="hljs-built_in">Send</span>&gt;(t: T) &#123;<br>    std::thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, t);<br>    &#125;).<span class="hljs-title function_ invoke__">join</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这⾥编译器报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">error[E0310]: the parameter type `T` may not live long enough<br>  --&gt; src/lib.rs:10:5<br>   |<br>9  | fn static_thread_print&lt;T: Display + Send&gt;(t: T) &#123;<br>   |                        -- help: consider adding an explicit lifetime bound...: `T: &#x27;static +`<br>10 |     std::thread::spawn(move || &#123;<br>   |     ^^^^^^^^^^^^^^^^^^<br>   |<br>note: ...so that the type `[closure@src/lib.rs:10:24: 12:6 t:T]` will meet its required lifetime bounds<br>  --&gt; src/lib.rs:10:5<br>   |<br>10 |     std::thread::spawn(move || &#123;<br>   |     ^^^^^^^^^^^^^^^^^^<br></code></pre></td></tr></table></figure><p>很好，编译器告诉了我们怎样修复这个问题，让我们修复⼀下。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::Display;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">dynamic_thread_print</span>(t: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Display + <span class="hljs-built_in">Send</span>&gt;) &#123;<br>    std::thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, t);<br>    &#125;).<span class="hljs-title function_ invoke__">join</span>();<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">static_thread_print</span>&lt;T: Display + <span class="hljs-built_in">Send</span> + <span class="hljs-symbol">&#x27;static</span>&gt;(t: T) &#123;<br>    std::thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, t);<br>    &#125;).<span class="hljs-title function_ invoke__">join</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>现在它编译通过了，但是这两个函数对⽐起来看起来挺奇怪的，为什么第⼆个函数要求 <code>T</code> 满⾜ <code>&#39;static</code> 约束⽽第⼀个函数不⽤呢？这是个刁钻的问题。事实上，通过⽣命周期省略规则，Rust ⾃动在第⼀个函数⾥推导并添加了⼀个 <code>&#39;static</code> 约束，所以其实两个函数都含有 <code>&#39;static</code> 约束。Rust 编译器实际看到的是这个样⼦的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::Display;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">dynamic_thread_print</span>(t: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Display + <span class="hljs-built_in">Send</span> + <span class="hljs-symbol">&#x27;static</span>&gt;) &#123;<br>    std::thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, t);<br>    &#125;).<span class="hljs-title function_ invoke__">join</span>();<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">static_thread_print</span>&lt;T: Display + <span class="hljs-built_in">Send</span> + <span class="hljs-symbol">&#x27;static</span>&gt;(t: T) &#123;<br>    std::thread::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">move</span> || &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, t);<br>    &#125;).<span class="hljs-title function_ invoke__">join</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>关键点回顾</p><ul><li>所有 trait 对象都含有⾃动推导的⽣命周期</li></ul><h2 id="7-编译器的报错信息会告诉我怎样修复我的程序"><a href="#7-编译器的报错信息会告诉我怎样修复我的程序" class="headerlink" title="7) 编译器的报错信息会告诉我怎样修复我的程序"></a>7) 编译器的报错信息会告诉我怎样修复我的程序</h2><p><strong>错误的推论</strong></p><ul><li>Rust 对 trait 对象的⽣命周期省略规则总是正确的</li><li>Rust ⽐我更懂我程序的语义</li></ul><p>这个误解是前两个误解的结合，来看⼀个例⼦：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::Display;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">box_displayable</span>&lt;T: Display&gt;(t: T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Display&gt; &#123;<br>    <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(t)<br>&#125;<br></code></pre></td></tr></table></figure><p>报错如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">error[E0310]: the parameter type `T` may not live long enough<br> --&gt; src/lib.rs:4:5<br>  |<br>3 | fn box_displayable&lt;T: Display&gt;(t: T) -&gt; Box&lt;dyn Display&gt; &#123;<br>  |                    -- help: consider adding an explicit lifetime bound...: `T: &#x27;static +`<br>4 |     Box::new(t)<br>  |     ^^^^^^^^^^^<br>  |<br>note: ...so that the type `T` will meet its required lifetime bounds<br> --&gt; src/lib.rs:4:5<br>  |<br>4 | Box::new(t)<br>  | ^^^^^^^^^^^<br></code></pre></td></tr></table></figure><p>好，让我们按照编译器的提示进⾏修复。这⾥我们先忽略⼀个事实：返回值中装箱的 trait 对象有⼀个⾃动推导的 <code>&#39;static</code> 约束，⽽编译器是基于这个没有显式说明的事实给出的修复建议。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::Display;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">box_displayable</span>&lt;T: Display + <span class="hljs-symbol">&#x27;static</span>&gt;(t: T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Display&gt; &#123;<br>    <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(t)<br>&#125;<br></code></pre></td></tr></table></figure><p>现在可以编译通过了，但这真的是我们想要的吗？可能是，也可能不是，编译器并没有提到其他修复⽅案，但下⾯这个也是⼀个合适的修复⽅案。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::fmt::Display;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">box_displayable</span>&lt;<span class="hljs-symbol">&#x27;a</span>, T: Display + <span class="hljs-symbol">&#x27;a</span>&gt;(t: T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> Display + <span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(t)<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数所能接受的实际参数⽐前⼀个函数多了不少！这个函数是不是更好？确实，但不⼀定必要，这取决于我们对程序的要求与约束。上⾯这个例⼦有点抽象，所以让我们看⼀个更简单明了的例⼦：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">return_first</span>(a: &amp;<span class="hljs-type">str</span>, b: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span> &#123;<br>    a<br>&#125;<br></code></pre></td></tr></table></figure><p>报错</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs text">error[E0106]: missing lifetime specifier<br> --&gt; src/lib.rs:1:38<br>1 | fn return_first(a: &amp;str, b: &amp;str) -&gt; &amp;str &#123;<br>  |                    ----     ----     ^ expected named lifetime parameter<br>  = help: this function&#x27;s return type contains a borrowed value, but the<br>signature does not say whether it is borrowed from `a` or `b`<br>help: consider introducing a named lifetime parameter<br>  |<br>  |<br>  |<br>1 | fn return_first&lt;&#x27;a&gt;(a: &amp;&#x27;a str, b: &amp;&#x27;a str) -&gt; &amp;&#x27;a str &#123;<br>  |                ^^^^    ^^^^^^^     ^^^^^^^     ^^^<br></code></pre></td></tr></table></figure><p>这个错误信息推荐我们给所有输⼊输出都标注上同样的⽣命周期注解。如果我们这么做了，那么程序将通过编译，但是这样写出的函数过度限制了返回类型。我们真正想要的是这个：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">return_first</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(a: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, b: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span> &#123;<br>    a<br>&#125;<br></code></pre></td></tr></table></figure><p>关键点回顾</p><ul><li>Rust 对 trait 对象的⽣命周期省略规则并不保证在任何情况下都正确</li><li>在程序的语义⽅⾯，Rust 并不⽐你懂</li><li>Rust 编译错误的提示信息所提出的修复⽅案并不⼀定能满⾜你对程序的需求</li></ul><h2 id="8-⽣命周期可以在运⾏时动态变⻓或变短"><a href="#8-⽣命周期可以在运⾏时动态变⻓或变短" class="headerlink" title="8) ⽣命周期可以在运⾏时动态变⻓或变短"></a>8) ⽣命周期可以在运⾏时动态变⻓或变短</h2><p>错误的推论</p><ul><li>容器类可以在运⾏时交换其内部的引⽤，从⽽改变⾃身的⽣命周期</li><li>Rust 借⽤检查器能进⾏⾼级的控制流分析</li></ul><p>这个编译不通过：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Has</span>&lt;<span class="hljs-symbol">&#x27;lifetime</span>&gt; &#123;<br>    lifetime: &amp;<span class="hljs-symbol">&#x27;lifetime</span> <span class="hljs-type">str</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">long</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;long&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">has</span> = Has &#123; lifetime: &amp;long &#125;;<br>    <span class="hljs-built_in">assert_eq!</span>(has.lifetime, <span class="hljs-string">&quot;long&quot;</span>);<br><br>    &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">short</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;short&quot;</span>);<br>        <span class="hljs-comment">// “转换到” 短的⽣命周期</span><br>        has.lifetime = &amp;short;<br>        <span class="hljs-built_in">assert_eq!</span>(has.lifetime, <span class="hljs-string">&quot;short&quot;</span>);<br><br>        <span class="hljs-comment">// “转换回” ⻓的⽣命周期（实际是并不是）</span><br>        has.lifetime = &amp;long;<br>        <span class="hljs-built_in">assert_eq!</span>(has.lifetime, <span class="hljs-string">&quot;long&quot;</span>);<br>        <span class="hljs-comment">// `short` 变量在这⾥ drop</span><br>    &#125;<br><br>    <span class="hljs-comment">// 编译失败， `short` 在 drop 后仍旧处于 “借⽤” 状态</span><br>    <span class="hljs-built_in">assert_eq!</span>(has.lifetime, <span class="hljs-string">&quot;long&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">error[E0597]: `short` does not live long enough<br> --&gt; src/main.rs:11:24<br>   |<br>11 | has.lifetime = &amp;short;<br>   |                ^^^^^^ borrowed value does not live long enough<br>...<br>15 | &#125;<br>   | - `short` dropped here while still borrowed<br>16 | assert_eq!(has.lifetime, &quot;long&quot;);<br>   | --------------------------------- borrow later used here<br></code></pre></td></tr></table></figure><p>下⾯这个还是报错，报错信息也和上⾯⼀样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Has</span>&lt;<span class="hljs-symbol">&#x27;lifetime</span>&gt; &#123;<br>    lifetime: &amp;<span class="hljs-symbol">&#x27;lifetime</span> <span class="hljs-type">str</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">long</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;long&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">has</span> = Has &#123; lifetime: &amp;long &#125;;<br>    <span class="hljs-built_in">assert_eq!</span>(has.lifetime, <span class="hljs-string">&quot;long&quot;</span>);<br><br>    <span class="hljs-comment">// 这个代码块逻辑上永远不会被执⾏</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-literal">false</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">short</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;short&quot;</span>);<br>        <span class="hljs-comment">// “转换到” 短的⽣命周期</span><br>        has.lifetime = &amp;short;<br>        <span class="hljs-built_in">assert_eq!</span>(has.lifetime, <span class="hljs-string">&quot;short&quot;</span>);<br><br>        <span class="hljs-comment">// “转换回” ⻓的⽣命周期（实际是并不是）</span><br>        has.lifetime = &amp;long;<br>        <span class="hljs-built_in">assert_eq!</span>(has.lifetime, <span class="hljs-string">&quot;long&quot;</span>);<br>        <span class="hljs-comment">// `short` 变量在这⾥ drop</span><br>    &#125;<br><br>    <span class="hljs-comment">// 还是编译失败， `short` 在 drop 后仍旧处于 “借⽤” 状态</span><br>    <span class="hljs-built_in">assert_eq!</span>(has.lifetime, <span class="hljs-string">&quot;long&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>⽣命周期必须在编译时被静态确定，⽽且 Rust 借⽤检查器只会做基本的控制流分析，所以它假设每个 <code>if-else</code> 块和 <code>match</code> 块的每个分⽀都能被执⾏，然后<strong>选出⼀个最短的⽣命周期赋给块中的变量</strong>。⼀旦⼀个变量被⼀个⽣命周期约束了，那么它将 永远 被这个⽣命周期所约束。<strong>⼀个变量的⽣命周期只能缩短，⽽且所有的缩短时机都在编译时确定。</strong></p><h2 id="9-将独占引⽤-amp-mut-降级为共享引⽤-amp-是-safe-的"><a href="#9-将独占引⽤-amp-mut-降级为共享引⽤-amp-是-safe-的" class="headerlink" title="9) 将独占引⽤(&amp;mut)降级为共享引⽤(&amp;)是 safe 的"></a>9) 将独占引⽤(<code>&amp;mut</code>)降级为共享引⽤(<code>&amp;</code>)是 safe 的</h2><p>错误的推论</p><ul><li>通过重借⽤引⽤内部的数据，能抹掉其原有的⽣命周期，然后赋⼀个新的上去</li></ul><p>你可以将⼀个独占引⽤作为参数传给⼀个接收共享引⽤的函数，因为 Rust 将隐式地重借⽤独占引⽤内部的数据，⽣成⼀个共享引⽤：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">takes_shared_ref</span>(n: &amp;<span class="hljs-type">i32</span>) &#123;&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">a</span> = <span class="hljs-number">10</span>;<br>    <span class="hljs-title function_ invoke__">takes_shared_ref</span>(&amp;<span class="hljs-keyword">mut</span> a); <span class="hljs-comment">// 编译通过</span><br>    <span class="hljs-title function_ invoke__">takes_shared_ref</span>(&amp;*(&amp;<span class="hljs-keyword">mut</span> a)); <span class="hljs-comment">// 上⾯那⾏去掉语法糖</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这在直觉上是合理的，因为将⼀个独占引⽤转换为共享引⽤显然是⽆害的，对吗？令⼈讶异的是，这并不对，下⾯的这段程序不能通过编译：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">a</span> = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span>: &amp;<span class="hljs-type">i32</span> = &amp;*(&amp;<span class="hljs-keyword">mut</span> a); <span class="hljs-comment">// 重借⽤为不可变引⽤</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span>: &amp;<span class="hljs-type">i32</span> = &amp;a;<br>    dbg!(b, c); <span class="hljs-comment">// 编译失败</span><br>&#125;<br></code></pre></td></tr></table></figure><p>报错如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">error[E0502]: cannot borrow `a` as immutable because it is also borrowed as mutable<br> --&gt; src/main.rs:4:19<br>  |<br>3 |     let b: &amp;i32 = &amp;*(&amp;mut a);<br>  |                     -------- mutable borrow occurs here<br>4 |     let c: &amp;i32 = &amp;a;<br>  |                   ^^ immutable borrow occurs here<br>5 | dbg!(b, c);<br>  |      - mutable borrow later used here<br></code></pre></td></tr></table></figure><p>代码⾥确实有⼀个独占引⽤，但是它⽴即重借⽤变成了⼀个共享引⽤，然后⾃身就被 drop 掉了。但是为什么 Rust 好像把这个重借⽤出来的共享引⽤看作是有⼀个独占的⽣命周期呢？上⾯这个例⼦中，允许独占引⽤直接降级为共享引⽤是没有问题的，但是这个允许确实会导致潜在的内存安全问题。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::Mutex;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Struct</span> &#123;<br>    mutex: Mutex&lt;<span class="hljs-type">String</span>&gt;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Struct</span> &#123;<br>    <span class="hljs-comment">// 将 self 的独占引⽤降级为 str 的共享引⽤</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_string</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span> &#123;<br>        <span class="hljs-keyword">self</span>.mutex.<span class="hljs-title function_ invoke__">get_mut</span>().<span class="hljs-title function_ invoke__">unwrap</span>()<br>    &#125;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">mutate_string</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-comment">// 如果 Rust 允许独占引⽤降级为共享引⽤，那么下⾯这⼀⾏代码执⾏后，</span><br>        <span class="hljs-comment">// 所有通过 get_string ⽅法返回的 &amp;str 都将变为⾮法引⽤</span><br>        *<span class="hljs-keyword">self</span>.mutex.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>() = <span class="hljs-string">&quot;surprise!&quot;</span>.<span class="hljs-title function_ invoke__">to_owned</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s</span> = Struct &#123;<br>        mutex: Mutex::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;string&quot;</span>.<span class="hljs-title function_ invoke__">to_owned</span>())<br>    &#125;;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">str_ref</span> = s.<span class="hljs-title function_ invoke__">get_string</span>(); <span class="hljs-comment">// 独占引⽤降级为共享引⽤</span><br>    s.<span class="hljs-title function_ invoke__">mutate_string</span>(); <span class="hljs-comment">// str_ref 失效，变成⾮法引⽤，现在是⼀个悬垂指针</span><br>    dbg!(str_ref); <span class="hljs-comment">// 当然，实际上会编译错误</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这⾥的关键点在于，你在重借⽤⼀个独占引⽤为共享引⽤时，就已经落⼊了⼀个陷阱：为了保证重借⽤得到的共享引⽤在其⽣命周期内有效，被重借⽤的独占引⽤也必须保证在这段时期有效，这延⻓了独占引⽤的⽣命周期！哪怕独占引⽤⾃身已经被 drop 掉了，但独占引⽤的⽣命周期却⼀直延续到共享引⽤的⽣命周期结束。使⽤重借⽤得到的共享引⽤是很难受的，因为它明明是⼀个共享引⽤但是却不能和其他共享引⽤共存。重借⽤得到的共享引⽤有着独占引⽤和共享引⽤的缺点，却没有⼆者的优点。我认为重借⽤⼀个独占引⽤为共享引⽤的⾏为应当被视为 Rust 的⼀种反模式。知道这种反模式是很重要的，当你看到这样的代码时，你就能轻易地发现错误了</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 将独占引⽤降级为共享引⽤</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">some_function</span>&lt;T&gt;(some_arg: &amp;<span class="hljs-keyword">mut</span> T) <span class="hljs-punctuation">-&gt;</span> &amp;T;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Struct</span>;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Struct</span> &#123;<br>    <span class="hljs-comment">// 将独占的 self 引⽤降级为共享的 self 引⽤</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">some_method</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-keyword">self</span>;<br><br>    <span class="hljs-comment">// 将独占的 self 引⽤降级为共享的 T 引⽤</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">other_method</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;T;<br>&#125;<br></code></pre></td></tr></table></figure><p>尽管你可以在函数和⽅法的声明⾥避免重借⽤，但是由于 Rust 会⾃动做隐式重借⽤，所以很容易⽆意识地遇到这种情况</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">PlayerID</span> = <span class="hljs-type">i32</span>;<br><br><span class="hljs-meta">#[derive(Debug, Default)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Player</span> &#123;<br>    score: <span class="hljs-type">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_game</span>(player_a: PlayerID, player_b: PlayerID, server: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;PlayerID, Player&gt;) &#123;<br>    <span class="hljs-comment">// 从 server 中得到 player, 如果不存在就创建⼀个默认的 player 并得到这个新创建的。</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">player_a</span>: &amp;Player = server.<span class="hljs-title function_ invoke__">entry</span>(player_a).<span class="hljs-title function_ invoke__">or_default</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">player_b</span>: &amp;Player = server.<span class="hljs-title function_ invoke__">entry</span>(player_b).<span class="hljs-title function_ invoke__">or_default</span>();<br><br>    <span class="hljs-comment">// 对得到的 player 做⼀些操作</span><br>    dbg!(player_a, player_b); <span class="hljs-comment">// 编译错误</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上⾯这段代码会编译失败。这⾥ <code>or_default()</code> 会返回⼀个 <code>&amp;mut Player</code>，但是由于我们添加了⼀个显式的类型标注，它会被隐式重借⽤成 <code>&amp;Player</code>。⽽为了达成我们真正的⽬的，我们不得不这样做：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::HashMap;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">PlayerID</span> = <span class="hljs-type">i32</span>;<br><br><span class="hljs-meta">#[derive(Debug, Default)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Player</span> &#123;<br>    score: <span class="hljs-type">i32</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">start_game</span>(player_a: PlayerID, player_b: PlayerID, server: &amp;<span class="hljs-keyword">mut</span> HashMap&lt;PlayerID, Player&gt;) &#123;<br>    <span class="hljs-comment">// 因为编译器不允许这两个返回值共存，所有这⾥直接丢弃这两个 &amp;mut Player</span><br>    server.<span class="hljs-title function_ invoke__">entry</span>(player_a).<span class="hljs-title function_ invoke__">or_default</span>();<br>    server.<span class="hljs-title function_ invoke__">entry</span>(player_b).<span class="hljs-title function_ invoke__">or_default</span>();<br><br>    <span class="hljs-comment">// 再次获取 player, 这次我们直接拿到共享引⽤，避免隐式的重借⽤</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">player_a</span> = server.<span class="hljs-title function_ invoke__">get</span>(&amp;player_a);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">player_b</span> = server.<span class="hljs-title function_ invoke__">get</span>(&amp;player_b);<br><br>    <span class="hljs-comment">// 对得到的 player 做⼀些操作</span><br>    dbg!(player_a, player_b); <span class="hljs-comment">// 现在能编译通过了</span><br>&#125;<br></code></pre></td></tr></table></figure><p>难⽤，⽽且很蠢，但这是我们为了内存安全这⼀信条所做出的牺牲。</p><p><strong>关键点回顾</strong></p><ul><li>尽量避免重借⽤⼀个独占引⽤为共享引⽤，不然你会遇到很多麻烦</li><li>重借⽤⼀个独占引⽤并不会结束其⽣命周期，哪怕它⾃身已经被 drop 掉了</li></ul><h2 id="10-对闭包的⽣命周期省略规则和函数⼀样"><a href="#10-对闭包的⽣命周期省略规则和函数⼀样" class="headerlink" title="10) 对闭包的⽣命周期省略规则和函数⼀样"></a>10) 对闭包的⽣命周期省略规则和函数⼀样</h2><p>这更像是 Rust 的陷阱⽽⾮误解尽管闭包可以被当作是⼀个函数，但是并不遵循和函数同样的⽣命周期省略规则。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">function</span>(x: &amp;<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">i32</span> &#123;<br>    x<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">closure</span> = |x: &amp;<span class="hljs-type">i32</span>| x;<br>&#125;<br></code></pre></td></tr></table></figure><p>报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">error: lifetime may not live long enough<br> --&gt; src/main.rs:6:29<br>  |<br>6 | let closure = |x: &amp;i32| x;<br>  |                   -   - ^ returning this value requires that `&#x27;1` must outlive `&#x27;2`<br>  |                   |   |<br>  |                   |   return type of closure is &amp;&#x27;2 i32<br>  |                   let&#x27;s call the lifetime of this reference `&#x27;1`<br></code></pre></td></tr></table></figure><p>去掉语法糖后，我们得到的是：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// 输⼊的⽣命周期应⽤到了输出上</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">function</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span> &#123;<br>    x<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// 输⼊和输出有它们⾃⼰各⾃的⽣命周期</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">closure</span> = <span class="hljs-keyword">for</span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>&gt; |x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span>| <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">i32</span> &#123; x &#125;;<br>    <span class="hljs-comment">// 注意：上⼀⾏并不是合法的语句，但是我们需要它来描述我们⽬的</span><br>&#125;<br></code></pre></td></tr></table></figure><p>出现这种差异并没有什么好处。只是在闭包最初的实现中，使⽤的类型推断语义与函数不同，⽽现在将⼆者做⼀个统⼀将是⼀个 breaking change, 因此现在已经没法改了。那么我们怎么显式地标注⼀个闭包的类型呢？我们有以下⼏种⽅案：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-comment">// 转换成 trait 对象，但这样是不定长的，所以会编译错误</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">identity</span>: <span class="hljs-keyword">dyn</span> <span class="hljs-title function_ invoke__">Fn</span>(&amp;<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">i32</span> = |x: &amp;<span class="hljs-type">i32</span>| x;<br>    <br>    <span class="hljs-comment">// 可以分配到堆上作为代替方案，但是在这里堆分配感觉有点蠢</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">identity</span>: <span class="hljs-type">Box</span>&lt;<span class="hljs-keyword">dyn</span> <span class="hljs-title function_ invoke__">Fn</span>(&amp;<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">i32</span>&gt; = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(|x: &amp;<span class="hljs-type">i32</span>| x);<br><br>    <span class="hljs-comment">// 可以不⽤堆分配⽽直接创建⼀个 &#x27;static 引⽤</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">identity</span>: &amp;<span class="hljs-keyword">dyn</span> <span class="hljs-title function_ invoke__">Fn</span>(&amp;<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">i32</span> = &amp;|x: &amp;<span class="hljs-type">i32</span>| x;<br><br>    <span class="hljs-comment">// 上⼀⾏去掉语法糖 :)</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">identity</span>: &amp;<span class="hljs-symbol">&#x27;static</span> (<span class="hljs-keyword">dyn</span> <span class="hljs-keyword">for</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; <span class="hljs-title function_ invoke__">Fn</span>(&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span> + <span class="hljs-symbol">&#x27;static</span>) = &amp;|x: &amp;<span class="hljs-type">i32</span>| <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">i32</span> &#123; x &#125;;<br><br>    <span class="hljs-comment">// 这看起来很完美，但可惜不符合语法</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">identity</span>: <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Fn</span>(&amp;<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">i32</span> = |x: &amp;<span class="hljs-type">i32</span>| x;<br><br>    <span class="hljs-comment">// 这个也⾏，但也不符合语法</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">identity</span> = <span class="hljs-keyword">for</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; |x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span>| <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span> &#123; x &#125;;<br><br>    <span class="hljs-comment">// 但是 &quot;impl trait&quot; 可以作为函数的返回值类型</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">return_identity</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">impl</span> <span class="hljs-title class_">Fn</span>(&amp;<span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">i32</span> &#123;<br>        |x| x<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">identity</span> = <span class="hljs-title function_ invoke__">return_identity</span>();<br><br>    <span class="hljs-comment">// 上⼀个解决⽅案的泛化版本</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">annotate</span>&lt;T, F&gt;(f: F) <span class="hljs-punctuation">-&gt;</span> F <span class="hljs-keyword">where</span> F: <span class="hljs-title function_ invoke__">Fn</span>(&amp;T) <span class="hljs-punctuation">-&gt;</span> &amp;T &#123;<br>        f<br>    &#125;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">identity</span> = <span class="hljs-title function_ invoke__">annotate</span>(|x: &amp;<span class="hljs-type">i32</span>| x);<br>&#125;<br></code></pre></td></tr></table></figure><p>我想你应该注意到了，在上⾯的例⼦中，如果对闭包应⽤ trait 约束，闭包会和函数遵循同样的⽣命周期省略规则。这⾥没有什么现实的教训或⻅解，只是说明⼀下闭包是这样的。</p><p><strong>关键点回顾</strong></p><ul><li>每个语⾔都有其陷阱</li><li>避免在闭包中使⽤⽣命周期！</li></ul><h2 id="11-39-static-引⽤总能被强制转换为-39-a-引⽤"><a href="#11-39-static-引⽤总能被强制转换为-39-a-引⽤" class="headerlink" title="11) &#39;static 引⽤总能被强制转换为 &#39;a 引⽤"></a>11) <code>&#39;static</code> 引⽤总能被强制转换为 <code>&#39;a</code> 引⽤</h2><p>我之前有过这样的代码：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_str</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>; <span class="hljs-comment">// 泛型版本</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">get_str</span>() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span>; <span class="hljs-comment">// &#x27;static 版本</span><br></code></pre></td></tr></table></figure><p>两者之间是否有实际的差异。我⼀开始并不确定，但⼀番研究过后遗憾地发现，是的，这⼆者确实有差异。通常在使⽤值时，我们能⽤ <code>&#39;static</code> 引⽤直接代替⼀个 <code>&#39;a</code> 引⽤，因为 Rust 会⾃动把 <code>&#39;static</code> 引⽤强制转换为 <code>&#39;a</code> 引⽤。直觉上这很合理，因为在⼀个对⽣命周期要求⽐较短的地⽅⽤⼀个⽣命周期⽐较⻓的引⽤绝不会导致任何内存安全问题。下⾯的这段代码通过编译，和预期⼀致：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> rand;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">generic_str_fn</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span> &#123;<br>    <span class="hljs-string">&quot;str&quot;</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">static_str_fn</span>() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span> &#123;<br>    <span class="hljs-string">&quot;str&quot;</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">a_or_b</span>&lt;T&gt;(a: T, b: T) <span class="hljs-punctuation">-&gt;</span> T &#123;<br>    <span class="hljs-keyword">if</span> rand::<span class="hljs-title function_ invoke__">random</span>() &#123;<br>        a<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        b<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">some_string</span> = <span class="hljs-string">&quot;string&quot;</span>.<span class="hljs-title function_ invoke__">to_owned</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">some_str</span> = &amp;some_string[..];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">str_ref</span> = <span class="hljs-title function_ invoke__">a_or_b</span>(some_str, <span class="hljs-title function_ invoke__">generic_str_fn</span>()); <span class="hljs-comment">// 编译通过</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">str_ref</span> = <span class="hljs-title function_ invoke__">a_or_b</span>(some_str, <span class="hljs-title function_ invoke__">static_str_fn</span>()); <span class="hljs-comment">// 编译通过</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然⽽当引⽤作为函数类型签名的⼀部分时，强制类型转换并不⽣效。所以下⾯这段代码不能通过编译：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> rand;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">generic_str_fn</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span> &#123;<br>    <span class="hljs-string">&quot;str&quot;</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">static_str_fn</span>() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;static</span> <span class="hljs-type">str</span> &#123;<br>    <span class="hljs-string">&quot;str&quot;</span><br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">a_or_b_fn</span>&lt;T, F&gt;(a: T, b_fn: F) <span class="hljs-punctuation">-&gt;</span> T<br>    <span class="hljs-keyword">where</span> F: <span class="hljs-title function_ invoke__">Fn</span>() <span class="hljs-punctuation">-&gt;</span> T<br>&#123;<br>    <span class="hljs-keyword">if</span> rand::<span class="hljs-title function_ invoke__">random</span>() &#123;<br>        a<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_ invoke__">b_fn</span>()<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">some_string</span> = <span class="hljs-string">&quot;string&quot;</span>.<span class="hljs-title function_ invoke__">to_owned</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">some_str</span> = &amp;some_string[..];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">str_ref</span> = <span class="hljs-title function_ invoke__">a_or_b_fn</span>(some_str, generic_str_fn); <span class="hljs-comment">// 编译通过</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">str_ref</span> = <span class="hljs-title function_ invoke__">a_or_b_fn</span>(some_str, static_str_fn); <span class="hljs-comment">// 编译错误</span><br>&#125;<br></code></pre></td></tr></table></figure><p>报错如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">error[E0597]: `some_string` does not live long enough<br> --&gt; src/main.rs:23:21<br>   |<br>23 | let some_str = &amp;some_string[..];<br>   |                 ^^^^^^^^^^^ borrowed value does not live long enough<br>...<br>25 | let str_ref = a_or_b_fn(some_str, static_str_fn);<br>   |               ---------------------------------- argument requires that `some_string` is borrowed for `&#x27;static`<br>26 | &#125;<br>   | - `some_string` dropped here while still borrowed<br></code></pre></td></tr></table></figure><p>很难说这是不是 Rust 的⼀个陷阱，把 <code>for&lt;T&gt; Fn() -&gt; &amp;&#39;static T</code> 强制转换为 <code>for&lt;&#39;a, T&gt; Fn() -&gt; &amp;&#39;a T</code> 并不是⼀个像把 <code>&amp;&#39;static str</code> 强制转换为 <code>&amp;&#39;a str</code> 这样简单直⽩的情况。前者是类型之间的转换，后者是值之间的转换。</p><p><strong>关键点回顾</strong></p><ul><li><code>for &lt;&#39;a，T&gt; fn（）-&gt;＆&#39;a T</code> 签名的函数⽐ <code>for &lt;T&gt; fn（）-&gt;＆&#39;static T</code> 签名的函数要更灵活，并且泛⽤于更多场景</li></ul><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>因为静态分析技术的局限以及 Rust 的保守性，可以看到 Rust 在内存安全做了很多看似很傻的实现（对于 C++ ⾼⼿来说实际上也很傻的）。对于恼羞成怒的 Rust 新⼿（包括作者本⼈），可以会⼀怒之下就 <code>unsafe&#123;&#125;</code> 就开始像写 C ⼀样写 Rust 了，但这显然违背了 Rust 这⻔语⾔的初衷。同时这⾥⾯提到的基于⽣命周期可能发⽣的内存安全问题，也能给 modern C++ 的程序员带来启发，并不是懂点指针和⾯向对象就能说⾃⼰会 C++ 的，⼀个资深的 C++ 程序员要时刻考虑内存安全问题。safe Rust 的好处就是，通过看似很傻的⽣命周期机制，尽可能的去帮程序员规避内存安全问题。</p><ul><li><code>T</code> 是 <code>&amp;T</code> 和 <code>&amp;mut T</code> 的超集</li><li><code>&amp;T</code> 和 <code>&amp;mut T</code> 是不相交的集合</li><li><code>T: &#39;static</code> 应当视为 “ <code>T</code> 满⾜ <code>&#39;static</code> ⽣命周期约束”</li><li>若 <code>T: &#39;static</code> 则 <code>T</code> 可以是⼀个有 <code>&#39;static</code> ⽣命周期的引⽤类型 或 是⼀个所有权类型</li><li>因为 <code>T: &#39;static</code> 包括了所有权类型，所以 <code>T</code><ul><li>可以在运⾏时动态分配</li><li>不需要在整个程序运⾏期间都有效</li><li>可以安全，⾃由地修改</li><li>可以在运⾏时被动态的 drop</li><li>可以有不同⻓度的⽣命周期</li></ul></li><li><code>T: &#39;a</code> ⽐ <code>&amp;&#39;a T</code> 更泛化，更灵活</li><li><code>T: &#39;a</code> 接受所有权类型，内部含有引⽤的所有权类型，和引⽤</li><li><code>&amp;&#39;a T</code> 只接受引⽤</li><li>若 <code>T: &#39;static</code> 则 <code>T: &#39;a</code> 因为对于所有 <code>&#39;a</code> 都有 <code>&#39;static &gt;= &#39;a</code></li><li>⼏乎所有的 Rust 代码都是泛型代码，并且到处都带有被省略掉的泛型⽣命周期注解e</li><li>Rust ⽣命周期省略规则并不保证在任何情况下都正确</li><li>在程序的语义⽅⾯，Rust 并不⽐你懂</li><li>可以试试给你的⽣命周期注解起⼀个有意义的名字</li><li>试着记住你在哪⾥添加了显式⽣命周期注解，以及为什么要</li><li>所有 trait 对象都含有⾃动推导的⽣命周期</li><li>Rust 编译错误的提示信息所提出的修复⽅案并不⼀定能满⾜你对程序的需求</li><li>⽣命周期在编译时被静态确定</li><li>⽣命周期在运⾏时不能被改变</li><li>Rust 借⽤检查器假设所有代码路径都能被执⾏，所以总是选择尽可能短的⽣命周期赋给变量</li><li>尽量避免重借⽤⼀个独占引⽤为共享引⽤，不然你会遇到很多麻烦</li><li>重借⽤⼀个独占引⽤并不会结束其⽣命周期，哪怕它⾃身已经被 drop 掉了</li><li>每个语⾔都有其陷阱</li><li><code>for &lt;&#39;a，T&gt; fn（）-&gt;＆&#39;a T</code> 签名的函数⽐ <code>for &lt;T&gt; fn（）-&gt;＆&#39;static T</code> 签名的函数要更灵活，并且泛⽤于更多场合。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 972 (Div. 2)</title>
    <link href="/2024/09/16/acm/codeforces/CodeforcesRound972/"/>
    <url>/2024/09/16/acm/codeforces/CodeforcesRound972/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Simple-Palindrome"><a href="#A-Simple-Palindrome" class="headerlink" title="A. Simple Palindrome"></a>A. Simple Palindrome</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>只允许使用 <code>aeiou</code> 构建一个字符串，使得其中的回文子序列尽可能少</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>注意是回文子序列，所以比如 <code>aeioua</code> 这种，看起来一个回文串都没有，实际上 <code>aea</code>, <code>aia</code>, <code>aoa</code> 等等都是可以构造出来的</p><p>显然，如果存在间隔的方式，那么带来的回文串一定会更多，毕竟 <code>aea</code> 里面还可以再提取出一个 <code>aa</code>。所以应该保证尽可能不要出现间隔字母即可，同时联系的字母也要少</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-type">int</span> cnt[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) ++cnt[i % <span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cnt[i]; ++j) cout &lt;&lt; <span class="hljs-string">&quot;aiueo&quot;</span>[i];<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B2-The-Strict-Teacher"><a href="#B2-The-Strict-Teacher" class="headerlink" title="B2. The Strict Teacher"></a>B2. The Strict Teacher</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一排方格，其中一部分格子上有老师，老师希望抓住某个学生，且老师和学生每次都会停留在当前的格子或者走到相邻的格子，给出老师的初始位置，询问如果学生的初始位置在某个值时，需要多久才能抓到</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>只需要考虑在所有老师最左边或者在最右边，或者在某两个中间这三种情况即可，简单题</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m, q;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(m)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: data) cin &gt;&gt; item;<br>    <span class="hljs-built_in">sort</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">while</span> (q--) &#123;<br>        <span class="hljs-type">int</span> t;<br>        cin &gt;&gt; t;<br>        <span class="hljs-keyword">if</span> (t &lt; data[<span class="hljs-number">0</span>]) cout &lt;&lt; data[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t &gt; data.<span class="hljs-built_in">back</span>()) cout &lt;&lt; n - data.<span class="hljs-built_in">back</span>() &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">auto</span> iter = <span class="hljs-built_in">upper_bound</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>(), t);<br>            <span class="hljs-type">int</span> r = iter.<span class="hljs-keyword">operator</span>*();<br>            --iter;<br>            <span class="hljs-type">int</span> l = iter.<span class="hljs-keyword">operator</span>*();<br>            cout &lt;&lt; (r - l) / <span class="hljs-number">2</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Lazy-Narek"><a href="#C-Lazy-Narek" class="headerlink" title="C. Lazy Narek"></a>C. Lazy Narek</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有 $n$ 个字符串，每个字符串长度为 $m$，允许选择其中几个（或者一个都不选），并按照原来的顺序拼接起来，<br>然后再从拼接后的字符串提取出一个子序列，使得这个子序列恰好是多个连续的 <code>narek</code> 这个字符串<br>将此子序列的长度减去提取走子序列后的 <code>narek</code> 字母数量，得到分数，问分数最大是多少</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>对于每一个字符串，当需要使用这个字符串的时候，当前状态只有 5 种可能的开始，即当前需要匹配 <code>n</code>/<code>a</code>/<code>r</code>/<code>e</code>/<code>k</code> 的时候，同时也只有 5 种结束状态</p><p>所以只需要枚举每一个字符串在不同的字母结束的时候的最优分数，然后做一下动态规划即可</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">signed</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">signed</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n, m;<br>        cin &gt;&gt; n &gt;&gt; m;<br>        string str = <span class="hljs-string">&quot;narek&quot;</span>;<br>        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: data) item.<span class="hljs-built_in">reserve</span>(m);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: data) cin &gt;&gt; item;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            dp[i].<span class="hljs-built_in">resize</span>(<span class="hljs-number">5</span>, <span class="hljs-number">-1000000</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">5</span>; ++k) &#123;<br>                <span class="hljs-type">int</span> cur = k, soc = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;c: data[i]) &#123;<br>                    <span class="hljs-keyword">if</span> (c == str[cur]) &#123;<br>                        ++cur;<br>                        <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">5</span>) &#123;<br>                            soc += <span class="hljs-number">5</span>;<br>                            cur = <span class="hljs-number">0</span>;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;n&#x27;</span> || c == <span class="hljs-string">&#x27;a&#x27;</span> || c == <span class="hljs-string">&#x27;r&#x27;</span> || c == <span class="hljs-string">&#x27;e&#x27;</span> || c == <span class="hljs-string">&#x27;k&#x27;</span>) --soc;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) dp[i][cur] = <span class="hljs-built_in">max</span>(dp[i][cur], soc);<br>                <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>                    dp[i][k] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][k], dp[i][k]);<br>                    dp[i][cur] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>][k] + soc, dp[i][cur]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) ans = <span class="hljs-built_in">max</span>(ans, dp[j][i] - i);<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《黑神话:悟空》游玩评测</title>
    <link href="/2024/09/08/game/Black-Myth-Wukong/"/>
    <url>/2024/09/08/game/Black-Myth-Wukong/</url>
    
    <content type="html"><![CDATA[<h1 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h1><p>首先还是恭喜悟空在发售后四天内完成了 1000万份的销售</p><p>在经历了 73 个小时的游玩之后，最终达成了九九八十一难的全成就，虽然没有完成二周目的探索，但是也算是经历了几乎全部的游戏内容</p><p><img src="/image/game/Black-Myth-Wukong/steam.png" alt="成就"></p><h1 id="个人评价"><a href="#个人评价" class="headerlink" title="个人评价"></a>个人评价</h1><h2 id="石刻"><a href="#石刻" class="headerlink" title="石刻"></a>石刻</h2><p>首先是非常巧的一点，在今年 6 月底的时候，恰好去到了大足石刻现场，也拍了不少照片，这里放一张大足的千手观音照片</p><p><img src="/image/game/Black-Myth-Wukong/rock.jpeg" alt="千手观音(大足石刻宝顶山景区)"></p><p>所以在看到黑神话第三章开始的大片的石雕的时候，也感受到了一种非常熟悉的感觉。和现场不同的一点是，现场的很多石刻，几乎没有太多的保护措施， 以至于漆画掉落严重，但是游戏中似乎都被比较好的进行重新上色了</p><p><img src="/image/game/Black-Myth-Wukong/rock2.jpeg" alt="大足石刻(大足石刻宝顶山景区)"></p><p>可以说在建模方面（虽然大部分应该都是扫描的）确实做了不少功夫</p><h2 id="购买之前"><a href="#购买之前" class="headerlink" title="购买之前"></a>购买之前</h2><p>接着来说说游戏本身。我并不是第一时间购买游戏的玩家，相反，我直到 23 号晚上才购买下游戏，且直到 24 号才开始游玩，有两个方面</p><ul><li>游戏本身被认为是是更接近于魂系游戏，而我个人并不是对这类游戏很感兴趣</li><li>国产游戏带来的失望太多，更何况是一个从 7 个人的小团队开始开发的游戏。个人并不希望无脑的对国产游戏而进行购买，反而是希望能够将自己的支持有意义</li></ul><p>最后决定购买的核心因素，一方面确实没有出现与最初的预告片的效果差距较大的心理落差的讨论，另一方面则是整体的游戏难度和一般的魂系游戏而言，确实较为简单</p><h2 id="游玩评测"><a href="#游玩评测" class="headerlink" title="游玩评测"></a>游玩评测</h2><h3 id="画面与地图设计-9-5-10"><a href="#画面与地图设计-9-5-10" class="headerlink" title="画面与地图设计(9.5/10)"></a>画面与地图设计(9.5/10)</h3><p>游戏的画面确实值得相当高的评分，无论是森林、沙地、雪山等等的画面确实值得评价为难以挑剔，在第三章的小西天土地将天命人带去湖上的过程，一路的雪景确实给我带来了不小的震撼</p><p>整体的地图设计也相对合理，虽然游戏没有给出地图，但是在游戏内容的指引还是相当清晰的，特别是在主要路线上安置了相当多的火盆火把用来提示路线</p><p>但是有个别地方还是缺少一些对于无地图的游戏的设计，比如在花果山的时候拿到筋斗云之后，反而不知道应该去哪里，特别是当我拿到筋斗云之后乱飞了一阵子，就彻底迷了路，我甚至都不知道自己在哪里<br>有人说可以跟着雷声走，起码能找到一个 BOSS，但是我当时所在的地方完全听不到雷声，同时更可怕的是，我无法降落，也无法传送，只能退出游戏重新进入的方式来回到土地庙。而回到土地庙之后，本来应该依靠打完 BOSS 后的剧情朝向来了解下一步应该去哪，变成了完全不知道接下来应该去哪了<br>如果说前 5 章的地图像是有过完整的地图设计，确实值得无地图的话，而第六章的地图可以说是完全没有设计，把所有的 BOSS 都堆积在一个圆形的大平台上一样</p><h3 id="音乐音效-8-5-10"><a href="#音乐音效-8-5-10" class="headerlink" title="音乐音效(8.5/10)"></a>音乐音效(8.5/10)</h3><p>音乐方面，可以很容易听出有不少的老板西游记电视剧里的音乐或者是变奏版本，这确实带来了不少好感，但是整体游玩过程中，音乐的体验似乎有点缺失，很难让你能分别出来，这个时候你应该注意安全，还是应该继续前进<br>在音乐方面一个非常典型的例子是《塞尔达传说荒野之息》中的沙漠地区，当 BOSS 吃到炸弹然后倒地的时候，背景音乐会立刻变奏来提醒你应该上前进攻了，或者 BOSS 瘫痪了。</p><h3 id="故事情节-8-5-10"><a href="#故事情节-8-5-10" class="headerlink" title="故事情节(8.5/10)"></a>故事情节(8.5/10)</h3><p>如果这个游戏是一个纯粹的魂系游戏，那我会给故事情节打 9.5 分甚至更高，但是既然制作者都说这不是魂系游戏了，那我只能给出 8.5 的评分<br>也许可能是我很小的时候就没有再看《西游记》了，其中对很多很多的故事情节反而没有任何印象，难以和游戏情节搭上，比如猪八戒什么时候和蜘蛛精有过关系了？我好像没有印象，再比如牛魔王的女儿萍萍有什么什么故事情节，猪八戒又什么时候杀了她的家人？我好像也没有印象，反而让人更加困惑<br>甚至红孩儿什么时候变成了夜叉？我越来越疑惑，在一路疑惑中继续打下去，似乎也没有给出太多的答案<br>当然你也可以说我没有认真看过《西游记》不知道故事情节，但如果这不是一部粉丝向作品的话，那我只了解其中的大致情节似乎也情有可原</p><h3 id="游戏性-9-10"><a href="#游戏性-9-10" class="headerlink" title="游戏性(9/10)"></a>游戏性(9/10)</h3><p>游戏性方面基本没有太多令人不舒服的地方，无论是技能加点还是四个技能 + 两个饰品的效果，也没有太多值得特别称赞的，所以还是可以给一个中规中矩的 9 分</p><h3 id="最终评价"><a href="#最终评价" class="headerlink" title="最终评价"></a>最终评价</h3><p>个人而言，我会给黑神话打 9.0/10 的分数，整体上也是一块非常出色的 3A 游戏，但是作为一个只需要 48 个小时就能在无跳剧情的情况下通关一周目全部支线任务和主线剧情，整体内容还是欠了一些，似乎地图和画风有了 268 的价位，但是内容却稍有不值这个价位。但是整体上还是属于值得购买的水平</p>]]></content>
    
    
    <categories>
      
      <category>游戏评测</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游戏评测</tag>
      
      <tag>黑神话悟空</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang 踩坑 —— interface 为参数的时候传 nil 指针</title>
    <link href="/2024/07/28/golang/interface-nil-param/"/>
    <url>/2024/07/28/golang/interface-nil-param/</url>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>这两天踩了一个奇怪的坑，抽出核心逻辑可以得到这样一段代码</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> V <span class="hljs-keyword">interface</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>V<br>next V<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewT</span><span class="hljs-params">(t V)</span></span> *T &#123;<br><span class="hljs-keyword">return</span> &amp;T&#123;next: t&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestName</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">var</span> tmp *T = <span class="hljs-literal">nil</span><br>newT := NewT(tmp)<br><span class="hljs-keyword">if</span> newT.next == <span class="hljs-literal">nil</span> &#123;<br>t.Log(<span class="hljs-string">&quot;newT.next is nil as expected.&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>t.Errorf(<span class="hljs-string">&quot;newT.next should be nil, but got %v&quot;</span>, newT.next)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，输出的内容是：<code>newT.next should be nil, but got &lt;nil&gt;</code></p><p>是不是挺疑惑的，稍做修改，将 <code>var tmp *T = nil</code> 改成 <code>var tmp V = nil</code></p><p>此时，运行得到的结果是：<code>newT.next is nil as expected.</code></p><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>最终在 <a href="https://groups.google.com/g/golang-nuts/c/s8kK700U8zw">Google Groups</a> 上找到了相关说明：</p><blockquote><p>I’m trying to understand why a nil pointer when converted to an interface produces a non-nil value.</p><p>Because different nil pointers can have different types, and the<br>interface remembers the type of the (nil) pointer (that it is converted from):<br>that remembering means that the interface value isn’t nil.</p><p>Is this a bug?</p><p>No.</p><p>(It’s a mild confusion based on the overloading of <code>nil</code> to mean the<br>zero value for pointers of any type and for interfaces — it’s not obvious<br>from the text of a program that the nils are of different types.)</p><p>Chris</p></blockquote><p>简单来说就是为了满足类似 C++ 的 RTTI 的特性，因为转为 <code>interface</code> 必然会丢失掉原来的类型信息，需要保存下原来的类型</p><p>这就导致了一个具体的变量传递给一个 <code>interface</code> 参数的函数的时候，因为会丢失掉原始的类型，所以将其包装成一个特殊的 <code>struct</code>。我们可以用 <code>unsafe</code> 的方式来获取到相关的信息</p><p>因为样例的 interface 在 golang 中使用类似如下的结构进行存储</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> eface <span class="hljs-keyword">struct</span> &#123;<br>_type *_type<br>data  unsafe.Pointer<br>&#125;<br></code></pre></td></tr></table></figure><p>所以我们可以使用如下方案提取具体的变量值：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> InterfaceStruct <span class="hljs-keyword">struct</span> &#123;<br>pt <span class="hljs-type">uintptr</span><br>pv <span class="hljs-type">uintptr</span><br>&#125;<br><br><span class="hljs-keyword">type</span> V <span class="hljs-keyword">interface</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> &#123;<br>V<br>next V<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewT</span><span class="hljs-params">(t V)</span></span> *T &#123;<br><span class="hljs-keyword">return</span> &amp;T&#123;next: t&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestName</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">var</span> tmp *T = <span class="hljs-literal">nil</span><br>newT := NewT(tmp)<br>pointer := *(*InterfaceStruct)(unsafe.Pointer(&amp;newT.next))<br>fmt.Println(pointer)<br>&#125;<br></code></pre></td></tr></table></figure><p>就可以得到执行结果为 <code>&#123;4309258112 0&#125;</code></p><p>也就是实际上 <code>data</code> 字段确实是 <code>0</code>，也就是 <code>nil</code>，但是其类型则存在一个 <code>_type</code> 的指针用来描述，所以在程序层面又不能说是 <code>nil</code></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用 magic 变量解决 UAF 问题</title>
    <link href="/2024/07/10/cpp/magic-variable-resolve-UAF/"/>
    <url>/2024/07/10/cpp/magic-variable-resolve-UAF/</url>
    
    <content type="html"><![CDATA[<p>最近学到了一个很有意思的方法解决 UA(Use-After-Free) 的问题，示例代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span>: _magic(<span class="hljs-number">0x41</span>), a(x) &#123;</span>&#125;<br><br>    ~<span class="hljs-built_in">A</span>() &#123;<br>        _magic = <span class="hljs-number">0xdead</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-built_in">assert</span>(_magic == <span class="hljs-number">0x41</span>);<br>        cout &lt;&lt; a &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">unsigned</span> _magic;<br>    <span class="hljs-type">int</span> a;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>(<span class="hljs-number">10</span>);<br>    a-&gt;<span class="hljs-built_in">print</span>();<br>    <span class="hljs-keyword">delete</span> a;<br>    a-&gt;<span class="hljs-built_in">print</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>简单来说就是在定义类的时候，增加一个 magic 的变量，用于记录当前的变量是否已经被释放了</p><p>同时使用了 <code>assert</code> 在每一个方法内判断一下是否正在执行被释放的代码</p><p>如果被释放了（示例中的代码），此时就会提示</p><blockquote><p>Assertion failed: (_magic == 0x41), function print, file main.cpp, line 16.</p></blockquote><p>其中可以注意到使用了 <code>0x41</code> 作为 magic 的默认值，也是为了解决 CPP 没有 RTTI 的问题，因为其恰好是 <code>A</code> 这个字母</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>UAF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 942 (Div. 2)</title>
    <link href="/2024/05/04/acm/codeforces/CodeforcesRound942/"/>
    <url>/2024/05/04/acm/codeforces/CodeforcesRound942/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Contest-Proposal"><a href="#A-Contest-Proposal" class="headerlink" title="A. Contest Proposal"></a>A. Contest Proposal</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有两个数组 $a, b$，已经从小到大排序好了，现在往 $a$ 数组最前面再塞入几个值，同时从最后面删除相同数量的值，使得 $\forall i \in [1, n], a_i \leq b_i$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>简单题，由于数据量很小，甚至可以暴力</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span>, <span class="hljs-title">b</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: a) cin &gt;&gt; i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: b) cin &gt;&gt; i;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; n &amp;&amp; r &lt; n) &#123;<br>        <span class="hljs-keyword">if</span> (a[l] &lt;= b[r]) &#123;<br>            ++l;<br>            ++r;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ++ans;<br>            ++r;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Coin-Games"><a href="#B-Coin-Games" class="headerlink" title="B. Coin Games"></a>B. Coin Games</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有两个人做游戏，有几个英镑再桌面上，有些正面朝上有些背面朝上。</p><p>每次操作，允许移走一个正面朝上的，然后连续选择两个剩下的影片进行翻转</p><p>问谁会操作到最后一次</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>翻转两个硬币等于没有翻转</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    string str;<br>    str.<span class="hljs-built_in">resize</span>(n);<br>    cin &gt;&gt; str;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; c: str) cnt += c == <span class="hljs-string">&#x27;U&#x27;</span>;<br>    cout &lt;&lt; (cnt % <span class="hljs-number">2</span> ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Permutation-Counting"><a href="#C-Permutation-Counting" class="headerlink" title="C. Permutation Counting"></a>C. Permutation Counting</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有 $n$ 种卡片，每种都有一定数量，现在允许额外再增加 $k$ 张，使得这些卡片可以组成一个数组，数组种的存在的 $[1, n]$ 的排列的子串尽可能多，问可以有多少个</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>只需要 $1, 2, 3, \dots, n, 1, 2, 3, \dots n$ 类似这样排列即可，通过二分找出每个数值都能到达的数量，然后排列起来</p><p>然后是剩下的那部分，比如多了一个 $1$，那么按照上面的排列方式，将 $1$ 放在最后面还能再多一次，即每有一个多出来的种类，就能增加一个子串</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, k;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: data) cin &gt;&gt; i;<br>    <span class="hljs-keyword">auto</span> check = [&amp;](<span class="hljs-type">int</span> x) &#123;<br>        <span class="hljs-type">int</span> use = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;v: data) &#123;<br>            <span class="hljs-keyword">if</span> (v &lt; x) use += x - v;<br>            <span class="hljs-keyword">if</span> (use &gt; k) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> use &lt;= k;<br>    &#125;;<br><br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">1e15</span>;<br>    <span class="hljs-keyword">while</span> (l + <span class="hljs-number">1</span> &lt; r) &#123;<br>        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, use = k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; v: data) &#123;<br>        <span class="hljs-keyword">if</span> (v &gt; l) ++ans;<br>        <span class="hljs-keyword">else</span> use -= l - v;<br>    &#125;<br>    ans = <span class="hljs-built_in">min</span>(n, use + ans);<br><br>    cout &lt;&lt; ans + (l - <span class="hljs-number">1</span>) * n + <span class="hljs-number">1</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D1-Reverse-Card-Easy-Version"><a href="#D1-Reverse-Card-Easy-Version" class="headerlink" title="D1. Reverse Card (Easy Version)"></a>D1. Reverse Card (Easy Version)</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>给出 $n, m$，求满足条件的 $a, b$ 对</p><ul><li>$1 \leq a \leq n, 1 \leq b \leq m$</li><li>$(a + b) \space mod \space b \times gcd(a, b) = 0$</li></ul><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>假定 $a = x \times y, b = x \times z$，且 $gcd(y, z) = 1$<br>则可以得到</p>$$          & (a + b) \space mod \space b \times gcd(a, b) = 0 \\\rightarrow & x \times y + x \times z = t \times (x \times z \times x) \\\rightarrow & y + z = t \times x \time z \\\rightarrow & 1 + \frac{y}{z} = t \times x \\$$<p>容易得到，必然 $\frac{y}{z}$ 是整数，而 $gcd(y, z) = 1$，所以 $z = 1$，故 $1 + y = t \times x$</p><p>所以很容易得到公式进行计算</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m, ans = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n &amp;&amp; i &lt;= m; ++i) &#123;<br>        <span class="hljs-type">int</span> my = n / i;<br>        ans += (my + <span class="hljs-number">1</span>) / i;<br>    &#125;<br>    cout &lt;&lt; ans - <span class="hljs-number">1</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D2-Reverse-Card-Hard-Version"><a href="#D2-Reverse-Card-Hard-Version" class="headerlink" title="D2. Reverse Card (Hard Version)"></a>D2. Reverse Card (Hard Version)</h1><h2 id="大致题意-4"><a href="#大致题意-4" class="headerlink" title="大致题意"></a>大致题意</h2><p>给出 $n, m$，求满足条件的 $a, b$ 对</p><ul><li>$1 \leq a \leq n, 1 \leq b \leq m$</li><li>$b \times gcd(a, b) \space mod \space (a + b) = 0$</li></ul><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>假定 $a = x \times y, b = x \times z$，且 $gcd(y, z) = 1$<br>则可以得到</p>$$          & b \times gcd(a, b) \space mod \space (a + b) = 0 \\\rightarrow & x \times z \times x = t \times (x \times y + x \times z) \\\rightarrow & x \times z = t \times (y + z) \\\rightarrow & x \times = \frac{t}{z} \times (y + z)$$<p>容易得到，必然 $\frac{y}{z}$ 是整数，而 $gcd(y, z) = 1$，所以必然只能用 $t$ 来承接除过来的 $z$，即上述公式中的表达</p><p>所以可以根据公式得到，只需要找到合理的互质数 $y, z$，即可找出有多少个 $x$ 满足条件，因为 $t$ 可以是任意值，即 $x$ 是 $y + z$ 的倍数</p><h2 id="AC-code-4"><a href="#AC-code-4" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m, ans = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span> || m &lt; <span class="hljs-number">2</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; gcd = [&amp;](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123;<br>        <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b, a % b);<br>    &#125;;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i * i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j * j &lt;= m; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">gcd</span>(i, j) != <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br><br>            ans += <span class="hljs-built_in">min</span>(n / i, m / j) / (i + j);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 941 (Div. 2)</title>
    <link href="/2024/05/03/acm/codeforces/CodeforcesRound941/"/>
    <url>/2024/05/03/acm/codeforces/CodeforcesRound941/</url>
    
    <content type="html"><![CDATA[<p><strong>从本篇开始，代码仅包含核心逻辑部分，多组数据的逻辑也将不再包含</strong></p><h1 id="A-Card-Exchange"><a href="#A-Card-Exchange" class="headerlink" title="A. Card Exchange"></a>A. Card Exchange</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有开始的 $n$ 张牌，每张牌有点数，可能相同也可能不同</p><p>允许进行如下操作：选择 $k$ 张相同的牌，弃掉，然后再摸进来 $k-1$ 张任意点数的牌</p><p>问最少可以剩下多少张牌</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>每次操作就可以整来 $k - 1$ 张的任意牌，所以只需要将任意牌单独计数，暴力循环找可以进行操作的点数，在包含任意牌的情况下，是否可以进行操作，能操作就操作</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n, k, cnt[<span class="hljs-number">101</span>] = &#123;&#125;;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            ++cnt[tmp];<br>        &#125;<br><br>        <span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">101</span>; ++i) &#123;<br>                <span class="hljs-keyword">if</span> (cnt[i] + tot &gt;= k) &#123;<br>                    <span class="hljs-keyword">if</span> (k - cnt[i] % k &lt;= tot) &#123;<br>                        tot -= k - cnt[i] % k;<br>                        cnt[i] += k - cnt[i] % k;<br>                    &#125;<br>                    flag = <span class="hljs-literal">false</span>;<br>                    tot += (cnt[i] / k) * (k - <span class="hljs-number">1</span>);<br>                    cnt[i] %= k;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i: cnt) tot += i;<br>        cout &lt;&lt; tot &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Rectangle-Filling"><a href="#B-Rectangle-Filling" class="headerlink" title="B. Rectangle Filling"></a>B. Rectangle Filling</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个矩阵，每个位置有黑色和白色两种情况，允许进行如下操作</p><p>在矩阵里选择两个相同的颜色的节点，将这两个节点组成的矩阵内的所有颜色变成和这两个节点的颜色相同</p><p>问是否能够通过任意次数的操作，使得整个矩阵变成完全相同的颜色的矩阵</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>容易得出如下结论：</p><ul><li>若一个矩阵的一个对角顶点颜色相同，则必然可以通过一次操作完成</li><li>若一个矩阵的一条边的两端颜色相同，且对边存在一个点的颜色和这两端相同，则可以通过两次操作完成</li></ul><p>其他情况均不可能</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n, m;<br>        cin &gt;&gt; n &gt;&gt; m;<br>        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">mp</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: mp) &#123;<br>            i.<span class="hljs-built_in">resize</span>(m);<br>            cin &gt;&gt; i;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (mp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == mp[n - <span class="hljs-number">1</span>][m - <span class="hljs-number">1</span>] || mp[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] == mp[<span class="hljs-number">0</span>][m - <span class="hljs-number">1</span>]) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (mp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == mp[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (mp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == mp[i][m - <span class="hljs-number">1</span>]) flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (mp[<span class="hljs-number">0</span>][m - <span class="hljs-number">1</span>] == mp[n - <span class="hljs-number">1</span>][m - <span class="hljs-number">1</span>]) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (mp[<span class="hljs-number">0</span>][m - <span class="hljs-number">1</span>] == mp[i][<span class="hljs-number">0</span>]) flag = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">if</span> (mp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == mp[<span class="hljs-number">0</span>][m - <span class="hljs-number">1</span>]) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) <span class="hljs-keyword">if</span> (mp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] == mp[n - <span class="hljs-number">1</span>][i]) flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (mp[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] == mp[n - <span class="hljs-number">1</span>][m - <span class="hljs-number">1</span>]) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) <span class="hljs-keyword">if</span> (mp[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] == mp[<span class="hljs-number">0</span>][i]) flag = <span class="hljs-literal">true</span>;<br><br>        cout &lt;&lt; (flag ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Everything-Nim"><a href="#C-Everything-Nim" class="headerlink" title="C. Everything Nim"></a>C. Everything Nim</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有 $n$ 个石头堆，Alice 和 Bob 玩游戏，轮流进行取石子，<br>每次取的时候，必须选择一个 $k$，满足现在有石头的石头堆中，石头数量最少的那个堆也有 $k$ 个石头<br>然后在每一堆里都同时取走 $k$ 个石头</p><p>谁最后没办法取石头，谁就输了，问最后谁赢了</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>首先，每次从所有堆里进行删除，可以等价将所有的石头堆排序后，变成差值堆，且必须从第一个石头堆开始取</p><p>那么问题就变成了：有一组石头堆，必须从第一个石头堆里开始取，每次可以取任意个数，问最后谁会取最后一次</p><p>这就很简单了，因为如果这个石头堆是 $1$ 个，那么大家都没得选，就是交换一下先后手，但是如果不是一个，那么就必然此时操作的人，可以是否要先手还是后手了，<br>因为此时他可以选择取到只剩下一个或者一个都不剩下，就可以实现交换先后手<br>所以核心是谁拿到了第一个先后手交换权，谁就能操纵整个游戏</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: data) cin &gt;&gt; i;<br>    <span class="hljs-built_in">sort</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">if</span> (data[<span class="hljs-number">0</span>] != <span class="hljs-number">1</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Alice&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (data[i] - data[i - <span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-keyword">if</span> (data[i] - data[i - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) ++cnt;<br>        <span class="hljs-keyword">else</span> &#123;<br>            ++cnt;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; (cnt % <span class="hljs-number">2</span> ? <span class="hljs-string">&quot;Alice&quot;</span> : <span class="hljs-string">&quot;Bob&quot;</span>) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Missing-Subsequence-Sum"><a href="#D-Missing-Subsequence-Sum" class="headerlink" title="D. Missing Subsequence Sum"></a>D. Missing Subsequence Sum</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>需要构造一个数列，满足</p><ul><li>对于 $k$，无法从数组中找到任何一个子序列，使得序列之和等于 $k$</li><li>对于 $i \in [1, n] \space and \space i \neq k$，必定从数组中找到任何一个子序列，使得序列之和等于 $k$</li></ul><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>如果不考虑不能构造 $k$ 的情况，其实相当简单，即都是 $2^x$ 即可，即二进制上考虑</p><p>接下来是考虑如何构造不出 $k$。首先假定一下 $k &gt; 1$，后面再单独讨论 $1$ 的情况</p><p>那么必然可以分为两个部分 $[1, k - 1]$ 和 $[k + 1, n]$</p><p>我们很容易得到这样一个结论：假如可以组成 $1$ 和 $k - 1$ 的话，如果组合一下必然可以得到 $k$，如果要组合不出来，<br>必定 $k - 1$ 中包含了 $1$ 的必要元素，同理，$k - 2$ 也可以如此推理，这样可以得到非常多的关系链</p><p>但是这些关系链重要吗，并不，因为太多太乱太无意义了，但是反而可以得到这样一个结论：如果所有小于 $k$ 的值之和是超过 $k$ 的，那么很容易能够找到一个组合，可以得到 $k$</p><p>所以只需要背着这条结论走即可，即刚好将比 $k$ 小的所有值加起来都比 $k$ 小即可，这样就可以构造出 $[1, k - 1]$ 的全部值了，<br>然后再加入一个 $k + 1$ 即可完成后面部分</p><p>不过稍微可能需要注意的需要再加入一个值，因为 $k$ 本身被排除在外了，所以这可能会导致原来依赖 $k$ 的值无法组成，<br>例如，如果 $k = 4$，那么 $6$ 就是一个很难组成的值，因为唯一包含第 $3$ 个比特位是 $1$ 的值就被干掉了，所以需要补充一个来避免这个问题</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, k, tot = <span class="hljs-number">0</span>, nxt = <span class="hljs-number">1</span>;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    ans.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">25</span>);<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span> (tot &lt; n) &#123;<br>        <span class="hljs-keyword">if</span> (flag &amp;&amp; tot + nxt &gt;= k) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(k - tot - <span class="hljs-number">1</span>);<br>            ans.<span class="hljs-built_in">push_back</span>(k + <span class="hljs-number">1</span>);<br>            ans.<span class="hljs-built_in">push_back</span>(k + (nxt &lt;&lt; <span class="hljs-number">1</span>));<br>            flag = <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> ans.<span class="hljs-built_in">push_back</span>(nxt);<br><br>        tot += nxt;<br>        nxt &lt;&lt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    cout &lt;&lt; ans.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ans.<span class="hljs-built_in">size</span>(); ++i) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == ans.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 940 (Div. 2) and CodeCraft-23</title>
    <link href="/2024/04/27/acm/codeforces/CodeforcesRound940/"/>
    <url>/2024/04/27/acm/codeforces/CodeforcesRound940/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Stickogon"><a href="#A-Stickogon" class="headerlink" title="A. Stickogon"></a>A. Stickogon</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有 $n$ 根木棍，问最多可以构成多少个等边的多边形，要求每一条边只能用一根木棍</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>构建成三角形就行，统计一下，每种边的数量整除 $3$ 即可</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            ++mp[tmp];<br>        &#125;<br><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[a, b]: mp) ans += b / <span class="hljs-number">3</span>;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-A-BIT-of-a-Construction"><a href="#B-A-BIT-of-a-Construction" class="headerlink" title="B. A BIT of a Construction"></a>B. A BIT of a Construction</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>给出一个整数 $k$，要求构造一个数组，其长度为给出的 $n$，每一项都不是负数，且满足 $\sum^n_{i=1} a_i = k$</p><p>问如何使得整个数组的 $a_1 | a_2 | \dots | a_n$ 的数中，比特位为 $1$ 数量最多</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>由于求和为 $k$，且每一项都不是负数，那么必然可以得到所有值都比 $k$ 小，最大起码也是等于</p><p>而题目要求比特位为 $1$ 尽可能多，而尽可能多的值必然是 $2^x - 1$，所以找最大的 $x$ 使得 $2^x \leq k$，然后剩下的数值不重要了，补充满 $k$ 即可</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            cout &lt;&lt; k &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">31</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">if</span> (k &gt;= (<span class="hljs-number">1</span> &lt;&lt; i) - <span class="hljs-number">1</span>) &#123;<br>                a = (<span class="hljs-number">1</span> &lt;&lt; i) - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; a &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; k - a;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; ++i) cout &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-number">0</span>;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-How-Does-the-Rook-Move"><a href="#C-How-Does-the-Rook-Move" class="headerlink" title="C. How Does the Rook Move?"></a>C. How Does the Rook Move?</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个棋盘，现在黑白两方轮着下，其中玩家使用白棋，电脑使用黑棋</p><p>电脑下棋的位置固定是根据用户下的位置的相反位置，例如玩家这一步下了 $(i, j)$，那么电脑则会下 $(j, i)$。<br>如果 $i = j$，那么就跳过电脑的回合</p><p>现在下的每一个棋都是城堡（类似中国象棋中的车），需要保证任何一步下的位置都必定不会被出现相互吃的情况，且目前已经有几个位置已经下好了，问剩下的还有几种可能下法</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>容易猜出这是一个递推的题，类似斐波那契数列。当然可以仔细来看</p><p>首先，已经下了几步这件事是无意义的，因为去掉已经下的那些行/列，就会回到一个普通的没有下的棋盘，<br>说白了就是个干扰项，只需要把给出的棋盘大小减去已经下过的位置的行数，就可以得到新的棋盘行数</p><p>同样的，不仅是已经下的位置，你现在下的位置也是如此，一旦下好了+电脑下好，再把下好的那几行/列删掉，就是一个新的空棋盘，所以这是一个递推</p><p>接下来是如何得到递推公式了，因为下哪一行都一样，删掉之后就是空白的，且根据要求，每一行必定有一个城堡，且求算的总数并不关系下的顺序，只看最后的样子，<br>那么我们可以只考虑第一行（因为第一行必定有一个城堡，可能是白的也可能是黑的）</p><p>如果第一行，我下了最左上角的位置，那么就会得到一个 $n - 1$ 的棋盘（$i = j$，机器人没有地方下）</p><p>如果第一行，我下了不是第一个位置，那么机器人必定会下对角线位置，即得到一个 $n - 2$ 的棋盘。因为这样的位置有 $n - 1$ 个，<br>且第一行可能是黑的也可能是白的，所以递推公式就是</p><p>$a_n = a_{n-1} + 2 \times (n - 1) \times a_{n - 2}$</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">3e5</span> + <span class="hljs-number">10</span>)</span></span>;<br>    ans[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    ans[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; ans.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        ans[i] = (ans[i - <span class="hljs-number">1</span>] + (ans[i - <span class="hljs-number">2</span>] * (i - <span class="hljs-number">1</span>) * <span class="hljs-number">2</span>) % mod) % mod;<br>    &#125;<br><br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        set&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            <span class="hljs-type">int</span> u, v;<br>            cin &gt;&gt; u &gt;&gt; v;<br>            st.<span class="hljs-built_in">insert</span>(u);<br>            st.<span class="hljs-built_in">insert</span>(v);<br>        &#125;<br>        cout &lt;&lt; ans[n - st.<span class="hljs-built_in">size</span>()] &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-A-BIT-of-an-Inequality"><a href="#D-A-BIT-of-an-Inequality" class="headerlink" title="D. A BIT of an Inequality"></a>D. A BIT of an Inequality</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>给出一个数组，要求找到一个元祖 $(x, y, z)$，满足 $0 \leq x \leq y \leq z \leq n, f(x, y) \oplus f(y, z) &gt; f(x, z)$</p><p>其中 $f(l, r) = a_l \oplus a_{l+1} \oplus a_{l+2} \oplus \dots \oplus a_{r}$</p><p>问有多少个不同的元组</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>很容易得到，$f(x, z) \oplus a_y = f(x, y) \oplus f(y, z)$，就是再异或上一边 $a_y$ 能让值变大</p><p>那么必然，原来 $a_y$ 中，最大的为 $1$ 那个比特位，$f(x, z)$ 为 $0$，毕竟如果是 $1$ 的话，肯定就变小了</p><p>接下来从这个角度分析，由于 $x \leq y \leq z$，所以 $f(x, z)$ 中一定已经异或过一次 $a_y$ 了，<br>而已知一个比特位 $a_y$ 是 $1$ 但是 $f(x, z)$ 是 $0$，那么必然在 $[x, z]$ 中，这个比特位为 $1$ 的，出现了偶数次，且至少 $2$ 次</p><p>所以只需要对于每一个可能的 $y$，找这个 $y$ 最大的为 $1$ 的那个比特位，为 $1$ 的次数恰好为偶数，且包含 $y$ 的区间数量即可。我采用了双向的奇偶标记</p><p>例如第三个例子，可以得到如下的表格</p><div class="table-container"><table><thead><tr><th style="text-align:center">index</th><th style="text-align:center">origin</th><th style="text-align:center">2^2</th><th style="text-align:center">forward</th><th style="text-align:center">back</th><th style="text-align:center">2^1</th><th style="text-align:center">forward</th><th style="text-align:center">back</th><th style="text-align:center">2^0</th><th style="text-align:center">forward</th><th style="text-align:center">back</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">7</td><td style="text-align:center">1</td><td style="text-align:center">odd</td><td style="text-align:center">even</td><td style="text-align:center">1</td><td style="text-align:center">odd</td><td style="text-align:center">even</td><td style="text-align:center">1</td><td style="text-align:center">odd</td><td style="text-align:center">even</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">3</td><td style="text-align:center">0</td><td style="text-align:center">odd</td><td style="text-align:center">odd</td><td style="text-align:center">1</td><td style="text-align:center">even</td><td style="text-align:center">odd</td><td style="text-align:center">1</td><td style="text-align:center">even</td><td style="text-align:center">odd</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">7</td><td style="text-align:center">1</td><td style="text-align:center">even</td><td style="text-align:center">odd</td><td style="text-align:center">1</td><td style="text-align:center">odd</td><td style="text-align:center">even</td><td style="text-align:center">1</td><td style="text-align:center">odd</td><td style="text-align:center">even</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">even</td><td style="text-align:center">even</td><td style="text-align:center">1</td><td style="text-align:center">even</td><td style="text-align:center">odd</td><td style="text-align:center">0</td><td style="text-align:center">odd</td><td style="text-align:center">odd</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">even</td><td style="text-align:center">even</td><td style="text-align:center">0</td><td style="text-align:center">even</td><td style="text-align:center">even</td><td style="text-align:center">1</td><td style="text-align:center">even</td><td style="text-align:center">odd</td></tr></tbody></table></div><p>这个表格的制作方式：</p><ul><li>先计算出每个值的每个比特位，放在 $2^x$ 列上</li><li>单独计算每一列 forward，从上往下走，初始值为 even，如果当前的 $2^x$ 是 $1$，则将前一个 forward 翻转后填入，反之则超过来</li><li>然后单独计算每一列 back，从下往上走，初始值为 forward 最后的值，填入逻辑同上</li></ul><p>然后统计某个位置，左边的 back 下不同类型的数量和右边的 forward 不同的类型数量，再做乘法即可</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: data) cin &gt;&gt; i;<br>        vector&lt;<span class="hljs-type">bool</span>&gt; flag[<span class="hljs-number">32</span>][<span class="hljs-number">2</span>];<br>        <span class="hljs-type">int</span> cntR[<span class="hljs-number">32</span>][<span class="hljs-number">2</span>] = &#123;&#125;, cntL[<span class="hljs-number">32</span>][<span class="hljs-number">2</span>] = &#123;&#125;, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">bool</span> cf[<span class="hljs-number">43</span>] = &#123;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: flag) i[<span class="hljs-number">0</span>].<span class="hljs-built_in">resize</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: flag) i[<span class="hljs-number">1</span>].<span class="hljs-built_in">resize</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">0</span>; v &lt; n; ++v) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; ++i) &#123;<br>                <span class="hljs-keyword">if</span> (data[v] &amp; (<span class="hljs-number">1ll</span> &lt;&lt; i)) cf[i] = !cf[i];<br>                flag[i][<span class="hljs-number">0</span>][v] = cf[i];<br>                ++cntR[i][cf[i]];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = n - <span class="hljs-number">1</span>; v &gt;= <span class="hljs-number">0</span>; --v) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; ++i) &#123;<br>                <span class="hljs-keyword">if</span> (data[v] &amp; (<span class="hljs-number">1ll</span> &lt;&lt; i)) cf[i] = !cf[i];<br>                flag[i][<span class="hljs-number">1</span>][v] = cf[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">0</span>; v &lt; n; ++v) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; ++i) ++cntL[i][flag[i][<span class="hljs-number">1</span>][v]];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">31</span>; i &gt;= <span class="hljs-number">0</span>; --i) <span class="hljs-keyword">if</span> (data[v] &amp; (<span class="hljs-number">1ll</span> &lt;&lt; i)) &#123;<br>                ans += cntL[i][<span class="hljs-number">0</span>] * cntR[i][<span class="hljs-number">0</span>] + cntL[i][<span class="hljs-number">1</span>] * cntR[i][<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; ++i) --cntR[i][flag[i][<span class="hljs-number">0</span>][v]];<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日本旅游杂记-东京篇</title>
    <link href="/2024/04/23/tourist/Japan-Tokyo-1/"/>
    <url>/2024/04/23/tourist/Japan-Tokyo-1/</url>
    
    <content type="html"><![CDATA[<h1 id="旅游计划前的闲聊"><a href="#旅游计划前的闲聊" class="headerlink" title="旅游计划前的闲聊"></a>旅游计划前的闲聊</h1><p>一直都在计划去日本旅游，不过因为各种原因搁置了，最近也打算趁着发年终奖了，计划去日本旅游一趟。</p><p>想着把旅游期间遇到的问题和计划也分享在这，可以作为其他想要去日本旅游的人的参考。当然，这是自由行的计划，如果是跟旅行团的话，还是乖乖听旅行团的安排吧</p><p>为什么考虑去日本旅游呢</p><p>我个人觉得旅行分为两类一类是人文旅游，一类是自然旅游</p><ul><li>人文旅游需要去那些和自己日常生活习惯完全不同的国家地区，去体验不同的人文，需要注意减少遇到和自己来自同一个地区的人</li><li>自然旅游需要去体验自然风光，那必须人越少越好，无论是不是和你来自同一个地区</li></ul><p>个人感觉目前自然旅游最成功的一次应该就是之前去甘南地区，也许以后有时间我可以来分享一下这段行程，而人文旅游最好的办法就是出国了</p><ul><li>核污水问题。这导致去日本旅游的人变少了，简简单单，就看你信不信日本的核污水排放期间的安全程度</li><li>日本是一个不免签的国家。这也就意味着但凡是有能力去日本旅游的，必定拥有一定的经济实力，相对而言遇到的国人素养更高一些，当然也更少一些</li><li>日本的汇率在跌。这对去日本旅游而言可能会有一些便宜，当然这也是次要条件，毕竟现在日本也面临了输入型通货膨胀，实际成本也不能确定到底是涨没涨</li></ul><h1 id="旅行前的准备"><a href="#旅行前的准备" class="headerlink" title="旅行前的准备"></a>旅行前的准备</h1><p>这块内容主要写在旅行之前，我做出的准备，当然完整的文章会在旅行结束后再发布，但是这块内容我尽量不再去做修改，而是在后面进行补充说明</p><p><strong>请务必注意，本段完全在旅行之前编写，不保证可信度，补充说明会在旅行结束后下面进行补充，请务必阅读完整</strong></p><h2 id="文书准备"><a href="#文书准备" class="headerlink" title="文书准备"></a>文书准备</h2><h3 id="护照"><a href="#护照" class="headerlink" title="护照"></a>护照</h3><p>前往日本旅游需要一本有效期至少还有 6 个月的护照，这个难度应该不是很高，去出入境管理机构办理即可，我记得我的护照大概用了一周的时间寄到了，<br>但是还是要留一些时间，毕竟要求只是 7 个工作日办理完成</p><p>护照需要身份证就可以办理了，一寸照片都是要求现场拍摄的。<br>另外需要你办理所在地，你需要拥有此地区居住证或者是暂住证，并不需要户口本其实也可以办理的，至少我没带户口本去也能办</p><p>护照当然是越早办理越好，一般成年人的护照有效期都是 10 年，只要你的旅游计划是最近 9 年内的，那就没有问题</p><h3 id="签证"><a href="#签证" class="headerlink" title="签证"></a>签证</h3><p>日本目前还不是免签地区，所以还是需要申请签证的，不过日本的旅游签证办理还算简单</p><blockquote><p>有关此类签证手续，需通过取得了日本国驻华使领馆（请确认<a href="https://www.cn.emb-japan.go.jp/itpr_zh/aboutus.html#kankatsu">各使领馆的管辖地区</a><br>）送签资格的<a href="https://www.cn.emb-japan.go.jp/itpr_zh/visa_dantai_daili.html">指定旅行社</a>进行申请。故申请人无法直接去使领馆办理及领取此类签证。<br>via. <a href="https://www.cn.emb-japan.go.jp/itpr_zh/visa_kanko.html">日本国驻华大使馆文件</a></p></blockquote><p>根据文件描述，旅游签证必须要由旅行社代为办理，不能直接去大使馆申请，必须去找一家旅行社去办理</p><p>为了方便起见，我还是直接选择一些旅游平台，比如飞猪、携程等进行办理，由于个人有一些奇怪的洁癖，各种互联网需求只选择一家平台且不比价，考虑到淘宝上就可以直接搜索到飞猪的商品，于是决定使用淘宝+飞猪的组合，包括后面全部的网络预订均选择了飞猪的服务</p><p>以上海的领事馆为例，在飞猪上搜索日本签证，就可以得到以下的费用情况</p><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">有效时间</th><th style="text-align:center">逗留时间</th><th style="text-align:center">价格</th><th style="text-align:center">一般年薪（税后）要求</th></tr></thead><tbody><tr><td style="text-align:center">单次旅游签证</td><td style="text-align:center">90天</td><td style="text-align:center">15天</td><td style="text-align:center">199</td><td style="text-align:center">100k 年收入</td></tr><tr><td style="text-align:center">具有足够经济能力人士的多次旅游签证</td><td style="text-align:center">3年</td><td style="text-align:center">30天</td><td style="text-align:center">435</td><td style="text-align:center">200k 年收入</td></tr><tr><td style="text-align:center">相当高收入人士的多次签证</td><td style="text-align:center">5年</td><td style="text-align:center">90天</td><td style="text-align:center">458.9</td><td style="text-align:center">500k 年收入</td></tr></tbody></table></div><p>相关材料可以在 <a href="https://www.cn.emb-japan.go.jp/files/100411249.pdf">此处</a> 拿到，当然具体要什么，还是得听旅游社的，比如年薪要求。不过如果是在校大学生的话，似乎办理单次签证比较轻松</p><h2 id="Visit-Japan-Web"><a href="#Visit-Japan-Web" class="headerlink" title="Visit Japan Web"></a>Visit Japan Web</h2><p>这个是可能很多人并不知道的，<a href="https://www.vjw.digital.go.jp/main/#/vjwplo001">地址在这里</a></p><p>这是日本入境前需要进行申请的地方，理论上你不填写也可以坐飞机，只不过在入关的时候还是要求你进行填写，如果提前在这里进行报备的话，入关会很快。<br>当然目前本人还没有体验过提前填写的好处，毕竟还没有出发</p><p>我也是从 <a href="https://www.youtube.com/watch?v=JyWB8SMrnLk">这里</a> 学到的，可以参考一下这位姐姐制作的视频，也很有价值</p><h2 id="现金"><a href="#现金" class="headerlink" title="现金"></a>现金</h2><p>根据经验而言，差不多一顿饭吃好一点的话，两个人可能需要 5000JPY，约等于 230CNY/30USD/250HKD/1000NTD 的样子，按照三日行程，需要 30K JPY 的样子，<br>当然听说很多地方都支持 Suica 卡或者使用 visa/PayPal/Mastercard 所以可能并不需要兑换太多的现金，可能更多是在一些小店铺进行购买，<br>故大概计划准备 10000 到 20000 左右的 JPY 吧，总归能找到不用现金吃饭的地方的吧</p><h2 id="交通"><a href="#交通" class="headerlink" title="交通"></a>交通</h2><h3 id="市区交通"><a href="#市区交通" class="headerlink" title="市区交通"></a>市区交通</h3><p>交通选择了了 Suica 卡，也就是 <a href="https://www.jreast.co.jp">这个</a></p><p>当然没有那么麻烦，因为是 iPhone 用户，所以你可以直接在手机的钱包应用里找到这张卡，在国内就可以直接办理，非常快，<br>路径是：钱包 $\rightarrow$ 添加卡 $\rightarrow$ 交通卡 $\rightarrow$ SUICA</p><p><img src="/image/tourist/Japan-Tokyo-1/SUICA.png" alt="SUICA"></p><p>很方便是不是，按照 iPhone 的公交卡机制，再开启快捷交通后，就可以直接用摄像头那块区域进行刷卡了，就和用实体卡一样……希望如此吧，也得等我试试</p><h3 id="机场交通"><a href="#机场交通" class="headerlink" title="机场交通"></a>机场交通</h3><p>另外需要额外注意的一个问题是，离东京最近的机场是羽田机场，但羽田机场通常是承载国内航班的，我们一般是飞到了成田国际机场，假如想从成田机场前往秋叶原，则有 55km……</p><p><img src="/image/tourist/Japan-Tokyo-1/distance.png" alt="distance"></p><p>这个距离还是稍微有那么一点点的可怕，目前也有三种交通方式</p><ul><li>来自 JR 的<a href="https://www.jreast.co.jp/multi/zh-CHS/pass/nex.html">N’EX 东京往返车票</a></li><li>京成成田 SKY ACCESS（京成 Access 特急）</li><li>Skyliner 天空快线</li></ul><p>这里考虑到达新宿的时间，如果是在上野、浅草、银座之类的地方就下车的话，应该会更快一些</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">N’EX</th><th style="text-align:center">SKY ACCESS</th><th style="text-align:center">Skyliner</th></tr></thead><tbody><tr><td style="text-align:center">time cost</td><td style="text-align:center">1h27m</td><td style="text-align:center">1h25m</td><td style="text-align:center">1h11m</td></tr><tr><td style="text-align:center">money cost</td><td style="text-align:center">5,000JPY</td><td style="text-align:center">2,960JPY</td><td style="text-align:center">5,580JPY</td></tr><tr><td style="text-align:center">transfer</td><td style="text-align:center">NO</td><td style="text-align:center">1 time</td><td style="text-align:center">1 time</td></tr><tr><td style="text-align:center">first time</td><td style="text-align:center">07:37</td><td style="text-align:center">05:41</td><td style="text-align:center">06:20</td></tr><tr><td style="text-align:center">last time</td><td style="text-align:center">21:44</td><td style="text-align:center">23:08</td><td style="text-align:center">23:00</td></tr></tbody></table></div><p>综合上看，还是坐 SKY ACCESS 比较值，时间也比较充裕，除了慢一点需要转车以外，基本就没太大缺点了。<br>另外，搭乘「京成 Access 特急」是不需要预约的！只要在抵达成田机场后于现场的自动售票机、售票中心购票，有 IC 票卡的更可以直接哔哔进站！</p><h2 id="旅游地点"><a href="#旅游地点" class="headerlink" title="旅游地点"></a>旅游地点</h2><p>做了一张东京地图，标注了核心的一些旅游景点</p><p><img src="/image/tourist/Japan-Tokyo-1/key-point.png" alt="key-point"></p><h3 id="涩谷"><a href="#涩谷" class="headerlink" title="涩谷"></a>涩谷</h3><h4 id="旅游地点-1"><a href="#旅游地点-1" class="headerlink" title="旅游地点"></a>旅游地点</h4><ul><li>涩谷 SKY <a href="https://www.shibuya-scramble-square.com/sky/ticket/">预定地址</a><ul><li>可以俯瞰整个东京地区，可以看到富士山、晴空塔、东京塔等景点</li><li>费用 2,200JPY，但是现场直接买票要 2,500JPY</li><li>日落很好看，需要提前很早很早在网上进行订票，不然是订不到日落时分时间进去的，只有下午场。</li><li>虽然并不限制什么时候出来，但是在里面待一个下午等日落还是有点……</li></ul></li><li>原宿地区<ul><li>指原宿车站到表参道站一路的店铺，包括来自竹下通出口的一带，有非常多的小吃和店家</li></ul></li><li>涩谷十字路口<ul><li>全球人流量最大的十字路口</li></ul></li></ul><h4 id="美食"><a href="#美食" class="headerlink" title="美食"></a>美食</h4><ul><li>極味屋 澀谷PARCO店<ul><li>日本〒150-0042 Tokyo, Shibuya City, Udagawacho, 15−1 渋谷パルコ地下 1階</li><li>美式牛扒屋，有松露炒饭，自助烤肉</li><li>日常营业时间：11:30–23:00，周末营业时间：11:00–22:30</li><li>人群约 2000JPY+</li></ul></li><li>LUKE’S LOBSTER 表參道貓街店<ul><li>三明治专卖店</li></ul></li><li>Micasadeco &amp; Cafe Jingumae<ul><li>咖啡甜点店，有松饼等</li><li>晚上不营业</li><li><a href="https://micasadecoandcafe.com/tokyo.html">菜单</a></li></ul></li><li>ANAKUMA CAFE - Harajuku<ul><li>熊熊咖啡厅，很好玩的咖啡店</li><li>单杯价格在 1,500JPY 左右</li><li><a href="https://anakuma.jp/pages/menu#food">菜单</a></li></ul></li></ul><h3 id="上野"><a href="#上野" class="headerlink" title="上野"></a>上野</h3><h4 id="旅游地点-2"><a href="#旅游地点-2" class="headerlink" title="旅游地点"></a>旅游地点</h4><ul><li>上野恩赐公园<ul><li>樱花季会比较好，非樱花季就比较尴尬了，可以进去逛逛</li></ul></li><li>晴空塔（东京天空树）<a href="https://www.tokyo-skytree.jp/ticket/individual/">官网</a><ul><li>要上去的话，价格还是比较贵的，提前至少一天预定费用是 2,700JPY，如果是当天预定的话需要 3,100JPY，成本还是稍微有一些高</li><li>不过有和隔壁的墨田水族馆合并的门票，价格为 4,700 JPY，组合票在这里 <a href="https://link-ticket.tokyo-skytree.jp/activity/zh/TICKETHUB-skytree_aquarium">购买</a></li><li>需要注意组合票必须先去天空树，逛完才能进入水族馆</li></ul></li><li>墨田水族馆 <a href="https://webket.jp/pc/ticket/index?fc=00294&amp;ac=8001">官网</a><ul><li>墨田地区的水族馆，单人 2,500JPY 价格不算很高，可以接受，而且是莉可莉丝的取景地，还是挺值得一去</li><li><img src="/image/tourist/Japan-Tokyo-1/Sumida-Aquarium.jpg" alt="Sumida Aquarium"></li></ul></li><li>浅草寺<ul><li>有着悠久历史寺庙，可以去参拜一下</li><li>记得收集一下御朱印</li></ul></li><li>Sumida Park/隅田公园<ul><li>沿河的一条，樱花季会比较好看</li><li>可以看到对面的晴空塔，如果不去晴空塔的话，这里观景也不错</li></ul></li></ul><h4 id="美食-1"><a href="#美食-1" class="headerlink" title="美食"></a>美食</h4><ul><li>Numazuko Kaisho<ul><li>1,500JPY 自助海鲜</li></ul></li><li>Bou-ya Uenorokuchometen(房家ホルモン館 上野六丁目店)<ul><li>烤肉店</li><li>有各种稀有部位的烤牛肉，比如牛肠、牛舌、</li><li>预期两个人的成本是 5,000JPY</li><li>可乐是梅汁口味的</li></ul></li></ul><h3 id="新宿"><a href="#新宿" class="headerlink" title="新宿"></a>新宿</h3><h4 id="旅游地点-3"><a href="#旅游地点-3" class="headerlink" title="旅游地点"></a>旅游地点</h4><h4 id="美食-2"><a href="#美食-2" class="headerlink" title="美食"></a>美食</h4><ul><li>Afuri Karakurenai Shinjuku Subnade（AFURI辛紅 新宿サブナード）<ul><li>拉面店，沾面</li><li><a href="https://afuri.com/karakurenai/">菜单</a></li><li>人群价格在 1100JPY 左右，相对廉价</li></ul></li></ul><h3 id="筑地市场"><a href="#筑地市场" class="headerlink" title="筑地市场"></a>筑地市场</h3><h4 id="美食-3"><a href="#美食-3" class="headerlink" title="美食"></a>美食</h4><p>（驻地不能边走边吃哦）</p><ul><li>とんぼや Tonboya<ul><li>碳烤鮪魚，500JPY 一串</li></ul></li><li>Onigiri Marutoyo<ul><li>周末休息的一家店</li><li>炸饭团</li></ul></li><li>Yamachō/Shouro<ul><li>玉子烧，很火爆</li></ul></li><li>Matcha Stand Maruni TOKYO TSUKIJI<ul><li>咖啡抹茶店</li><li><a href="https://matchastandmaruni.com/zh-tw">官网</a></li><li>抹茶单杯 650JPY</li></ul></li><li>YONEMOTO Coffee Shop Tsukiji New Shop<ul><li>很有名的老店，推荐黑糖蜜咖啡</li></ul></li><li>Saito Suisan（斉藤水産㈱）<ul><li>生吃牡蛎，1400JPY 一个</li></ul></li><li>Soratsuki<ul><li>甜点店，有奶昔等</li></ul></li></ul><h3 id="月岛-佃岛"><a href="#月岛-佃岛" class="headerlink" title="月岛/佃岛"></a>月岛/佃岛</h3><h4 id="美食-4"><a href="#美食-4" class="headerlink" title="美食"></a>美食</h4><ul><li>KYUEI MELON PAN（月島久栄）<ul><li>面包店</li><li>菠萝面包 200JPY</li></ul></li><li>Moheji Hanare（月島もんじゃ もへじ はなれ）<ul><li>文字烧</li></ul></li></ul><h3 id="丰州"><a href="#丰州" class="headerlink" title="丰州"></a>丰州</h3><h4 id="旅游地点-4"><a href="#旅游地点-4" class="headerlink" title="旅游地点"></a>旅游地点</h4><ul><li>Tokyo Toyosu Manyo club（東京豊洲 万葉倶楽部）<ul><li>超级公共浴室，泡澡</li><li>八楼可以免费泡脚，记得自带毛巾</li></ul></li></ul><h4 id="美食-5"><a href="#美食-5" class="headerlink" title="美食"></a>美食</h4><p>下午两点打烊的街区</p><ul><li>海鮮丼 大江戶 豐洲市場內店<ul><li><a href="https://www.tsukiji-ooedo.com">菜单与营业时间</a></li><li>人均约 2500JPY</li><li>14:30 打烊</li></ul></li><li>濱風茶房<ul><li>抹茶店，有甜点，比如栗子蛋糕（1000JPY）</li><li>18:00 打烊</li></ul></li><li>越後屋 助五郎<ul><li>烤鱼串</li><li>19:00 打烊</li><li>稍微有点贵</li></ul></li></ul><h3 id="秋叶原"><a href="#秋叶原" class="headerlink" title="秋叶原"></a>秋叶原</h3><h4 id="美食-6"><a href="#美食-6" class="headerlink" title="美食"></a>美食</h4><ul><li>肉屋橫丁<ul><li>烤肉自助，和牛吃到饱</li><li>一个人 6980JPY</li></ul></li></ul><h3 id="麻布台"><a href="#麻布台" class="headerlink" title="麻布台"></a>麻布台</h3><h4 id="旅游地点-5"><a href="#旅游地点-5" class="headerlink" title="旅游地点"></a>旅游地点</h4><ul><li>teamLab Borderless: MORI Building DIGITAL ART MUSEUM<ul><li><a href="https://www.teamlab.art/jp/e/tokyo/">官网</a></li><li>美术馆，整个房间都是屏幕的艺术馆，艺术内容会和你的互动进行变化</li><li>门票很贵，日常一个人 4000JPY，节假日或者临近的日期容易涨到 4400JPY 甚至 4800JPY</li></ul></li><li>Hills House 33F<ul><li>高空视野，可以近距离看到东京铁塔，还是免费的景点</li></ul></li></ul><h4 id="美食-7"><a href="#美食-7" class="headerlink" title="美食"></a>美食</h4><ul><li>Pelican café<ul><li>一家卖吐司的店，评分有高有低，排队比较久</li></ul></li><li>椀もなか 花一会<ul><li>18:00 关门</li><li>各种冲泡的调料，适合买回去当礼物</li></ul></li></ul><h2 id="住宿"><a href="#住宿" class="headerlink" title="住宿"></a>住宿</h2><p>住宿可以考虑根据游玩路线制定，日本的酒店的房间和床都比较小</p><h2 id="旅行路线推荐"><a href="#旅行路线推荐" class="headerlink" title="旅行路线推荐"></a>旅行路线推荐</h2><p>路线考虑是从新宿出发，回到新宿的，所以不一定适合，也可以根据上面的地点自己进行拟定</p><h3 id="新宿-涩谷-台场-丰州-月岛-筑地市场"><a href="#新宿-涩谷-台场-丰州-月岛-筑地市场" class="headerlink" title="新宿-涩谷-台场-丰州-月岛-筑地市场"></a>新宿-涩谷-台场-丰州-月岛-筑地市场</h3><p><img src="/image/tourist/Japan-Tokyo-1/line1.png" alt="line1"></p><ul><li>早上从新宿出发</li><li>先乘坐 JR 山手线，到达原宿站</li><li>从原宿站的竹下口出</li><li>沿着出口方向一直向东步行到竹下口红绿灯处，然后再向南走，一路走到新宿站<ul><li>LUKE’S LOBSTER 表參道貓街店</li><li>Micasadeco &amp; Cafe Jingumae</li><li>ANAKUMA CAFE - Harajuku</li></ul></li><li>中午到达新宿站<ul><li>極味屋 澀谷PARCO店</li><li>涩谷十字路口</li></ul></li><li>乘坐崎京線到达东京电讯</li><li>前往台场海滨公园<ul><li>台场海滨公园</li></ul></li><li>下午再向北步行至丰州<ul><li>Tokyo Toyosu Manyo club</li><li>濱風茶房</li><li>越後屋 助五郎</li></ul></li><li>然后再西北方向，经过月岛<ul><li>Moheji Hanare（月島もんじゃ もへじ はなれ）</li><li>KYUEI MELON PAN（月島久栄）</li></ul></li><li>傍晚到达筑地市场<ul><li>とんぼや Tonboya</li><li>Onigiri Marutoyo</li><li>Yamachō/Shouro</li><li>Matcha Stand Maruni TOKYO TSUKIJI</li><li>YONEMOTO Coffee Shop Tsukiji New Shop</li><li>Saito Suisan（斉藤水産㈱）</li><li>Soratsuki</li></ul></li><li>晚上可以选择在银座附近逛街</li></ul><h3 id="新宿-上野-押上-麻布台"><a href="#新宿-上野-押上-麻布台" class="headerlink" title="新宿-上野-押上-麻布台"></a>新宿-上野-押上-麻布台</h3><ul><li>早上从新宿出发</li><li>乘坐 JR 山手线，到达上野<ul><li>上野恩赐公园</li></ul></li><li>然后乘坐东京地下铁的银座线再前往浅草<ul><li>浅草寺</li><li>隅田公园</li></ul></li><li>中午回到上野地区解决午餐<ul><li>Bou-ya Uenorokuchometen(房家ホルモン館 上野六丁目店)</li></ul></li><li>乘坐地下铁银座线转都营浅草线前往押上<ul><li>墨田水族馆</li></ul></li><li>傍晚前往麻布台，并解决晚饭<ul><li>Hills House 33F</li><li>椀もなか 花一会</li></ul></li></ul><h2 id="现金-1"><a href="#现金-1" class="headerlink" title="现金"></a>现金</h2><p>按照 5000 一顿来算，三天大概需要 30k 的日元，可以在各大银行进行兑汇，但是好像很难预约，需要想要去旅游的可以多找找别的渠道</p><h2 id="电器"><a href="#电器" class="headerlink" title="电器"></a>电器</h2><p>日本的民用电压统一为 100V，但是在日本东部地区（比如东京）是采用 50Hz，而西部地区（京都、大阪等）是 60Hz</p><p>这是在二战之后，由美国负责帮忙重建关西地区，而关东地区则由英国帮忙重建，所以导致了日本同时并存两种频率的供电系统。<br>当然对于频率而言影响并不大，现在绝大部分电器都支持了 50Hz-60Hz，但是电压方面需要额外关注一下，<br>因为国内使用的是 220V 的高电压，部分相对廉价的设备通常仅支持 200V-220V，如果有不足的话需要额外购买一些</p><p>另外的，日本采用的也是和国内相同的接口形状，所以如果转换插头的电压范围是满足日本的电压的情况下，就不需要额外购买了</p><h1 id="旅行后的回顾"><a href="#旅行后的回顾" class="headerlink" title="旅行后的回顾"></a>旅行后的回顾</h1><p>在东京游玩了三天之后，再加上经历了一大堆繁琐的事情之后，终于有时间来补充剩下部分了，这里将会主要聊聊旅行准备相关的事情</p><h2 id="Visit-Japan-Web-1"><a href="#Visit-Japan-Web-1" class="headerlink" title="Visit Japan Web"></a>Visit Japan Web</h2><p>这是非常方便的东西，可以代替你在飞机上有人发放的纸质入境申请，包括后续不少流程可以直接使用，<br>同时还有免税 QR code，当然我还没有用上，听说需要单次消费超过 5000JPY 才能使用</p><h2 id="现金-2"><a href="#现金-2" class="headerlink" title="现金"></a>现金</h2><p>在日本支付方式比起国内要方便多了，绝大部分店铺都支持刷卡、现金、PayPal，相当一部分的店铺还支持了 Alipay，<br>另外值得注意的一点，日本的交通卡（即上面提到的 Suica 卡）也是支持作为日常的消费使用卡片，支持率通常比 Alipay 还要高，<br>所以如果你没有一张 visa 或者 master card，那么可以考虑在 Suica 卡中多充值一些金额。不过听说还有很多支持 Apple Pay，但是我自己还没有尝试过</p><p>另外，在个别的店铺，是只支持现金支付的，虽然是仅支持现金，但是也能保证给你开出一张打印的小票，除了浅草寺里是没有小票也不支持电子支付，必须现金</p><h2 id="交通-1"><a href="#交通-1" class="headerlink" title="交通"></a>交通</h2><h3 id="三大轨道交通公司"><a href="#三大轨道交通公司" class="headerlink" title="三大轨道交通公司"></a>三大轨道交通公司</h3><p>东京的交通非常的便利，便利到有点过于便利了</p><p>很多时候我觉得共享单车是一种非常好的解决城市内最后一公里的交通问题，因为地铁的站点密度并不是很高，通常两个站之间的距离可以达到 1-2km，<br>加上现在的人们通常并不喜欢乘坐公交车，所以必然存在着最后一公里的问题<br>但是对于日本而言，如果你只考虑乘坐轨道交通，那么就压根不存在最后一公里的问题，因为站点密度实在太高了，通常两个站之间的直线距离只有 500m</p><p>举个例子，这个是都营地下铁的东京运营图，可以再拿国内城市的地铁图来比较一下密度，当然看起来和北京比，似乎也差不多，看起来可能略多一些<br>但是整个东京拥有三家和都营地下铁一样规模的轨道交通运营公司，且这几家的公司甚至不共用站点<br>而图里的仅仅只是一家公司的站点，可见东京的轨道交通的发达程度</p><p><img src="/image/tourist/Japan-Tokyo-1/kotsu.jpeg" alt="kotsu"></p><p>东京的轨道交通主要分为两大类，三家公司。分别是 JR东日本、东京地下铁、都营地下铁，其中后面两家统称为地铁，前者则俗称为 JR。虽然都是轨道交通，<br>但是 JR 和地铁则完全不同，比较典型的特点是：地铁的站点看起来都比较小，比较隐藏，而 JR 站点都有很大的规模，类似国内的地铁站</p><p>其中 JR东日本的标识非常容易认，即一个大大的 JR 字母，而东京地下铁则是蓝色的 M 字母构型，都营地下铁则是一片绿色的银杏叶</p><p>比如下图，是都营地下铁的浅草桥站的入口， 因为当时是大晚上，且忙于赶路，所以没有拍照，但是我在 Google Maps 中找到了入口。<br>如果不明说下面的图中有地铁站入口，你能很快发现吗</p><p><img src="/image/tourist/Japan-Tokyo-1/AsakusabashiEki.png" alt="AsakusabashiEki"></p><p>仔细关注图片中央的深红色衣服的人附近的一个门口上面的标识</p><p>大部分较小的地铁站点都比较隐藏，不论是东京地下铁公司的站点还是都营地下铁的站点，似乎都隐藏在很多店铺之间</p><p>而 JR 站则一般比较大，比如秋叶原站的入口</p><p><img src="/image/tourist/Japan-Tokyo-1/AkihabaraEki.jpeg" alt="AkihabaraEki"></p><p>当然 JR 和地铁之间还有很多区别，例如地铁上不能吃东西，但是 JR 可以，再比如地铁有不少站点是在地下的，而 JR 则全都是地上轨道交通。<br>但是从价格、速度、体验上，我确实没有感觉出太多的区别</p><h3 id="乘坐细节注意"><a href="#乘坐细节注意" class="headerlink" title="乘坐细节注意"></a>乘坐细节注意</h3><p>需要值的注意的是，东京轨道交通从地上进站一路到站台，地面上都会划有方向，大部分情况下是靠左，也就是你需要靠左侧走楼梯进站。<br>虽然实际上靠左还是靠右都是可以的，但是毕竟是作为访客，还是非常推荐和当地人一样，尽量靠左走</p><p>另外，大部分东京的地铁进站都是纯楼梯的，没有扶手电梯，所以对于不打算定居在一个酒店的人而言，可能要经历比较大的负担——拎着行李箱走很多很多的楼梯<br>要注意由于东京的地铁是多个公司运营的，公司之间的站台不共享，这也就导致你即使全程使用地铁，也需要不断的走楼梯进行进站出站，这还是挺折腾人的</p><p>另外值得一提的是日本的扶手电梯，一定要站在左边！一定要站在左边！一定要站在左边！日本的不成文规定：左侧是用来站着的，右侧是用来走的，<br>所以如果你不小心站到了右侧，务必要走上去，不要堵着后面的人了</p><p>另外非常建议的事情是，下载 Google Maps，在日本使用的时候，便利程度和高德完全不是一个 level 的软件了，<br>它会告诉精确的告诉你应该进入哪个站，到哪个站台，接下来有哪些时间的班车你可以坐，每辆班车预期从本站出发的时间以及到达的时间、目前的延误时间，<br>甚至在地铁上还会通知你下一站要下车了</p><h2 id="旅游地点-6"><a href="#旅游地点-6" class="headerlink" title="旅游地点"></a>旅游地点</h2><p>有不少旅游地点需要注意</p><ul><li>原宿地区：这里的店铺都是 11 点才开门，唯一的一家 10 点开门的是中式餐厅。另外如果你需要特意去购买某些东西，反而建议早一点去，有很多人会提前排队</li><li>筑地市场：这里的店家关门都比较早，似乎下午就找不到什么开着门的店铺了</li><li>Hills House 33F：这里的 33F 是要从 B1 楼的特殊电梯才能进入，仔细找一下，有一个特殊的入口<ul><li>另外现在并非完全免费，需要你在 33F 的咖啡店里至少购买一杯咖啡才能进入，价格不算贵，但是需要额外加上 500JPY，不过即使这样，总价也不高</li><li>另外此处的咖啡店只支持非现金支付，一般在那个特殊的电梯前，会有保安向你确认</li></ul></li></ul><h2 id="其他相关"><a href="#其他相关" class="headerlink" title="其他相关"></a>其他相关</h2><p>日本的红绿灯稍微有一些不一样，日本的红绿灯有这种特殊的计时，其是通过还有几个两点来表示总共还有多久，<br>比如总共 6 个光电，亮了 2 个，意味着当前颜色的灯还有 1/3 的时间，完全没有精确的时间，只有大概的比例</p><p><img src="/image/tourist/Japan-Tokyo-1/TrafficLights.JPEG" alt="TrafficLights"></p><p>另外就是日本对智能马桶的执着有点过分，你甚至可以在地铁站的公共厕所内发现智能马桶……</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>旅行计划</tag>
      
      <tag>日本</tag>
      
      <tag>东京</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 939 (Div. 2)</title>
    <link href="/2024/04/21/acm/codeforces/CodeforcesRound939/"/>
    <url>/2024/04/21/acm/codeforces/CodeforcesRound939/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Nene’s-Game"><a href="#A-Nene’s-Game" class="headerlink" title="A. Nene’s Game"></a>A. Nene’s Game</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一排士兵，按照 $1,2,3,4 \dots n$ 的顺序喊，每次喊道 $a_i$ 的位置就踢出队伍，问最后剩下几个人</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>只需要关注第一个被踢出去的人就行了</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> k, q, s;<br>        cin &gt;&gt; k &gt;&gt; q;<br>        cin &gt;&gt; s;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; k; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; ++i) &#123;<br>            <span class="hljs-type">int</span> n;<br>            cin &gt;&gt; n;<br>            cout &lt;&lt; <span class="hljs-built_in">min</span>(n, s - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == q - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Nene-and-the-Card-Game"><a href="#B-Nene-and-the-Card-Game" class="headerlink" title="B. Nene and the Card Game"></a>B. Nene and the Card Game</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一组牌，每种数字只出现在两张牌上</p><p>现在将这组牌打散后分给两个人，并进行游戏。游戏的每一轮，当前的出牌手需要出一张牌，如果这张牌上的数值的另外一张已经在场上了，那么就会获得 1 份</p><p>现在给你其中一个人的手牌，问最多可以得到多少分</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>两边的牌是映射的，所以先手出一张，后手跟一张，这样是刚刚好的，所以先手只能赚到那些两张牌都在自己手里的分数</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        set&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            st.<span class="hljs-built_in">insert</span>(tmp);<br>        &#125;<br>        cout &lt;&lt; n - st.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Nene’s-Magical-Matrix"><a href="#C-Nene’s-Magical-Matrix" class="headerlink" title="C. Nene’s Magical Matrix"></a>C. Nene’s Magical Matrix</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个矩阵，现在允许每次往一行或者一列上覆盖写 $1, 2, 3 \dots n$ 的某一个排列，问最终的整个矩阵的求和是多少</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>每个位置都能变成它的横坐标和纵坐标里的较大者，简单模拟即可</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) ans += <span class="hljs-built_in">max</span>(i, j) + <span class="hljs-number">1</span>;<br>        cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-number">2</span> * n &lt;&lt; endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) cout &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; j + <span class="hljs-number">1</span>;<br>            cout &lt;&lt; endl;<br>            cout &lt;&lt; <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) cout &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; j + <span class="hljs-number">1</span>;<br>            cout &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Nene-and-the-Mex-Operator"><a href="#D-Nene-and-the-Mex-Operator" class="headerlink" title="D. Nene and the Mex Operator"></a>D. Nene and the Mex Operator</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个初始数组，允许你每次选择一个子串，将其的每一个值变成这个子串的 $MEX$，问可以让整个数组的所有位置之和最大是多少</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>注意这个数组最大只能是 18 个数值，所以可以随意暴力</p><p>容易得到，最终一定可以把选择的区间都变成和当前区间长度相同的那个值，比如区间长度为 $3$，那么最终这个区间可以变成三个 $3$</p><p>首先通过 dp 计算出哪些区间要进行上面的操作，然后再递归构建即可</p><p>比如我通过一定手段能够构建 $0, 1, 2, 3, 4, x$，就能通过一次 $MEX$ 得到 $5, 5, 5, 5, 5, 5$，<br>这个时候如果我再去尝试构建 $0, 1, 2, 3, 4$ 就可以重复之前的构建过程了，重复构建前五个值，相当于递归两次即可</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span>, <span class="hljs-title">dp</span><span class="hljs-params">(n)</span>, <span class="hljs-title">dr</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: data) cin &gt;&gt; i;<br>    dp[<span class="hljs-number">0</span>] = data[<span class="hljs-number">0</span>] &gt;= <span class="hljs-number">1</span> ? data[<span class="hljs-number">0</span>] : <span class="hljs-number">1</span>;<br>    dr[<span class="hljs-number">0</span>] = data[<span class="hljs-number">0</span>] &gt;= <span class="hljs-number">1</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>        dp[i] = dp[i - <span class="hljs-number">1</span>] + data[i];<br>        dr[i] = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &gt;= <span class="hljs-number">1</span>; --j)<br>            <span class="hljs-keyword">if</span> (dp[j - <span class="hljs-number">1</span>] + (i - j + <span class="hljs-number">1</span>) * (i - j + <span class="hljs-number">1</span>) &gt; dp[i]) &#123;<br>                dp[i] = dp[j - <span class="hljs-number">1</span>] + (i - j + <span class="hljs-number">1</span>) * (i - j + <span class="hljs-number">1</span>);<br>                dr[i] = j;<br>            &#125;<br>        <span class="hljs-keyword">if</span> ((i + <span class="hljs-number">1</span>) * (i + <span class="hljs-number">1</span>) &gt; dp[i]) &#123;<br>            dr[i] = <span class="hljs-number">0</span>;<br>            dp[i] = (i + <span class="hljs-number">1</span>) * (i + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; ans;<br>    ans.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">2e5</span>);<br><br>    <span class="hljs-keyword">auto</span> zero = [&amp;](<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r) &#123;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; ++i) <span class="hljs-keyword">if</span> (data[i] == <span class="hljs-number">0</span>) flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (flag) ans.<span class="hljs-built_in">emplace_back</span>(l, r);<br>        <span class="hljs-keyword">else</span> &#123;<br>            ans.<span class="hljs-built_in">emplace_back</span>(l, r);<br>            ans.<span class="hljs-built_in">emplace_back</span>(l, r);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; ++i) data[i] = <span class="hljs-number">0</span>;<br>    &#125;;<br>    function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r) &#123;<br>        <span class="hljs-keyword">if</span> (l == r) &#123;<br>            <span class="hljs-keyword">if</span> (data[l] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>            ans.<span class="hljs-built_in">emplace_back</span>(l, l);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(l, r - <span class="hljs-number">1</span>);<br>        ans.<span class="hljs-built_in">emplace_back</span>(l, r);<br>        ans.<span class="hljs-built_in">emplace_back</span>(l, r - <span class="hljs-number">1</span>);<br>        data[r] = r - l;<br>        <span class="hljs-built_in">dfs</span>(l, r - <span class="hljs-number">1</span>);<br>    &#125;;<br><br>    <span class="hljs-keyword">auto</span> f = [&amp;](<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r) &#123;<br>        <span class="hljs-built_in">zero</span>(l, r);<br>        <span class="hljs-built_in">dfs</span>(l, r);<br>        ans.<span class="hljs-built_in">emplace_back</span>(l, r);<br>    &#125;;<br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; lr;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-keyword">if</span> (dr[i] == <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">f</span>(dr[i], i);<br>        i = dr[i];<br>    &#125;<br><br>    cout &lt;&lt; dp[n - <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; ans.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[a, b]: ans) cout &lt;&lt; a + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; b + <span class="hljs-number">1</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 928 (Div. 4)</title>
    <link href="/2024/04/20/acm/codeforces/CodeforcesRound928/"/>
    <url>/2024/04/20/acm/codeforces/CodeforcesRound928/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Vlad-and-the-Best-of-Five"><a href="#A-Vlad-and-the-Best-of-Five" class="headerlink" title="A. Vlad and the Best of Five"></a>A. Vlad and the Best of Five</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给出五个字母，其中只有 A/B，问那个字母出现次数多</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>简单题，统计一下就行</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        string str;<br>        str.<span class="hljs-built_in">resize</span>(<span class="hljs-number">5</span>);<br>        cin &gt;&gt; str;<br>        <span class="hljs-type">int</span> cnt[<span class="hljs-number">2</span>] = &#123;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: str) ++cnt[i - <span class="hljs-string">&#x27;A&#x27;</span>];<br>        cout &lt;&lt; (cnt[<span class="hljs-number">0</span>] &gt; cnt[<span class="hljs-number">1</span>] ? <span class="hljs-string">&#x27;A&#x27;</span> : <span class="hljs-string">&#x27;B&#x27;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Vlad-and-Shapes"><a href="#B-Vlad-and-Shapes" class="headerlink" title="B. Vlad and Shapes"></a>B. Vlad and Shapes</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>检查一个图案是不是正方形还是三角形</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>三角形不好检查，检查正方形就行，即四个角落都是染色的即可</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: data) i.<span class="hljs-built_in">resize</span>(n), cin &gt;&gt; i;<br>        <span class="hljs-type">int</span> d[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, n, <span class="hljs-number">0</span>, n&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (data[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>            d[<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(d[<span class="hljs-number">0</span>], i);<br>            d[<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(d[<span class="hljs-number">1</span>], i);<br>            d[<span class="hljs-number">2</span>] = <span class="hljs-built_in">max</span>(d[<span class="hljs-number">2</span>], j);<br>            d[<span class="hljs-number">3</span>] = <span class="hljs-built_in">min</span>(d[<span class="hljs-number">3</span>], j);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (data[d[<span class="hljs-number">0</span>]][d[<span class="hljs-number">2</span>]] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; data[d[<span class="hljs-number">1</span>]][d[<span class="hljs-number">2</span>]] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; data[d[<span class="hljs-number">0</span>]][d[<span class="hljs-number">3</span>]] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; data[d[<span class="hljs-number">1</span>]][d[<span class="hljs-number">3</span>]] == <span class="hljs-string">&#x27;1&#x27;</span>)<br>            cout &lt;&lt; <span class="hljs-string">&quot;SQUARE&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;TRIANGLE&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Vlad-and-a-Sum-of-Sum-of-Digits"><a href="#C-Vlad-and-a-Sum-of-Sum-of-Digits" class="headerlink" title="C. Vlad and a Sum of Sum of Digits"></a>C. Vlad and a Sum of Sum of Digits</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>计算 $1, n$ 之间的所有值，将其的每一个 10 进制的值相加后再相加得到的结果</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>暴力即可，注意打表</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(<span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; data.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        data[i] = data[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> t = i;<br>        <span class="hljs-keyword">while</span> (t) &#123;<br>            data[i] += t % <span class="hljs-number">10</span>;<br>            t /= <span class="hljs-number">10</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        cout &lt;&lt; data[n] &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Vlad-and-Division"><a href="#D-Vlad-and-Division" class="headerlink" title="D. Vlad and Division"></a>D. Vlad and Division</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>给出 $n$ 个值，将其变成多个组，满足任意一个组内的任意两个值，满足他们两个值的任意比特位都不一样</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>每个组里最多两个值，即必须是 $a_i ^ a_j = 0x7fffffff$</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            ++st[tmp];<br>        &#125;<br><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> iter = st.<span class="hljs-built_in">begin</span>();<br>            <span class="hljs-type">int</span> a = iter-&gt;first;<br>            <span class="hljs-keyword">if</span> (iter-&gt;second == <span class="hljs-number">1</span>) st.<span class="hljs-built_in">erase</span>(iter);<br>            <span class="hljs-keyword">else</span> --iter-&gt;second;<br><br>            <span class="hljs-type">int</span> b = (~a) ^ (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">31</span>);<br>            iter = st.<span class="hljs-built_in">find</span>(b);<br>            <span class="hljs-keyword">if</span> (iter != st.<span class="hljs-built_in">end</span>()) --iter-&gt;second;<br>            <span class="hljs-keyword">if</span> (iter != st.<span class="hljs-built_in">end</span>() &amp;&amp; iter-&gt;second == <span class="hljs-number">0</span>) st.<span class="hljs-built_in">erase</span>(iter);<br>            ++ans;<br>        &#125;<br><br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="E-Vlad-and-an-Odd-Ordering"><a href="#E-Vlad-and-an-Odd-Ordering" class="headerlink" title="E. Vlad and an Odd Ordering"></a>E. Vlad and an Odd Ordering</h1><h2 id="大致题意-4"><a href="#大致题意-4" class="headerlink" title="大致题意"></a>大致题意</h2><p>有 $1, 2, 3, \dots, n$ 个数，先从小到大取出所有的奇数排成一排，<br>然后再取出剩下值中的，满足是一个奇数乘上一个 $2$ 的值，从小到大排成一排<br>然后再取出剩下值中的，满足是一个奇数乘上一个 $3$ 的值，从小到大排成一排</p><p>依此类推，直到用完，问第 $k$ 个值是多少</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>实际上没有 $3$ 的机会了，同样的也没有 $5$ 的机会了</p><p>其实就是二进制里，把最后一位是 $1$ 的取走，然后取倒数第二位是 $1$ 的，依此类推</p><h2 id="AC-code-4"><a href="#AC-code-4" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        <span class="hljs-type">int</span> s = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">int</span> t = (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (k &lt;= t) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            k -= t;<br>            n -= t;<br>            s &lt;&lt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        cout &lt;&lt; (k * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>) * s &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="F-Vlad-and-Avoiding-X"><a href="#F-Vlad-and-Avoiding-X" class="headerlink" title="F. Vlad and Avoiding X"></a>F. Vlad and Avoiding X</h1><h2 id="大致题意-5"><a href="#大致题意-5" class="headerlink" title="大致题意"></a>大致题意</h2><p>一个 $7 \times 7 的矩阵，开始的时候一些方格已经被染成黑色，要让中间不出现 X 形状的图案，问至少需要染白多少个方格$</p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>暴力就行了</p><h2 id="AC-code-5"><a href="#AC-code-5" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">data</span><span class="hljs-params">(<span class="hljs-number">7</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: data) i.<span class="hljs-built_in">resize</span>(<span class="hljs-number">7</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: data) cin &gt;&gt; i;<br>        <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">49</span>;<br>        function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> s) &#123;<br>            <span class="hljs-keyword">if</span> (s &gt;= ans) <span class="hljs-keyword">return</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">6</span>; ++i) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">6</span>; ++j)<br>                <span class="hljs-keyword">if</span> (data[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;B&#x27;</span> &amp;&amp; data[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;B&#x27;</span> &amp;&amp;<br>                    data[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;B&#x27;</span> &amp;&amp; data[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;B&#x27;</span> &amp;&amp; data[i][j] == <span class="hljs-string">&#x27;B&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;ar: arr) &#123;<br>                        data[i + ar[<span class="hljs-number">0</span>]][j + ar[<span class="hljs-number">1</span>]] = <span class="hljs-string">&#x27;W&#x27;</span>;<br>                        <span class="hljs-built_in">dfs</span>(s + <span class="hljs-number">1</span>);<br>                        data[i + ar[<span class="hljs-number">0</span>]][j + ar[<span class="hljs-number">1</span>]] = <span class="hljs-string">&#x27;B&#x27;</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            ans = <span class="hljs-built_in">min</span>(ans, s);<br>        &#125;;<br><br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="G-Vlad-and-Trouble-at-MIT"><a href="#G-Vlad-and-Trouble-at-MIT" class="headerlink" title="G. Vlad and Trouble at MIT"></a>G. Vlad and Trouble at MIT</h1><h2 id="大致题意-6"><a href="#大致题意-6" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一棵树，有些节点上的人要播放音乐，有一些节点上的人要睡觉，有一些则无所谓</p><p>现在需要创建一些墙使得放英语的人不会吵到睡觉的人，音乐会随着树的边传播，墙只能创建在边上，问最少需要多少个墙</p><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>树上搜索即可，如果当前节点是要播放音乐的，那么和它的所有要播放音乐或者无所谓的节点都可以连在一块，反之也一样。<br>但是如果是无所谓的人，那么就要看它的直接孩子节点中要播放音乐的多还是要睡觉的多了</p><h2 id="AC-code-6"><a href="#AC-code-6" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">g</span>(n);<br>        string str;<br>        str.<span class="hljs-built_in">resize</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            g[tmp - <span class="hljs-number">1</span>].<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>        cin &gt;&gt; str;<br><br>        <span class="hljs-type">int</span> ans = n - <span class="hljs-number">1</span>;<br>        function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> c) &#123;<br>            <span class="hljs-keyword">if</span> (g[c].<span class="hljs-built_in">empty</span>()) &#123;<br>                <span class="hljs-keyword">return</span> str[c] == <span class="hljs-string">&#x27;P&#x27;</span> ? <span class="hljs-number">1</span> : (str[c] == <span class="hljs-string">&#x27;C&#x27;</span> ? <span class="hljs-number">2</span> : <span class="hljs-number">0</span>);<br>            &#125;<br>            <span class="hljs-type">int</span> cnt[<span class="hljs-number">3</span>] = &#123;&#125;;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;n: g[c]) ++cnt[<span class="hljs-built_in">dfs</span>(n)];<br>            <span class="hljs-keyword">if</span> (str[c] == <span class="hljs-string">&#x27;P&#x27;</span>) &#123;<br>                ans -= cnt[<span class="hljs-number">1</span>] + cnt[<span class="hljs-number">2</span>];<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str[c] == <span class="hljs-string">&#x27;S&#x27;</span>) &#123;<br>                ans -= cnt[<span class="hljs-number">0</span>] + cnt[<span class="hljs-number">2</span>];<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (cnt[<span class="hljs-number">0</span>] &gt; cnt[<span class="hljs-number">1</span>]) &#123;<br>                    ans -= cnt[<span class="hljs-number">0</span>] + cnt[<span class="hljs-number">2</span>];<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cnt[<span class="hljs-number">1</span>] &gt; cnt[<span class="hljs-number">0</span>]) &#123;<br>                    ans -= cnt[<span class="hljs-number">1</span>] + cnt[<span class="hljs-number">2</span>];<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    ans -= cnt[<span class="hljs-number">0</span>] + cnt[<span class="hljs-number">2</span>];<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 927 (Div. 3)</title>
    <link href="/2024/04/14/acm/codeforces/CodeforcesRound927/"/>
    <url>/2024/04/14/acm/codeforces/CodeforcesRound927/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Thorns-and-Coins"><a href="#A-Thorns-and-Coins" class="headerlink" title="A. Thorns and Coins"></a>A. Thorns and Coins</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一条路，有些地方有陷阱，有些地方有金币，每次只能向前走一步或者跳到第二步，在不踩到陷阱的情况下，最多可以收集多少金币</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最早出现连续两个陷阱的地方就是结束，统计前面的金币数量即可</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        string str;<br>        str.<span class="hljs-built_in">resize</span>(n);<br>        cin &gt;&gt; str;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            cnt += str[i] == <span class="hljs-string">&#x27;@&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; str[i] == <span class="hljs-string">&#x27;*&#x27;</span> &amp;&amp; str[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;*&#x27;</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        cout &lt;&lt; cnt &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Chaya-Calendar"><a href="#B-Chaya-Calendar" class="headerlink" title="B. Chaya Calendar"></a>B. Chaya Calendar</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有 $n$ 个预兆，每个预兆都有出现的周期</p><p>且如果出现了第一个预兆后出现了第二个预兆，且在这个第二个预兆后又出现了第三个预兆，以此类推，当出现最后一个预兆的时候，就是末日，问末日是哪一天</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>不断找合法的倍数即可</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            <span class="hljs-type">int</span> c = (cur + tmp) / tmp;<br>            cur = c * tmp;<br>        &#125;<br>        cout &lt;&lt; cur &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-LR-remainders"><a href="#C-LR-remainders" class="headerlink" title="C. LR-remainders"></a>C. LR-remainders</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组，现在每次删除掉最左边和最右边的值，问此时剩余的所有值的乘积与 $m$ 的取模值，已知了删除顺序，问所有次的取模的值</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>反向操作即可</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n, m;<br>        cin &gt;&gt; n &gt;&gt; m;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: data) cin &gt;&gt; i;<br>        string str;<br>        str.<span class="hljs-built_in">resize</span>(n);<br>        cin &gt;&gt; str;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">order</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;L&#x27;</span>) order[i] = data[l++];<br>            <span class="hljs-keyword">else</span> order[i] = data[r--];<br>        &#125;<br><br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            cur = (cur * order[i]) % m;<br>            data[i] = cur;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cout &lt;&lt; data[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Card-Game"><a href="#D-Card-Game" class="headerlink" title="D. Card Game"></a>D. Card Game</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一副扑克牌，其中有一个花色是王牌，王牌的牌大于其他花色的牌，相同花色的牌，则数值越大越大</p><p>现在有 $2 \times n$ 张牌，问是否恰好存在 $n$ 对牌，使得每一对都是可以比较出大小的值</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>模拟即可，不是很难</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n, sp;<br>        <span class="hljs-type">char</span> s;<br>        cin &gt;&gt; n &gt;&gt; s;<br>        sp = (s == <span class="hljs-string">&#x27;C&#x27;</span> ? <span class="hljs-number">0</span> : (s == <span class="hljs-string">&#x27;D&#x27;</span> ? <span class="hljs-number">1</span> : (s == <span class="hljs-string">&#x27;H&#x27;</span> ? <span class="hljs-number">2</span> : <span class="hljs-number">3</span>)));<br>        vector&lt;<span class="hljs-type">int</span>&gt; data[<span class="hljs-number">4</span>];<br>        string str;<br>        str.<span class="hljs-built_in">resize</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n * <span class="hljs-number">2</span>; ++i) &#123;<br>            cin &gt;&gt; str;<br>            <span class="hljs-keyword">if</span> (str[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;C&#x27;</span>) data[<span class="hljs-number">0</span>].<span class="hljs-built_in">push_back</span>(str[<span class="hljs-number">0</span>]);<br>            <span class="hljs-keyword">if</span> (str[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;D&#x27;</span>) data[<span class="hljs-number">1</span>].<span class="hljs-built_in">push_back</span>(str[<span class="hljs-number">0</span>]);<br>            <span class="hljs-keyword">if</span> (str[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;H&#x27;</span>) data[<span class="hljs-number">2</span>].<span class="hljs-built_in">push_back</span>(str[<span class="hljs-number">0</span>]);<br>            <span class="hljs-keyword">if</span> (str[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;S&#x27;</span>) data[<span class="hljs-number">3</span>].<span class="hljs-built_in">push_back</span>(str[<span class="hljs-number">0</span>]);<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(data[<span class="hljs-number">0</span>].<span class="hljs-built_in">begin</span>(), data[<span class="hljs-number">0</span>].<span class="hljs-built_in">end</span>(), greater&lt;&gt;());<br>        <span class="hljs-built_in">sort</span>(data[<span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>(), data[<span class="hljs-number">1</span>].<span class="hljs-built_in">end</span>(), greater&lt;&gt;());<br>        <span class="hljs-built_in">sort</span>(data[<span class="hljs-number">2</span>].<span class="hljs-built_in">begin</span>(), data[<span class="hljs-number">2</span>].<span class="hljs-built_in">end</span>(), greater&lt;&gt;());<br>        <span class="hljs-built_in">sort</span>(data[<span class="hljs-number">3</span>].<span class="hljs-built_in">begin</span>(), data[<span class="hljs-number">3</span>].<span class="hljs-built_in">end</span>(), greater&lt;&gt;());<br>        vector&lt;pair&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt;, pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt;&gt;&gt; ans;<br>        ans.<span class="hljs-built_in">reserve</span>(n);<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i == sp) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = (<span class="hljs-type">int</span>)data[i].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">1</span>; j -= <span class="hljs-number">2</span>) ans.<span class="hljs-built_in">push_back</span>(&#123;&#123;i, data[i][j]&#125;, &#123;i, data[i][j - <span class="hljs-number">1</span>]&#125;&#125;);<br>            <span class="hljs-keyword">if</span> (data[i].<span class="hljs-built_in">size</span>() % <span class="hljs-number">2</span> &amp;&amp; !data[sp].<span class="hljs-built_in">empty</span>()) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(&#123;&#123;i, data[i][<span class="hljs-number">0</span>]&#125;, &#123;sp, data[sp].<span class="hljs-built_in">back</span>()&#125;&#125;);<br>                data[sp].<span class="hljs-built_in">pop_back</span>();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data[i].<span class="hljs-built_in">size</span>() % <span class="hljs-number">2</span>) flag = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = (<span class="hljs-type">int</span>)data[sp].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">1</span>; j -= <span class="hljs-number">2</span>) ans.<span class="hljs-built_in">push_back</span>(&#123;&#123;sp, data[sp][j]&#125;, &#123;sp, data[sp][j - <span class="hljs-number">1</span>]&#125;&#125;);<br><br>        <span class="hljs-keyword">if</span> (!flag) cout &lt;&lt; <span class="hljs-string">&quot;IMPOSSIBLE&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">auto</span> to_char = [](<span class="hljs-type">int</span> i) &#123;<br>                <span class="hljs-keyword">switch</span> (i) &#123;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;C&#x27;</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;D&#x27;</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;H&#x27;</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;S&#x27;</span>;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;A&#x27;</span>;<br>            &#125;;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;[a, b]: ans)<br>                cout &lt;&lt; a.second &lt;&lt; <span class="hljs-built_in">to_char</span>(a.first) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; b.second &lt;&lt; <span class="hljs-built_in">to_char</span>(b.first) &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="E-Final-Countdown"><a href="#E-Final-Countdown" class="headerlink" title="E. Final Countdown"></a>E. Final Countdown</h1><h2 id="大致题意-4"><a href="#大致题意-4" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个倒计时，但是它每次减少的时候，需要的耗时与改变的值的数量相同，比如 $10 \rightarrow 9$ 需要 $2$ 秒</p><p>问当前的倒计时值实际需要多少秒</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>类似不同的进制值，进制分别是 $1, 11, 111, 1111, 11111, 11111 \dots$</p><h2 id="AC-code-4"><a href="#AC-code-4" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        string str;<br>        str.<span class="hljs-built_in">resize</span>(n);<br>        cin &gt;&gt; str;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            ans[i + <span class="hljs-number">1</span>] = str[i] - <span class="hljs-string">&#x27;0&#x27;</span> + tmp;<br>            tmp += str[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>            ans[i - <span class="hljs-number">1</span>] += ans[i] / <span class="hljs-number">10</span>;<br>            ans[i] %= <span class="hljs-number">10</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!ans[start]) ++start;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt;= n; ++i) cout &lt;&lt; ans[i];<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="F-Feed-Cats"><a href="#F-Feed-Cats" class="headerlink" title="F. Feed Cats"></a>F. Feed Cats</h1><h2 id="大致题意-5"><a href="#大致题意-5" class="headerlink" title="大致题意"></a>大致题意</h2><p>有 $m$ 只猫，每只猫可以出现在 $[l_i, r_i]$ 的范围内，每只猫只允许吃一次食物，吃多了就会死。</p><p>问现在在不同的格子上放食物（每次放的食物量足够任意数量的猫吃），在保证不会出现吃死的情况下，最多可以喂饱多少只小猫</p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>其实就是取几个点，使得他们之间没有跨越相同的区间，同时总跨越的区间足够多</p><p>简单 dp 一下即可</p><h2 id="AC-code-5"><a href="#AC-code-5" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n, m;<br>        cin &gt;&gt; n &gt;&gt; m;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">data</span>(m), rdata;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[a, b]: data) cin &gt;&gt; a &gt;&gt; b;<br>        rdata = data;<br>        <span class="hljs-built_in">sort</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(rdata.<span class="hljs-built_in">begin</span>(), rdata.<span class="hljs-built_in">end</span>(), [&amp;](<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;rhs) &#123;<br>            <span class="hljs-keyword">return</span> lhs.second != rhs.second ? lhs.second &lt; rhs.second : lhs.first &lt; rhs.first;<br>        &#125;);<br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, greater&lt;&gt;&gt; q;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, res = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (l &lt; m &amp;&amp; data[l].first &lt;= i) &#123;<br>                q.<span class="hljs-built_in">push</span>(data[l++]);<br>                ++cnt;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (r &lt; m &amp;&amp; rdata[r].second &lt; i) &#123;<br>                ++r;<br>                cnt--;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; q.<span class="hljs-built_in">top</span>().second &lt; i) q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (q.<span class="hljs-built_in">empty</span>()) ans[i] = ans[i - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">else</span> ans[i] = ans[q.<span class="hljs-built_in">top</span>().first - <span class="hljs-number">1</span>] + cnt;<br>            ans[i] = <span class="hljs-built_in">max</span>(ans[i], ans[i - <span class="hljs-number">1</span>]);<br>            res = <span class="hljs-built_in">max</span>(res, ans[i]);<br>        &#125;<br>        cout &lt;&lt; res &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="G-Moving-Platforms"><a href="#G-Moving-Platforms" class="headerlink" title="G. Moving Platforms"></a>G. Moving Platforms</h1><h2 id="大致题意-6"><a href="#大致题意-6" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个图，其中每一个点都有一个权值 $l_i$，一个步长 $s_i$。<br>每个单位时间后，每个点的权值变成 $l_i \leftarrow (l_i + s_i) \space mod \space H$</p><p>如果两个点之间有边，且他们权值此时相同，则连通，否则边不可用，且走过一个边需要花费一个单位时间</p><p>问从第 1 个节点走到第 n 个节点需要多少时间</p><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>容易得到，实际上每一条边的可通行时间是一个 $ax + b$ 函数的值，其中 $x \in [0, \inf)$，如果能够求出所有边的函数，那么就很容易了</p><p>接下来是如何计算边的 $a, b$ 了</p><p>首先 $a$ 很容易，因为都是累加，所以需要满足 $s_i \times t - s_j \times t \equiv 0 (mod \space H)$</p><p>容易得到方程 $a \leftarrow \frac{lcm(s_i - s_j, H)}{s_i - s_j}$</p><p>接下来是如何算 $b$ 了，即第一次需要走多少步，他们才会相同</p><p>容易得到 $l_i + t_1 \times s_i \equiv l_j + t_1 \times s_j (mod \space H)$</p><p>变换可以得到 $t_1 \times (s_i - s_j) + t_2 \times H = l_j - l_i$</p><p>这很显然可以使用扩展欧几里得去做，求算出 $t_1$ 是多少，再通过计算得到 $b$ 即可</p><p>然后正常的图上求最短路径即可</p><h2 id="AC-code-6"><a href="#AC-code-6" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span> &amp;, <span class="hljs-type">int</span> &amp;)&gt; exGcd = [&amp;exGcd](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y) &#123;<br>            <span class="hljs-keyword">if</span> (!b) &#123;<br>                x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">return</span> a;<br>            &#125;<br>            <span class="hljs-type">int</span> ret = <span class="hljs-built_in">exGcd</span>(b, a % b, y, x);<br>            y -= a / b * x;<br>            <span class="hljs-keyword">return</span> ret;<br>        &#125;;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span> &#123; <span class="hljs-type">int</span> a, b, v, n; &#125;;<br><br>        <span class="hljs-type">int</span> n, m, H;<br>        cin &gt;&gt; n &gt;&gt; m &gt;&gt; H;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">l</span><span class="hljs-params">(n)</span>, <span class="hljs-title">s</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-function">vector&lt;edge&gt; <span class="hljs-title">edges</span><span class="hljs-params">(m * <span class="hljs-number">2</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">head</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: l) cin &gt;&gt; i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: s) cin &gt;&gt; i;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-type">int</span> u, v;<br>            cin &gt;&gt; u &gt;&gt; v;<br><br>            <span class="hljs-type">int</span> a = s[u - <span class="hljs-number">1</span>] - s[v - <span class="hljs-number">1</span>], b = H, x, y;<br>            <span class="hljs-type">int</span> g = <span class="hljs-built_in">exGcd</span>(a, b, x, y);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(l[v - <span class="hljs-number">1</span>] - l[u - <span class="hljs-number">1</span>]) % <span class="hljs-built_in">abs</span>(g)) <span class="hljs-keyword">continue</span>;<br><br>            a = <span class="hljs-built_in">abs</span>(b / g);<br>            b = (a - (((l[u - <span class="hljs-number">1</span>] - l[v - <span class="hljs-number">1</span>]) / g * x) % a + a) % a) % a;<br>            edges[i &lt;&lt; <span class="hljs-number">1</span>] = &#123;a, b, v, head[u]&#125;;<br>            edges[i &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] = &#123;a, b, u, head[v]&#125;;<br>            head[u] = i &lt;&lt; <span class="hljs-number">1</span>;<br>            head[v] = i &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>;<br>        &#125;<br><br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, greater&lt;&gt;&gt; q;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visit</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>        q.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> [cost, cur] = q.<span class="hljs-built_in">top</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (visit[cur]) <span class="hljs-keyword">continue</span>;<br>            visit[cur] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (cur == n) &#123;<br>                ans = cost;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e = head[cur]; ~e; e = edges[e].n) &#123;<br>                <span class="hljs-type">int</span> tmp = (cost - edges[e].b + edges[e].a - <span class="hljs-number">1</span>) / edges[e].a;<br>                <span class="hljs-type">int</span> nc = tmp * edges[e].a + edges[e].b;<br>                q.<span class="hljs-built_in">emplace</span>(nc + <span class="hljs-number">1</span>, edges[e].v);<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 926 (Div. 2)</title>
    <link href="/2024/04/12/acm/codeforces/CodeforcesRound926/"/>
    <url>/2024/04/12/acm/codeforces/CodeforcesRound926/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Sasha-and-the-Beautiful-Array"><a href="#A-Sasha-and-the-Beautiful-Array" class="headerlink" title="A. Sasha and the Beautiful Array"></a>A. Sasha and the Beautiful Array</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组，现在允许你任意排序它，使得其所有的相邻对之差之和最小，问如何操作</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>排序一下就行，这样就等于最大的那个值减去最小的那个</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: data) cin &gt;&gt; i;<br>        <span class="hljs-built_in">sort</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>());<br>        cout &lt;&lt; data.<span class="hljs-built_in">back</span>() - data.<span class="hljs-built_in">front</span>() &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Sasha-and-the-Drawing"><a href="#B-Sasha-and-the-Drawing" class="headerlink" title="B. Sasha and the Drawing"></a>B. Sasha and the Drawing</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个正方形，其上有 $4 \times n - 2$ 条对角线，现在要你染黑一些格子，使得这些对角线至少有 $x$ 个被覆盖，问最少染黑几个</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>只要染黑第一行和最下面一行即可，显然，除了四个角落，其他几个点染了就是影响两条对角线</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n, m;<br>        cin &gt;&gt; n &gt;&gt; m;<br>        <span class="hljs-keyword">if</span> (m &lt;= <span class="hljs-number">4</span> * n - <span class="hljs-number">4</span>) cout &lt;&lt; (m + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m == <span class="hljs-number">4</span> * n - <span class="hljs-number">3</span>) cout &lt;&lt; <span class="hljs-number">2</span> * n - <span class="hljs-number">1</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m == <span class="hljs-number">4</span> * n - <span class="hljs-number">2</span>) cout &lt;&lt; <span class="hljs-number">2</span> * n &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Sasha-and-the-Casino"><a href="#C-Sasha-and-the-Casino" class="headerlink" title="C. Sasha and the Casino"></a>C. Sasha and the Casino</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>在赌场赌博，已知每次可以下注任意合理的钱 $y$，赢了就收回 $k \times y$，输了就没了，且最多连续输 $x$ 场，问是否赚到任意数量的钱</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>根据赌徒原理做，要保证你每次下注的时候，如果赢了能把之前输的钱全都赚回来，且还要多赚一点</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> k, x, a;<br>        cin &gt;&gt; k &gt;&gt; x &gt;&gt; a;<br>        <span class="hljs-type">int</span> ca = a, lose = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; x; ++i) &#123;<br>            <span class="hljs-type">int</span> cur = (lose + k - <span class="hljs-number">1</span>) / (k - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (ca &lt; cur) &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            ca -= cur;<br>            lose += cur;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ca * k &lt;= a) flag = <span class="hljs-literal">false</span>;<br>        cout &lt;&lt; (flag ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Sasha-and-a-Walk-in-the-City"><a href="#D-Sasha-and-a-Walk-in-the-City" class="headerlink" title="D. Sasha and a Walk in the City"></a>D. Sasha and a Walk in the City</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一棵树，现在要选择一定数量的节点染色，使得任意两个节点之间的路径最多只经过两个染黑节点，问如何操作</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>树上 dp 即可，关注当前节点到所有下面的子节点中，染色数量最多的路径染色了多少个，可以枚举 1 个和 2 个的情况（0 个一定只有一种）</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">edges</span>((n - <span class="hljs-number">1</span>) * <span class="hljs-number">2</span>);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">head</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-type">int</span> u, v;<br>            cin &gt;&gt; u &gt;&gt; v;<br>            edges[i &lt;&lt; <span class="hljs-number">1</span>] = &#123;v, head[u]&#125;;<br>            edges[i &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] = &#123;u, head[v]&#125;;<br>            head[u] = i &lt;&lt; <span class="hljs-number">1</span>;<br>            head[v] = i &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>;<br>        &#125;<br><br>        function&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> p) &#123;<br>            <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e = head[u]; ~e; e = edges[e].second) &#123;<br>                <span class="hljs-keyword">if</span> (edges[e].first == p) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">auto</span> [na, nb] = <span class="hljs-built_in">dfs</span>(edges[e].first, u);<br>                a = (a * (<span class="hljs-number">1</span> + na)) % mod;<br>                b = (b + na + nb) % mod;<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(a, b);<br>        &#125;;<br><br>        <span class="hljs-keyword">auto</span> [a, b] = <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        cout &lt;&lt; (a + b + <span class="hljs-number">1</span>) % mod &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 925 (Div. 3)</title>
    <link href="/2024/04/06/acm/codeforces/CodeforcesRound925/"/>
    <url>/2024/04/06/acm/codeforces/CodeforcesRound925/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Recovering-a-Small-String"><a href="#A-Recovering-a-Small-String" class="headerlink" title="A. Recovering a Small String"></a>A. Recovering a Small String</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个字符串，长度固定为 $3$ 个字母，将其的每个字母对应的字母下标相加的值已知，问字典序最小的字符串是多少</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>简单题，从后往前考虑即可，后面的尽可能大就是前面尽可能小</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">str</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;<br>        str[<span class="hljs-number">2</span>] = <span class="hljs-built_in">min</span>(<span class="hljs-number">26</span>, n - <span class="hljs-number">2</span>);<br>        n -= str[<span class="hljs-number">2</span>];<br>        str[<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(<span class="hljs-number">26</span>, n - <span class="hljs-number">1</span>);<br>        n -= str[<span class="hljs-number">1</span>];<br>        str[<span class="hljs-number">0</span>] = n;<br>        cout &lt;&lt; (<span class="hljs-type">char</span>)(str[<span class="hljs-number">0</span>] + <span class="hljs-string">&#x27;a&#x27;</span> - <span class="hljs-number">1</span>) &lt;&lt; (<span class="hljs-type">char</span>)(str[<span class="hljs-number">1</span>] + <span class="hljs-string">&#x27;a&#x27;</span> - <span class="hljs-number">1</span>) &lt;&lt; (<span class="hljs-type">char</span>)(str[<span class="hljs-number">2</span>] + <span class="hljs-string">&#x27;a&#x27;</span> - <span class="hljs-number">1</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Make-Equal"><a href="#B-Make-Equal" class="headerlink" title="B. Make Equal"></a>B. Make Equal</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有 $n$ 个水壶，每次允许将前面的水壶里的一部分水倒入到后面的水壶，问是否可能使得所有水壶的水一样多</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>记录一个中间值，从前往后遍历，超过平均值就把超出部分加到中间值上，反之则减去，只要中间值不出现负数即可</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: data) cin &gt;&gt; i;<br>        <span class="hljs-type">int</span> tar = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;i: data) tar += i;<br>        tar /= n;<br>        <span class="hljs-type">int</span> last = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; i:data) &#123;<br>            last += i - tar;<br>            <span class="hljs-keyword">if</span> (last &lt; <span class="hljs-number">0</span>) flag = <span class="hljs-literal">false</span>;<br>        &#125;<br>        cout &lt;&lt; (flag ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;No&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Make-Equal-Again"><a href="#C-Make-Equal-Again" class="headerlink" title="C. Make Equal Again"></a>C. Make Equal Again</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一段数组，允许最多选择一段区间，把区间的数值变成一个任意值，问最少需要选择多少的区间才能让整个数组变成一样的值</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>看看最左边的值和最右边的值即可，如果一样就抓中间的，如果不一样就尝试一下都变成最左边的值或者最右边的值即可</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: data) cin &gt;&gt; i;<br>        <span class="hljs-comment">// left</span><br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r =  n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; n &amp;&amp; data[l] == data[<span class="hljs-number">0</span>]) ++l;<br>        <span class="hljs-keyword">while</span> (r &gt;= <span class="hljs-number">0</span> &amp;&amp; data[r] == data[n - <span class="hljs-number">1</span>]) -- r;<br>        <span class="hljs-keyword">if</span> (data[<span class="hljs-number">0</span>] == data[n - <span class="hljs-number">1</span>]) cout &lt;&lt; <span class="hljs-built_in">max</span>(r - l + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-built_in">min</span>(n - l, r + <span class="hljs-number">1</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Divisible-Pairs"><a href="#D-Divisible-Pairs" class="headerlink" title="D. Divisible Pairs"></a>D. Divisible Pairs</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>已知一个数组，找出满足如下条件的 $i, j$ 对，问有多少对</p><ul><li>$(a_i + a_j) \space mod \space x = 0$</li><li>$(a_i - a_j) \space mod \space y = 0$</li></ul><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>从取摸特点考虑，容易得出</p>$$a_i \space mod \space x + a_j \space mod \space x = x$$<p>且</p>$$a_i \space mod \space y = a_j \space mod \space y$$<p>所以只需要统计 $mod \space x$ 和 $mod \space y$ 的结果即可。我这里直接用了高位</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n, x, y;<br>        cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;<br>        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            <span class="hljs-type">int</span> a = tmp % x, b = tmp % y;<br>            <span class="hljs-keyword">auto</span> iter = cnt.<span class="hljs-built_in">find</span>(a &lt;&lt; <span class="hljs-number">32</span> | b);<br>            <span class="hljs-keyword">if</span> (iter != cnt.<span class="hljs-built_in">end</span>()) ans += iter-&gt;second;<br>            ++cnt[(a == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : (x - a)) &lt;&lt; <span class="hljs-number">32</span> | b];<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="E-Anna-and-the-Valentine’s-Day-Gift"><a href="#E-Anna-and-the-Valentine’s-Day-Gift" class="headerlink" title="E. Anna and the Valentine’s Day Gift"></a>E. Anna and the Valentine’s Day Gift</h1><h2 id="大致题意-4"><a href="#大致题意-4" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组，两个人博弈</p><ul><li>A 每次允许将数组中的一个值，在 10 进制上做翻转，并清除掉前导 0</li><li>B 每次允许将数组的两个值在十进制上直接拼接在一块</li></ul><p>问最终得到的唯一一个的数值和 $10^m$ 的大小关系是什么</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>一个是要通过翻转来删除后缀 0，能够有效的减少最终数值的长度，而另外一个可以拼接把后缀 0 隐藏在数值内部，所以只需要考虑所有的后缀 0 长度即可</p><h2 id="AC-code-4"><a href="#AC-code-4" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n, m;<br>        cin &gt;&gt; n &gt;&gt; m;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1000000000</span>, k = <span class="hljs-number">9</span>; j &gt;= <span class="hljs-number">1</span>; j /= <span class="hljs-number">10</span>, --k)<br>                <span class="hljs-keyword">if</span> (tmp % j == <span class="hljs-number">0</span>) &#123;<br>                    data[i] = k;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1000000000</span>, k = <span class="hljs-number">10</span>; j &gt;= <span class="hljs-number">1</span>; j /= <span class="hljs-number">10</span>, --k)<br>                <span class="hljs-keyword">if</span> (tmp &gt;= j) &#123;<br>                    tot += k;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>(), greater&lt;&gt;());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i += <span class="hljs-number">2</span>) tot -= data[i];<br>        cout &lt;&lt; (tot &gt; m ? <span class="hljs-string">&quot;Sasha&quot;</span> : <span class="hljs-string">&quot;Anna&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="F-Chat-Screenshots"><a href="#F-Chat-Screenshots" class="headerlink" title="F. Chat Screenshots"></a>F. Chat Screenshots</h1><h2 id="大致题意-5"><a href="#大致题意-5" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个未知的默认的初始的排列，现在给出 $k$ 个通过其演变来的数组，演变的方式是将原始数组中的某一个值提到最开头，其他值顺序不变</p><p>问这些数组是否来自同一个初始的排列</p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>放弃第一个值，直接拓扑即可，能拓扑就是成功</p><h2 id="AC-code-5"><a href="#AC-code-5" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">data</span>(k);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;v: data) &#123;<br>            v.<span class="hljs-built_in">resize</span>(n);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: v) cin &gt;&gt; i;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        vector&lt;set&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">map</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;v: data) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; ++i) map[v[i - <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>].<span class="hljs-built_in">insert</span>(v[i] - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">deg</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;v: map) <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;i: v) ++deg[i];<br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (!deg[i]) q.<span class="hljs-built_in">push</span>(i);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> cur = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            ++cnt;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; i: map[cur]) <span class="hljs-keyword">if</span> (!--deg[i]) q.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        cout &lt;&lt; (cnt == n ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="G-One-Dimensional-Puzzle"><a href="#G-One-Dimensional-Puzzle" class="headerlink" title="G. One-Dimensional Puzzle"></a>G. One-Dimensional Puzzle</h1><h2 id="大致题意-6"><a href="#大致题意-6" class="headerlink" title="大致题意"></a>大致题意</h2><p>有 4 种方块，现在需要把它们拼接在一行里，问有多少种排列方式</p><p><img src="/image/acm/codeforces/CodeforcesRound925/G.png" alt="G"></p><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>显然，当不存在 1 和 2 的时候，同时仅存在 3 和 4 的时候，那么</p><ul><li>如果只有 3 或者 4，那么只有一种排法</li><li>如果同时有 3 和 4，那么就没有排法</li></ul><p>接下来要考虑的肯定是 1 和 2 至少其中一个有的情况。</p><p>也容易发现，3 和 4 本质上并不会改变接口的形状，只是增长了一些现有的结构罢了，所以容易得出，3 / 4 在是否能够排列出这件事上，不重要</p><p>而 1 和 2 不一样，前者会减少一个凹形，后者会减少一个凸形，而一个 1 只会引入两个凸形，如果恰好，2 的数量比 1 多两个，那么必然会导致无法组成一行</p><p>同理，1 比 2 多两个也会导致组成不了形状。实际上也很容易得出，一定上组成 1/2/1/2/1/2 这样的依次排列形状（先不考虑 3/4）</p><p>所以如果 1 和 2 一样多，那么就可以得到 1/2/1/2 这样的组合，同时也可以得到 2/1/2/1 这样的组合。<br>如果恰好差一个，那么必然是 1/2/1/2/1 或者 2/1/2/1/2 其中之一，显然此时分成了两种情况考虑</p><p>接下来看 3/4 的情况，实际上 3/4 就是往 1/2 组成的结构里插入即可，于是问题就回到了在 $n$ 个和盒子中放 $m$ 个苹果的问题，注意可以空箱子</p><p>即答案就是 $\begin{pmatrix} n + m - 1 \\ m - 1 \end{pmatrix}$</p><h2 id="AC-code-6"><a href="#AC-code-6" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<br>        <span class="hljs-keyword">auto</span> qp = [&amp;](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> p) &#123;<br>            <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (p) &#123;<br>                <span class="hljs-keyword">if</span> (p &amp; <span class="hljs-number">1</span>) res = res * a % mod;<br>                a = a * a % mod;<br>                p &gt;&gt;= <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;;<br>        <span class="hljs-keyword">auto</span> inv = [&amp;](<span class="hljs-type">int</span> v) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">qp</span>(v, mod - <span class="hljs-number">2</span>); &#125;;<br>        <span class="hljs-keyword">auto</span> step = [&amp;](<span class="hljs-type">int</span> n) &#123;<br>            <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) res = res * i % mod;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;;<br>        <span class="hljs-keyword">auto</span> cal = [&amp;](<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m) &#123;<br>            <span class="hljs-type">int</span> a = <span class="hljs-built_in">step</span>(n + m <span class="hljs-number">-1</span>), b = <span class="hljs-built_in">step</span>(m - <span class="hljs-number">1</span>), c = <span class="hljs-built_in">step</span>(n);<br>            a = a * <span class="hljs-built_in">inv</span>(b) % mod;<br>            a = a * <span class="hljs-built_in">inv</span>(c) % mod;<br>            <span class="hljs-keyword">return</span> a;<br>        &#125;;<br><br>        <span class="hljs-type">int</span> c1, c2, c3, c4;<br>        cin &gt;&gt; c1 &gt;&gt; c2 &gt;&gt; c3 &gt;&gt; c4;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(c1 - c2) &gt; <span class="hljs-number">1</span> || (c1 == <span class="hljs-number">0</span> &amp;&amp; c2 == <span class="hljs-number">0</span> &amp;&amp; c3 != <span class="hljs-number">0</span> &amp;&amp; c4 != <span class="hljs-number">0</span>)) &#123;<br>            cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (c1 == <span class="hljs-number">0</span> &amp;&amp; c2 == <span class="hljs-number">0</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> tmp = <span class="hljs-built_in">max</span>(c1, c2);<br>        <span class="hljs-keyword">if</span> (c1 == c2) &#123;<br>            <span class="hljs-type">int</span> ans1 = <span class="hljs-number">1</span>, ans2 = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (c3 != <span class="hljs-number">0</span>) &#123;<br>                ans1 = ans1 * <span class="hljs-built_in">cal</span>(c3, tmp) % mod;<br>                ans2 = ans2 * <span class="hljs-built_in">cal</span>(c3, tmp + <span class="hljs-number">1</span>) % mod;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (c4 != <span class="hljs-number">0</span>) &#123;<br>                ans2 = ans2 * <span class="hljs-built_in">cal</span>(c4, tmp) % mod;<br>                ans1 = ans1 * <span class="hljs-built_in">cal</span>(c4, tmp + <span class="hljs-number">1</span>) % mod;<br>            &#125;<br>            ans = (ans1 + ans2) % mod;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (c3 != <span class="hljs-number">0</span>) ans = ans * <span class="hljs-built_in">cal</span>(c3, tmp) % mod;<br>            <span class="hljs-keyword">if</span> (c4 != <span class="hljs-number">0</span>) ans = ans * <span class="hljs-built_in">cal</span>(c4, tmp) % mod;<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 924 (Div. 2)</title>
    <link href="/2024/04/05/acm/codeforces/CodeforcesRound924/"/>
    <url>/2024/04/05/acm/codeforces/CodeforcesRound924/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Rectangle-Cutting"><a href="#A-Rectangle-Cutting" class="headerlink" title="A. Rectangle Cutting"></a>A. Rectangle Cutting</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个矩型，将其切割成两半，然后再拼接起来，问是否可能得到另外一个矩型</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>简单题，直接尝试一下就行了</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (a % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> ra = a / <span class="hljs-number">2</span>, rb = b * <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (ra != b || rb != a) flag = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (b % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> ra = a * <span class="hljs-number">2</span>, rb = b / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (ra != b || rb != a) flag = <span class="hljs-literal">true</span>;<br>        &#125;<br>        cout &lt;&lt; (flag ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;No&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Equalize"><a href="#B-Equalize" class="headerlink" title="B. Equalize"></a>B. Equalize</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>已知一个数组，现在将一个等长的排列加到这个数组上，问最多出现多少个相同的值</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>等价于在长度为 $n$ 的值范围内，原始数组有多少个不同的值</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) cin &gt;&gt; i;<br>        <span class="hljs-built_in">sort</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> end = (<span class="hljs-type">int</span>)(<span class="hljs-built_in">unique</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>()) - data.<span class="hljs-built_in">begin</span>());<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r = <span class="hljs-number">0</span>; r &lt; end; ++r) &#123;<br>            <span class="hljs-keyword">while</span> (data[r] - data[l] &gt;= n) ++l;<br>            ans = <span class="hljs-built_in">max</span>(ans, r - l + <span class="hljs-number">1</span>);<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Physical-Education-Lesson"><a href="#C-Physical-Education-Lesson" class="headerlink" title="C. Physical Education Lesson"></a>C. Physical Education Lesson</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组，其值类似一个波长为 $x$ 的波，从 $1 \rightarrow k \rightarrow 1$，现在只知道第 $n$ 的位置是 $x$，问有多种不同的波的可能</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> x, n, v[<span class="hljs-number">2</span>];<br>        cin &gt;&gt; x &gt;&gt; n;<br>        <span class="hljs-comment">// upside</span><br>        v[<span class="hljs-number">0</span>] = x - n;<br>        <span class="hljs-comment">// downside</span><br>        v[<span class="hljs-number">1</span>] = x + n - <span class="hljs-number">2</span>;<br>        set&lt;<span class="hljs-type">int</span>&gt; st;<br><br>        <span class="hljs-keyword">auto</span> add = [&amp;](<span class="hljs-type">int</span> x) &#123;<br>            <span class="hljs-keyword">if</span> (x % <span class="hljs-number">2</span> || x &lt; n * <span class="hljs-number">2</span> - <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br>            st.<span class="hljs-built_in">insert</span>(x);<br>        &#125;;<br>        <span class="hljs-keyword">auto</span> cal = [&amp;](<span class="hljs-type">int</span> x) &#123;<br>            <span class="hljs-type">int</span> r = <span class="hljs-built_in">min</span>((<span class="hljs-type">int</span>)<span class="hljs-built_in">sqrt</span>(x) + <span class="hljs-number">10</span>, x);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; r; ++i) <span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">add</span>(i);<br>                <span class="hljs-built_in">add</span>(x / i);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-built_in">cal</span>(v[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">cal</span>(v[<span class="hljs-number">1</span>]);<br><br>        cout &lt;&lt; st.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Lonely-Mountain-Dungeons"><a href="#D-Lonely-Mountain-Dungeons" class="headerlink" title="D. Lonely Mountain Dungeons"></a>D. Lonely Mountain Dungeons</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>有 $n$ 个不同的种族，每个种族有不同数量的士兵，现在需要将它们组成 $k$ 只军队，每个士兵必定属于某一个军队</p><p>每多创建一个军队，其就要减少 $x$ 的战斗力，而当同一个种族的两个士兵被分配到不同的队伍的情况下，则会增加 $b$ 单位的战斗力</p><p>问最大的战斗力可能是多少</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>三分一下队伍数量即可</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n, b, x;<br>        cin &gt;&gt; n &gt;&gt; b &gt;&gt; x;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">c</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: c) cin &gt;&gt; i;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><br>        <span class="hljs-keyword">auto</span> check = [&amp;](<span class="hljs-type">int</span> mid) &#123;<br>            <span class="hljs-type">int</span> res = -x * (mid - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;i: c) &#123;<br>                <span class="hljs-type">int</span> v = i / mid, c1 = i % mid, c2 = mid - c1;<br>                res += b * c1 * (v + <span class="hljs-number">1</span>) * (i - v - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>                res += b * c2 * v * (i - v) / <span class="hljs-number">2</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;;<br><br>        <span class="hljs-keyword">while</span> (l + <span class="hljs-number">10</span> &lt; r) &#123;<br>            <span class="hljs-type">int</span> ml = (<span class="hljs-number">2</span> * l + r) / <span class="hljs-number">3</span>, mr = (l + <span class="hljs-number">2</span> * r) / <span class="hljs-number">3</span>;<br>            <span class="hljs-type">int</span> rl = <span class="hljs-built_in">check</span>(ml), rr = <span class="hljs-built_in">check</span>(mr);<br>            <span class="hljs-keyword">if</span> (rl &lt; rr) l = ml;<br>            <span class="hljs-keyword">else</span> r = mr;<br>        &#125;<br><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt;= r; ++i)<br>            ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">check</span>(i));<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="E-Modular-Sequence"><a href="#E-Modular-Sequence" class="headerlink" title="E. Modular Sequence"></a>E. Modular Sequence</h1><h2 id="大致题意-4"><a href="#大致题意-4" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组，第一个值已经确定，其后的每一个值的，等于前一个值 $+ y$ 或者等于 $mod \space y$，且已知长度和总和，问是否存在这样的数组</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>容易得到，最终因为变化都和 $y$ 有关，所以 $x \space y$ 这部分的值，必然会被每一个单位所保留，即每一个值必定等价于 $t \times y + x \space mod \space y$</p><p>所以可以先 $s \leftarrow $，那么所有值就等于 $t \times y$</p><p>再统一除以 $y$ 可以得到 $s \leftarrow \frac{s - n \times (x \space mod \space y)}{y}$ 而数组则是几个递增的阶梯（$0, 1, 2, \dots$）组成</p><p>所以只需要求解阶梯的数量和每个阶梯的长度即可</p><p>容易得到一个简单的结论：最长的阶梯不超过 $650$，因为 $(1 + 650) \times 650 / 2 = 211575$，所以可以通过暴力的手段解决</p><p>定义 <code>dp[i]</code> 表示当前 $s$ 还剩下 $i$ 个值需要处理的时候，已经消耗了多少个位置，对于每一个 $i$，暴力遍历 $650$ 种可能性即可</p><h2 id="AC-code-4"><a href="#AC-code-4" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n, x, y, s;<br>        cin &gt;&gt; n &gt;&gt; x &gt;&gt; y &gt;&gt; s;<br><br>        <span class="hljs-keyword">if</span> ((s - n * (x % y)) % y || (x % y) * n &gt; s || x &gt; s) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> rs = (s - n * (x % y)) / y;<br>        <span class="hljs-type">int</span> st = x / y - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (x / y &gt; rs) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(rs + <span class="hljs-number">1</span>, &#123;<span class="hljs-number">0x3fffffff</span>, <span class="hljs-number">-1</span>&#125;);<br>        dp[rs] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = st + <span class="hljs-number">1</span>, tmp = <span class="hljs-number">0</span>; i &lt;= s; ++i) &#123;<br>            tmp += i;<br>            <span class="hljs-keyword">if</span> (tmp == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (rs - tmp &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>            dp[rs - tmp] = &#123;i, rs&#125;;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = rs - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; --i)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">623</span>; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (i - (<span class="hljs-number">1</span> + j) * j / <span class="hljs-number">2</span> &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">if</span> (dp[i - (<span class="hljs-number">1</span> + j) * j / <span class="hljs-number">2</span>].first &lt;= dp[i].first + j + <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>                dp[i - (<span class="hljs-number">1</span> + j) * j / <span class="hljs-number">2</span>] = &#123;dp[i].first + j + <span class="hljs-number">1</span>, i&#125;;<br>            &#125;<br>        <span class="hljs-keyword">if</span> (st + n &lt; dp[<span class="hljs-number">0</span>].first) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">while</span> (~cur) &#123;<br>            <span class="hljs-keyword">if</span> (dp[cur].second != <span class="hljs-number">-1</span>) res.<span class="hljs-built_in">push_back</span>(dp[cur].second - cur);<br>            cur = dp[cur].second;<br>            <span class="hljs-keyword">if</span> (res.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">100</span>) &#123;<br>                cerr &lt;&lt; <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; res.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-type">int</span> cost = <span class="hljs-number">0</span>, j = i == <span class="hljs-number">0</span> ? st + <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (cost &lt;= res[i]) &#123;<br>                cout &lt;&lt; j * y + x % y &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>                ++index;<br>                ++j;<br>                cost += j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (index &lt; n) &#123;<br>            cout &lt;&lt; x % y &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>            ++index;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 923 (Div. 3)</title>
    <link href="/2024/03/31/acm/codeforces/CodeforcesRound923/"/>
    <url>/2024/03/31/acm/codeforces/CodeforcesRound923/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Make-it-White"><a href="#A-Make-it-White" class="headerlink" title="A. Make it White"></a>A. Make it White</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一段黑白间隔的数组，允许选择其中的一段，将其涂成白色，问最小要多长</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>找到最左边和最右边黑色即可</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        string str;<br>        str.<span class="hljs-built_in">resize</span>(n);<br>        cin &gt;&gt; str;<br>        <span class="hljs-type">int</span> l = n, r = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;B&#x27;</span>) &#123;<br>            l = <span class="hljs-built_in">min</span>(l, i);<br>            r = <span class="hljs-built_in">max</span>(r, i);<br>        &#125;<br>        cout &lt;&lt; r - l + <span class="hljs-number">1</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Following-the-String"><a href="#B-Following-the-String" class="headerlink" title="B. Following the String"></a>B. Following the String</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>已知一个数组，其映射一个相同长度的字符串，其中每一个数值表示对应字符串里的这个位置上的字母，是整个字符串里第几次出现</p><p>给出一个合理的字符串</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>找就行了，对于每一个位置，找到一个合理的字母放上去就行了</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) cin &gt;&gt; i;<br>        <span class="hljs-type">int</span> cnt[<span class="hljs-number">26</span>] = &#123;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">26</span>; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (cnt[j] == data[i]) &#123;<br>                    cout &lt;&lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>&gt;(j + <span class="hljs-string">&#x27;a&#x27;</span>);<br>                    ++cnt[j];<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Choose-the-Different-Ones"><a href="#C-Choose-the-Different-Ones" class="headerlink" title="C. Choose the Different Ones!"></a>C. Choose the Different Ones!</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有两个数组，分别取出 $\frac{k}{2}$ 个数值，使得正好得到 $[1, k]$ 这几个数，问是否可能</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>找出 $[1, k]$ 中，仅存在一侧的数值，看看是不是有一次持有的这种值超过 $\frac{k}{2}$ 个即可</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n, m, k;<br>        cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">char</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(k + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            <span class="hljs-keyword">if</span> (tmp &lt;= k) data[tmp] |= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            <span class="hljs-keyword">if</span> (tmp &lt;= k) data[tmp] |= <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> cnt[<span class="hljs-number">2</span>] = &#123;&#125;;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; ++i) <span class="hljs-keyword">if</span> (data[i] == <span class="hljs-number">0</span>) flag = <span class="hljs-literal">false</span>; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data[i] &lt;= <span class="hljs-number">2</span>) ++cnt[data[i] - <span class="hljs-number">1</span>];<br>        cout &lt;&lt; (flag &amp;&amp; cnt[<span class="hljs-number">0</span>] &lt;= k / <span class="hljs-number">2</span> &amp;&amp; cnt[<span class="hljs-number">1</span>] &lt;= k / <span class="hljs-number">2</span> ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Find-the-Different-Ones"><a href="#D-Find-the-Different-Ones" class="headerlink" title="D. Find the Different Ones!"></a>D. Find the Different Ones!</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组，每次给出一个区间的询问，问区间内是否存在任何两个值不一样</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>只要记录所有值发生变化的下标即可，然后找一下区间内有没有下标，有的话取下标两边的值即可</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n, q;<br>        cin &gt;&gt; n;<br>        set&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-type">int</span> last = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span> &amp;&amp; tmp != last) st.<span class="hljs-built_in">insert</span>(i + <span class="hljs-number">1</span>);<br>            last = tmp;<br>        &#125;<br>        cin &gt;&gt; q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; ++i) &#123;<br>            <span class="hljs-type">int</span> l, r;<br>            cin &gt;&gt; l &gt;&gt; r;<br>            <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> iter = st.<span class="hljs-built_in">upper_bound</span>(l);<br>            <span class="hljs-keyword">if</span> (iter == st.<span class="hljs-built_in">end</span>() || *iter &gt; r) cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">else</span> cout &lt;&lt; *iter - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; *iter &lt;&lt; endl;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="E-Klever-Permutation"><a href="#E-Klever-Permutation" class="headerlink" title="E. Klever Permutation"></a>E. Klever Permutation</h1><h2 id="大致题意-4"><a href="#大致题意-4" class="headerlink" title="大致题意"></a>大致题意</h2><p>已知 $n, k$，需要给出一个 $n$ 的排列，使得任取两组相邻的 $k$ 个数值组成的和，差值不超过 1</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>从滑动窗口的视角看比较容易</p><p>把原始的有序排列拆成 $\left \lfloor \frac{n}{k} \right \rfloor$ 份，然后依次从每一份中取一个值，排列成一个数组即可</p><p>注意取的时候，奇数份内从大到小，而偶数份从小到大即可</p><h2 id="AC-code-4"><a href="#AC-code-4" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">data</span>(k);<br>        <span class="hljs-type">int</span> page = n / k, start = n % k;<br>        data[<span class="hljs-number">0</span>] = &#123;<span class="hljs-number">1</span>, page + (start != <span class="hljs-number">0</span>)&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; k; ++i) &#123;<br>            data[i] = &#123;data[i - <span class="hljs-number">1</span>].second + <span class="hljs-number">1</span>, data[i - <span class="hljs-number">1</span>].second + page&#125;;<br>            <span class="hljs-keyword">if</span> (i &lt; start) data[i].second++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) cout &lt;&lt; data[i % k].second-- &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>            <span class="hljs-keyword">else</span> cout &lt;&lt; data[i % k].first++ &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="F-Microcycle"><a href="#F-Microcycle" class="headerlink" title="F. Microcycle"></a>F. Microcycle</h1><h2 id="大致题意-5"><a href="#大致题意-5" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个无向图，找一个包含最小边权的环</p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>类似生成树，只不过反过来，从最大权重的边开始遍历，找到最后一个会触发环逻辑的边即可，然后再根据确认的边的两个点找环即可</p><p>用一下并查集即可</p><h2 id="AC-code-5"><a href="#AC-code-5" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n, m;<br>        cin &gt;&gt; n &gt;&gt; m;<br>        vector&lt;tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">data</span>(m);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[u, v, w]: data) cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br> <br>        <span class="hljs-built_in">sort</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;lhs, <span class="hljs-type">const</span> tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; rhs) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(lhs) &gt; <span class="hljs-built_in">get</span>&lt;<span class="hljs-number">2</span>&gt;(rhs);<br>        &#125;);<br> <br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fa</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n + <span class="hljs-number">1</span>; ++i) fa[i] = i;<br>        function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>)&gt; find = [&amp;](<span class="hljs-type">const</span> <span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> x == fa[x] ? x : fa[x] = <span class="hljs-built_in">find</span>(fa[x]); &#125;;<br>        <span class="hljs-keyword">auto</span> join = [&amp;](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;<br>            x = <span class="hljs-built_in">find</span>(x);<br>            y = <span class="hljs-built_in">find</span>(y);<br>            <span class="hljs-keyword">if</span> (x == y) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            fa[y] = x;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;;<br> <br>        tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; start;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">head</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)</span></span>;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; edges;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;[u, v, w]: data) &#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">join</span>(u, v)) start = &#123;u, v, w&#125;;<br>            <span class="hljs-keyword">else</span> &#123;<br>                edges.<span class="hljs-built_in">emplace_back</span>(u, head[v]);<br>                head[v] = (<span class="hljs-type">int</span>) edges.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>                edges.<span class="hljs-built_in">emplace_back</span>(v, head[u]);<br>                head[u] = (<span class="hljs-type">int</span>) edges.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br> <br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)</span></span>;<br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        <span class="hljs-keyword">auto</span> [l, r, w] = start;<br>        dis[l] = <span class="hljs-number">0</span>;<br>        q.<span class="hljs-built_in">push</span>(l);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> cur = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e = head[cur]; ~e; e = edges[e].second) &#123;<br>                <span class="hljs-keyword">if</span> (dis[edges[e].first] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<br>                dis[edges[e].first] = dis[cur] + <span class="hljs-number">1</span>;<br>                q.<span class="hljs-built_in">push</span>(edges[e].first);<br>            &#125;<br>        &#125;<br> <br>        cout &lt;&lt; w &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; dis[r] + <span class="hljs-number">1</span> &lt;&lt; endl;<br>        cout &lt;&lt; r;<br>        <span class="hljs-type">int</span> cur = r;<br>        <span class="hljs-keyword">while</span> (cur != l) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e = head[cur]; ~e; e = edges[e].second) &#123;<br>                <span class="hljs-keyword">if</span> (dis[edges[e].first] + <span class="hljs-number">1</span> == dis[cur]) &#123;<br>                    cur = edges[e].first;<br>                    cout &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; cur;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="G-Paint-Charges"><a href="#G-Paint-Charges" class="headerlink" title="G. Paint Charges"></a>G. Paint Charges</h1><h2 id="大致题意-6"><a href="#大致题意-6" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组，数组上，对于每一个值可以进行如下操作其中一个，或者不操作</p><ul><li>将当前值左侧的 $a_i$ 个值进行染色（包含自己）</li><li>将当前值右侧的 $a_i$ 个值进行染色（包含自己）</li></ul><p>问最少操作几次，可以使得整个数组都被染色</p><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>考虑 dp，定义 <code>dp[i][j]</code> 表示，当前是关注的是第 $i$ 个值，且此时染色到 $j$ 位置的时候，最小花费是多少</p><p>显然 $dp_{i,j} = dp_{i-1,j}$</p><p>同时，考虑向左和向右的填涂即可</p><p>此时可以发现，大部分样例都过了，除了一个特殊的 case：一个值先不管左边，先往右进行染色，然后由右边的值来补偿左边的。</p><p>这种 case 也可以融入进 dp 的逻辑</p><h2 id="AC-code-6"><a href="#AC-code-6" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) cin &gt;&gt; data[i];<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3fffffff</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; item: dp) item.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>, INF);<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-comment">// nothing</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n + <span class="hljs-number">1</span>; ++j) dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-comment">// go left</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-built_in">max</span>(i - data[i] + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>); j &lt;= i; ++j) dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j], dp[i - <span class="hljs-number">1</span>][<span class="hljs-built_in">max</span>(i - data[i], <span class="hljs-number">0</span>)] + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// go right</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt;= <span class="hljs-built_in">min</span>(i + data[i] - <span class="hljs-number">1</span>, n); ++j) dp[i][j] = <span class="hljs-built_in">min</span>(dp[i][j], dp[i - <span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// go left + another go right</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (i - data[i] + <span class="hljs-number">1</span> &gt;= j || j + data[j] - <span class="hljs-number">1</span> &lt;= i) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-built_in">max</span>(i - data[i], <span class="hljs-number">0</span>); k &lt;= <span class="hljs-built_in">min</span>(j + data[j] - <span class="hljs-number">1</span>, n); ++k)<br>                    dp[i][k] = <span class="hljs-built_in">min</span>(dp[i][k], dp[j - <span class="hljs-number">1</span>][<span class="hljs-built_in">max</span>(i - data[i], <span class="hljs-number">0</span>)] + <span class="hljs-number">2</span>);<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; dp[n][n] &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 922 (Div. 2)</title>
    <link href="/2024/03/24/acm/codeforces/CodeforcesRound922/"/>
    <url>/2024/03/24/acm/codeforces/CodeforcesRound922/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Brick-Wall"><a href="#A-Brick-Wall" class="headerlink" title="A. Brick Wall"></a>A. Brick Wall</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一堵砖墙，由砖块组成，每一个砖块都是 $1 \times k$ （$k$ 可以是任意值，每一块砖块的 $k$ 可以不一样）的方块，可以横放或者纵向放</p><p>问横放和纵放的最大差值是多少</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>那全都横放不就行了</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n, m;<br>        cin &gt;&gt; n &gt;&gt; m;<br>        cout &lt;&lt; n * (m / <span class="hljs-number">2</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Minimize-Inversions"><a href="#B-Minimize-Inversions" class="headerlink" title="B. Minimize Inversions"></a>B. Minimize Inversions</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有两个数组，每次允许操作选择两个下标，在两个数组中分别操作交换这两个下标的值</p><p>问让这两个数组的逆序对数量之和最小，应该如何操作</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>大胆猜测，把其中一个数组排序好就行了</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">data</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [fst, snd]: data) cin &gt;&gt; fst;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [fst, snd]: data) cin &gt;&gt; snd;<br>        <span class="hljs-built_in">sort</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cout &lt;&lt; data[i].first &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cout &lt;&lt; data[i].second &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-XOR-distance"><a href="#C-XOR-distance" class="headerlink" title="C. XOR-distance"></a>C. XOR-distance</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有两个数，现在希望找到一个 $x$，使得 $\left | (a \oplus x) - (b \oplus x)\right |$ 最小，且 $x \in [0, r]$</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>由于是异或运算，且最后取了绝对值，实际上对于每一个比特位而言，$x$ 取什么毫无意义。因为对于这个比特位而言，$x$ 取任意值，不同的则还是不同，相同的则还是相同</p><p>所以考虑的情况是，某个高的比特位发生了 $a \neq b$ 的情况，这个时候需要努力去构造另外一个值的下面的比特位，使得高位的这个差值带来的影响尽可能小</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> a, b, r;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; r;<br><br>        <span class="hljs-keyword">auto</span> f = [&amp;](<span class="hljs-type">const</span> <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> i) &#123;<br>            <span class="hljs-type">int</span> rs = r, res = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>                <span class="hljs-keyword">if</span> ((a &amp; <span class="hljs-number">1LL</span> &lt;&lt; i) == (b &amp; <span class="hljs-number">1LL</span> &lt;&lt; i)) res += <span class="hljs-number">1LL</span> &lt;&lt; i;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v &amp; <span class="hljs-number">1LL</span> &lt;&lt; i) &#123;<br>                    <span class="hljs-keyword">if</span> (rs &gt;= <span class="hljs-number">1LL</span> &lt;&lt; i) rs -= <span class="hljs-number">1LL</span> &lt;&lt; i;<br>                    <span class="hljs-keyword">else</span> res += <span class="hljs-number">2</span> * (<span class="hljs-number">1LL</span> &lt;&lt; i);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;;<br><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">63</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">if</span> ((a &amp; <span class="hljs-number">1LL</span> &lt;&lt; i) == (b &amp; <span class="hljs-number">1LL</span> &lt;&lt; i)) <span class="hljs-keyword">continue</span>;<br>            ans = <span class="hljs-number">1</span> + <span class="hljs-built_in">f</span>(a &amp; <span class="hljs-number">1LL</span> &lt;&lt; i ? a : b, i - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Blocking-Elements"><a href="#D-Blocking-Elements" class="headerlink" title="D. Blocking Elements"></a>D. Blocking Elements</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>从一个数组中，取出一部分值，将整个数组拆成 $n$ 份，将每一份内进行求和，同时取出的值也作为单独的一份进行求和，这些求和值中最大的就是这个数组的代价</p><p>问代价最小是多少</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>显然，可以二分，问题是如何检查二分的答案是否合法，这里设二分得到的答案是 $v$</p><p>可以通过 dp 的方式来计算，令 <code>dp[i]</code> 作为第 $i$ 个值被选中后，$[1, i]$ 中被选中的那些值的总代价</p><p>可以得到 $dp[i] = dp[j] + a[i]$，其中 $j \in [l, i), \sum_{x=l}^{i-1} a_x \leq v$</p><p>故搞个优先队列维护一下即可</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span>, <span class="hljs-title">dp</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) cin &gt;&gt; i;<br>        <span class="hljs-keyword">auto</span> check = [&amp;](<span class="hljs-type">const</span> <span class="hljs-type">int</span> v) &#123;<br>            priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, greater&lt;&gt;&gt; pq;<br>            pq.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);<br>            <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, tot = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                <span class="hljs-keyword">if</span> (pq.<span class="hljs-built_in">empty</span>()) dp[i] = data[i];<br>                <span class="hljs-keyword">else</span> dp[i] = pq.<span class="hljs-built_in">top</span>().first + data[i];<br>                tot += data[i];<br>                <span class="hljs-keyword">while</span> (tot &gt; v) &#123;<br>                    tot -= data[l];<br>                    ++l;<br>                &#125;<br>                pq.<span class="hljs-built_in">emplace</span>(dp[i], i);<br>                <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>() &amp;&amp; pq.<span class="hljs-built_in">top</span>().second + <span class="hljs-number">1</span> &lt; l) pq.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>()) &#123;<br>                <span class="hljs-keyword">if</span> (pq.<span class="hljs-built_in">top</span>().first &lt;= v) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                pq.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;;<br><br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">1e18</span>;<br>        <span class="hljs-keyword">while</span> (l + <span class="hljs-number">1</span> &lt; r) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-type">const</span> <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-built_in">check</span>(mid)) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid;<br>        &#125;<br>        cout &lt;&lt; r &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="E-ace5-and-Task-Order"><a href="#E-ace5-and-Task-Order" class="headerlink" title="E. ace5 and Task Order"></a>E. ace5 and Task Order</h1><h2 id="大致题意-4"><a href="#大致题意-4" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个未知的数组 $a$ 和一个未知的初始值 $x$</p><p>每次允许你询问一个 $i$，若</p><ul><li>$a_i &lt; x$，则返回 <code>&lt;</code>，且 $x \leftarrow x - 1$</li><li>$a_i &gt; x$，则返回 <code>&gt;</code>，且 $x \leftarrow x + 1$</li><li>$a_i = x$，则返回 <code>=</code></li></ul><p>要求求出原始数组</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>因为不断轮询同一个值，必然最后 $x$ 和它相同</p><p>这之后再询问别的值，可以得到它们的关系，同时再询问一次之前的那个值，就可以恢复回来</p><p>可以考虑类似快排的方式进行操作即可。注意可以考虑随机函数避免被数据恶心</p><h2 id="AC-code-4"><a href="#AC-code-4" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pos</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) pos[i] = i;<br><br>        <span class="hljs-keyword">auto</span> pre = [&amp;](<span class="hljs-type">const</span> <span class="hljs-type">int</span> i) &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span> &lt;&lt; i &lt;&lt; endl;<br>                cout.<span class="hljs-built_in">flush</span>();<br>                <span class="hljs-type">char</span> tmp;<br>                cin &gt;&gt; tmp;<br>                <span class="hljs-keyword">if</span> (tmp == <span class="hljs-string">&#x27;=&#x27;</span>) <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-keyword">auto</span> check = [&amp;](<span class="hljs-type">const</span> <span class="hljs-type">int</span> i, <span class="hljs-type">const</span> <span class="hljs-type">int</span> base) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span> &lt;&lt; i &lt;&lt; endl;<br>            cout.<span class="hljs-built_in">flush</span>();<br>            <span class="hljs-type">char</span> tmp, temp;<br>            cin &gt;&gt; tmp;<br>            cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span> &lt;&lt; base &lt;&lt; endl;<br>            cout.<span class="hljs-built_in">flush</span>();<br>            cin &gt;&gt; temp;<br>            <span class="hljs-keyword">return</span> tmp == <span class="hljs-string">&#x27;&lt;&#x27;</span>;<br>        &#125;;<br><br>        function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; qs = [&amp;](<span class="hljs-type">const</span> <span class="hljs-type">int</span> l, <span class="hljs-type">const</span> <span class="hljs-type">int</span> r) &#123;<br>            <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br>            <span class="hljs-built_in">swap</span>(pos[<span class="hljs-built_in">rand</span>() % (r - l) + l], pos[r]);<br>            <span class="hljs-built_in">pre</span>(pos[r]);<br>            <span class="hljs-type">int</span> c = l;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt; r; ++i) <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(pos[i], pos[r])) <span class="hljs-built_in">swap</span>(pos[c++], pos[i]);<br>            <span class="hljs-built_in">swap</span>(pos[c], pos[r]);<br>            <span class="hljs-built_in">qs</span>(l, c - <span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">qs</span>(c + <span class="hljs-number">1</span>, r);<br>        &#125;;<br>        <span class="hljs-built_in">qs</span>(<span class="hljs-number">1</span>, n);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) ans[pos[i]] = i;<br>        cout &lt;&lt; <span class="hljs-string">&quot;! &quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n];<br>        cout.<span class="hljs-built_in">flush</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 921 (Div. 2)</title>
    <link href="/2024/03/23/acm/codeforces/CodeforcesRound921/"/>
    <url>/2024/03/23/acm/codeforces/CodeforcesRound921/</url>
    
    <content type="html"><![CDATA[<h1 id="A-We-Got-Everything-Covered"><a href="#A-We-Got-Everything-Covered" class="headerlink" title="A. We Got Everything Covered!"></a>A. We Got Everything Covered!</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个字符串长度为 $n$，其最多包含 $k$ 种不同的字母，你需要给出一个序列，使得这个字符串一定是你给出的序列的子序列</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>就是要满足 $k$ 种字母，长度为 $n$ 下的所有可能的组合，即每一个位置都可能是 $k$ 个值</p><p>所以最简单的方式就是把 $k$ 个字母依次输出，重复 $n$ 次即可</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n, m;<br>        cin &gt;&gt; n &gt;&gt; m;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) cout &lt;&lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>&gt;(<span class="hljs-string">&#x27;a&#x27;</span> + j);<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-A-Balanced-Problemset"><a href="#B-A-Balanced-Problemset" class="headerlink" title="B. A Balanced Problemset?"></a>B. A Balanced Problemset?</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>把一个数值 $x$，拆成 $n$ 份，问它们的 <code>gcd</code> 最大可以是多少</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>因为 <code>gcd</code> 意味着所有值都有这个因子，那么它们加起来之后，也一定有这个因子。故这个值必定是最初的值的因子</p><p>所以找一个够分成 $n$ 份的即可，不需要均分</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n, m;<br>        cin &gt;&gt; n &gt;&gt; m;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> r = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-built_in">sqrt</span>(n)) + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-built_in">min</span>(r, n); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (n % i != <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (i &gt;= m) ans = <span class="hljs-built_in">max</span>(ans, n / i);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n / i &gt;= m) ans = <span class="hljs-built_in">max</span>(ans, i);<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Did-We-Get-Everything-Covered"><a href="#C-Did-We-Get-Everything-Covered" class="headerlink" title="C. Did We Get Everything Covered?"></a>C. Did We Get Everything Covered?</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>和 A 题刚好相反，找一个不满足的字符串，使得不是给出的字符串的子序列即可</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>考虑最差的情况，即每次都取从左到右最后出现的那个字母的值，即可尽可能的往后选取</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n, k, m;<br>        cin &gt;&gt; n &gt;&gt; k &gt;&gt; m;<br>        string str;<br>        str.<span class="hljs-built_in">resize</span>(m);<br>        cin &gt;&gt; str;<br>        set&lt;<span class="hljs-type">char</span>&gt; st;<br>        <span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>;<br>        vector&lt;<span class="hljs-type">char</span>&gt; ans;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; c: str) &#123;<br>            <span class="hljs-keyword">if</span> (c &lt; <span class="hljs-string">&#x27;a&#x27;</span> || c &gt;= <span class="hljs-string">&#x27;a&#x27;</span> + k) <span class="hljs-keyword">continue</span>;<br>            st.<span class="hljs-built_in">insert</span>(c);<br>            <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">size</span>() == k) &#123;<br>                st.<span class="hljs-built_in">clear</span>();<br>                ++tot;<br>                ans.<span class="hljs-built_in">push_back</span>(c);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (tot &gt;= n) cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) <span class="hljs-keyword">if</span> (!st.<span class="hljs-built_in">count</span>(i + <span class="hljs-string">&#x27;a&#x27;</span>)) c = i + <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (i &lt; ans.<span class="hljs-built_in">size</span>()) cout &lt;&lt; ans[i]; <span class="hljs-keyword">else</span> cout &lt;&lt; c;<br>            cout &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Good-Trip"><a href="#D-Good-Trip" class="headerlink" title="D. Good Trip"></a>D. Good Trip</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>有 $n$ 个人，其中有 $m$ 对朋友，每对朋友都有一个亲密度 $f_i$。</p><p>每次随机选择两个人，如果它们是朋友，则得到对应亲密度的积分，然后使得他们的亲密度 +1</p><p>选择 $k$ 次后，期望积分是多少</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>容易得到任何一种组合的选取的概率是 $\frac{2}{n \times (n-1)}$，故单次提供的共享应该是 $f_i \times \frac{2}{n \times (n-1)}$</p><p>而每次结束之后，被选中的朋友的积分会加一，而对于期望而言，相当于每一对朋友的积分都增加 $\frac{2}{n \times (n-1)}$</p><p>依次可以得到，最终每一对的共享就是 $f_i \times \frac{2}{n \times (n-1)} + (f_i + \frac{2}{n \times (n-1)}) \times \frac{2}{n \times (n-1)} + \dots + (f_i + (k - 1) \times \frac{2}{n \times (n-1)}) \times \frac{2}{n \times (n-1)}$</p><p>再化简一下，取一下逆元即可</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>        <span class="hljs-keyword">auto</span> qp = [&amp;](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> p) &#123;<br>            <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (p) &#123;<br>                <span class="hljs-keyword">if</span> (p &amp; <span class="hljs-number">1</span>) ans = ans * a % mod;<br>                a = a * a % mod;<br>                p &gt;&gt;= <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;;<br>        <span class="hljs-type">int</span> n, m, k;<br>        cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> i = <span class="hljs-built_in">qp</span>(n * (n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> % mod, mod - <span class="hljs-number">2</span>);<br>        vector&lt;tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">data</span>(m);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [l, r, v]: data) cin &gt;&gt; l &gt;&gt; r &gt;&gt; v;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> [_l, _r, v]: data) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-type">int</span> l = v * k % mod;<br>            <span class="hljs-type">const</span> <span class="hljs-type">int</span> r = i * ((k - <span class="hljs-number">1</span>) * k / <span class="hljs-number">2</span> % mod) % mod;<br>            <span class="hljs-type">const</span> <span class="hljs-type">int</span> t = (l + r) * i % mod;<br>            ans = (ans + t) % mod;<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Educational Codeforces Round 161 (Rated for Div. 2)</title>
    <link href="/2024/03/22/acm/codeforces/EducationalCodeforcesRound161/"/>
    <url>/2024/03/22/acm/codeforces/EducationalCodeforcesRound161/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Tricky-Template"><a href="#A-Tricky-Template" class="headerlink" title="A. Tricky Template"></a>A. Tricky Template</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>设定一种模式串，对于模式串中的每一个字符，如果是小写，则表示必须匹配这个小写字母，如果是大写，则表示必定不匹配对应的那个小写字母</p><p>再给出三个字符串，问是否存在一个模式串，恰好匹配前面两个字符串，同时不匹配第三个字符串</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>只要有一个位置的字母，前两个字符串和第三个字符串都不同即可，这样只要那个位置的模式串是大写的第三个字符串的字符即可</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        string a, b, c;<br>        a.<span class="hljs-built_in">resize</span>(n);<br>        b.<span class="hljs-built_in">resize</span>(n);<br>        c.<span class="hljs-built_in">resize</span>(n);<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (a[i] != c[i] &amp;&amp; b[i] != c[i]) flag = <span class="hljs-literal">true</span>;<br>        cout &lt;&lt; (flag ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Forming-Triangles"><a href="#B-Forming-Triangles" class="headerlink" title="B. Forming Triangles"></a>B. Forming Triangles</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有 n 条边，每条边的长度都是 $2^x$，问可以组成多少个使用了不同边的三角形</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>因为 $2^x$ 恰好满足一个特点：$2^{a} + 2^{b} &lt; 2^c$，当 $a &lt; b &lt; c$ 时，也就是容易得到，至少有两条边相同才有可能</p><p>所以只需要讨论一下两条边相同和三条边相同的情况即可，当然也可以一起讨论了</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            ++cnt[tmp];<br>        &#125;<br>        <span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> [fst, snd]: cnt) &#123;<br>            <span class="hljs-keyword">if</span> (snd == <span class="hljs-number">2</span>) ans += tot;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (snd &gt; <span class="hljs-number">2</span>) ans += tot * snd * (snd - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + snd * (snd - <span class="hljs-number">1</span>) * (snd - <span class="hljs-number">2</span>) / <span class="hljs-number">6</span>;<br>            tot += snd;<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Closest-Cities"><a href="#C-Closest-Cities" class="headerlink" title="C. Closest Cities"></a>C. Closest Cities</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一排城市，每个城市都有一个坐标，每个城市都可以前往其他的城市。而一个城市距离较近的那个城市的花费成本为 1，而前往其他城市的成本就是距离</p><p>计算任意两个城市之间的距离</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>因为移动移动是从左移动到右边，或者从右边移动到左边，路径只有一条，所以可以前后做两次前缀和解决</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span>, <span class="hljs-title">cl</span><span class="hljs-params">(n)</span>, <span class="hljs-title">cr</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) cin &gt;&gt; i;<br>        cl[<span class="hljs-number">0</span>] = cr[n - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span> || data[i - <span class="hljs-number">1</span>] - data[i - <span class="hljs-number">2</span>] &gt;= data[i] - data[i - <span class="hljs-number">1</span>]) cl[i] = cl[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> cl[i] = cl[i - <span class="hljs-number">1</span>] + data[i] - data[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">if</span> (i == n - <span class="hljs-number">2</span> || data[i + <span class="hljs-number">2</span>] - data[i + <span class="hljs-number">1</span>] &gt;= data[i + <span class="hljs-number">1</span>] - data[i]) cr[i] = cr[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> cr[i] = cr[i + <span class="hljs-number">1</span>] + data[i + <span class="hljs-number">1</span>] - data[i];<br>        &#125;<br>        <span class="hljs-type">int</span> m;<br>        cin &gt;&gt; m;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-type">int</span> u, v;<br>            cin &gt;&gt; u &gt;&gt; v;<br>            <span class="hljs-keyword">if</span> (u &lt;= v) cout &lt;&lt; cl[v - <span class="hljs-number">1</span>] - cl[u - <span class="hljs-number">1</span>] &lt;&lt; endl;<br>            <span class="hljs-keyword">else</span> cout &lt;&lt; cr[v - <span class="hljs-number">1</span>] - cr[u - <span class="hljs-number">1</span>] &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Berserk-Monsters"><a href="#D-Berserk-Monsters" class="headerlink" title="D. Berserk Monsters"></a>D. Berserk Monsters</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一排怪物，每一个怪物都有一定攻击力和防御力，当一个怪物一次性受到的攻击大于其防御力的时候，将会死亡</p><p>现在每个怪物将会同时攻击它相邻的两个怪物，经过 $n$ 轮次后，问每一轮死了多少怪物</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>首先是非常容易计算是否会死亡，即只要相邻两个怪物的攻击力高于其防御力即可，由于不是生命值，所以很容易统计</p><p>而每轮只有死亡怪物后，其相邻的怪物才会有可能死亡，所以只需要考虑每次发生变化的怪物附近即可，不需要考虑全部怪物</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span>, <span class="hljs-title">d</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: a) cin &gt;&gt; i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: d) cin &gt;&gt; i;<br>        map&lt;<span class="hljs-type">int</span>, pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; mp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) mp[i] = &#123;a[i], d[i]&#125;;<br>        <span class="hljs-keyword">auto</span> check = [&amp;](map&lt;<span class="hljs-type">int</span>, pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;::iterator&amp; cur) &#123;<br>            <span class="hljs-type">int</span> cost = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (cur != mp.<span class="hljs-built_in">begin</span>()) &#123;<br>                --cur;<br>                cost += cur-&gt;second.first;<br>                ++cur;<br>            &#125;<br>            ++cur;<br>            <span class="hljs-keyword">if</span> (cur != mp.<span class="hljs-built_in">end</span>()) cost += cur-&gt;second.first;<br>            --cur;<br><br>            <span class="hljs-keyword">return</span> cost &gt; cur-&gt;second.second;<br>        &#125;;<br><br>        set&lt;<span class="hljs-type">int</span>&gt; s[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = mp.<span class="hljs-built_in">begin</span>(); iter != mp.<span class="hljs-built_in">end</span>(); ++iter) <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(iter)) s[<span class="hljs-number">0</span>].<span class="hljs-built_in">insert</span>(iter-&gt;first);<br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>, nxt = <span class="hljs-number">1</span>, tot = <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector <span class="hljs-title">ans</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">while</span> (!s[cur].<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; c: s[cur]) &#123;<br>                ++ans[tot];<br>                mp.<span class="hljs-built_in">erase</span>(c);<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; c: s[cur]) &#123;<br>                <span class="hljs-keyword">auto</span> iter = mp.<span class="hljs-built_in">upper_bound</span>(c);<br>                <span class="hljs-keyword">if</span> (iter != mp.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(iter)) s[nxt].<span class="hljs-built_in">insert</span>(iter-&gt;first);<br>                <span class="hljs-keyword">if</span> (iter != mp.<span class="hljs-built_in">begin</span>()) &#123;<br>                    --iter;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(iter)) s[nxt].<span class="hljs-built_in">insert</span>(iter-&gt;first);<br>                &#125;<br>            &#125;<br>            s[cur].<span class="hljs-built_in">clear</span>();<br>            <span class="hljs-built_in">swap</span>(cur, nxt);<br>            ++tot;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="E-Increasing-Subsequences"><a href="#E-Increasing-Subsequences" class="headerlink" title="E. Increasing Subsequences"></a>E. Increasing Subsequences</h1><h2 id="大致题意-4"><a href="#大致题意-4" class="headerlink" title="大致题意"></a>大致题意</h2><p>请构造一个字符串，使其内部的递增子序列的数量恰好是 $n$ 个</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>容易得到，如果是简单的递增序列，其长度子序列数量的关系是</p><div class="table-container"><table><thead><tr><th style="text-align:center">len</th><th style="text-align:center">count</th><th style="text-align:center">addition</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">4</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">8</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">16</td><td style="text-align:center">8</td></tr></tbody></table></div><p>很明显与 $2^x$ 有关，如果已经存在一个从 1 开始的递增序列，往其后面添加一个数值 $x$，则可以带来 $2^{x-1}$ 个数量的增加</p><h2 id="AC-code-4"><a href="#AC-code-4" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        --n;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">62</span>;<br>        <span class="hljs-keyword">while</span> (n &lt; (<span class="hljs-number">1LL</span> &lt;&lt; cur) - <span class="hljs-number">1</span>) --cur;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cur; ++i) ans.<span class="hljs-built_in">push_back</span>(i);<br>        n -= (<span class="hljs-number">1LL</span> &lt;&lt; cur) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (n) &#123;<br>            <span class="hljs-keyword">while</span> (n &gt;= <span class="hljs-number">1LL</span> &lt;&lt; cur - <span class="hljs-number">1</span>) &#123;<br>                n -= <span class="hljs-number">1LL</span> &lt;&lt; cur - <span class="hljs-number">1</span>;<br>                ans.<span class="hljs-built_in">push_back</span>(cur);<br>            &#125;<br>            --cur;<br>        &#125;<br>        cout &lt;&lt; ans.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ans.<span class="hljs-built_in">size</span>(); ++i) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == ans.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 920 (Div. 3)</title>
    <link href="/2024/03/19/acm/codeforces/CodeforcesRound920/"/>
    <url>/2024/03/19/acm/codeforces/CodeforcesRound920/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Square"><a href="#A-Square" class="headerlink" title="A. Square"></a>A. Square</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>告诉你一个正方形的四个顶点的坐标，问正方形的面积</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>记录最大和最小的 x 和 y，很好计算</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> mi = <span class="hljs-number">1000</span>, ma = <span class="hljs-number">-1000</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i) &#123;<br>            <span class="hljs-type">int</span> u, v;<br>            cin &gt;&gt; u &gt;&gt; v;<br>            mi = <span class="hljs-built_in">min</span>(mi, v);<br>            ma = <span class="hljs-built_in">max</span>(ma, v);<br>        &#125;<br>        cout &lt;&lt; (ma - mi) * (ma - mi) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Arranging-Cats"><a href="#B-Arranging-Cats" class="headerlink" title="B. Arranging Cats"></a>B. Arranging Cats</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有两个 <code>01</code> 字符串，允许对第一个字符串进行如下操作</p><ul><li>将一个 1 变成 0</li><li>将一个 0 变成 1</li><li>将一个 1 和另外一个 0 交换一下位置</li></ul><p>问最多操作几次能让两个字符串相同</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>多用第三个方法即可，统计 1 的数量即可</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        string str1, str2;<br>        str1.<span class="hljs-built_in">resize</span>(n);<br>        str2.<span class="hljs-built_in">resize</span>(n);<br>        cin &gt;&gt; str1 &gt;&gt; str2;<br>        <span class="hljs-type">int</span> cnt[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = &#123;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (str1[i] == str2[i]) <span class="hljs-keyword">continue</span>;<br>            ++cnt[<span class="hljs-number">0</span>][str1[i] - <span class="hljs-string">&#x27;0&#x27;</span>];<br>            ++cnt[<span class="hljs-number">1</span>][str2[i] - <span class="hljs-string">&#x27;0&#x27;</span>];<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-built_in">max</span>(cnt[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], cnt[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Sending-Messages"><a href="#C-Sending-Messages" class="headerlink" title="C. Sending Messages"></a>C. Sending Messages</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个手机，待机每小时要消耗 $a$ 电量，而每次开机关机则需要消耗 $b$ 电量，最开始有 $f$ 电量</p><p>问在固定的 $n$ 个发送信息任务是否能够完成</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>计算两次相邻的信息之间，选择待机还是选择关机即可</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n, f, a, b;<br>        cin &gt;&gt; n &gt;&gt; f &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-type">int</span> last = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> cur;<br>            cin &gt;&gt; cur;<br>            f -= <span class="hljs-built_in">min</span>(b, a * (cur - last));<br>            last = cur;<br>        &#125;<br>        cout &lt;&lt; (f &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Very-Different-Array"><a href="#D-Very-Different-Array" class="headerlink" title="D. Very Different Array"></a>D. Very Different Array</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>有两个数组 $a, b$，允许从 $b$ 选择 $x$ 个值，组成和 $a$ 长度相同的字符串，使得和 $a$ 尽可能不一样</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>排序后，大的和小的匹配，小的和大的匹配，注意要同时开始匹配，选择两侧差值较大者</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n, m;<br>        cin &gt;&gt; n &gt;&gt; m;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span>, <span class="hljs-title">b</span><span class="hljs-params">(m)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: a) cin &gt;&gt; i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: b) cin &gt;&gt; i;<br>        <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (l + r &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(a[l] - b[m - l - <span class="hljs-number">1</span>]) &gt; <span class="hljs-built_in">abs</span>(a[n - r - <span class="hljs-number">1</span>] - b[r])) &#123;<br>                ans += <span class="hljs-built_in">abs</span>(a[l] - b[m - l - <span class="hljs-number">1</span>]);<br>                ++l;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans += <span class="hljs-built_in">abs</span>(a[n - r - <span class="hljs-number">1</span>] - b[r]);<br>                ++r;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="E-Eat-the-Chip"><a href="#E-Eat-the-Chip" class="headerlink" title="E. Eat the Chip"></a>E. Eat the Chip</h1><h2 id="大致题意-4"><a href="#大致题意-4" class="headerlink" title="大致题意"></a>大致题意</h2><p>有两个棋子在棋盘上，只允许向前、向左前、向右前移动，问是否可能发送吃的可能</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>每个棋子的可能到达的格子可以绘制出来，只需奥看最终的相遇那一行是否是有覆盖关系即可</p><h2 id="AC-code-4"><a href="#AC-code-4" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n, m, ax, ay, bx, by;<br>        cin &gt;&gt; n &gt;&gt; m &gt;&gt; ax &gt;&gt; ay &gt;&gt; bx &gt;&gt; by;<br>        <span class="hljs-keyword">if</span> (bx &lt;= ax) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Draw&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> al = ay, ar = ay, bl = by, br = by;<br>        <span class="hljs-type">const</span> <span class="hljs-type">bool</span> flag = (bx - ax) % <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (ax &lt; bx) &#123;<br>            al = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, al - <span class="hljs-number">1</span>);<br>            ar = <span class="hljs-built_in">min</span>(m, ar + <span class="hljs-number">1</span>);<br>            ++ax;<br>            <span class="hljs-keyword">if</span> (ax == bx) <span class="hljs-keyword">break</span>;<br>            bl = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, bl - <span class="hljs-number">1</span>);<br>            br = <span class="hljs-built_in">min</span>(m, br + <span class="hljs-number">1</span>);<br>            --bx;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (flag) cout &lt;&lt; (al &lt;= bl &amp;&amp; ar &gt;= br ? <span class="hljs-string">&quot;Alice&quot;</span> : <span class="hljs-string">&quot;Draw&quot;</span>) &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; (bl &lt;= al &amp;&amp; br &gt;= ar ? <span class="hljs-string">&quot;Bob&quot;</span> : <span class="hljs-string">&quot;Draw&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="F-Sum-of-Progression"><a href="#F-Sum-of-Progression" class="headerlink" title="F. Sum of Progression"></a>F. Sum of Progression</h1><h2 id="大致题意-5"><a href="#大致题意-5" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组，给出 $s, d, k$，计算 $\sum<em>{i=0}^{k} (i + 1) \times a\</em>{s+i \times d}$</p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>分两种情况做，如果 $k$ 比较大，那么可以暴力，如果比较小，那么就通过前缀和进行优化计算</p><p>而前缀和则需要考虑间隔 $[1, sqrt(n)]$ 的每一种情况 $x$</p><p>每一种情况下需要计算 $s_i = s_{i-x} + a_i$ 和 $s_i = s_{i-x} + t \times a_i$</p><h2 id="AC-code-5"><a href="#AC-code-5" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n, q;<br>        cin &gt;&gt; n &gt;&gt; q;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) cin &gt;&gt; i;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> cap = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-built_in">sqrt</span>(n)) + <span class="hljs-number">1</span>, n);<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">a</span>(cap), <span class="hljs-built_in">b</span>(cap);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cap; ++i) &#123;<br>            a[i].<span class="hljs-built_in">resize</span>(n, <span class="hljs-number">0</span>);<br>            b[i].<span class="hljs-built_in">resize</span>(n, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; ++j) a[i][j] = b[i][j] = data[j];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                a[i][j] = a[i][j - i - <span class="hljs-number">1</span>] + (j + i + <span class="hljs-number">1</span>) / (i + <span class="hljs-number">1</span>) * data[j];<br>                b[i][j] = b[i][j - i - <span class="hljs-number">1</span>] + data[j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; ++i) &#123;<br>            <span class="hljs-type">int</span> s, d, k;<br>            cin &gt;&gt; s &gt;&gt; d &gt;&gt; k;<br>            <span class="hljs-keyword">if</span> (d &lt;= cap) &#123;<br>                <span class="hljs-type">const</span> <span class="hljs-type">int</span> start = s - d, end = s + d * (k - <span class="hljs-number">1</span>), cp = (s - <span class="hljs-number">1</span>) / d;<br>                <span class="hljs-type">const</span> <span class="hljs-type">int</span> as = a[d - <span class="hljs-number">1</span>][end - <span class="hljs-number">1</span>] - (start &lt;= <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : a[d - <span class="hljs-number">1</span>][start - <span class="hljs-number">1</span>]), bs = cp * (b[d - <span class="hljs-number">1</span>][end - <span class="hljs-number">1</span>] - (start &lt;= <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : b[d - <span class="hljs-number">1</span>][start - <span class="hljs-number">1</span>]));<br>                cout &lt;&lt; as - bs &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; k; ++j)<br>                    ans += (j + <span class="hljs-number">1</span>) * data[s + j * d - <span class="hljs-number">1</span>];<br>                cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="G-Mischievous-Shooter"><a href="#G-Mischievous-Shooter" class="headerlink" title="G. Mischievous Shooter"></a>G. Mischievous Shooter</h1><h2 id="大致题意-6"><a href="#大致题意-6" class="headerlink" title="大致题意"></a>大致题意</h2><p>可以在一个图上绘制固定形状的一个三角形，问最多能覆盖多少个目标点</p><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>也是前缀和，用斜向的前缀和即可</p><p>至于四种方向，可以考虑翻转图，而不是翻转形状</p><h2 id="AC-code-6"><a href="#AC-code-6" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n, m, k;<br>        cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">map</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; s: map) &#123;<br>            s.<span class="hljs-built_in">resize</span>(m);<br>            cin &gt;&gt; s;<br>        &#125;<br> <br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">h</span>(n), <span class="hljs-built_in">v</span>(n), <span class="hljs-built_in">r</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: h) i.<span class="hljs-built_in">resize</span>(m, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: v) i.<span class="hljs-built_in">resize</span>(m, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: r) i.<span class="hljs-built_in">resize</span>(m, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">auto</span> cal = [&amp;](vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; &amp;mp) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                h[i][<span class="hljs-number">0</span>] = v[i][<span class="hljs-number">0</span>] = r[i][<span class="hljs-number">0</span>] = mp[i][<span class="hljs-number">0</span>];<br>                h[i][m - <span class="hljs-number">1</span>] = v[i][m - <span class="hljs-number">1</span>] = r[i][m - <span class="hljs-number">1</span>] = mp[i][m - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>                h[<span class="hljs-number">0</span>][j] = v[<span class="hljs-number">0</span>][j] = r[<span class="hljs-number">0</span>][j] = mp[<span class="hljs-number">0</span>][j];<br>                h[n - <span class="hljs-number">1</span>][j] = v[n - <span class="hljs-number">1</span>][j] = r[n - <span class="hljs-number">1</span>][j] = mp[n - <span class="hljs-number">1</span>][j];<br>            &#125;<br> <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; m; ++j) h[i][j] = h[i][j - <span class="hljs-number">1</span>] + mp[i][j];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) v[i][j] = v[i - <span class="hljs-number">1</span>][j] + mp[i][j];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m - <span class="hljs-number">2</span>; j &gt;= <span class="hljs-number">0</span>; --j) r[i][j] = r[i - <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>] + mp[i][j];<br> <br>            vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">ans</span>(n);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: ans) i.<span class="hljs-built_in">resize</span>(m, <span class="hljs-number">0</span>);<br>            <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br> <br>            <span class="hljs-comment">// tl</span><br>            ans[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-built_in">min</span>(k, n - <span class="hljs-number">1</span>); ++i) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-built_in">min</span>(k - i, m - <span class="hljs-number">1</span>); ++j) ans[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] += mp[i][j];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>) &#123;<br>                    ans[i][<span class="hljs-number">0</span>] = ans[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>                    ans[i][<span class="hljs-number">0</span>] -= h[i - <span class="hljs-number">1</span>][<span class="hljs-built_in">min</span>(k, m - <span class="hljs-number">1</span>)];<br>                    <span class="hljs-type">const</span> <span class="hljs-type">int</span> out = <span class="hljs-built_in">max</span>(i + k - n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>                    <span class="hljs-keyword">if</span> (out &gt;= m) <span class="hljs-keyword">continue</span>;<br>                    ans[i][<span class="hljs-number">0</span>] += r[i + k - out][out] - (k + <span class="hljs-number">1</span> &gt;= m ? <span class="hljs-number">0</span> : r[i - <span class="hljs-number">1</span>][k + <span class="hljs-number">1</span>]);<br>                &#125;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; m; ++j) &#123;<br>                    ans[i][j] = ans[i][j - <span class="hljs-number">1</span>];<br>                    ans[i][j] -= v[<span class="hljs-built_in">min</span>(i + k, n - <span class="hljs-number">1</span>)][j - <span class="hljs-number">1</span>] - (i == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : v[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);<br>                    <span class="hljs-keyword">if</span> (j + k &gt;= m + n - <span class="hljs-number">1</span> - i) <span class="hljs-keyword">continue</span>;<br>                    <span class="hljs-type">const</span> <span class="hljs-type">int</span> out = <span class="hljs-built_in">max</span>(i + k - n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>                    ans[i][j] += r[i + k - out][j + out] - (i == <span class="hljs-number">0</span> || j + k + <span class="hljs-number">1</span> &gt;= m ? <span class="hljs-number">0</span> : r[i - <span class="hljs-number">1</span>][j + k + <span class="hljs-number">1</span>]);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) res = <span class="hljs-built_in">max</span>(res, ans[i][j]);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ACM_LOCAL</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>                    <span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a = <span class="hljs-number">0</span>; i + a &lt; n &amp;&amp; a &lt;= k; ++a) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b = <span class="hljs-number">0</span>; b + a &lt;= k &amp;&amp; j + b &lt; m; ++b) tmp += mp[i + a][j + b];<br>                    <span class="hljs-keyword">if</span> (tmp != ans[i][j]) cerr &lt;&lt; <span class="hljs-string">&quot;tl: &quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; j &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; tmp &lt;&lt; <span class="hljs-string">&#x27;-&#x27;</span> &lt;&lt; ans[i][j] &lt;&lt; endl;<br>                &#125;<br>            &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>            <span class="hljs-keyword">return</span> res;<br>        &#125;;<br> <br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; mp;<br>        mp.<span class="hljs-built_in">resize</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: mp) i.<span class="hljs-built_in">resize</span>(m);<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br> <br>        <span class="hljs-comment">// 1</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) mp[i][j] = map[i][j] == <span class="hljs-string">&#x27;#&#x27;</span>;<br>        ans = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">cal</span>(mp), ans);<br> <br>        <span class="hljs-comment">// 2</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) mp[i][j] = map[i][m - j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;#&#x27;</span>;<br>        ans = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">cal</span>(mp), ans);<br> <br>        <span class="hljs-comment">// 3</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) mp[i][j] = map[n - i - <span class="hljs-number">1</span>][j] == <span class="hljs-string">&#x27;#&#x27;</span>;<br>        ans = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">cal</span>(mp), ans);<br> <br>        <span class="hljs-comment">// 4</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) mp[i][j] = map[n - i - <span class="hljs-number">1</span>][m - j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;#&#x27;</span>;<br>        ans = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">cal</span>(mp), ans);<br> <br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 919 (Div. 2)</title>
    <link href="/2024/03/15/acm/codeforces/CodeforcesRound919/"/>
    <url>/2024/03/15/acm/codeforces/CodeforcesRound919/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Satisfying-Constraints"><a href="#A-Satisfying-Constraints" class="headerlink" title="A. Satisfying Constraints"></a>A. Satisfying Constraints</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给出一堆条件，包括是否大于、小于且不等于某个值，问最终有几个值符合条件</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先记录最小的那个区间，然后再过滤掉不满足的，就行了</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = INT_MAX;<br>        set&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> o, x;<br>            cin &gt;&gt; o &gt;&gt; x;<br>            <span class="hljs-keyword">if</span> (o == <span class="hljs-number">1</span>) l = <span class="hljs-built_in">max</span>(l, x);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (o == <span class="hljs-number">2</span>) r = <span class="hljs-built_in">min</span>(r, x);<br>            <span class="hljs-keyword">else</span> s.<span class="hljs-built_in">insert</span>(x);<br>        &#125;<br>        <span class="hljs-type">int</span> cnt = r - l + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; v: s) <span class="hljs-keyword">if</span> (v &lt;= r &amp;&amp; v &gt;= l) --cnt;<br>        cout &lt;&lt; <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, cnt) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Summation-Game"><a href="#B-Summation-Game" class="headerlink" title="B. Summation Game"></a>B. Summation Game</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>两个人博弈，一个人先移除最多 $k$ 个值，另外一个人将会把最多 $x$ 个值变成负数，问最终所有值加起来最大是多少</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>显然，删除最大的最有利，所以枚举删除几个即可</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n, k, x;<br>        cin &gt;&gt; n &gt;&gt; k &gt;&gt; x;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) cin &gt;&gt; i;<br>        <span class="hljs-built_in">sort</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>(), greater&lt;&gt;());<br>        <span class="hljs-type">int</span> total = <span class="hljs-number">0</span>, fx = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            total += data[i];<br>            fx += i &lt; x ? data[i] : <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>, ma = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = x; l &lt; k; ++l, ++r) &#123;<br>            cur -= r &lt; n ? <span class="hljs-number">2</span> * data[r] : <span class="hljs-number">0</span>;<br>            cur += data[l];<br>            ma = <span class="hljs-built_in">max</span>(ma, cur);<br>        &#125;<br>        cout &lt;&lt; total - fx - fx + ma &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Partitioning-the-Array"><a href="#C-Partitioning-the-Array" class="headerlink" title="C. Partitioning the Array"></a>C. Partitioning the Array</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>一个数组，对于每个值再找一个特殊值取模，将其拆成 $n$ 等分，得到的每一个等分的数组相同，问有几种拆法</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>拆法必然是数组长度的因子，暴力枚举即可。因为一个树的因子一定不会很多</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a, <span class="hljs-type">const</span> <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> b == <span class="hljs-number">0</span> ? a : <span class="hljs-built_in">gcd</span>(b, a % b);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) cin &gt;&gt; i;<br>        <span class="hljs-keyword">auto</span> check = [&amp;](<span class="hljs-type">const</span> <span class="hljs-type">int</span> x) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-type">int</span> len = n / x;<br>            <span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; x; ++i)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len; ++j)<br>                    tmp = <span class="hljs-built_in">gcd</span>(<span class="hljs-built_in">abs</span>(data[i * len + j] - data[(i - <span class="hljs-number">1</span>) * len + j]), tmp);<br>            <span class="hljs-keyword">return</span> tmp != <span class="hljs-number">1</span>;<br>        &#125;;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i * i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (n % i) <span class="hljs-keyword">continue</span>;<br>            ans += <span class="hljs-built_in">check</span>(i);<br>            <span class="hljs-keyword">if</span> (i * i != n) ans += <span class="hljs-built_in">check</span>(n / i);<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Array-Repetition"><a href="#D-Array-Repetition" class="headerlink" title="D. Array Repetition"></a>D. Array Repetition</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>开始有一个空的数组，有两种操作：</p><ul><li>往数组最后加一个元素 $x$</li><li>把整个数组复制 $x$ 次</li></ul><p>问最终的数组中，第 $i$ 位是什么</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>最终的数值一定是第一个操作得到的，所以可以考虑不断递归逆向整个操作过程，看看目标位置最终是被哪一次加入元素带来的</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n, q;<br>        cin &gt;&gt; n &gt;&gt; q;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">data</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [fst, snd]: data) cin &gt;&gt; fst &gt;&gt; snd;<br>        map&lt;<span class="hljs-type">int</span>, list&lt;<span class="hljs-type">int</span>&gt;&gt; mp;<br>        <span class="hljs-type">int</span> maxK = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            mp[tmp].<span class="hljs-built_in">push_back</span>(i);<br>            maxK = <span class="hljs-built_in">max</span>(maxK, tmp);<br>        &#125;<br>        <span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (data[i].first == <span class="hljs-number">1</span>) ++tot;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> ((maxK + tot - <span class="hljs-number">1</span>) / tot &lt;= <span class="hljs-number">1</span> + data[i].second)<br>                    data[i].second = (maxK + tot - <span class="hljs-number">1</span>) / tot;<br>                tot *= <span class="hljs-number">1</span> + data[i].second;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (tot &gt;= maxK) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(q)</span></span>;<br>        <span class="hljs-keyword">for</span> (; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">if</span> (data[i].first == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> iter = mp.<span class="hljs-built_in">find</span>(tot); iter != mp.<span class="hljs-built_in">end</span>())<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; v: iter-&gt;second) ans[v] = data[i].second;<br>                mp.<span class="hljs-built_in">erase</span>(tot);<br>                --tot;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">const</span> <span class="hljs-type">int</span> len = tot / (<span class="hljs-number">1</span> + data[i].second);<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = mp.<span class="hljs-built_in">upper_bound</span>(len); iter != mp.<span class="hljs-built_in">end</span>(); ) &#123;<br>                    list&lt;<span class="hljs-type">int</span>&gt;&amp; l = mp[(iter-&gt;first - <span class="hljs-number">1</span>) % len + <span class="hljs-number">1</span>];<br>                    l.<span class="hljs-built_in">splice</span>(l.<span class="hljs-built_in">end</span>(), iter-&gt;second);<br>                    <span class="hljs-keyword">auto</span> nxtIter = iter;<br>                    ++nxtIter;<br>                    mp.<span class="hljs-built_in">erase</span>(iter);<br>                    iter = nxtIter;<br>                &#125;<br>                tot = len;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; ++i) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == q - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello 2024</title>
    <link href="/2024/03/10/acm/codeforces/Hello2024/"/>
    <url>/2024/03/10/acm/codeforces/Hello2024/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Wallet-Exchange"><a href="#A-Wallet-Exchange" class="headerlink" title="A. Wallet Exchange"></a>A. Wallet Exchange</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>Alice 和 Bob 博弈，有两个钱包，每次可以选择一个钱包取走一块钱，问谁会没有办法操作</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>求和对 2 取模就行了</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        cout &lt;&lt; ((a + b) % <span class="hljs-number">2</span> ? <span class="hljs-string">&quot;Alice&quot;</span> : <span class="hljs-string">&quot;Bob&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Plus-Minus-Split"><a href="#B-Plus-Minus-Split" class="headerlink" title="B. Plus-Minus Split"></a>B. Plus-Minus Split</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个 <code>-+</code> 组成的字符串，允许将其拆成任意数量段，将 <code>-</code> 视为 <code>-1</code> 然后将 <code>+</code> 视为 <code>1</code>，然后对每一段单独求和</p><p>再将每一段的和乘上其长度，得到段的成本，所有段的成本之和就是总成本，问让成本最低怎么办</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>易得，除了之和等于 <code>0</code> 的情况，其他情况都不要合成一个段，所以最终就是求和成 <code>0</code> 的段以外部分成本</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        string str;<br>        str.<span class="hljs-built_in">resize</span>(n);<br>        cin &gt;&gt; str;<br>        <span class="hljs-type">int</span> cnt[<span class="hljs-number">2</span>] = &#123;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; c: str) ++cnt[c == <span class="hljs-string">&#x27;+&#x27;</span>];<br>        cout &lt;&lt; <span class="hljs-built_in">abs</span>(cnt[<span class="hljs-number">0</span>] - cnt[<span class="hljs-number">1</span>]) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Grouping-Increases"><a href="#C-Grouping-Increases" class="headerlink" title="C. Grouping Increases"></a>C. Grouping Increases</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>将一个字符串拆成两个子序列，每个子序列内，每有一对相邻的正序对就算一个成本，问如何拆让拆成本最小</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>贪心模拟即可</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-type">int</span> data[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            <span class="hljs-keyword">if</span> (tmp &gt; data[<span class="hljs-number">0</span>] &amp;&amp; tmp &gt; data[<span class="hljs-number">1</span>]) &#123;<br>                data[data[<span class="hljs-number">0</span>] &gt; data[<span class="hljs-number">1</span>] ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>] = tmp;<br>                ++ans;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tmp &lt;= data[<span class="hljs-number">0</span>] &amp;&amp; tmp &lt;= data[<span class="hljs-number">1</span>])<br>                data[data[<span class="hljs-number">0</span>] &gt; data[<span class="hljs-number">1</span>] ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>] = tmp;<br>            <span class="hljs-keyword">else</span> data[data[<span class="hljs-number">0</span>] &gt; data[<span class="hljs-number">1</span>] ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>] = tmp;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-built_in">max</span>(ans - <span class="hljs-number">2</span>, <span class="hljs-number">0</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-01-Tree"><a href="#D-01-Tree" class="headerlink" title="D. 01 Tree"></a>D. 01 Tree</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个 01 字典树，已知每个叶子节点的值中 <code>1</code> 的数量，以及所有叶子节点的顺序</p><p>问是否存在这样的字典树</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>因为每个值必然有一个相邻的节点和它差 <code>1</code>（那个节点不一定是叶子节点）</p><p>所以可以从最大值开始，每次找它相邻的值上是否有一个恰好比它小 1 的值，那么可以删除这两个值，把他们的父节点的值加进去（恰好就是它们两个中的较小者）</p><p>注意相邻的两个相同相邻的值的时候，它们可以合并</p><p>整个过程有点类似哈夫曼编码的过程</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">index</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            mp.<span class="hljs-built_in">emplace</span>(i, tmp);<br>            index[tmp].<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t = n - <span class="hljs-number">1</span>; t &gt; <span class="hljs-number">0</span>; --t) &#123;<br>            <span class="hljs-keyword">auto</span>&amp; v = index[t];<br>            <span class="hljs-keyword">if</span> (v.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i: v) &#123;<br>                <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> iter = mp.<span class="hljs-built_in">find</span>(i);<br>                <span class="hljs-comment">// check near same</span><br>                <span class="hljs-keyword">auto</span> riter = iter;<br>                ++riter;<br>                <span class="hljs-keyword">if</span> (riter != mp.<span class="hljs-built_in">end</span>() &amp;&amp; riter-&gt;second == t) &#123;<br>                    mp.<span class="hljs-built_in">erase</span>(iter);<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-comment">// check near - 1</span><br>                <span class="hljs-keyword">if</span> (riter-&gt;second == t - <span class="hljs-number">1</span>) &#123;<br>                    mp.<span class="hljs-built_in">erase</span>(iter);<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> liter = iter; liter != mp.<span class="hljs-built_in">begin</span>()) &#123;<br>                    --liter;<br>                    <span class="hljs-keyword">if</span> (liter-&gt;second == t - <span class="hljs-number">1</span>) &#123;<br>                        mp.<span class="hljs-built_in">erase</span>(iter);<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; (mp.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span> &amp;&amp; mp.<span class="hljs-built_in">begin</span>()-&gt;second == <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Good Bye 2023</title>
    <link href="/2024/03/03/acm/codeforces/GoodBye2023/"/>
    <url>/2024/03/03/acm/codeforces/GoodBye2023/</url>
    
    <content type="html"><![CDATA[<h1 id="A-2023"><a href="#A-2023" class="headerlink" title="A. 2023"></a>A. 2023</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>已知一个数组，其每个值的乘积之和恰好是 2023，但是删除掉了 $k$ 个值后，得到数组 $b$，在已知 $b$ 的情况下反推原数组</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>反过来除一下即可</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            sum *= tmp;<br>            <span class="hljs-keyword">if</span> (sum &gt; <span class="hljs-number">2023</span>) &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                sum = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (flag &amp;&amp; <span class="hljs-number">2023</span> % sum == <span class="hljs-number">0</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span> &lt;&lt; <span class="hljs-number">2023</span> / sum;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; k; ++i) cout &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-number">1</span>;<br>            cout &lt;&lt; endl;<br>        &#125; <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Two-Divisors"><a href="#B-Two-Divisors" class="headerlink" title="B. Two Divisors"></a>B. Two Divisors</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个值 $x$，已知它的两个最大的因子，问 $x$</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>若 $gcd(a, b) == a$ 则为 $b <em> b / a$ 否则为 $a </em> b / gcd(a, b)$</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int unsigned long long</span><br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-type">const</span> <span class="hljs-type">int</span> c = __gcd(a, b); c != a) cout &lt;&lt; a * b / c &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; b / c * b &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Training-Before-the-Olympiad"><a href="#C-Training-Before-the-Olympiad" class="headerlink" title="C. Training Before the Olympiad"></a>C. Training Before the Olympiad</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有两个人玩游戏，每次可以选择一个数组中的两个值，移除它们两个并添加一个 $\left \lfloor \frac{a_i + a_j}{2} \right \rfloor  \times 2$</p><p>第一个操作的人希望让最后剩下的那个值最大，第二个操作的人希望最小，问依次操作的情况下，最终结果是多少</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>因为每次操作结束多出来的一定是偶数，所以要尽可能变成偶数</p><p>所以第一个人一定是尽力把两个奇数先合并了，第二个人一定是尽力选一个奇数一个偶数</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) cin &gt;&gt; i;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>, tot = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            cnt += data[i] % <span class="hljs-number">2</span>;<br>            tot += data[i];<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) cout &lt;&lt; tot &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>            <span class="hljs-keyword">else</span> cout &lt;&lt; tot - (cnt / <span class="hljs-number">3</span> + (cnt % <span class="hljs-number">3</span> == <span class="hljs-number">1</span>)) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Mathematical-Problem"><a href="#D-Mathematical-Problem" class="headerlink" title="D. Mathematical Problem"></a>D. Mathematical Problem</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>给出一个 $n$，希望找到 $n$ 个 $n$ 位的数值，它们都是某个值的幂次，且这 $n$ 个值都可以相互通过交换数值位置变换得到</p><p>给出一组解</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>因为当 $n = 11$ 的时候，能够凑成的数量已经超过 99 个，所以剩下的情况下只要在上面的情况下后面加 0 即可 </p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">data</span>(<span class="hljs-number">12</span>);<br>    data[<span class="hljs-number">1</span>] = &#123;<span class="hljs-number">9</span>&#125;;<br>    data[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">169</span>, <span class="hljs-number">196</span>, <span class="hljs-number">961</span>&#125;;<br>    data[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">16384</span>, <span class="hljs-number">31684</span>, <span class="hljs-number">36481</span>, <span class="hljs-number">38416</span>, <span class="hljs-number">43681</span>&#125;;<br>    data[<span class="hljs-number">7</span>] = &#123;<span class="hljs-number">1493284</span>, <span class="hljs-number">3214849</span>, <span class="hljs-number">3912484</span>, <span class="hljs-number">4239481</span>, <span class="hljs-number">4293184</span>, <span class="hljs-number">4932841</span>, <span class="hljs-number">9132484</span>&#125;;<br>    data[<span class="hljs-number">9</span>] = &#123;<span class="hljs-number">236759769</span>, <span class="hljs-number">297769536</span>, <span class="hljs-number">369677529</span>, <span class="hljs-number">526977936</span>, <span class="hljs-number">677925369</span>, <span class="hljs-number">769729536</span>, <span class="hljs-number">773562969</span>, <span class="hljs-number">796763529</span>, <span class="hljs-number">927567936</span>, <span class="hljs-number">956293776</span>, <span class="hljs-number">993762576</span>&#125;;<br>    data[<span class="hljs-number">11</span>] = &#123;<br>        <span class="hljs-number">10948273956</span>, <span class="hljs-number">12395704896</span>, <span class="hljs-number">12899053476</span>, <span class="hljs-number">13056947289</span>, <span class="hljs-number">13769849025</span>, <span class="hljs-number">14909875236</span>, <span class="hljs-number">15072963984</span>, <span class="hljs-number">15890367249</span>, <span class="hljs-number">16385792049</span>, <span class="hljs-number">16795382409</span>, <span class="hljs-number">17250983649</span>, <span class="hljs-number">17592308496</span>, <span class="hljs-number">17805432969</span>, <span class="hljs-number">17869540329</span>,<br>        <span class="hljs-number">18096437529</span>, <span class="hljs-number">18543902976</span>, <span class="hljs-number">19036548729</span>, <span class="hljs-number">19936875204</span>, <span class="hljs-number">23897140569</span>, <span class="hljs-number">24091385796</span>, <span class="hljs-number">24196735809</span>, <span class="hljs-number">24371580996</span>, <span class="hljs-number">27939456801</span>, <span class="hljs-number">28347109956</span>, <span class="hljs-number">29137465809</span>, <span class="hljs-number">29163075984</span>, <span class="hljs-number">30524981796</span>, <span class="hljs-number">30896147529</span>,<br>        <span class="hljs-number">30965792841</span>, <span class="hljs-number">31489567209</span>, <span class="hljs-number">31528974096</span>, <span class="hljs-number">31829057649</span>, <span class="hljs-number">31899746025</span>, <span class="hljs-number">31957640289</span>, <span class="hljs-number">34507892169</span>, <span class="hljs-number">34860997521</span>, <span class="hljs-number">37869549201</span>, <span class="hljs-number">37918604529</span>, <span class="hljs-number">38495617209</span>, <span class="hljs-number">39276501489</span>, <span class="hljs-number">39564790281</span>, <span class="hljs-number">39784690521</span>,<br>        <span class="hljs-number">40217895936</span>, <span class="hljs-number">42513078969</span>, <span class="hljs-number">42750938169</span>, <span class="hljs-number">43596187209</span>, <span class="hljs-number">43608715929</span>, <span class="hljs-number">45192807396</span>, <span class="hljs-number">47031295689</span>, <span class="hljs-number">48913072569</span>, <span class="hljs-number">48963510729</span>, <span class="hljs-number">49218753609</span>, <span class="hljs-number">49327965801</span>, <span class="hljs-number">49918730625</span>, <span class="hljs-number">49956273081</span>, <span class="hljs-number">50329781649</span>,<br>        <span class="hljs-number">50473912896</span>, <span class="hljs-number">50824997136</span>, <span class="hljs-number">51436879209</span>, <span class="hljs-number">52349897601</span>, <span class="hljs-number">54197236809</span>, <span class="hljs-number">58396172409</span>, <span class="hljs-number">58730129649</span>, <span class="hljs-number">59380429761</span>, <span class="hljs-number">59438927601</span>, <span class="hljs-number">59632174809</span>, <span class="hljs-number">62391547089</span>, <span class="hljs-number">63975102489</span>, <span class="hljs-number">65378910249</span>, <span class="hljs-number">68135094729</span>,<br>        <span class="hljs-number">69713425089</span>, <span class="hljs-number">70152938496</span>, <span class="hljs-number">71489390625</span>, <span class="hljs-number">71985963204</span>, <span class="hljs-number">72153480996</span>, <span class="hljs-number">72195390864</span>, <span class="hljs-number">72953469801</span>, <span class="hljs-number">74902931856</span>, <span class="hljs-number">75318960249</span>, <span class="hljs-number">76921358409</span>, <span class="hljs-number">78031952964</span>, <span class="hljs-number">79495238601</span>, <span class="hljs-number">79542613089</span>, <span class="hljs-number">79910243856</span>,<br>        <span class="hljs-number">80319527649</span>, <span class="hljs-number">80356941729</span>, <span class="hljs-number">84701953296</span>, <span class="hljs-number">84703699521</span>, <span class="hljs-number">84992073156</span>, <span class="hljs-number">85970931264</span>, <span class="hljs-number">86293175049</span>, <span class="hljs-number">86939471025</span>, <span class="hljs-number">87965034921</span>, <span class="hljs-number">90127845369</span>, <span class="hljs-number">90163874529</span>, <span class="hljs-number">90248571396</span>, <span class="hljs-number">90372985641</span>, <span class="hljs-number">91302478569</span>,<br>        <span class="hljs-number">91534687209</span>, <span class="hljs-number">91625473809</span>, <span class="hljs-number">91987250436</span>, <span class="hljs-number">92305984761</span>, <span class="hljs-number">92504789316</span>, <span class="hljs-number">94829507136</span>, <span class="hljs-number">94971830625</span>, <span class="hljs-number">95971083264</span>, <span class="hljs-number">96438197025</span>, <span class="hljs-number">98015329476</span>, <span class="hljs-number">99270365184</span>, <span class="hljs-number">99764381025</span>, <span class="hljs-number">99853472016</span><br>    &#125;;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">11</span>) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cout &lt;&lt; data[n][i] &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            cout &lt;&lt; data[<span class="hljs-number">11</span>][i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">11</span>; j &lt; n; ++j) cout &lt;&lt; <span class="hljs-string">&#x27;0&#x27;</span>;<br>            cout &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 918 (Div. 4)</title>
    <link href="/2024/03/03/acm/codeforces/CodeforcesRound918/"/>
    <url>/2024/03/03/acm/codeforces/CodeforcesRound918/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Odd-One-Out"><a href="#A-Odd-One-Out" class="headerlink" title="A. Odd One Out"></a>A. Odd One Out</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>找出三个值中不同的那个</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>把三个值异或一下就行了</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        cout &lt;&lt; (a ^ b ^ c) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Not-Quite-Latin-Square"><a href="#B-Not-Quite-Latin-Square" class="headerlink" title="B. Not Quite Latin Square"></a>B. Not Quite Latin Square</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个矩阵，每一行每一列由 ABC 组成，问缺少的那个是什么</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>直接统计所有 ABC 数量，少的那个就是</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        string str;<br>        <span class="hljs-type">int</span> cnt[<span class="hljs-number">3</span>] = &#123;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) &#123;<br>            cin &gt;&gt; str;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; c: str)<br>                <span class="hljs-keyword">if</span> (c != <span class="hljs-string">&#x27;?&#x27;</span>) ++cnt[c - <span class="hljs-string">&#x27;A&#x27;</span>];<br>        &#125;<br>        cout &lt;&lt; (cnt[<span class="hljs-number">0</span>] == <span class="hljs-number">2</span> ? <span class="hljs-string">&#x27;A&#x27;</span> : (cnt[<span class="hljs-number">1</span>] == <span class="hljs-number">2</span> ? <span class="hljs-string">&#x27;B&#x27;</span> : <span class="hljs-string">&#x27;C&#x27;</span>)) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Can-I-Square"><a href="#C-Can-I-Square" class="headerlink" title="C. Can I Square?"></a>C. Can I Square?</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一个数组，问所有值加起来是否是一个平方数</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>二分一下就行了</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            sum += tmp;<br>        &#125;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">1e9</span> + <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">while</span> (l + <span class="hljs-number">1</span> &lt; r) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-type">const</span> <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>; mid * mid &lt;= sum) l = mid;<br>            <span class="hljs-keyword">else</span> r = mid;<br>        &#125;<br>        cout &lt;&lt; (l * l == sum ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Unnatural-Language-Processing"><a href="#D-Unnatural-Language-Processing" class="headerlink" title="D. Unnatural Language Processing"></a>D. Unnatural Language Processing</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>已知一段话仅有 <code>abcde</code> 组成，且组成的每个单词都是“辅音+元音”或者“辅音+元音+辅音”的格式，要求分割一下字符串</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>把所有元音前面那个作为开头就行了</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        string str;<br>        str.<span class="hljs-built_in">reserve</span>(n);<br>        cin &gt;&gt; str;<br>        cout &lt;&lt; str[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; n &amp;&amp; (str[i + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;a&#x27;</span> || str[i + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;e&#x27;</span>)) cout &lt;&lt; <span class="hljs-string">&#x27;.&#x27;</span>;<br>            cout &lt;&lt; str[i];<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="E-Romantic-Glasses"><a href="#E-Romantic-Glasses" class="headerlink" title="E. Romantic Glasses"></a>E. Romantic Glasses</h1><h2 id="大致题意-4"><a href="#大致题意-4" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个原始数组，选取它的一段区间，这段区间内的偶数位和奇数位各自相加恰好相等，问是否存在</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>把原始数组的奇数位置和偶数位置各自累加，做前缀和，然后再求差值，找是否存在差值相同的情况</p><h2 id="AC-code-4"><a href="#AC-code-4" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) cin &gt;&gt; i;<br>        <span class="hljs-type">int</span> pre[<span class="hljs-number">2</span>] = &#123;&#125;;<br>        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br>        ++mp[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            pre[i % <span class="hljs-number">2</span>] += data[i];<br>            ++mp[pre[<span class="hljs-number">1</span>] - pre[<span class="hljs-number">0</span>]];<br>        &#125;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [fst, snd]: mp) <span class="hljs-keyword">if</span> (snd &gt;= <span class="hljs-number">2</span>) flag = <span class="hljs-literal">true</span>;<br>        cout &lt;&lt; (flag ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="F-Greetings"><a href="#F-Greetings" class="headerlink" title="F. Greetings"></a>F. Greetings</h1><h2 id="大致题意-5"><a href="#大致题意-5" class="headerlink" title="大致题意"></a>大致题意</h2><p>每个人都从 $a_i$ 走到 $b_i$ 问是否会发生几次相撞</p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>对着 $a$ 排序后，对 $b$ 求逆序对即可</p><h2 id="AC-code-5"><a href="#AC-code-5" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">data</span>(n);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [fst, snd]: data) cin &gt;&gt; fst &gt;&gt; snd;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) b[i] = data[i].second;<br>        <span class="hljs-built_in">sort</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>());<br><br>        function&lt;ll(vector&lt;<span class="hljs-type">int</span>&gt;&amp;, vector&lt;<span class="hljs-type">int</span>&gt;&amp;, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; mergeSort = [&amp;](vector&lt;<span class="hljs-type">int</span>&gt;&amp; record, vector&lt;<span class="hljs-type">int</span>&gt;&amp; tmp, <span class="hljs-type">const</span> <span class="hljs-type">int</span> l, <span class="hljs-type">const</span> <span class="hljs-type">int</span> r) &#123;<br>            <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-number">0ll</span>;<br>            <span class="hljs-type">const</span> <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>            ll inv_count = <span class="hljs-built_in">mergeSort</span>(record, tmp, l, mid) + <span class="hljs-built_in">mergeSort</span>(record, tmp, mid + <span class="hljs-number">1</span>, r);<br>            <span class="hljs-type">int</span> i = l, j = mid + <span class="hljs-number">1</span>, poss = l;<br>            <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>                <span class="hljs-keyword">if</span> (record[i] &lt;= record[j]) &#123;<br>                    tmp[poss] = record[i];<br>                    ++i;<br>                    inv_count += j - (mid + <span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    tmp[poss] = record[j];<br>                    ++j;<br>                &#125;<br>                ++poss;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ind = i; ind &lt;= mid; ++ind) &#123;<br>                tmp[poss++] = record[ind];<br>                inv_count += j - (mid + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ind = j; ind &lt;= r; ++ind) &#123;<br>                tmp[poss++] = record[ind];<br>            &#125;<br>            <span class="hljs-built_in">copy</span>(tmp.<span class="hljs-built_in">begin</span>() + l, tmp.<span class="hljs-built_in">begin</span>() + r + <span class="hljs-number">1</span>, record.<span class="hljs-built_in">begin</span>() + l);<br>            <span class="hljs-keyword">return</span> inv_count;<br>        &#125;;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">record</span><span class="hljs-params">(n)</span>, <span class="hljs-title">tmp</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) record[i] = data[i].second;<br>        cout &lt;&lt; <span class="hljs-built_in">mergeSort</span>(record, tmp, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="G-Bicycles"><a href="#G-Bicycles" class="headerlink" title="G. Bicycles"></a>G. Bicycles</h1><h2 id="大致题意-6"><a href="#大致题意-6" class="headerlink" title="大致题意"></a>大致题意</h2><p>每个城市都有不同速度的车，从 1 号城市出发，问走到 n 号城市需要多久</p><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>计算到达每一个城市，且用 $i$ 辆车的情况下，最小费用是多少，然后在图上不断 bfs 即可</p><h2 id="AC-code-6"><a href="#AC-code-6" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-comment">// bool flag = false;</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n, m;<br>        cin &gt;&gt; n &gt;&gt; m;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">head</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)</span>, <span class="hljs-title">s</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        vector&lt;tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">edges</span>(m * <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-type">int</span> u, v, w;<br>            cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br>            edges[i &lt;&lt; <span class="hljs-number">1</span>] = &#123;u, w, head[v]&#125;;<br>            edges[i &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] = &#123;v, w, head[u]&#125;;<br>            head[v] = i &lt;&lt; <span class="hljs-number">1</span>;<br>            head[u] = i &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) cin &gt;&gt; s[i];<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">last</span>(n + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: last) i.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>, LONG_LONG_MAX);<br>        last[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> c = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> e = head[c];<br>            <span class="hljs-keyword">while</span> (~e) &#123;<br>                <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [to, w, next] = edges[e];<br>                e = next;<br>                <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>                    <span class="hljs-keyword">if</span> (last[c][i] == LONG_LONG_MAX) <span class="hljs-keyword">continue</span>;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-type">const</span> <span class="hljs-type">int</span> nc = last[c][i] + w * s[i]; last[to][i] &gt; nc) &#123;<br>                        flag = <span class="hljs-literal">true</span>;<br>                        last[to][i] = nc;<br>                        last[to][to] = <span class="hljs-built_in">min</span>(last[to][to], last[to][i]);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (flag) q.<span class="hljs-built_in">push</span>(to);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> ans = LONG_LONG_MAX;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) ans = <span class="hljs-built_in">min</span>(ans, last[n][i]);<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人备份的常用 macOS 清理命令</title>
    <link href="/2024/03/01/mac/clean-my-mac/"/>
    <url>/2024/03/01/mac/clean-my-mac/</url>
    
    <content type="html"><![CDATA[<h1 id="清理-brew（-opt-homebrew）"><a href="#清理-brew（-opt-homebrew）" class="headerlink" title="清理 brew（/opt/homebrew）"></a>清理 brew（/opt/homebrew）</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">brew upgrade<br>brew autoremove<br>brew cleanup --prune=0<br></code></pre></td></tr></table></figure><h1 id="清理-log-日志（-private-var-db-diagnostics）"><a href="#清理-log-日志（-private-var-db-diagnostics）" class="headerlink" title="清理 log 日志（/private/var/db/diagnostics）"></a>清理 log 日志（/private/var/db/diagnostics）</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo log erase --all<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>macOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 917 (Div. 2)</title>
    <link href="/2024/02/25/acm/codeforces/CodeforcesRound917/"/>
    <url>/2024/02/25/acm/codeforces/CodeforcesRound917/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Least-Product"><a href="#A-Least-Product" class="headerlink" title="A. Least Product"></a>A. Least Product</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组，允许你将每个值变成比原值更接近 0 的值，问如何操作可以使得整个数组的积最小</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果负数是偶数个，那么随便找个值变成 0，如果是奇数个，那就别动</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>, zero = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            flag ^= tmp &lt; <span class="hljs-number">0</span>;<br>            zero |= tmp == <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (zero || flag) cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;1\n1 0&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Erase-First-or-Second-Letter"><a href="#B-Erase-First-or-Second-Letter" class="headerlink" title="B. Erase First or Second Letter"></a>B. Erase First or Second Letter</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个字符串，允许每次删除第一个或者第二个字母，操作无限制次数，问最多可以有多少个不同的字符串</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>可以这样思考，如果是一个长度的字符串，那么必然是有多少种字母就是多少个</p><p>如果长度等于 2，那么必然是上面的基础上，再加上最后那个字母，那么应该等于首字母的种类数</p><p>三个的情况，那必然是在一个字母的基础上，加上原字符串最后两个字母，那么应该也等于首字母的种类数</p><p>所以只需要考虑位置即可，如果一个字母出现的第一个位置就是最后那个了，那么必然没有它开头的两个、三个的字符串了</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        string str;<br>        str.<span class="hljs-built_in">reserve</span>(n);<br>        cin &gt;&gt; str;<br>        map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; cnt;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) ++cnt[str[i]];<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            ans += <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;(cnt.<span class="hljs-built_in">size</span>());<br>            <span class="hljs-keyword">if</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> iter = cnt.<span class="hljs-built_in">find</span>(str[i]); iter-&gt;second == <span class="hljs-number">1</span>) cnt.<span class="hljs-built_in">erase</span>(iter);<br>            <span class="hljs-keyword">else</span> --iter-&gt;second;<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Watering-an-Array"><a href="#C-Watering-an-Array" class="headerlink" title="C. Watering an Array"></a>C. Watering an Array</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有两个字符串，$a, b$，长度为 $n, d$，必须要操作 $d$ 次，每次可以选择下面两个其中一个，且必须执行其中一个，假设本次是第 $x$ 次操作</p><ul><li>将 $\forall i \in [1, d_x], a_i \leftarrow a_i + 1$</li><li>计算 $a_i = i$ 的数量，并获得对应的分数，然后再进行 $\forall i \in [1, n], a_i \leftarrow 0$</li></ul><p>问最高分数可以是多少</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>假设某次操作了 2 操作，然后因为每次会让所有值加一，所以无论操作几次，最终最多也只有一个值能满足要求</p><p>所以最好的方案是操作一次 1 然后操作一次 2，这样可以稳定拿到一分，等价于两次操作必定能拿到一次</p><p>所以核心需要关注的是最开始的 $a$ 数组的情况，因为数组仅有 2000 个，而且 $b$ 数组是一个循环数组</p><p>假设我们开始操作了 $x$ 次 1 后再进行操作 2，那么带来的最大分数就是 $n - \frac{x}{k}$<br>（操作 $k$ 次最多只有一次对整个数组都 +1 的情况下的分值最大，否则最大分值就是 $n - x$ 了）</p><p>而如果不那么做，直接按照上面的方案走，可以拿到 $\frac{x}{2}$ 的分数</p><p>所以得到 $\frac{x}{2} &lt; n - \frac{x}{k} \rightarrow (1 + \frac{2}{k}) x &lt; 2n \rightarrow x &lt; 2n$</p><p>所以考虑 $2n$ 以内的情况即可</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n, k, d;<br>        cin &gt;&gt; n &gt;&gt; k &gt;&gt; d;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span>, <span class="hljs-title">v</span><span class="hljs-params">(k)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) cin &gt;&gt; i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: v) cin &gt;&gt; i;<br>        <span class="hljs-comment">// init ans</span><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (data[i] == i + <span class="hljs-number">1</span>) ++ans;<br>        ans += (d - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">min</span>(<span class="hljs-number">2</span> * n, d - <span class="hljs-number">1</span>); ++i) &#123;<br>            <span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (j &lt; v[i % k]) ++data[j];<br>                <span class="hljs-keyword">if</span> (data[j] == j + <span class="hljs-number">1</span>) ++tmp;<br>            &#125;<br>            tmp += (d - <span class="hljs-number">2</span> - i) / <span class="hljs-number">2</span>;<br>            ans = <span class="hljs-built_in">max</span>(ans, tmp);<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Yet-Another-Inversions-Problem"><a href="#D-Yet-Another-Inversions-Problem" class="headerlink" title="D. Yet Another Inversions Problem"></a>D. Yet Another Inversions Problem</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>给出两个初始的数组 $p, q$，其中 $p$ 数组必定是 $[1, 2n-1]$ 中的所有奇数的排列，而 $q$ 数组一定是 $[0, k - 1]$ 的排列</p><p>现在构建一个新的数组 $a_{i \times k + j} = p_i \times 2^{q_j}$</p><p>问这个数组有多少个逆序对</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>首先是 $q$ 数组本身的逆序，这种情况下，自己和自己就可以产生逆序对，这个部分可以通过归并排序解决，所以单独处理即可</p><p>接下来考虑不同数值之间的情况，显然可以通过 01 字典树完成。注意因为乘法其实就是左移，所以可以直接用每个字符串的最大比特位开始建树，<br>记录在经过某个节点的时候，剩下多长的比特位。</p><p>然后再遍历数组，每次遍历的点从树中移除，并且在遍历到某个节点的时候，需要关注一下它的姐妹节点上有多少数值经过了，<br>可以根据其剩下的比特位，推算出有多少的组合可以比它大，还需要关注在当前节点结束的数值的情况，<br>以及如果当前自己已经结束，那么剩下经过这个点的其他字符串的情况</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">tree</span>(<span class="hljs-number">2e5</span> * <span class="hljs-number">2</span>), <span class="hljs-built_in">next</span>(<span class="hljs-number">2e5</span> * <span class="hljs-number">2</span>);<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">end</span><span class="hljs-params">(<span class="hljs-number">2e5</span> * <span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: tree) i.<span class="hljs-built_in">resize</span>(<span class="hljs-number">20</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: next) i.<span class="hljs-built_in">resize</span>(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(n)</span>, <span class="hljs-title">q</span><span class="hljs-params">(k)</span>, <span class="hljs-title">cache</span><span class="hljs-params">(k)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: p) cin &gt;&gt; i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: q) cin &gt;&gt; i;<br><br>        <span class="hljs-type">int</span> root, tail = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">auto</span> build = [&amp;] &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; ++i) tree[tail][i] = <span class="hljs-number">0</span>;<br>            next[tail][<span class="hljs-number">0</span>] = next[tail][<span class="hljs-number">1</span>] = <span class="hljs-number">-1</span>;<br>            end[tail] = <span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">assert</span>(tail &lt; tree.<span class="hljs-built_in">size</span>());<br>            <span class="hljs-keyword">return</span> tail++;<br>        &#125;;<br><br>        root = <span class="hljs-built_in">build</span>();<br><br>        <span class="hljs-keyword">auto</span> move = [&amp;](<span class="hljs-type">const</span> <span class="hljs-type">int</span> x, <span class="hljs-type">const</span> <span class="hljs-type">int</span> v) &#123;<br>            <span class="hljs-type">int</span> i = <span class="hljs-number">20</span>;<br>            <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; (x &amp; <span class="hljs-number">1</span> &lt;&lt; i) == <span class="hljs-number">0</span>) --i;<br>            <span class="hljs-type">int</span> cur = root;<br>            <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">const</span> <span class="hljs-type">int</span> flag = x &amp; <span class="hljs-number">1</span> &lt;&lt; i ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (next[cur][flag] == <span class="hljs-number">-1</span>) next[cur][flag] = <span class="hljs-built_in">build</span>();<br>                cur = next[cur][flag];<br>                tree[cur][i] += v;<br>                --i;<br>            &#125;<br>            end[cur] += v;<br>        &#125;;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pi: p) <span class="hljs-built_in">move</span>(pi, <span class="hljs-number">1</span>);<br><br>        ll ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">constexpr</span> ll mod = <span class="hljs-number">998244353</span>;<br>        <span class="hljs-keyword">auto</span> pos = [&amp;](<span class="hljs-type">const</span> <span class="hljs-type">int</span> gap, <span class="hljs-type">const</span> <span class="hljs-type">int</span> cnt) &#123;<br>            <span class="hljs-keyword">if</span> (gap &gt;= k) <span class="hljs-keyword">return</span>;<br>            <span class="hljs-type">const</span> ll ps = <span class="hljs-number">1ll</span> * (k - gap + <span class="hljs-number">1</span>) * (k - gap) / <span class="hljs-number">2</span> % mod;<br>            <span class="hljs-type">const</span> ll tmp = ps * cnt % mod;<br>            ans = (ans + tmp) % mod;<br>        &#125;;<br><br>        <span class="hljs-keyword">auto</span> neg = [&amp;](<span class="hljs-type">int</span> gap, <span class="hljs-type">const</span> <span class="hljs-type">int</span> cnt) &#123;<br>            gap += <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (gap &gt; k) <span class="hljs-keyword">return</span>;<br>            <span class="hljs-type">const</span> ll ps = <span class="hljs-number">1ll</span> * (k - gap + <span class="hljs-number">1</span>) * (k - gap) / <span class="hljs-number">2</span> % mod;<br>            <span class="hljs-type">const</span> ll all = <span class="hljs-number">1ll</span> * (k + <span class="hljs-number">1</span>) * k / <span class="hljs-number">2</span> % mod;<br>            <span class="hljs-type">const</span> ll tmp = (all - ps - k) * cnt % mod;<br>            ans = (ans + tmp) % mod;<br>        &#125;;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pi: p) &#123;<br>            <span class="hljs-built_in">move</span>(pi, <span class="hljs-number">-1</span>);<br>            <span class="hljs-type">int</span> i = <span class="hljs-number">20</span>;<br>            <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; (pi &amp; <span class="hljs-number">1</span> &lt;&lt; i) == <span class="hljs-number">0</span>) --i;<br>            <span class="hljs-type">int</span> cur = root;<br>            <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">const</span> <span class="hljs-type">int</span> flag = pi &amp; <span class="hljs-number">1</span> &lt;&lt; i ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br><br>                <span class="hljs-keyword">if</span> (<span class="hljs-type">const</span> <span class="hljs-type">int</span> other = next[cur][flag ^ <span class="hljs-number">1</span>]; other != <span class="hljs-number">-1</span>)<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ind = <span class="hljs-number">0</span>; ind &lt; <span class="hljs-number">20</span>; ++ind)<br>                        <span class="hljs-keyword">if</span> (tree[other][ind] &gt; <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-type">const</span> <span class="hljs-type">int</span> gap = ind + (flag ^ <span class="hljs-number">1</span>) - i;<br>                            <span class="hljs-built_in">pos</span>(<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, gap), tree[other][ind]);<br>                            <span class="hljs-keyword">if</span> (gap &lt; <span class="hljs-number">0</span>) <span class="hljs-built_in">neg</span>(-gap, tree[other][ind]);<br>                        &#125;<br><br>                cur = next[cur][flag];<br>                <span class="hljs-type">const</span> <span class="hljs-type">int</span> gap = <span class="hljs-built_in">max</span>(-i, -k + <span class="hljs-number">1</span>);<br>                <span class="hljs-built_in">pos</span>(<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, gap), end[cur]);<br>                <span class="hljs-keyword">if</span> (gap &lt; <span class="hljs-number">0</span>) <span class="hljs-built_in">neg</span>(-gap, end[cur]);<br>                --i;<br>            &#125;<br><br>            <span class="hljs-keyword">auto</span> cal = [&amp;](<span class="hljs-type">const</span> <span class="hljs-type">int</span> node) &#123;<br>                <span class="hljs-keyword">if</span> (node == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ind = <span class="hljs-number">0</span>; ind &lt; <span class="hljs-number">20</span>; ++ind)<br>                    <span class="hljs-keyword">if</span> (tree[node][ind] &gt; <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-type">const</span> <span class="hljs-type">int</span> gap = ind + <span class="hljs-number">2</span>;<br>                        <span class="hljs-built_in">pos</span>(<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, gap), tree[node][ind]);<br>                        <span class="hljs-keyword">if</span> (gap &lt; <span class="hljs-number">0</span>) <span class="hljs-built_in">neg</span>(-gap, tree[node][ind]);<br>                    &#125;<br>            &#125;;<br>            <span class="hljs-built_in">cal</span>(next[cur][<span class="hljs-number">0</span>]);<br>            <span class="hljs-built_in">cal</span>(next[cur][<span class="hljs-number">1</span>]);<br>        &#125;<br><br>        function&lt;ll(vector&lt;<span class="hljs-type">int</span>&gt;&amp;, vector&lt;<span class="hljs-type">int</span>&gt;&amp;, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; mergeSort = [&amp;](vector&lt;<span class="hljs-type">int</span>&gt;&amp; record, vector&lt;<span class="hljs-type">int</span>&gt;&amp; tmp, <span class="hljs-type">const</span> <span class="hljs-type">int</span> l, <span class="hljs-type">const</span> <span class="hljs-type">int</span> r) &#123;<br>            <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> <span class="hljs-number">0ll</span>;<br>            <span class="hljs-type">const</span> <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>            ll inv_count = <span class="hljs-built_in">mergeSort</span>(record, tmp, l, mid) + <span class="hljs-built_in">mergeSort</span>(record, tmp, mid + <span class="hljs-number">1</span>, r);<br>            <span class="hljs-type">int</span> i = l, j = mid + <span class="hljs-number">1</span>, poss = l;<br>            <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;<br>                <span class="hljs-keyword">if</span> (record[i] &lt;= record[j]) &#123;<br>                    tmp[poss] = record[i];<br>                    ++i;<br>                    inv_count += j - (mid + <span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    tmp[poss] = record[j];<br>                    ++j;<br>                &#125;<br>                ++poss;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ind = i; ind &lt;= mid; ++ind) &#123;<br>                tmp[poss++] = record[ind];<br>                inv_count += j - (mid + <span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ind = j; ind &lt;= r; ++ind) &#123;<br>                tmp[poss++] = record[ind];<br>            &#125;<br>            <span class="hljs-built_in">copy</span>(tmp.<span class="hljs-built_in">begin</span>() + l, tmp.<span class="hljs-built_in">begin</span>() + r + <span class="hljs-number">1</span>, record.<span class="hljs-built_in">begin</span>() + l);<br>            <span class="hljs-keyword">return</span> inv_count;<br>        &#125;;<br><br>        <span class="hljs-type">const</span> ll cnt = <span class="hljs-built_in">mergeSort</span>(q, cache, <span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">const</span> ll tmp = cnt * n % mod;<br>        ans = (ans + tmp) % mod;<br><br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pinely Round 3 (Div. 1 + Div. 2)</title>
    <link href="/2024/02/24/acm/codeforces/PinelyRound3/"/>
    <url>/2024/02/24/acm/codeforces/PinelyRound3/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Distinct-Buttons"><a href="#A-Distinct-Buttons" class="headerlink" title="A. Distinct Buttons"></a>A. Distinct Buttons</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>初始在 $(0, 0)$ 点，问是否可能只往三个方向移动的情况下，到达所有给出的点位，不需要按照顺序</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看看所有点是不是都在两个相邻的象限内即可</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-type">bool</span> flag[<span class="hljs-number">4</span>] = &#123;<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> u, v;<br>            cin &gt;&gt; u &gt;&gt; v;<br>            <span class="hljs-keyword">if</span> (u &gt; <span class="hljs-number">0</span>) flag[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (u &lt; <span class="hljs-number">0</span>) flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (v &gt; <span class="hljs-number">0</span>) flag[<span class="hljs-number">2</span>] = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (v &lt; <span class="hljs-number">0</span>) flag[<span class="hljs-number">3</span>] = <span class="hljs-literal">false</span>;<br>        &#125;<br>        cout &lt;&lt; (flag[<span class="hljs-number">0</span>] || flag[<span class="hljs-number">1</span>] || flag[<span class="hljs-number">2</span>] || flag[<span class="hljs-number">3</span>] ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Make-Almost-Equal-With-Mod"><a href="#B-Make-Almost-Equal-With-Mod" class="headerlink" title="B. Make Almost Equal With Mod"></a>B. Make Almost Equal With Mod</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组，允许你挑选一个值，让所有值 mod 它之后，剩下的值中至少有两个不一样的，问可能的选择</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>从二进制角度看，找到最后一位大家都不一样的，然后取比它大一点的那个 $2^n$ 即可</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) cin &gt;&gt; i;<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            set&lt;<span class="hljs-type">int</span>&gt; tmp;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) tmp.<span class="hljs-built_in">insert</span>(data[i] % k);<br>            <span class="hljs-keyword">if</span> (tmp.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) &#123;<br>                cout &lt;&lt; k &lt;&lt; endl;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            k &lt;&lt;= <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Heavy-Intervals"><a href="#C-Heavy-Intervals" class="headerlink" title="C. Heavy Intervals"></a>C. Heavy Intervals</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一堆区间$[l_i, r_i]$和相同数量的以及数组 $c$，问是否可以通过重新排列每个区间的 $l$, $r$ 以及 $c$，使得</p><p>$\sum_{i=1}^n c_i \times (r_i - l_i)$ 最小</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>可以得到，要让最大的 $c$ 去匹配最小的区间即可，所以要尽可能制造 $(r_i - l_i)$ 之和不变的情况下，区间差异最大</p><p>所以可以从大到小遍历 $r$ 去找对应第一个匹配的 $l$ 即可</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">l</span><span class="hljs-params">(n)</span>, <span class="hljs-title">c</span><span class="hljs-params">(n)</span></span>;<br>        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; r;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: l) cin &gt;&gt; i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            ++r[tmp];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: c) cin &gt;&gt; i;<br>        <span class="hljs-built_in">sort</span>(l.<span class="hljs-built_in">begin</span>(), l.<span class="hljs-built_in">end</span>(), greater&lt;&gt;());<br>        <span class="hljs-built_in">sort</span>(c.<span class="hljs-built_in">begin</span>(), c.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">len</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> iter = r.<span class="hljs-built_in">upper_bound</span>(l[i]);<br>            len[i] = iter-&gt;first - l[i];<br>            <span class="hljs-keyword">if</span> (iter-&gt;second == <span class="hljs-number">1</span>) r.<span class="hljs-built_in">erase</span>(iter);<br>            <span class="hljs-keyword">else</span> --iter-&gt;second;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(len.<span class="hljs-built_in">begin</span>(), len.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) ans += len[i] * c[n - <span class="hljs-number">1</span> - i];<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Split-Plus-K"><a href="#D-Split-Plus-K" class="headerlink" title="D. Split Plus K"></a>D. Split Plus K</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个初始的数组，允许每次选择其中的一个值，让其加上给出的 $k$，然后拆成两个，</p><p>问经过多少次操作后，整个数组的所有值相同</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>假设最终的值为 $m$，可以得到</p><p>$a_i = m \times t_i - (t_i - 1) \times k$</p><p>化简得到 $a_i - k = t_i \times (m - k)$</p><p>由于都是整数，且所有 $i$ 的 $m - k$ 相同，则可以得到 $m - k$ 可以是 $gcd_{i=1}^n (a_i - k)$</p><p>那么就简单了</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-comment">// NOLINTNEXTLINE(*-no-recursion)</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> a, <span class="hljs-type">const</span> <span class="hljs-type">int</span> b)</span> -&gt; <span class="hljs-type">int</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">gcd</span>(b, a % b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) cin &gt;&gt; i;<br><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> mk = data[<span class="hljs-number">0</span>] - k;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) mk = <span class="hljs-built_in">gcd</span>(mk, data[i] - k);<br>        <span class="hljs-keyword">if</span> (mk == <span class="hljs-number">0</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> ans = LONG_LONG_MAX;<br>        <span class="hljs-keyword">auto</span> check = [&amp;](<span class="hljs-type">int</span> m) &#123;<br>            <span class="hljs-keyword">if</span> (m == k) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>            <span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                <span class="hljs-keyword">if</span> ((data[i] - m) % (m - k) != <span class="hljs-number">0</span> || (data[i] - m) / (m - k) &lt; <span class="hljs-number">0</span>) &#123;<br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                tmp += (data[i] - m) / (m - k);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (flag) ans = <span class="hljs-built_in">min</span>(ans, tmp);<br>            <span class="hljs-keyword">return</span> flag;<br>        &#125;;<br><br>        <span class="hljs-built_in">check</span>(mk + k);<br>        cout &lt;&lt; (ans == LONG_LONG_MAX ? <span class="hljs-number">-1</span> : ans) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Educational Codeforces Round 160 (Rated for Div. 2)</title>
    <link href="/2024/02/17/acm/codeforces/EducationalCodeforcesRound160/"/>
    <url>/2024/02/17/acm/codeforces/EducationalCodeforcesRound160/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Rating-Increase"><a href="#A-Rating-Increase" class="headerlink" title="A. Rating Increase"></a>A. Rating Increase</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有两个分数，并列写在一起了，已知第一个分数一定小于第二个分数，问是否可能，并给出一种拆法</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>找到第二个非 <code>0</code> 的值前面拆开就行，就是最优的情况</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        string str;<br>        str.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">10</span>);<br>        cin &gt;&gt; str;<br>        <span class="hljs-type">int</span> a[<span class="hljs-number">2</span>] = &#123;str.<span class="hljs-built_in">front</span>() - <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-number">0</span>&#125;, cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; str.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (cur == <span class="hljs-number">0</span> &amp;&amp; str[i] != <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                cur = <span class="hljs-number">1</span>;<br>            &#125;<br>            a[cur] *= <span class="hljs-number">10</span>;<br>            a[cur] += str[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (a[<span class="hljs-number">0</span>] &lt; a[<span class="hljs-number">1</span>]) cout &lt;&lt; a[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; a[<span class="hljs-number">1</span>] &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Swap-and-Delete"><a href="#B-Swap-and-Delete" class="headerlink" title="B. Swap and Delete"></a>B. Swap and Delete</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个 $01$ 字符串，允许选择一个字符进行删除（并消耗一点成本），或者交换两个值（不消耗成本），<br>问是否可以经过任意次数操作后，使得新的字符串和原来的字符串没有一个字符相同</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>从头开始尽力使用交换即可，如果遇到一个字符不能靠交换解决了，那么其后面的字符都得删掉</p><p>因为是要与原始字符串不同，仅删掉这个字符，后面的字符就到这个字符的位置了</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    string str;<br>    str.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        cin &gt;&gt; str;<br>        <span class="hljs-type">int</span> cnt[<span class="hljs-number">2</span>] = &#123;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; c: str) ++cnt[c - <span class="hljs-string">&#x27;0&#x27;</span>];<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (cnt[(str[i] - <span class="hljs-string">&#x27;0&#x27;</span>) ^ <span class="hljs-number">1</span>]) --cnt[(str[i] - <span class="hljs-string">&#x27;0&#x27;</span>) ^ <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">else</span> &#123;<br>                ans = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(str.<span class="hljs-built_in">size</span>()) - i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Game-with-Multiset"><a href="#C-Game-with-Multiset" class="headerlink" title="C. Game with Multiset"></a>C. Game with Multiset</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个有 $2^n$ 组成的集合，每次允许往里面添加值，问是否可以靠这几个值相加得到某个具体的值</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>从二进制角度考虑即可，为每一个位置进行凑，不足就让下面的位置进上来</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-type">int</span> cnt[<span class="hljs-number">30</span>] = &#123;&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> q = <span class="hljs-number">0</span>; q &lt; n; ++q) &#123;<br>        <span class="hljs-type">int</span> op, v;<br>        cin &gt;&gt; op &gt;&gt; v;<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) ++cnt[v];<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> last = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">29</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>                last &lt;&lt;= <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> cur = last + ((v &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>                last = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, cur - cnt[i]);<br>            &#125;<br>            cout &lt;&lt; (last == <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 915 (Div. 2)</title>
    <link href="/2024/02/16/acm/codeforces/CodeforcesRound915/"/>
    <url>/2024/02/16/acm/codeforces/CodeforcesRound915/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Constructive-Problems"><a href="#A-Constructive-Problems" class="headerlink" title="A. Constructive Problems"></a>A. Constructive Problems</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个棋盘，允许选择一定数量的方格先进行染色</p><p>若某个方格的相邻四个格子中，横向至少有一个已经染色，且纵向至少也有一个已经染色的情况下，那么这个格子也可以被自然染色</p><p>问最少最初选择的方格数量是多少</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对角线即可</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        cout &lt;&lt; <span class="hljs-built_in">max</span>(a, b) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Begginer’s-Zelda"><a href="#B-Begginer’s-Zelda" class="headerlink" title="B. Begginer’s Zelda"></a>B. Begginer’s Zelda</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一棵树，允许每次选择树上的一条路径，然后将路径上的所有的点都挤压到一个点上，问最多需要挤压几次才能让整个树变成一个点</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>其实只需要统计叶子结点数量就行了，然后两两连线挤压即可，必定存在一种方法使得整个树的所有边被遍历</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">deg</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-type">int</span> u, v;<br>            cin &gt;&gt; u &gt;&gt; v;<br>            ++deg[u];<br>            ++deg[v];<br>        &#125;<br><br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) cnt += deg[i] == <span class="hljs-number">1</span>;<br>        cout &lt;&lt; (cnt + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Largest-Subsequence"><a href="#C-Largest-Subsequence" class="headerlink" title="C. Largest Subsequence"></a>C. Largest Subsequence</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个字符串，接下来有如下操作</p><ul><li>找到这个字符串中字典序最大子序列</li><li>将这个子序列进行右移操作，仅对序列内的值生效</li></ul><p>问需要操作几次才能使得整个数组有序</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>因为是字典序最大子序列，那么必然得到的子序列是一个递减的序列。</p><p>而要求是右移，即把最后面的值放到最前面，那么必然放到最前面的是最小的那个值，那么必然下一次得到字典序最大子序列的时候，必定不会包含这个值了</p><p>也就是说，实际上每次操作后，下一次得到的子序列就是上一次的子序列删掉最开头的位置和最后面的那个值，即排序操作仅对这个子序列生效</p><p>所以只需要看这个子序列需要操作几次才能有序，以及是否能够保证整个序列有序</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        string str;<br>        str.<span class="hljs-built_in">reserve</span>(n);<br>        cin &gt;&gt; str;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">st</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-type">int</span> r = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (r &gt; <span class="hljs-number">0</span> &amp;&amp; str[st[r - <span class="hljs-number">1</span>]] &lt; str[i]) --r;<br>            st[r++] = i;<br>        &#125;<br>        <span class="hljs-type">int</span> ans = r;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; r; ++i) <span class="hljs-keyword">if</span> (str[st[i]] == str[st[<span class="hljs-number">0</span>]]) --ans;<br>        --r;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>; l &lt; r; ++l, --r) <span class="hljs-built_in">swap</span>(str[st[l]], str[st[r]]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (str[i] &lt; str[i - <span class="hljs-number">1</span>]) ans = <span class="hljs-number">-1</span>;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Cyclic-MEX"><a href="#D-Cyclic-MEX" class="headerlink" title="D. Cyclic MEX"></a>D. Cyclic MEX</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个 $[0, n-1]$ 的排列，允许进行任意次的右移操作</p><p>问找到一种的排列，使得 $\sum_{i=1}^n mex([a_1, a_2, \dots a_{i}])$ 最大</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>这种数组的 $mex$ 其实就等于要求算的那个值后面的值中最小的那个值</p><p>考虑每次右移带来的效果</p><ul><li>首先是最前面的那个 $mex([a_1])$ 会被删除掉</li><li>然后影响从最后一个开始，找到第一个比当前值更小的值，这期间的所有值带来的贡献都变成当前值</li><li>然后再加上固定 $n$ 的贡献</li></ul><p>所以可以考虑单调栈的方式去做</p><p>但是我觉得这个方案有点累，所以直接用线段树了。虽然说是仅影响了更小的那个值以及后面的值<br>但是要明确的是，那个更小的值前面的带来的贡献，必然小于等于那个更小的值，所以只需要全局把贡献降低到当前值即可</p><p>用样例举个例子</p><div class="table-container"><table><thead><tr><th style="text-align:center">index</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th></tr></thead><tbody><tr><td style="text-align:center">start</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">4</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">mex</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">rotate</td><td style="text-align:center">3</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">mex</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">8</td></tr></tbody></table></div><ul><li>可以看到，首先是 $2$ 移动到后面去了，贡献变成了 $8$</li><li>然后是可以注意到，因为 $2$ 在最后面，所以所有值的贡献是不可能超过 $2$ 的，因为它必然是所有值后面的值</li></ul><p>所以直接用线段树暴力即可，注意做好懒处理</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegTree</span> &#123;<br>    vector&lt;ll&gt; sum, ma, mi;<br>    vector&lt;<span class="hljs-type">bool</span>&gt; lazy;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">SegTree</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> n)</span> : sum((n &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">10</span>), ma((n &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">10</span>), mi((n &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">10</span>), lazy((n &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">10</span>) &#123;</span>&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> l, <span class="hljs-type">const</span> <span class="hljs-type">int</span> r)</span> </span>&#123; <span class="hljs-keyword">return</span> (l + r) | (l != r); &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> l, <span class="hljs-type">const</span> <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> i = <span class="hljs-built_in">get</span>(l, r), li = <span class="hljs-built_in">get</span>(l, mid), ri = <span class="hljs-built_in">get</span>(mid + <span class="hljs-number">1</span>, r);<br>        sum[i] = sum[li] + sum[ri];<br>        ma[i] = <span class="hljs-built_in">max</span>(ma[li], ma[ri]);<br>        mi[i] = <span class="hljs-built_in">min</span>(mi[li], mi[ri]);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> l, <span class="hljs-type">const</span> <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> i = <span class="hljs-built_in">get</span>(l, r), li = <span class="hljs-built_in">get</span>(l, mid), ri = <span class="hljs-built_in">get</span>(mid + <span class="hljs-number">1</span>, r);<br>        lazy[i] = <span class="hljs-literal">false</span>;<br>        lazy[li] = <span class="hljs-literal">true</span>;<br>        lazy[ri] = <span class="hljs-literal">true</span>;<br>        sum[li] = (mid - l + <span class="hljs-number">1</span>) * mi[i];<br>        sum[ri] = (r - mid) * mi[i];<br>        ma[li] = ma[ri] = ma[i];<br>        mi[li] = mi[ri] = mi[i];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> l, <span class="hljs-type">const</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> <span class="hljs-type">int</span> x, <span class="hljs-type">const</span> ll v)</span> </span>&#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> i = <span class="hljs-built_in">get</span>(l, r);<br>        <span class="hljs-keyword">if</span> (l == r) &#123;<br>            sum[i] = ma[i] = mi[i] = v;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (lazy[i]) <span class="hljs-built_in">push</span>(l, r);<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (x &lt;= mid) <span class="hljs-built_in">update</span>(l, mid, x, v);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">update</span>(mid + <span class="hljs-number">1</span>, r, x, v);<br>        <span class="hljs-built_in">up</span>(l, r);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> l, <span class="hljs-type">const</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> ll v)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i = <span class="hljs-built_in">get</span>(l, r);<br>        <span class="hljs-keyword">if</span> (ma[i] &lt;= v) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (mi[i] &gt; v) &#123;<br>            ma[i] = mi[i] = v;<br>            sum[i] = (r - l + <span class="hljs-number">1</span>) * v;<br>            lazy[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (l == r) &#123;<br>            sum[i] = ma[i] = mi[i] = v;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">update</span>(l, mid, v);<br>        <span class="hljs-built_in">update</span>(mid + <span class="hljs-number">1</span>, r, v);<br>        <span class="hljs-built_in">up</span>(l, r);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) cin &gt;&gt; i;<br><br>        <span class="hljs-function">vector <span class="hljs-title">flag</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = n;<br>        <span class="hljs-function">SegTree <span class="hljs-title">tree</span><span class="hljs-params">(r)</span></span>;<br>        <span class="hljs-comment">// init</span><br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            flag[data[i]] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">while</span> (flag[cur]) ++cur;<br>            tree.<span class="hljs-built_in">update</span>(l, r, i + <span class="hljs-number">1</span>, cur);<br>        &#125;<br>        ll ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            tree.<span class="hljs-built_in">update</span>(l, r, data[i]);<br>            tree.<span class="hljs-built_in">update</span>(l, r, i + <span class="hljs-number">1</span>, n);<br><br>            ans = <span class="hljs-built_in">max</span>(ans, tree.sum[tree.<span class="hljs-built_in">get</span>(l, r)]);<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 914 (Div. 2)</title>
    <link href="/2024/02/15/acm/codeforces/CodeforcesRound914/"/>
    <url>/2024/02/15/acm/codeforces/CodeforcesRound914/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Forked"><a href="#A-Forked" class="headerlink" title="A. Forked!"></a>A. Forked!</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>棋盘上有一个皇后和一个国王，且骑士的移动方式是给出的 “日” 字形式，存在几个位置，使得骑士可以同时吃国王和皇后</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>虽然不是 “日” 字，但是一个骑士最多也就只能走 8 个位置，所以暴力枚举就行</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> a, b, xk, yk, xq, yq;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; xk &gt;&gt; yk &gt;&gt; xq &gt;&gt; yq;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> arr[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>        set&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; s;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> ar: arr) &#123;<br>            s.<span class="hljs-built_in">insert</span>(&#123;xk + a * ar[<span class="hljs-number">0</span>], yk + b * ar[<span class="hljs-number">1</span>]&#125;);<br>            s.<span class="hljs-built_in">insert</span>(&#123;xk + b * ar[<span class="hljs-number">0</span>], yk + a * ar[<span class="hljs-number">1</span>]&#125;);<br>        &#125;<br><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> ar: arr) &#123;<br>            <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">count</span>(&#123;xq + a * ar[<span class="hljs-number">0</span>], yq + b * ar[<span class="hljs-number">1</span>]&#125;)) &#123;<br>                s.<span class="hljs-built_in">erase</span>(&#123;xq + a * ar[<span class="hljs-number">0</span>], yq + b * ar[<span class="hljs-number">1</span>]&#125;);<br>                ++ans;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">count</span>(&#123;xq + b * ar[<span class="hljs-number">0</span>], yq + a * ar[<span class="hljs-number">1</span>]&#125;)) &#123;<br>                s.<span class="hljs-built_in">erase</span>(&#123;xq + b * ar[<span class="hljs-number">0</span>], yq + a * ar[<span class="hljs-number">1</span>]&#125;);<br>                ++ans;<br>            &#125;<br>        &#125;<br><br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Collecting-Game"><a href="#B-Collecting-Game" class="headerlink" title="B. Collecting Game"></a>B. Collecting Game</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组，选择其中的一个值作为初始值，然后每次进行如下操作：</p><ol><li>选择一个剩下的值，满足其小于当前的值</li><li>删除它，并把其值加到当前值上</li></ol><p>问每一位的值作为初始值的情况下，最多可以干掉多少值</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>因为每一个值都可以干掉它以及比它小的值，所以只需要这些值加起来比恰好大于它的值还要大的话，那么就可以继续增大</p><p>而最终的结果一定是卡在某个值处，使得所有逼比它小的值加起来都没有它大，那么这个时候，比它小的那个值必然只能消除到这个位置</p><p>依次类推，只需要依次找到满足 $\sum_{i=1}^x a_i &lt; a_{x+1}$ 即可，那么必然可以类似前缀和一样处理就行</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">data</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [fst, snd]: data) cin &gt;&gt; fst;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) data[i].second = i;<br>        <span class="hljs-built_in">sort</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; n) &#123;<br>            <span class="hljs-type">int</span> r = l + <span class="hljs-number">1</span>;<br>            sum += data[l].first;<br>            <span class="hljs-keyword">while</span> (r &lt; n &amp;&amp; sum &gt;= data[r].first) &#123;<br>                sum += data[r].first;<br>                ++r;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt; r; ++i) ans[data[i].second] = r - <span class="hljs-number">1</span>;<br><br>            l = r;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Array-Game"><a href="#C-Array-Game" class="headerlink" title="C. Array Game"></a>C. Array Game</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组，允许你每次选择其中的两个值，把它们的差值加入到队列中，问经过 $k$ 次操作后，数组中最小的值最小可能是多少</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>如果操作三次，那么可以连续两次拿同两个值，然后再让结果的那两值的差值加入数组，那么必然得到 $0$，即最小的值</p><p>所以问题只需要考虑一次操作和两次操作即可</p><p>一次操作很简单，$n^2$ 暴力扫就行了</p><p>二次操作也很简单，$n^2$ 暴力扫的同时，将结果和原始数组中看看，是否有足够相近的值</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        set&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            data[i] = tmp;<br>            s.<span class="hljs-built_in">insert</span>(tmp);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (k &gt;= <span class="hljs-number">3</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123;<br>            cout &lt;&lt; *s.<span class="hljs-built_in">begin</span>() &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> ans1 = *s.<span class="hljs-built_in">begin</span>(), ans2 = *s.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-type">int</span> tmp = <span class="hljs-built_in">abs</span>(data[i] - data[j]);<br>                <span class="hljs-keyword">auto</span> riter = s.<span class="hljs-built_in">upper_bound</span>(tmp);<br>                <span class="hljs-keyword">auto</span> liter = riter;<br>                <span class="hljs-keyword">if</span> (liter != s.<span class="hljs-built_in">begin</span>()) --liter;<br>                <span class="hljs-keyword">if</span> (riter == s.<span class="hljs-built_in">end</span>()) --riter;<br>                ans1 = <span class="hljs-built_in">min</span>(ans1, tmp);<br>                ans2 = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(ans2, tmp), <span class="hljs-built_in">min</span>(<span class="hljs-built_in">abs</span>(*riter - tmp), <span class="hljs-built_in">abs</span>(*liter - tmp)));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) cout &lt;&lt; ans1 &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; ans2 &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D2-Set-To-Max-Hard-Version"><a href="#D2-Set-To-Max-Hard-Version" class="headerlink" title="D2. Set To Max (Hard Version)"></a>D2. Set To Max (Hard Version)</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组，允许每次操作选择一个区间 $[l, r]$，使得 $a_i \leftarrow max(a_{l \dots r}), \forall i \in [l, r]$</p><p>问只操作数组 $a$ 的情况下是否有可能做到</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>首先，数组 $a$ 里面的每一个值，必然有其最大的作用范围，毕竟是取区间最大，可以通过两次单调栈的方式来找到每个值可以作用到的最大区间</p><p>然后只需要找到每一个值所来自哪个值的效果即可，可以用双指针在两个数组上移动即可</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span>, <span class="hljs-title">b</span><span class="hljs-params">(n)</span>, <span class="hljs-title">la</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span>, <span class="hljs-title">ra</span><span class="hljs-params">(n, n)</span></span>;<br>        <span class="hljs-type">int</span> r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: a) cin &gt;&gt; i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: b) cin &gt;&gt; i;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; a[st.<span class="hljs-built_in">top</span>()] &lt; a[i]) &#123;<br>                ra[st.<span class="hljs-built_in">top</span>()] = i;<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            st.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) st.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; a[st.<span class="hljs-built_in">top</span>()] &lt; a[i]) &#123;<br>                la[st.<span class="hljs-built_in">top</span>()] = i + <span class="hljs-number">1</span>;<br>                st.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            st.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) st.<span class="hljs-built_in">pop</span>();<br><br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">while</span> (r &gt;= <span class="hljs-number">0</span> &amp;&amp; (a[r] != b[i] || la[r] &gt; i || ra[r] &lt;= i)) --r;<br>            <span class="hljs-keyword">if</span> (a[r] != b[i] || la[r] &gt; i || ra[r] &lt;= i) &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        cout &lt;&lt; (flag ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 913 (Div. 3)</title>
    <link href="/2024/02/14/acm/codeforces/CodeforcesRound913/"/>
    <url>/2024/02/14/acm/codeforces/CodeforcesRound913/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Rook"><a href="#A-Rook" class="headerlink" title="A. Rook"></a>A. Rook</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个棋盘，上有一个城堡，问这个城堡能走到哪些格子</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>把横向和纵向的都枚举出来就行了</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        string str;<br>        cin &gt;&gt; str;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (str[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;a&#x27;</span> + i) cout &lt;&lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>&gt;(<span class="hljs-string">&#x27;a&#x27;</span> + i) &lt;&lt; str[<span class="hljs-number">1</span>] &lt;&lt; endl;<br><br>            <span class="hljs-keyword">if</span> (str[<span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;1&#x27;</span> + i) cout &lt;&lt; str[<span class="hljs-number">0</span>] &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-YetnotherrokenKeoard"><a href="#B-YetnotherrokenKeoard" class="headerlink" title="B. YetnotherrokenKeoard"></a>B. YetnotherrokenKeoard</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个键盘，如果输入 <code>B</code> 则删除最后输入的大写字母，如果输入的是 <code>b</code> 则删除最后输入的小写字母，给出输入的字母，问最终输出什么</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>从后往前遍历去做就比较简单了，统计还有一个 <code>B</code>/<code>b</code> 没有处理过即可</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    string str;<br>    str.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        cin &gt;&gt; str;<br>        list&lt;<span class="hljs-type">char</span>&gt; l;<br>        <span class="hljs-type">int</span> cnt[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = str.<span class="hljs-built_in">rbegin</span>(); iter != str.<span class="hljs-built_in">rend</span>(); ++iter) &#123;<br>            <span class="hljs-keyword">if</span> (iter.<span class="hljs-keyword">operator</span>*() == <span class="hljs-string">&#x27;b&#x27;</span>) ++cnt[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (iter.<span class="hljs-keyword">operator</span>*() == <span class="hljs-string">&#x27;B&#x27;</span>) ++cnt[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (iter.<span class="hljs-keyword">operator</span>*() &gt;= <span class="hljs-string">&#x27;A&#x27;</span> &amp;&amp; iter.<span class="hljs-keyword">operator</span>*() &lt;= <span class="hljs-string">&#x27;Z&#x27;</span> &amp;&amp; cnt[<span class="hljs-number">1</span>]) --cnt[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (iter.<span class="hljs-keyword">operator</span>*() &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; iter.<span class="hljs-keyword">operator</span>*() &lt;= <span class="hljs-string">&#x27;z&#x27;</span> &amp;&amp; cnt[<span class="hljs-number">0</span>]) --cnt[<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">else</span> l.<span class="hljs-built_in">push_front</span>(iter.<span class="hljs-keyword">operator</span>*());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; c: l) cout &lt;&lt; c;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Removal-of-Unattractive-Pairs"><a href="#C-Removal-of-Unattractive-Pairs" class="headerlink" title="C. Removal of Unattractive Pairs"></a>C. Removal of Unattractive Pairs</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>每次可以选择两个相邻的字符，如果不同则同时删除，问最后最少是多少个字符</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>简单题，如果有一个字符的数量超过一半，那就不行</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    string str;<br>    str.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n &gt;&gt; str;<br>        <span class="hljs-type">int</span> cnt[<span class="hljs-number">26</span>] = &#123;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; c: str) ++cnt[c - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-type">int</span> i : cnt) &#123;<br>            <span class="hljs-keyword">if</span> (i * <span class="hljs-number">2</span> &gt; n) &#123;<br>                cout &lt;&lt; i * <span class="hljs-number">2</span> - n &lt;&lt; endl;<br>                flag = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!flag) cout &lt;&lt; (n % <span class="hljs-number">2</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Jumping-Through-Segments"><a href="#D-Jumping-Through-Segments" class="headerlink" title="D. Jumping Through Segments"></a>D. Jumping Through Segments</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>有 $n$ 个线段，落在 x 轴上，要求从 $0$ 点开始，每次允许往前或者往后走至多 $k$ 步，使得当走完第 $i$ 步的时候，恰好落在第 $i$ 个线段上，问最小的 $k$</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>二分 $k$ 即可</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">data</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [fst, snd]: data) cin &gt;&gt; fst &gt;&gt; snd;<br>        <span class="hljs-type">int</span> ml = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [fst, snd]: data) ml = <span class="hljs-built_in">max</span>(fst, ml);<br>        <span class="hljs-keyword">if</span> (ml == <span class="hljs-number">0</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">1e9</span> + <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">auto</span> check = [&amp;](<span class="hljs-type">const</span> <span class="hljs-type">int</span> x) &#123;<br>            <span class="hljs-type">int</span> bl = <span class="hljs-number">0</span>, br = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [fst, snd]: data) &#123;<br>                bl -= x;<br>                br += x;<br>                bl = <span class="hljs-built_in">max</span>(bl, fst);<br>                br = <span class="hljs-built_in">min</span>(br, snd);<br>                <span class="hljs-keyword">if</span> (bl &gt; br) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;;<br>        <span class="hljs-keyword">while</span> (l + <span class="hljs-number">1</span> &lt; r) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-type">const</span> <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-built_in">check</span>(mid)) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid;<br>        &#125;<br>        cout &lt;&lt; r &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="E-Good-Triples"><a href="#E-Good-Triples" class="headerlink" title="E. Good Triples"></a>E. Good Triples</h1><h2 id="大致题意-4"><a href="#大致题意-4" class="headerlink" title="大致题意"></a>大致题意</h2><p>定义 $digsum(x)$ 等于其每一位的数值相加的结果</p><p>问是否存在组合 $(a, b, c)$，使得 $a + b + c = n$ 且 $digsum(a) + digsum(b) + digsum(c) = digsum(n)$</p><p>其中 $n$ 为给出的值</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>从十进制角度考虑问题，从每一位看，三个值每一位可以是 $[0, 9]$。</p><p>可以考虑从高位开始逐位枚举当前位的值，因为任意位置最多只能是 $27$，所以每一个位置，可能被下面的位置借走两个值，<br>所以每一个位置的可能的值是 $x, x-1, x-2$，而同时也需要把下面的位置加上对应的借位的值</p><p>每一位的值可能是 $[0, 27]$，每个值所能得到的可能的排列是确定的，只需要将每个位置的排列可能性乘起来就行，做个 dfs 即可</p><h2 id="AC-code-4"><a href="#AC-code-4" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-type">int</span> base[<span class="hljs-number">28</span>] = &#123;&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a = <span class="hljs-number">0</span>; a &lt; <span class="hljs-number">10</span>; ++a)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b = <span class="hljs-number">0</span>; b &lt; <span class="hljs-number">10</span>; ++b)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c = <span class="hljs-number">0</span>; c &lt; <span class="hljs-number">10</span>; ++c) ++base[a + b + c];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n, tot = <span class="hljs-number">0</span>;<br>        cin &gt;&gt; n;<br>        <span class="hljs-type">int</span> tmp = n, index = <span class="hljs-number">7</span>, arr[<span class="hljs-number">8</span>] = &#123;&#125;;<br>        <span class="hljs-keyword">while</span> (tmp) &#123;<br>            arr[index--] = tmp % <span class="hljs-number">10</span>;<br>            tot += tmp % <span class="hljs-number">10</span>;<br>            tmp /= <span class="hljs-number">10</span>;<br>        &#125;<br><br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>, cur = <span class="hljs-number">1</span>;<br>        function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">const</span> <span class="hljs-type">int</span> i) &#123;<br>            <span class="hljs-keyword">if</span> (arr[i] &gt; <span class="hljs-number">27</span>) <span class="hljs-keyword">return</span>;<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">7</span>) &#123;<br>                <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; x: arr) sum += x;<br>                <span class="hljs-keyword">if</span> (sum == tot) ans += cur * base[arr[i]];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d = <span class="hljs-number">0</span>; d &lt; <span class="hljs-number">3</span>; ++d) &#123;<br>                    <span class="hljs-keyword">if</span> (arr[i] &lt; d) <span class="hljs-keyword">continue</span>;<br>                    arr[i] -= d;<br>                    arr[i + <span class="hljs-number">1</span>] += d * <span class="hljs-number">10</span>;<br>                    cur *= base[arr[i]];<br><br>                    <span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>);<br><br>                    cur /= base[arr[i]];<br>                    arr[i] += d;<br>                    arr[i + <span class="hljs-number">1</span>] -= d * <span class="hljs-number">10</span>;<br>                &#125;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br><br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="F-Shift-and-Reverse"><a href="#F-Shift-and-Reverse" class="headerlink" title="F. Shift and Reverse"></a>F. Shift and Reverse</h1><h2 id="大致题意-5"><a href="#大致题意-5" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组，每次操作允许进行两个操作其中之一</p><ul><li>把最后一个值放到最前面</li><li>翻转整个数组</li></ul><p>问是否可能通过操作，使得数组变得非递减</p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>有点类似切牌的操作，这么搞最终都是数组原序列的翻转，所以需要数组本身基本有序才行</p><p>所以只需要搞清楚是把后面的数直接往前拿，还是说是先翻转后再拿即可</p><h2 id="AC-code-5"><a href="#AC-code-5" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) cin &gt;&gt; i;<br>        <span class="hljs-type">int</span> cnt[<span class="hljs-number">2</span>] = &#123;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (data[i - <span class="hljs-number">1</span>] &gt; data[i]) ++cnt[<span class="hljs-number">0</span>]; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data[i - <span class="hljs-number">1</span>] &lt; data[i]) ++cnt[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (cnt[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">1</span> &amp;&amp; cnt[<span class="hljs-number">1</span>] &gt; <span class="hljs-number">1</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (cnt[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cnt[<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> ans = INT_MAX;<br>        <span class="hljs-keyword">if</span> (cnt[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">back</span>() &lt;= data.<span class="hljs-built_in">front</span>()) &#123;<br>                <span class="hljs-type">int</span> key = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (data[i - <span class="hljs-number">1</span>] &gt; data[i]) key = i;<br>                ans = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(n - key, key + <span class="hljs-number">2</span>), ans);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cnt[<span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">back</span>() &gt;= data.<span class="hljs-built_in">front</span>()) &#123;<br>                <span class="hljs-type">int</span> key = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (data[i - <span class="hljs-number">1</span>] &lt; data[i]) key = i;<br>                ans = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(n - key + <span class="hljs-number">1</span>, key + <span class="hljs-number">1</span>), ans);<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; (ans == INT_MAX ? <span class="hljs-number">-1</span> : ans) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="G-Lights"><a href="#G-Lights" class="headerlink" title="G. Lights"></a>G. Lights</h1><h2 id="大致题意-6"><a href="#大致题意-6" class="headerlink" title="大致题意"></a>大致题意</h2><p>有 $n$ 盏灯，$n$ 个开关，每个开关管理两个灯，$i, a_i$，每次使用开关可以把这两盏灯的状态翻转，<br>问是否存在一种开关方法，使得所有灯被关闭</p><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>因为一个开关必定可以改变当前灯的状态，以及改变另外一个灯的状态，所以可以得到一张图，<br>然后根据拓扑序，如果当前节点是开灯的，那么必然得使用这盏灯的开关，因为这是最后能改变灯状态的开关了，最后可能会成环，没办法拓扑序了</p><p>因为每次关灯，会影响到两个灯的状态，所以一个环上必须要恰好还剩下偶数盏灯没有被关闭才行，然后再环上找小弧即可</p><h2 id="AC-code-6"><a href="#AC-code-6" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tc = <span class="hljs-number">0</span>; tc &lt; _; ++tc) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        string str;<br>        str.<span class="hljs-built_in">reserve</span>(n);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nxt</span><span class="hljs-params">(n)</span>, <span class="hljs-title">deg</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span>, ans</span>;<br>        cin &gt;&gt; str;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: nxt) cin &gt;&gt; i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: nxt) ++deg[--i];<br><br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (!deg[i]) q.<span class="hljs-built_in">push</span>(i);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> cur = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (str[cur] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(cur);<br>                str[cur] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                str[nxt[cur]] = str[nxt[cur]] == <span class="hljs-string">&#x27;0&#x27;</span> ? <span class="hljs-string">&#x27;1&#x27;</span> : <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125;<br>            --deg[nxt[cur]];<br>            <span class="hljs-keyword">if</span> (!deg[nxt[cur]]) q.<span class="hljs-built_in">push</span>(nxt[cur]);<br>        &#125;<br><br>        <span class="hljs-type">bool</span> ret = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (!deg[i] || str[i] == <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> len = <span class="hljs-number">1</span>, half = <span class="hljs-number">1</span>, cur = nxt[i], flag = str[cur] == <span class="hljs-string">&#x27;0&#x27;</span>, cnt = str[cur] == <span class="hljs-string">&#x27;0&#x27;</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (cur != i) &#123;<br>                cur = nxt[cur];<br>                ++len;<br>                half += flag;<br>                <span class="hljs-keyword">if</span> (str[cur] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                    flag ^= <span class="hljs-number">1</span>;<br>                    ++cnt;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cnt % <span class="hljs-number">2</span>) &#123;<br>                ret = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            cur = i;<br>            <span class="hljs-keyword">if</span> (half * <span class="hljs-number">2</span> &lt;= len) flag = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> flag = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (len--) &#123;<br>                <span class="hljs-keyword">if</span> (flag) ans.<span class="hljs-built_in">push_back</span>(cur);<br>                str[cur] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                cur = nxt[cur];<br>                <span class="hljs-keyword">if</span> (str[cur] == <span class="hljs-string">&#x27;1&#x27;</span>) flag ^= <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!ret) &#123;<br>            cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        cout &lt;&lt; ans.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ans.<span class="hljs-built_in">size</span>(); ++i) cout &lt;&lt; ans[i] + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == ans.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Educational Codeforces Round 159 (Rated for Div. 2)</title>
    <link href="/2024/02/12/acm/codeforces/EducationalCodeforcesRound159/"/>
    <url>/2024/02/12/acm/codeforces/EducationalCodeforcesRound159/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Binary-Imbalance"><a href="#A-Binary-Imbalance" class="headerlink" title="A. Binary Imbalance"></a>A. Binary Imbalance</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个 <code>01</code> 字符串，每次允许选择两个相邻的字母中间插入一个 <code>01</code> 字符，如果相邻的两个字母不同则插入 <code>0</code> 否则插入 <code>1</code></p><p>问是否可能经过任意次数操作后，字符串中的 <code>0</code> 比 <code>1</code> 多</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>只要有 <code>0</code> 就行了</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        string str;<br>        str.<span class="hljs-built_in">reserve</span>(n);<br>        cin &gt;&gt; str;<br>        <span class="hljs-type">int</span> cnt[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; c: str) ++cnt[c - <span class="hljs-string">&#x27;0&#x27;</span>];<br>        cout &lt;&lt; (cnt[<span class="hljs-number">0</span>] ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Getting-Points"><a href="#B-Getting-Points" class="headerlink" title="B. Getting Points"></a>B. Getting Points</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有 $n$ 天的学期，每一天都可以选择是学习还是休息，学习的话，会得到 $l$ 分，同时可以完成至多两个任务，每个任务可以得到 $t$ 分</p><p>任务每隔 $7$ 天会生成一个，第一个任务在第 $1$ 天生成，每个任务一旦被完成就不能再次得到分数</p><p>问在至少得到 $p$ 分的情况下，最多可以休息多少天</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>因为任务每 $7$ 天才有一个，而每天可以完成 $2$ 个，所以必然可以把任务做完。即然要休息时间足够久，那么必然是最后几天完成任务即可</p><p>所以只需要考虑最后需要多少天进行学习即可。</p><p>当然也可以考虑分类讨论，比如所有天都是完成两个任务的学习，或者个别天是不做任何任务的学习</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, p, l, t;<br>        cin &gt;&gt; n &gt;&gt; p &gt;&gt; l &gt;&gt; t;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> cnt = (n + <span class="hljs-number">6</span>) / <span class="hljs-number">7</span>, d = (cnt + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (d * l + t * cnt &gt;= p)<br>            cout &lt;&lt; n - ((<span class="hljs-number">2</span> * t + l + p - <span class="hljs-number">1</span>) / (<span class="hljs-number">2</span> * t + l)) &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span><br>            cout &lt;&lt; n - ((p - cnt * t + l - <span class="hljs-number">1</span>) / l) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Insert-and-Equalize"><a href="#C-Insert-and-Equalize" class="headerlink" title="C. Insert and Equalize"></a>C. Insert and Equalize</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个初始的数组，每个值不同，需要往里面加入一个任选的值，让数组仍然保持不同</p><p>然后进行 $t$ 次操作，每次操作是选择一个值并将其加上 $x$，问让所有值都相同的，最少多少的 $t$</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>先不管加入一个值这个事情，如果只是纯粹的做加法，那么非常简单，只需要找到所有差值的最大公约数就行了，那么这个公约数就是 $x$</p><p>那么也就可以得到 $t$ 了，即所有值变成 $a_{max}$ 所需要的步数</p><p>接下来是加入一个值的部分，因为必须要和原来的数组不同，所以可以考虑尝试 $a_{max} - c \times x$，而 $c$ 就是需要额外增加的成本，所以要尽可能小即可</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">gcd</span>(b, a % b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) cin &gt;&gt; i;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>());<br>        set&lt;<span class="hljs-type">int</span>&gt; dif;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) dif.<span class="hljs-built_in">insert</span>(data[i + <span class="hljs-number">1</span>] - data[i]);<br>        <span class="hljs-type">int</span> g = dif.<span class="hljs-built_in">begin</span>().<span class="hljs-keyword">operator</span>*();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; s: dif) g = <span class="hljs-built_in">gcd</span>(g, s);<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; i: data) ans += (data[n - <span class="hljs-number">1</span>] - i) / g;<br>        <span class="hljs-keyword">if</span> (dif.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) ans += n;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-type">const</span> <span class="hljs-type">int</span> tmp = n - <span class="hljs-number">1</span> - i; data[i] + tmp * g != data[n - <span class="hljs-number">1</span>]) &#123;<br>                    ans += tmp;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="E-Collapsing-Strings"><a href="#E-Collapsing-Strings" class="headerlink" title="E. Collapsing Strings"></a>E. Collapsing Strings</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一堆的字符串，使用 $\left | x \right |$ 表示 $x$ 的字符串长度</p><p>定义一个函数，$C(a, b)$，其中 $a, b$ 都是字符串</p>$$C(a, b) =\left\{\begin{matrix}a, & \left | b \right |  = 0 \\b, & \left | a \right |  = 0 \\C(a_{1 \dots \left | a \right | - 1}, b_{2 \dots \left | b \right |}), & a_{\left | a \right |} = b_1 \\a + b, & others\end{matrix}\right.$$<p>问</p>$$\sum_{i=1}^{n} \sum_{j=1}^{n} \left | C(s_i, s_j) \right |$$<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>其实就是要找出任意两个字符串之间，前后重叠的部分即可</p><p>可以考虑用字典树做，每个字典树的节点上记录下当前节点有多少字符串在这里结束了，又有多少字符串经过了这个节点，总共有多少个字符在其子节点上即可</p><p>然后再扫一遍全部的字符串即可</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    string str;<br>    str.<span class="hljs-built_in">resize</span>(<span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>, <span class="hljs-number">-1</span>);<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>        <span class="hljs-type">int</span> arr[<span class="hljs-number">26</span>]&#123;&#125;;<br>        <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>, end = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-built_in">node</span>() &#123; <span class="hljs-built_in">memset</span>(arr, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> arr); &#125;<br>    &#125;;<br>    <span class="hljs-function">vector&lt;node&gt; <span class="hljs-title">tree</span><span class="hljs-params">(<span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> root = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> nxt = <span class="hljs-number">1</span>;<br><br>    vector&lt;string&gt; data;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cin &gt;&gt; str;<br>        <span class="hljs-type">int</span> cur = root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>; l &lt; str.<span class="hljs-built_in">size</span>(); ++l) &#123;<br>            <span class="hljs-keyword">if</span> (!~tree[cur].arr[str[l] - <span class="hljs-string">&#x27;a&#x27;</span>]) &#123;<br>                tree[cur].arr[str[l] - <span class="hljs-string">&#x27;a&#x27;</span>] = nxt++;<br>            &#125;<br>            cur = tree[cur].arr[str[l] - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            tree[cur].len += <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(str.<span class="hljs-built_in">size</span>()) - l;<br>            ++tree[cur].cnt;<br>        &#125;<br>        ++tree[cur].end;<br>        data.<span class="hljs-built_in">push_back</span>(str);<br>    &#125;<br><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        string &amp;s = data[i];<br>        <span class="hljs-type">int</span> cur = root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(s.<span class="hljs-built_in">size</span>()) - <span class="hljs-number">1</span>; l &gt;= <span class="hljs-number">0</span>; --l) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">26</span>; ++x) <span class="hljs-keyword">if</span> (x != s[l] - <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; tree[cur].arr[x] != <span class="hljs-number">-1</span>)<br>                ans += tree[tree[cur].arr[x]].len + <span class="hljs-number">1LL</span> * (l + <span class="hljs-number">1</span>) * tree[tree[cur].arr[x]].cnt;<br>            ans += <span class="hljs-number">1LL</span> * (l + <span class="hljs-number">1</span>) * tree[cur].end;<br>            cur = tree[cur].arr[s[l] - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-keyword">if</span> (!~cur) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cur != <span class="hljs-number">-1</span>) <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-type">int</span> x : tree[cur].arr) <span class="hljs-keyword">if</span> (x != <span class="hljs-number">-1</span>) ans += tree[x].len;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 912 (Div. 2)</title>
    <link href="/2024/02/10/acm/codeforces/CodeforcesRound912/"/>
    <url>/2024/02/10/acm/codeforces/CodeforcesRound912/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Halloumi-Boxes"><a href="#A-Halloumi-Boxes" class="headerlink" title="A. Halloumi Boxes"></a>A. Halloumi Boxes</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组，每次允许选择其中一段长度不超过 $k$ 的字串进行翻转，问是否可能将其排序好</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最有用的翻转就是两个值，那就是冒泡了，所以要么本身有序，要么 $k \geq 2$ 就行了</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) cin &gt;&gt; i;<br>        <span class="hljs-type">bool</span> sorted = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (data[i] &lt; data[i - <span class="hljs-number">1</span>]) sorted = <span class="hljs-literal">false</span>;<br>        cout &lt;&lt; (sorted || k &gt;= <span class="hljs-number">2</span> ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-StORage-room"><a href="#B-StORage-room" class="headerlink" title="B. StORage room"></a>B. StORage room</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个矩阵，其中的每一项 $M_{i,j} = a_i | a_j$，问是否能得到原始数组的其中一种可能</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>即然是 $M_{i,j} = a_i | a_j$，那么反过来可以得到 $a_i = M_{i,0} &amp; M_{i,1} &amp; M_{i,2} \dots$</p><p>这不一定是原始解，但是一定是正确的解。还原后再验证一下矩阵对不对就行了</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">data</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) i.<span class="hljs-built_in">resize</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; j: i) cin &gt;&gt; j;<br>        <span class="hljs-function">vector <span class="hljs-title">ans</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j)<br>                <span class="hljs-keyword">if</span> (j != i) ans[i] &amp;= data[i][j];<br>        <span class="hljs-type">bool</span> check = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (i == j) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> (data[i][j] != (ans[i] | ans[j])) check = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!check) cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cout &lt;&lt; (ans[i] == <span class="hljs-number">-1</span> ? <span class="hljs-number">1</span> : ans[i]) &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n <span class="hljs-number">-1</span>];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Theofanis’-Nightmare"><a href="#C-Theofanis’-Nightmare" class="headerlink" title="C. Theofanis’ Nightmare"></a>C. Theofanis’ Nightmare</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>一个数组，其中有负值，将其拆成多个字串，然后按照原始顺序从左往右编号，从 1 开始编号</p><p>然后将每个字串内求和，乘上其的编号，最后再相加，问如何拆最大</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>从最后一个值看，假如其为 $c$，那么如果其独立出去，和不独立出去，和前面的段合并，那么得到的差值就是 $c$，因为 $(n + 1) \times c - (n) \times c$</p><p>所以，如果 $c &gt; 0$ 那么这样做是有意义的，反之则应该尽力避免拆</p><p>类推可以得到，如果当前值即之后的所有值加起来是 $&lt; 0$，那么不要拆，反之则拆即可</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) cin &gt;&gt; i;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) sum += i;<br>        <span class="hljs-type">int</span> seg = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) &#123;<br>            <span class="hljs-keyword">if</span> (sum &lt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (seg == <span class="hljs-number">0</span>) seg = <span class="hljs-number">1</span>;<br>                ans += seg * i;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                ++seg;<br>                ans += seg * i;<br>            &#125;<br>            sum -= i;<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D1-Maximum-And-Queries-easy-version"><a href="#D1-Maximum-And-Queries-easy-version" class="headerlink" title="D1. Maximum And Queries (easy version)"></a>D1. Maximum And Queries (easy version)</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组，允许每次给其中一个值 $+1$，最多执行 $k$ 次，问最终得到的数组的每一项进行位与运算，问最大值可以是多少</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>要从位运算上下思路</p><p>如果一个值的某个位不是 <code>1</code>，那么如果通过 $+1$ 的方式把它变成 <code>1</code>，带来的后果就是更低位置的都会归零</p><p>所以我们需要从高位开始枚举位置，假设把这个位置大家都变成 <code>1</code>，那么就可以带来结果上的增长，但是会需要消耗一定的 $k$</p><p>注意一旦消耗过 $k$，那么再试图对这个值进行累加的时候，要把低位都认为是 <code>0</code> 了</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, q;<br>    cin &gt;&gt; n &gt;&gt; q;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) cin &gt;&gt; i;<br>    <span class="hljs-keyword">while</span> (q--) &#123;<br>        <span class="hljs-type">int</span> k, ans = <span class="hljs-number">0</span>;<br>        cin &gt;&gt; k;<br>        <span class="hljs-function">vector <span class="hljs-title">flag</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">62</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-comment">// try this bit</span><br>            <span class="hljs-type">int</span> cost = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">const</span> <span class="hljs-type">int</span> p = <span class="hljs-number">1LL</span> &lt;&lt; i;<br>            <span class="hljs-function">vector <span class="hljs-title">tmp</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span></span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (flag[j]) cost += p;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (data[j] &amp; p) <span class="hljs-keyword">continue</span>;<br>                    cost += p - data[j] % p;<br>                    tmp[j] = <span class="hljs-literal">true</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (cost &lt; <span class="hljs-number">0</span>) &#123;<br>                    cost = k + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (k &gt;= cost) &#123;<br>                k -= cost;<br>                ans += p;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) flag[j] = tmp[j] | flag[j];<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="E-Geo-Game"><a href="#E-Geo-Game" class="headerlink" title="E. Geo Game"></a>E. Geo Game</h1><h2 id="大致题意-4"><a href="#大致题意-4" class="headerlink" title="大致题意"></a>大致题意</h2><p>有两个人博弈，二维屏幕上有一些点，其中一个固定为起始点，两个人轮流指定下一个点，不可以是之前选中的点，直到所有点都被走到</p><p>然后求算路径的欧几里得距离的平方和，问能否保证是偶数或者是奇数</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>仔细思考就会发现很像是一笔画问题</p><p>如果某个点与开始点的欧几里得距离是奇数，我将其归为一类 A，另外的点为另外一类 B。那么显然，同一个类内的点相互走并不会变化结果的奇偶性。<br>但是不同类的路径就会变化奇偶性。非常巧的是，因为每个点都会被进入一次和出去一次，<br>所以理论如果要回到开始点，那么最终一定是偶数，因为一旦进入 A 类，就一定要回去 B 类，即每个 A 类的点会产生两条路径，也就是最终没有变化奇偶性</p><p>那么我们可以得到，如果 A 类点作为最后一个点，那么路径就是奇数的，否则就是偶数，然后再根据博弈再去模拟即可</p><h2 id="AC-code-4"><a href="#AC-code-4" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, sx, sy;<br>        cin &gt;&gt; n &gt;&gt; sx &gt;&gt; sy;<br>        set&lt;<span class="hljs-type">int</span>&gt; data[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> u, v;<br>            cin &gt;&gt; u &gt;&gt; v;<br>            <span class="hljs-type">const</span> <span class="hljs-type">int</span> cost = <span class="hljs-built_in">abs</span>(u - sx) + <span class="hljs-built_in">abs</span>(v - sy);<br>            data[cost % <span class="hljs-number">2</span>].<span class="hljs-built_in">insert</span>(i + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (data[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() &gt;= data[<span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-comment">// chose first</span><br>            cout &lt;&lt; <span class="hljs-string">&quot;First&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                <span class="hljs-keyword">if</span> (data[<span class="hljs-number">1</span>].<span class="hljs-built_in">empty</span>()) &#123;<br>                    <span class="hljs-keyword">auto</span> iter = data[<span class="hljs-number">0</span>].<span class="hljs-built_in">begin</span>();<br>                    cout &lt;&lt; *iter &lt;&lt; endl;<br>                    data[<span class="hljs-number">0</span>].<span class="hljs-built_in">erase</span>(iter);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">auto</span> iter = data[<span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>();<br>                    cout &lt;&lt; *iter &lt;&lt; endl;<br>                    data[<span class="hljs-number">1</span>].<span class="hljs-built_in">erase</span>(iter);<br>                &#125;<br><br>                ++i;<br>                <span class="hljs-keyword">if</span> (i &lt; n) &#123;<br>                    <span class="hljs-comment">// read</span><br>                    <span class="hljs-type">int</span> tmp;<br>                    cin &gt;&gt; tmp;<br>                    data[<span class="hljs-number">0</span>].<span class="hljs-built_in">erase</span>(tmp);<br>                    data[<span class="hljs-number">1</span>].<span class="hljs-built_in">erase</span>(tmp);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// chose second</span><br>            cout &lt;&lt; <span class="hljs-string">&quot;Second&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                <span class="hljs-type">int</span> tmp;<br>                cin &gt;&gt; tmp;<br>                data[<span class="hljs-number">0</span>].<span class="hljs-built_in">erase</span>(tmp);<br>                data[<span class="hljs-number">1</span>].<span class="hljs-built_in">erase</span>(tmp);<br>                ++i;<br><br>                <span class="hljs-keyword">if</span> (i &lt; n) &#123;<br>                    <span class="hljs-keyword">if</span> (data[<span class="hljs-number">0</span>].<span class="hljs-built_in">empty</span>()) &#123;<br>                        <span class="hljs-keyword">auto</span> iter = data[<span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>();<br>                        cout &lt;&lt; *iter &lt;&lt; endl;<br>                        data[<span class="hljs-number">1</span>].<span class="hljs-built_in">erase</span>(iter);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">auto</span> iter = data[<span class="hljs-number">0</span>].<span class="hljs-built_in">begin</span>();<br>                        cout &lt;&lt; *iter &lt;&lt; endl;<br>                        data[<span class="hljs-number">0</span>].<span class="hljs-built_in">erase</span>(iter);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 911 (Div. 2)</title>
    <link href="/2024/02/03/acm/codeforces/CodeforcesRound911/"/>
    <url>/2024/02/03/acm/codeforces/CodeforcesRound911/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Cover-in-Water"><a href="#A-Cover-in-Water" class="headerlink" title="A. Cover in Water"></a>A. Cover in Water</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个区域，有些地方有空有些地方有墙，可以进行如下操作</p><ol><li>选择一个空的区域，放上水</li><li>选择已经已经有水的区域，把水移动到别的地方</li></ol><p>如果一个地方是空的，且它的两边都是水，那么这个地方自然也有水</p><p>问最少操作多少次 1 操作，能让所有空的地方都有水</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由于 2 操作不计入成本，所以要多移动，而因为两个水中间会无限生成水，所以可以不断移走中间的水来实现</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        string str;<br>        str.<span class="hljs-built_in">reserve</span>(n);<br>        cin &gt;&gt; str;<br>        <span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>, ma = <span class="hljs-number">0</span>, cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; item: str) &#123;<br>            <span class="hljs-keyword">if</span> (item == <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                ++tot;<br>                ++cur;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ma = <span class="hljs-built_in">max</span>(ma, cur);<br>                cur = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        ma = <span class="hljs-built_in">max</span>(ma, cur);<br>        <span class="hljs-keyword">if</span> (ma &gt;= <span class="hljs-number">3</span>) cout &lt;&lt; <span class="hljs-number">2</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; tot &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Laura-and-Operations"><a href="#B-Laura-and-Operations" class="headerlink" title="B. Laura and Operations"></a>B. Laura and Operations</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有三个值，$a, b, c$，每次允许减少其中两个 $x$，然后增加剩下的那个 $x$，问是否可能最后只剩下其中一个值</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>反过来思考，一个值可以变成剩下两个值。</p><p>如果希望最后留下的是 $a$，那么必然 $b = c$，那么可以考虑不断减少 $b/c$ 使得 $b/c$ 相同，也就是说，只要 $b+c$ 是偶数即可</p><p>同理可以得到剩下两个的解</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        cout &lt;&lt; ((b + c) % <span class="hljs-number">2</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; ((a + c) % <span class="hljs-number">2</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; ((b + a) % <span class="hljs-number">2</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Anji’s-Binary-Tree"><a href="#C-Anji’s-Binary-Tree" class="headerlink" title="C. Anji’s Binary Tree"></a>C. Anji’s Binary Tree</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一颗二叉树，每个节点上都有 <code>LRU</code> 三个字母的其中一个，分别表示当到达这个节点的时候如何移动，比如 <code>L</code> 表示移动到它的左孩子</p><p>问至少修改几个，可以从根节点出发到任意一个叶子节点</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>树上找路径就行，每个节点选择左边和右边的代价里选较小的即可</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        string str;<br>        str.<span class="hljs-built_in">reserve</span>(n);<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">node</span>(n);<br>        cin &gt;&gt; str;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [fst, snd]: node) cin &gt;&gt; fst &gt;&gt; snd;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [fst, snd]: node) &#123;<br>            --fst;<br>            --snd;<br>        &#125;<br><br>        function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">const</span> <span class="hljs-type">int</span> x) &#123;<br>            <span class="hljs-keyword">if</span> (node[x].first == <span class="hljs-number">-1</span> &amp;&amp; node[x].second == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (node[x].first == <span class="hljs-number">-1</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(node[x].second) + (str[x] != <span class="hljs-string">&#x27;R&#x27;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (node[x].second == <span class="hljs-number">-1</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(node[x].first) + (str[x] != <span class="hljs-string">&#x27;L&#x27;</span>);<br>            &#125;<br>            <span class="hljs-type">const</span> <span class="hljs-type">int</span> l = <span class="hljs-built_in">dfs</span>(node[x].first) + (str[x] != <span class="hljs-string">&#x27;L&#x27;</span>), r = <span class="hljs-built_in">dfs</span>(node[x].second) + (str[x] != <span class="hljs-string">&#x27;R&#x27;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(l, r);<br>        &#125;;<br><br>        cout &lt;&lt; <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeTON Round 7 (Div. 1 + Div. 2, Rated, Prizes!)</title>
    <link href="/2024/01/28/acm/codeforces/CodeTONRound7/"/>
    <url>/2024/01/28/acm/codeforces/CodeTONRound7/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Jagged-Swaps"><a href="#A-Jagged-Swaps" class="headerlink" title="A. Jagged Swaps"></a>A. Jagged Swaps</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组，允许选择一个值，其左右两边都是大于当前值的情况下，将当前值和后面的那个值交换一下位置。问是否可能把整个数组排序好</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>可以从插入排序的方式去考虑，只需要第一个值是对的就行了</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) cin &gt;&gt; i;<br>        cout &lt;&lt; (data.<span class="hljs-built_in">front</span>() == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-AB-Flipping"><a href="#B-AB-Flipping" class="headerlink" title="B. AB Flipping"></a>B. AB Flipping</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个 AB 组成的数组，若存在 AB 这样的子字符串，则翻转 AB，且每个下标只能被翻转一次，问最多可以翻转多少次</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>若存在一堆连续的 <code>AAAABBB</code> 这样的字符串，那么仅最后一个不能进行翻转，其他所有位置都能发生翻转，所以只需要找出这样的连续对数量即可</p><p>需要注意的是，如果是 <code>AABBAABB</code> 这种两组的，虽然对于每一个单独的组而言，最后一个不能翻转，但是整体上，除了最后的最后那个，其他也都可以翻转</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        string str;<br>        str.<span class="hljs-built_in">reserve</span>(n);<br>        cin &gt;&gt; str;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, cntB = <span class="hljs-number">0</span>, flag = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = str.<span class="hljs-built_in">rbegin</span>(); iter != str.<span class="hljs-built_in">rend</span>(); ++iter) &#123;<br>            <span class="hljs-keyword">if</span> (*iter == <span class="hljs-string">&#x27;B&#x27;</span>) &#123;<br>                flag = <span class="hljs-number">1</span>;<br>                cntB++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans += flag + cntB;<br>                cntB = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-built_in">max</span>(ans - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Matching-Arrays"><a href="#C-Matching-Arrays" class="headerlink" title="C. Matching Arrays"></a>C. Matching Arrays</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有 AB 两个数组，每次任意排序 B 数组，问是否存在一个排列，使得 $a_i &gt; b_i$ 的 $i$ 的数量恰好是 $x$</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>很简单的一个想法：两个数组排序后，然后将 B 数组的前 $x$ 个值放到后面去即可。然后再判断是否符合预期</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, x;<br>        cin &gt;&gt; n &gt;&gt; x;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">a</span>(n);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [fst, snd]: a) cin &gt;&gt; fst;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) a[i].second = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: b) cin &gt;&gt; i;<br>        <span class="hljs-built_in">sort</span>(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            res += a[i].first &gt; b[(i + x) % n];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (res == x) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) a[a[i].second].first = b[(i + x) % n];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cout &lt;&lt; a[i].first &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n - <span class="hljs-number">1</span>];<br>        &#125; <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Ones-and-Twos"><a href="#D-Ones-and-Twos" class="headerlink" title="D. Ones and Twos"></a>D. Ones and Twos</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个仅有 $1, 2$ 组成数组，每次有两种操作：将其中一个值改成 $1, 2$，问是否存在一个子串，满足求和等于 $x$（x 是每次询问给出的值）</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>因为数组仅有 $1, 2$ 组成，那么必然，如果总值是 $s$，那么必然可以得到 $s - 2$ 的字串（删掉一侧的值或者删掉两侧的值），<br>同理也可以得到 $s-4, s-6, \dots$ 直到等于 $0 or 1$</p><p>所以只需要维护总和就能解决一般的值了。</p><p>而如果需要奇偶性和之和不同，那么必然需要减去一个 $1$，那么只需要找到左右两边最近的 $1$，<br>然后减去那一侧的 $2$ 和第一个 $1$，就可以得到最大可以满足的和全部之和奇偶性不同的值了，然后可以继续按照上面的推论</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, q;<br>        cin &gt;&gt; n &gt;&gt; q;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) cin &gt;&gt; i;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        set&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; i: data) sum += i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (data[i] == <span class="hljs-number">1</span>) s.<span class="hljs-built_in">insert</span>(i);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> qs = <span class="hljs-number">0</span>; qs &lt; q; ++qs) &#123;<br>            <span class="hljs-type">int</span> op;<br>            cin &gt;&gt; op;<br>            <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-type">int</span> x;<br>                cin &gt;&gt; x;<br>                <span class="hljs-keyword">if</span> (x &gt; sum) cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((x &amp; <span class="hljs-number">1</span>) == (sum &amp; <span class="hljs-number">1</span>)) cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">empty</span>()) &#123;<br>                        cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    <span class="hljs-type">const</span> <span class="hljs-type">int</span> m = <span class="hljs-built_in">min</span>(*s.<span class="hljs-built_in">begin</span>(), n - *s.<span class="hljs-built_in">rbegin</span>() - <span class="hljs-number">1</span>);<br>                    <span class="hljs-type">const</span> <span class="hljs-type">int</span> tmp = sum - m * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;<br>                    cout &lt;&lt; (x &lt;= tmp ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> a, b;<br>                cin &gt;&gt; a &gt;&gt; b;<br>                <span class="hljs-keyword">if</span> (data[a - <span class="hljs-number">1</span>] == <span class="hljs-number">1</span>) s.<span class="hljs-built_in">erase</span>(a - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (b == <span class="hljs-number">1</span>) s.<span class="hljs-built_in">insert</span>(a - <span class="hljs-number">1</span>);<br>                sum -= data[a - <span class="hljs-number">1</span>] - b;<br>                data[a - <span class="hljs-number">1</span>] = b;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="E-Permutation-Sorting"><a href="#E-Permutation-Sorting" class="headerlink" title="E. Permutation Sorting"></a>E. Permutation Sorting</h1><h2 id="大致题意-4"><a href="#大致题意-4" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个 $n$ 的排列的数组，每次按照如下操作进行</p><ul><li>选出其中 $a_i \neq i$ 的 $i$，得到一个由 $i$ 组成的数组 $s$</li><li>$a_{s_{i \space mod \space k+1}} \leftarrow a_{s_i}$</li></ul><p>重复进行后，直到整个数组排序完成，问每一个下标完成排序需要操作几次</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>从题意来看，其实就是每次将没有满足条件的值，右移一格，直到大家都满足了</p><p>由于在正常情况下，每次只移动一格，所以需要的成本就等于位置差值</p><p>但是因为有别的值会因为满足位置了，就不需要再路过这个节点了，也就可以省去一次移动成本，例如</p><div class="table-container"><table><thead><tr><th style="text-align:center">index</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th></tr></thead><tbody><tr><td style="text-align:center">start</td><td style="text-align:center">3</td><td style="text-align:center">5</td><td style="text-align:center">4</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">turn 1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">5</td><td style="text-align:center">(4)</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">turn 2</td><td style="text-align:center">(1)</td><td style="text-align:center">(2)</td><td style="text-align:center">(3)</td><td style="text-align:center">(4)</td><td style="text-align:center">(5)</td></tr></tbody></table></div><p>注意到，本来初始为 $5$ 的值，本应该走 $3$ 次才能到目标地点的，但是因为 $4$ 提前到达目标地点，<br>所以 $5$ 只需要走两次即可，为了方便表示，我们把 $4$ 的移动描述成 $[3,4]$，同理，那么 $5$ 就是 $[2,5]$</p><p>故我们需要找到的是，每个值要进行横跨的时候，会同时跨越的其他区间数量，即有哪些节点，他们开始的位置比当前值晚的同时，结束位置还比当前值早</p><p>我们可以用线段树来维护这样的值，如果存在一个 $[l,r]$，那么必然可以对所有 $[<l, >r]$ 的区间产生减少一次移动成本的效果<br>那么我们可以将 $[r+1,n]$ 的区间都 $+1$，而如何表示 $&lt;l$，则可以通过访问顺序来控制，我们保证从左往右访问即可，<br>每次访问后，将当前节点带来的区间进行删除</p><p>需要注意的是，因为移动是环形的，所以需要维护两倍区间长度，不然可能会出错</p><h2 id="AC-code-4"><a href="#AC-code-4" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegTree</span> &#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; s, laz;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">SegTree</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>: s((n &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">10</span>), laz((n &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">10</span>) &#123;</span>&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-type">static</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> l, <span class="hljs-type">const</span> <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (l + r) | (l != r);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> l, <span class="hljs-type">const</span> <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        s[<span class="hljs-built_in">get</span>(l, r)] = s[<span class="hljs-built_in">get</span>(l, mid)] + s[<span class="hljs-built_in">get</span>(mid + <span class="hljs-number">1</span>, r)];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> l, <span class="hljs-type">const</span> <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        laz[<span class="hljs-built_in">get</span>(l, r)] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (l == r) &#123;<br>            s[<span class="hljs-built_in">get</span>(l, r)] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">build</span>(l, mid);<br>        <span class="hljs-built_in">build</span>(mid + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-built_in">up</span>(l, r);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> l, <span class="hljs-type">const</span> <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> k = <span class="hljs-built_in">get</span>(l, r);<br>        <span class="hljs-keyword">if</span> (laz[k]) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            s[<span class="hljs-built_in">get</span>(l, mid)] += laz[k] * (mid - l + <span class="hljs-number">1</span>);<br>            s[<span class="hljs-built_in">get</span>(mid + <span class="hljs-number">1</span>, r)] += laz[k] * (r - mid);<br>            laz[<span class="hljs-built_in">get</span>(l, mid)] += laz[k];<br>            laz[<span class="hljs-built_in">get</span>(mid + <span class="hljs-number">1</span>, r)] += laz[k];<br>            laz[k] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> l, <span class="hljs-type">const</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> <span class="hljs-type">int</span> x, <span class="hljs-type">const</span> <span class="hljs-type">int</span> y, <span class="hljs-type">const</span> <span class="hljs-type">int</span> w)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == x &amp;&amp; y == r) &#123;<br>            s[<span class="hljs-built_in">get</span>(l, r)] += w * (r - l + <span class="hljs-number">1</span>);<br>            laz[<span class="hljs-built_in">get</span>(l, r)] += w;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">push</span>(l, r);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-type">const</span> <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>; y &lt;= mid) &#123;<br>            <span class="hljs-built_in">update</span>(l, mid, x, y, w);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt; mid) &#123;<br>            <span class="hljs-built_in">update</span>(mid + <span class="hljs-number">1</span>, r, x, y, w);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">update</span>(l, mid, x, mid, w);<br>            <span class="hljs-built_in">update</span>(mid + <span class="hljs-number">1</span>, r, mid + <span class="hljs-number">1</span>, y, w);<br>        &#125;<br>        <span class="hljs-built_in">up</span>(l, r);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> l, <span class="hljs-type">const</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> <span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r) &#123;<br>            <span class="hljs-keyword">return</span> s[<span class="hljs-built_in">get</span>(l, r)];<br>        &#125;<br>        <span class="hljs-built_in">push</span>(l, r);<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (x &lt;= mid) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(l, mid, x);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(mid + <span class="hljs-number">1</span>, r, x);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span>, <span class="hljs-title">ans</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-function">SegTree <span class="hljs-title">tree</span><span class="hljs-params">(<span class="hljs-number">2</span> * n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) cin &gt;&gt; i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-type">int</span> target = data[i] &gt; i ? data[i] : data[i] + n;<br>            tree.<span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span> * n, target, <span class="hljs-number">2</span> * n, <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (target &lt; n) tree.<span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span> * n, target + n, <span class="hljs-number">2</span> * n, <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-type">int</span> target = data[i] &gt; i ? data[i] : data[i] + n;<br>            tree.<span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span> * n, target, <span class="hljs-number">2</span> * n, <span class="hljs-number">-1</span>);<br>            ans[data[i] - <span class="hljs-number">1</span>] = target - (i + <span class="hljs-number">1</span>) - tree.<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span> * n, target);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Educational Codeforces Round 158 (Rated for Div. 2)</title>
    <link href="/2024/01/19/acm/codeforces/EducationalCodeforcesRound158/"/>
    <url>/2024/01/19/acm/codeforces/EducationalCodeforcesRound158/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Line-Trip"><a href="#A-Line-Trip" class="headerlink" title="A. Line Trip"></a>A. Line Trip</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一辆车，需要开到某个目的地，然后再回来，路上有几个加油站，初始的时候或者经过加油站的时候，油可以加满，问油箱的容量最小为多少</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>注意一下最后回来那段是两段折返的路就行了</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, x;<br>        cin &gt;&gt; n &gt;&gt; x;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) cin &gt;&gt; i;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-built_in">max</span>(data.<span class="hljs-built_in">front</span>(), <span class="hljs-number">2</span> * (x - data.<span class="hljs-built_in">back</span>()));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i= <span class="hljs-number">1</span>; i &lt; n; ++i) ans = <span class="hljs-built_in">max</span>(ans, data[i] - data[i - <span class="hljs-number">1</span>]);<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Chip-and-Ribbon"><a href="#B-Chip-and-Ribbon" class="headerlink" title="B. Chip and Ribbon"></a>B. Chip and Ribbon</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组，开始的每一个值都是 0，除了第一个值是 1，有一个指针指向其中一个数值</p><p>每次允许将当前指针指到下一个值，或者直接传送到另外一个任意位置，必须要进行一次移动，然后将移动后的值 $+1$</p><p>问最小的传送次数</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>注意每次移动只能移动到下一个值，也就是要回来删必须传送</p><p>所以对于每一个递减的子串，只取决于第一个值的代价，而第一个值的代价又和它前一个值相关，因为只要减少到和前一个值一样就行了</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) cin &gt;&gt; i;<br>        <span class="hljs-type">int</span> begin = data[<span class="hljs-number">0</span>], ans = data[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>            <span class="hljs-keyword">if</span> (data[i] &gt; data[i - <span class="hljs-number">1</span>])<br>                ans += data[i] - data[i - <span class="hljs-number">1</span>];<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Add-Divide-and-Floor"><a href="#C-Add-Divide-and-Floor" class="headerlink" title="C. Add, Divide and Floor"></a>C. Add, Divide and Floor</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组，每次允许将每一个值都加上任选的一个 $x$，然后再向下取整的方式除以 $2$。问最少需要操作多少次才能让所有值一样</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>其实只需要考虑最大和最小的那两个值即可</p><p>考虑公式$\left \lfloor \frac{a+x}{2} \right \rfloor = \left \lfloor \frac{a}{2} + \frac{x}{2} \right \rfloor$ 可以得到<br>实际上 $x$ 应该尽可能小才是，否则差值并不能很快缩小</p><p>因为是向下取整，所以当最小的值是奇数的时候，且最大值是偶数的时候，这个时候全部的值加上 $1$ 就可以非常有效的降低差值，<br>而在其他的时候 $x$ 取 $0$ 即可</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-type">int</span> mi = INT_MAX, ma = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            mi = <span class="hljs-built_in">min</span>(mi, tmp);<br>            ma = <span class="hljs-built_in">max</span>(ma, tmp);<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">while</span> (mi != ma) &#123;<br>            <span class="hljs-keyword">if</span> (mi % <span class="hljs-number">2</span> &amp;&amp; !(ma % <span class="hljs-number">2</span>)) &#123;<br>                mi = (mi + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>                ma = (ma + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>                ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mi /= <span class="hljs-number">2</span>;<br>                ma /= <span class="hljs-number">2</span>;<br>                ans.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; ans.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>        <span class="hljs-keyword">if</span> (ans.<span class="hljs-built_in">size</span>() &lt;= n) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; i: ans) cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Yet-Another-Monster-Fight"><a href="#D-Yet-Another-Monster-Fight" class="headerlink" title="D. Yet Another Monster Fight"></a>D. Yet Another Monster Fight</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一组怪物，允许选择一个初始的怪物进行攻击，</p><p>攻击后，伤害会连锁伤害到其他的怪物上，连锁的顺序是随机选择一个被攻击过的怪物附近的一个没有被攻击的怪物，最终所有怪物都会被连锁到。<br>而连锁的伤害则是逐步递减</p><p>问在可以指定直接攻击的怪物的情况下，最小的初始攻击应该是多少，才能将所有怪都干掉</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>由于连锁的顺序是随机的，所以对于每一个怪物而言，它的最晚承受伤害的时间就是它左边的所有怪都受到过伤害了，或者是它右边所有的怪都受到过伤害了，<br>至于应该是左边还是右边，那就取决于第一个怪是在它左边还是右边。<br>那么对于它而言，无论选择哪一个初始的怪，其需要的初始伤害是确定的，即它自身的生命值 + 它左边/右边的怪的数量</p><p>那么就可以枚举所有的初始的怪，然后找出左边所有怪里面，最大的需要是多少，和其右边里面，最大的需要是多少，然后在和当前怪的生命值取较大值即可</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) cin &gt;&gt; i;<br>    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; l, r;<br>    <span class="hljs-type">int</span> ans = INT_MAX;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) ++r[data[i] + i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> iter = r.<span class="hljs-built_in">find</span>(data[i] + i); iter-&gt;second == <span class="hljs-number">1</span>) r.<span class="hljs-built_in">erase</span>(iter);<br>        <span class="hljs-keyword">else</span> --iter-&gt;second;<br>        <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>) ++l[data[i - <span class="hljs-number">1</span>] + n - i];<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> ls = l.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">0</span> : l.<span class="hljs-built_in">rbegin</span>()-&gt;first, rs = r.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">0</span> : r.<span class="hljs-built_in">rbegin</span>()-&gt;first;<br>        ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">max</span>(data[i], <span class="hljs-built_in">max</span>(ls, rs)));<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 910 (Div. 2)</title>
    <link href="/2024/01/17/acm/codeforces/CodeforcesRound910/"/>
    <url>/2024/01/17/acm/codeforces/CodeforcesRound910/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Milica-and-String"><a href="#A-Milica-and-String" class="headerlink" title="A. Milica and String"></a>A. Milica and String</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个 A/B 组成的字符串，每次允许选择前 $n$ 个字母，将他们都变成 A/B，问最少的操作次数</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>简单题，最简单的方式就是枚举每一种可能，计算结果是否符合预期就行</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        string str;<br>        str.<span class="hljs-built_in">reserve</span>(n);<br>        cin &gt;&gt; str;<br>        <span class="hljs-type">int</span> cntB = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cntB += str[i] == <span class="hljs-string">&#x27;B&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (cntB == k) &#123;<br>            cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-type">const</span> <span class="hljs-type">bool</span> useA = cntB &gt; k;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (cntB &gt; k) &#123;<br>                cntB -= str[i] == <span class="hljs-string">&#x27;B&#x27;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cntB += str[i] != <span class="hljs-string">&#x27;B&#x27;</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (cntB == k) &#123;<br>                cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>                cout &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; (useA ? <span class="hljs-string">&#x27;A&#x27;</span> : <span class="hljs-string">&#x27;B&#x27;</span>) &lt;&lt; endl;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Milena-and-Admirer"><a href="#B-Milena-and-Admirer" class="headerlink" title="B. Milena and Admirer"></a>B. Milena and Admirer</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>允许不断的差分一个数组中的值，问至少需要拆多少次，才能让数组非递减</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>也比较简单，从后往前遍历，如果当前值比后面的值大，则均匀的拆成 $x$ 份，使得恰好比后面的值小或者相同即可</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) cin &gt;&gt; i;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-keyword">if</span> (data[i] &gt; data[i + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-type">const</span> <span class="hljs-type">int</span> cut = data[i] / data[i + <span class="hljs-number">1</span>] + (data[i] % data[i + <span class="hljs-number">1</span>] == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>);<br>                data[i] /= cut;<br>                ans += cut - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Colorful-Grid"><a href="#C-Colorful-Grid" class="headerlink" title="C. Colorful Grid"></a>C. Colorful Grid</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个棋盘，允许在棋盘的边上染色，然后使得从最左上角到最右下角的某一条路径长度恰好为 $k$ 的同时，路径上一定上红蓝间隔染色的</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>即然可以重复点，那么最好的办法是找一个可以旋转的环，在里面转到足够多次就行。</p><p>因为需要红蓝间隔，那么必然最小的环就是 $4$ 个单位长度的格子，所以如果 $k$ 恰好是最短的距离加上 $4n$ 的话，就可以这样解决</p><p>但是还有一种情况，也就是不满足 $4n$ 的时候，例如 $3 \times 2$ 的方格，走 5 步，也是可以到达的（可以自己绘制一下）</p><p>故所以需要兼容上面的两种情况，我给出的一种解法如下</p><p><img src="/image/acm/codeforces/CodeforcesRound910/C1.jpeg" alt="C1"></p><p>首先根据矩形的长边，旋选择左边或者右边的，然后固定将左上角绘制成上述形状，然后再补充移动到右下角的路径即可</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, m, k;<br>        cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> mi = n - <span class="hljs-number">1</span> + m - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (k &lt; mi) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-type">const</span> <span class="hljs-type">int</span> cut = k - mi; cut != <span class="hljs-number">0</span> &amp;&amp; cut % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span> &amp;&amp; m == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">if</span> (k % <span class="hljs-number">4</span> != <span class="hljs-number">2</span>) cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;B\nB\nR R&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; <span class="hljs-built_in">a</span>(n), <span class="hljs-built_in">b</span>(n - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: a) i.<span class="hljs-built_in">resize</span>(m - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: b) i.<span class="hljs-built_in">resize</span>(m);<br><br>        <span class="hljs-keyword">if</span> (n &gt;= m) &#123;<br>            a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = a[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = a[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>] = b[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;B&#x27;</span>;<br>            b[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = b[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = b[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;R&#x27;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m - <span class="hljs-number">1</span>; ++i) a[<span class="hljs-number">2</span>][i] = a[<span class="hljs-number">2</span>][i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;R&#x27;</span> ? <span class="hljs-string">&#x27;B&#x27;</span> : <span class="hljs-string">&#x27;R&#x27;</span>;<br>            <span class="hljs-type">const</span> <span class="hljs-type">char</span> last = b[<span class="hljs-number">1</span>][m - <span class="hljs-number">1</span>];<br>            b[<span class="hljs-number">1</span>][m - <span class="hljs-number">1</span>] = a[<span class="hljs-number">2</span>][m - <span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) b[i][m - <span class="hljs-number">1</span>] = b[i - <span class="hljs-number">1</span>][m - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;R&#x27;</span> ? <span class="hljs-string">&#x27;B&#x27;</span> : <span class="hljs-string">&#x27;R&#x27;</span>;<br>            b[<span class="hljs-number">1</span>][m - <span class="hljs-number">1</span>] = last;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = b[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = b[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = b[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;R&#x27;</span>;<br>            a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = a[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;B&#x27;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) b[i][<span class="hljs-number">2</span>] = b[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;R&#x27;</span> ? <span class="hljs-string">&#x27;B&#x27;</span> : <span class="hljs-string">&#x27;R&#x27;</span>;<br>            <span class="hljs-type">const</span> <span class="hljs-type">char</span> last = a[n - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>            a[n - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = b[n - <span class="hljs-number">2</span>][<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; m - <span class="hljs-number">1</span>; ++i) a[n - <span class="hljs-number">1</span>][i] = a[n - <span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;R&#x27;</span> ? <span class="hljs-string">&#x27;B&#x27;</span> : <span class="hljs-string">&#x27;R&#x27;</span>;<br>            a[n - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = last;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; i: a) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; j: i) cout &lt;&lt; (j ? j : <span class="hljs-string">&#x27;R&#x27;</span>) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>            cout &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; i: b) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; j: i) cout &lt;&lt; (j ? j : <span class="hljs-string">&#x27;R&#x27;</span>) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>            cout &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Absolute-Beauty"><a href="#D-Absolute-Beauty" class="headerlink" title="D. Absolute Beauty"></a>D. Absolute Beauty</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>有两个数组，允许交换 $b$ 数组中的两个值一次，问使得 $\sum^n_{i=1} \left | a_i - b_i \right |$ 最大的可能是多少</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>首先得画几个图来理解，为了方便，此处先假定 $a_i &lt; b_i$（后续可以证明可以恒定满足此等式）</p><p>那么可以得到主要有两种情况</p><p><img src="/image/acm/codeforces/CodeforcesRound910/D1.jpeg" alt="D1"></p><p>可见，只有右边的情况是能够真正有意义的，有意义的部分是 $a_j - b_i$</p><p>那么就需要找到最大的 $a_j - b_i$ 即可</p><p>然后我们再来看看如何证明最开始说的 $a_i &lt; b_i$。你可以尝试将图里的 $a,b$ 交换位置，你会发现对最终的结果没有影响</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span>, <span class="hljs-title">b</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: a) cin &gt;&gt; i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: b) cin &gt;&gt; i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (a[i] &gt; b[i]) <span class="hljs-built_in">swap</span>(a[i], b[i]);<br><br>        <span class="hljs-type">int</span> mib = <span class="hljs-number">0</span>, maa = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (b[i] &lt; b[mib]) mib = i;<br>            <span class="hljs-keyword">if</span> (a[i] &gt; a[maa]) maa = i;<br>        &#125;<br><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) ans += <span class="hljs-built_in">abs</span>(a[i] - b[i]);<br>        ans += <span class="hljs-built_in">max</span>(<span class="hljs-number">0LL</span>, <span class="hljs-number">2</span> * (a[maa] - b[mib]));<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="E-Sofia-and-Strings"><a href="#E-Sofia-and-Strings" class="headerlink" title="E. Sofia and Strings"></a>E. Sofia and Strings</h1><h2 id="大致题意-4"><a href="#大致题意-4" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个字符串 $a$，允许你无数次操作如下的两个方法其中之一</p><ul><li>选择其中一个片段，进行排序</li><li>删掉一个指定的字符</li></ul><p>问是否能够变成 $b$ 字符串</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>这里的选择片段排序，实际上最有用的就是选择两个相邻的字母排序，这样就可以最小的改动的情况下，将一个值往前移动</p><p>而需要达成这个目标，就意味着每次移动的时候，前面的值都需要比当前值大，否则前面的值只能删除。</p><p>故可以考虑遍历 $b$ 的字母，找到当前可用的最小的在 $a$ 中的位置，并将前面的那些字符移动到后面（比当前字母大），或者删除</p><h2 id="AC-code-4"><a href="#AC-code-4" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, m;<br>        cin &gt;&gt; n &gt;&gt; m;<br>        string sn, sm;<br>        sn.<span class="hljs-built_in">reserve</span>(n);<br>        sm.<span class="hljs-built_in">reserve</span>(m);<br>        cin &gt;&gt; sn &gt;&gt; sm;<br>        vector&lt;queue&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">v</span>(<span class="hljs-number">26</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) v[sn[i] - <span class="hljs-string">&#x27;a&#x27;</span>].<span class="hljs-built_in">push</span>(i);<br><br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (v[sm[i] - <span class="hljs-string">&#x27;a&#x27;</span>].<span class="hljs-built_in">empty</span>()) &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-type">int</span> t = v[sm[i] - <span class="hljs-string">&#x27;a&#x27;</span>].<span class="hljs-built_in">front</span>();<br>            v[sm[i] - <span class="hljs-string">&#x27;a&#x27;</span>].<span class="hljs-built_in">pop</span>();<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; sm[i] - <span class="hljs-string">&#x27;a&#x27;</span>; ++j) <span class="hljs-keyword">while</span> (!v[j].<span class="hljs-built_in">empty</span>() &amp;&amp; v[j].<span class="hljs-built_in">front</span>() &lt; t) v[j].<span class="hljs-built_in">pop</span>();<br>        &#125;<br><br>        cout &lt;&lt; (flag ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 909 (Div. 3)</title>
    <link href="/2024/01/07/acm/codeforces/CodeforcesRound909/"/>
    <url>/2024/01/07/acm/codeforces/CodeforcesRound909/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Game-with-Integers"><a href="#A-Game-with-Integers" class="headerlink" title="A. Game with Integers"></a>A. Game with Integers</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有两个人 A/B 博弈，每次操作可以使一个值 $+1/-1$</p><p>问在 A 先操作的情况下，A 操作后恰好值可以被 3 整除，则 A 获胜，给出初始值，问 A 是否可能获胜</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>初始是 3 的倍数就不能获胜，很简单</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        cout &lt;&lt; (n % <span class="hljs-number">3</span> ? <span class="hljs-string">&quot;First&quot;</span> : <span class="hljs-string">&quot;Second&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-250-Thousand-Tons-of-TNT"><a href="#B-250-Thousand-Tons-of-TNT" class="headerlink" title="B. 250 Thousand Tons of TNT"></a>B. 250 Thousand Tons of TNT</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有 $n$ 箱 TNT，不同重量但顺序固定，有 $k$ 辆卡车，每辆卡车从第一箱 TNT 开始取，每辆车恰好分到 $\frac{n}{k}$ 个 TNT 箱。</p><p>问在所有可能的 $k$ 下，什么时候可以使得最重的卡车和最轻的卡车差值最大。</p><p>(不过，题意中题到了 MrBeast，有意思)</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>在可能的 $k$ 下，说明必须是 $n$ 的因子，因为一个数的因子不可能很多，所以暴力扫就行了</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) cin &gt;&gt; i;<br><br>        <span class="hljs-keyword">auto</span> cal = [&amp;](<span class="hljs-type">const</span> <span class="hljs-type">int</span> x) &#123;<br>            <span class="hljs-type">int</span> mi = LONG_LONG_MAX, ma = <span class="hljs-number">0</span>;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i += x) &#123;<br>                <span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; x; ++j) tmp += data[i + j];<br>                mi = <span class="hljs-built_in">min</span>(mi, tmp);<br>                ma = <span class="hljs-built_in">max</span>(ma, tmp);<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> ma - mi;<br>        &#125;;<br><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (n % i) <span class="hljs-keyword">continue</span>;<br>            ans = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">cal</span>(i), ans);<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Yarik-and-Array"><a href="#C-Yarik-and-Array" class="headerlink" title="C. Yarik and Array"></a>C. Yarik and Array</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>类似最大的连续字串和，只不过还要求必须奇偶间隔开</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>稍微改一下 dp 转移方程即可，非常简单</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) cin &gt;&gt; i;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n)</span></span>;<br>        ans[<span class="hljs-number">0</span>] = data[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> res = ans[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(data[i]) % <span class="hljs-number">2</span> ^ <span class="hljs-built_in">abs</span>(data[i - <span class="hljs-number">1</span>]) % <span class="hljs-number">2</span>) ans[i] = <span class="hljs-built_in">max</span>(data[i], ans[i - <span class="hljs-number">1</span>] + data[i]);<br>            <span class="hljs-keyword">else</span> ans[i] = data[i];<br>            res = <span class="hljs-built_in">max</span>(res, ans[i]);<br>        &#125;<br><br>        cout &lt;&lt; res &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Yarik-and-Musical-Notes"><a href="#D-Yarik-and-Musical-Notes" class="headerlink" title="D. Yarik and Musical Notes"></a>D. Yarik and Musical Notes</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组，问有多少个对满足 $(2^{b_i})^{2^{b_j}} = (2^{b_j})^{2^{b_i}}$</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2>$$\begin{cases}& (2^{b_i})^{2^{b_j}} & = & (2^{b_j})^{2^{b_i}} \\\Rightarrow & 2^{b_i \times 2^{b_j}} & = & 2^{b_j \times 2^{b_i}} \\\Rightarrow & b_i \times 2^{b_j} & = & b_j \times 2^{b_i} \\\Rightarrow & \frac{b_i}{b_j} & = & \frac{2^{b_i}}{2^{b_j}} \\\Rightarrow & \frac{b_i}{b_j} & = & 2^{b_i - b_j}\end{cases}$$<p>设 $x = b_i - b_j$，得 $b_i = x + b_j$</p><p>得到</p>$$\begin{cases}& \frac{b_j + x}{b_j} & = & 2^x \\\Rightarrow & b_j + x & = & b_j \times 2^x \\\Rightarrow & x & = & b_j \times (2^x - 1) \\\Rightarrow & b_j & = & \frac{x}{2^x - 1} \\\end{cases}$$<p>绘图可以得到</p><p><img src="/image/acm/codeforces/CodeforcesRound909/D1.png" alt="D1"></p><p>仅有 $x=0,x=1$ 有正整数解，所以显然，只能恰好相同或者恰好为 $1, 2$ 可以成对</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            ++cnt[tmp];<br>        &#125;<br><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [fst, snd]: cnt) ans += snd * (snd - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        ans += cnt[<span class="hljs-number">1</span>] * cnt[<span class="hljs-number">2</span>];<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="E-Queue-Sort"><a href="#E-Queue-Sort" class="headerlink" title="E. Queue Sort"></a>E. Queue Sort</h1><h2 id="大致题意-4"><a href="#大致题意-4" class="headerlink" title="大致题意"></a>大致题意</h2><p>每次可以把第一个值，从后往前找到第一个严格小于它的值，然后放到它后面，问操作几次可以让数组有序</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>如果说当前值已经是最小的那个，那么每次移动一定会回到第一个，所以就会无法操作，即需要保证最小的那个出现的时候，后面的都得是有序的即可</p><h2 id="AC-code-4"><a href="#AC-code-4" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) cin &gt;&gt; i;<br>        <span class="hljs-type">int</span> mi = INT_MAX;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; i: data) mi = <span class="hljs-built_in">min</span>(mi, i);<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (data[t] != mi) ++t;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = t + <span class="hljs-number">1</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (data[i] &lt; data[i - <span class="hljs-number">1</span>]) flag = <span class="hljs-literal">false</span>;<br>        cout &lt;&lt; (flag ? t : <span class="hljs-number">-1</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="F-Alex’s-whims"><a href="#F-Alex’s-whims" class="headerlink" title="F. Alex’s whims"></a>F. Alex’s whims</h1><h2 id="大致题意-5"><a href="#大致题意-5" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一棵树，每次允许操作其中一条边（保证还是树的情况下）使得每次操作后，存在两个叶子节点（仅有一条边即为叶子节点）的距离恰好为给出的值</p><p>给出一种初始的树以及相关的操作方式</p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>简单题，都串成链，然后把最后的一个点，要多少，就连到哪，这样距离 $1$ 节点的距离恰好就是给出的值</p><h2 id="AC-code-5"><a href="#AC-code-5" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, q;<br>        cin &gt;&gt; n &gt;&gt; q;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(q)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) cin &gt;&gt; i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; endl;<br>        <span class="hljs-type">int</span> cur = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; i: data) &#123;<br>            <span class="hljs-keyword">if</span> (i == cur) &#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;-1 -1 -1&quot;</span> &lt;&lt; endl;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; cur &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; i &lt;&lt; endl;<br>            cur = i;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="G-Unusual-Entertainment"><a href="#G-Unusual-Entertainment" class="headerlink" title="G. Unusual Entertainment"></a>G. Unusual Entertainment</h1><h2 id="大致题意-6"><a href="#大致题意-6" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个 $n$ 的排列的数组 $p$，以及一棵节点数为 $n$ 的树，根为 $1$ 节点</p><p>每次询问 $l, r, x$，数组中 $[l, r]$ 区间内，是否存在至少一个点 $y$，满足 $y$ 是 $x$ 的一个孩子节点或者是 $x$ 本身</p><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>我的思路和大部分人的思路不太一样，有一点比较暴力的味道。 看起来这道题就要离线处理了，那么可以考虑在树上做一遍操作把所有答案都算出来</p><p>首先，如何找到一个节点全部的孩子节点，那么就可以考虑使用树上 dfs 的方式来查找，在进入 dfs 到离开 dfs 的期间，那么遇到的点都是它的孩子</p><p>如果说此时在遍历到某个节点 $n$，这个节点在上面的数组 $p$ 的位置是 $m$，且这个 $m$ 恰好出现在了它的父节点的某个询问中，即父节点询问的区间包含 $m$<br>那么这个父节点的这个询问就是成功的，命中的。</p><p>那么我们需要维护的就是这个节点上面所有的父节点的询问。由于询问都是区间的模式，那么可以考虑用线段树维护，每个线段树的节点保存所遇到的询问的集合。</p><p>当遍历到某个树上的节点 $n$ 的时候，找出它所在 $p$ 中的 $m$，然后再看看这个 $m$ 在哪些父节点的询问中，对遇到的询问都标记为有结果即可。</p><p>通过这个方式，在进入某个节点的时候，将对这个节点的询问都放进线段树，离开的时候，都从线段树里取走，就可以实现在树上 dfs 期间，通过线段树完成搜索</p><h2 id="AC-code-6"><a href="#AC-code-6" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, q;<br>        cin &gt;&gt; n &gt;&gt; q;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>            <span class="hljs-type">int</span> v, n;<br>        &#125;;<br>        <span class="hljs-function">vector&lt;node&gt; <span class="hljs-title">edge</span><span class="hljs-params">(n * <span class="hljs-number">2</span> - <span class="hljs-number">2</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">head</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)</span>, <span class="hljs-title">pos</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;;<br>        vector&lt;vector&lt;tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">query</span>(n + <span class="hljs-number">1</span>);<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; qs;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-type">int</span> u, v;<br>            cin &gt;&gt; u &gt;&gt; v;<br>            edge[i &lt;&lt; <span class="hljs-number">1</span>] = &#123;v, head[u]&#125;;<br>            edge[i &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>] = &#123;u, head[v]&#125;;<br>            head[u] = i &lt;&lt; <span class="hljs-number">1</span>;<br>            head[v] = i &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            pos[tmp] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; ++i) &#123;<br>            <span class="hljs-type">int</span> l, r, x;<br>            cin &gt;&gt; l &gt;&gt; r &gt;&gt; x;<br>            qs.<span class="hljs-built_in">emplace_back</span>(l, r);<br>            query[x].<span class="hljs-built_in">emplace_back</span>(l, r, i);<br>        &#125;<br><br>        vector&lt;set&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">tree</span>(n * <span class="hljs-number">2</span> + <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">auto</span> get = [](<span class="hljs-type">const</span> <span class="hljs-type">int</span> l, <span class="hljs-type">const</span> <span class="hljs-type">int</span> r) &#123;<br>            <span class="hljs-built_in">return</span> (l + r) | (l != r);<br>        &#125;;<br>        function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; _add = [&amp;](<span class="hljs-type">const</span> <span class="hljs-type">int</span> l, <span class="hljs-type">const</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> <span class="hljs-type">int</span> x, <span class="hljs-type">const</span> <span class="hljs-type">int</span> y, <span class="hljs-type">const</span> <span class="hljs-type">int</span> v) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (x == l &amp;&amp; y == r) &#123;<br>                tree[<span class="hljs-built_in">get</span>(l, r)].<span class="hljs-built_in">insert</span>(v);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (y &lt;= mid) _add(l, mid, x, y, v);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt; mid) _add(mid + <span class="hljs-number">1</span>, r, x, y, v);<br>            <span class="hljs-keyword">else</span> &#123;<br>                _add(l, mid, x, mid, v);<br>                _add(mid + <span class="hljs-number">1</span>, r, mid + <span class="hljs-number">1</span>, y, v);<br>            &#125;<br>        &#125;;<br>        function&lt;<span class="hljs-type">bool</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; _del = [&amp;](<span class="hljs-type">const</span> <span class="hljs-type">int</span> l, <span class="hljs-type">const</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> <span class="hljs-type">int</span> x, <span class="hljs-type">const</span> <span class="hljs-type">int</span> y, <span class="hljs-type">const</span> <span class="hljs-type">int</span> v) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (x == l &amp;&amp; y == r) &#123;<br>                <span class="hljs-keyword">return</span> tree[<span class="hljs-built_in">get</span>(l, r)].<span class="hljs-built_in">erase</span>(v) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (y &lt;= mid) <span class="hljs-keyword">return</span> _del(l, mid, x, y, v);<br>            <span class="hljs-keyword">if</span> (x &gt; mid) <span class="hljs-keyword">return</span> _del(mid + <span class="hljs-number">1</span>, r, x, y, v);<br>            <span class="hljs-keyword">return</span> _del(l, mid, x, mid, v) &amp;&amp; _del(mid + <span class="hljs-number">1</span>, r, mid + <span class="hljs-number">1</span>, y, v);<br>        &#125;;<br>        function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;&amp;)&gt; _find = [&amp;](<span class="hljs-type">const</span> <span class="hljs-type">int</span> l, <span class="hljs-type">const</span> <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> <span class="hljs-type">int</span> v, vector&lt;<span class="hljs-type">int</span>&gt;&amp; res) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; i: tree[<span class="hljs-built_in">get</span>(l, r)]) res.<span class="hljs-built_in">push_back</span>(i);<br>            <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span>;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-type">const</span> <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>; v &lt;= mid) &#123;<br>                _find(l, mid, v, res);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v &gt; mid) &#123;<br>                _find(mid + <span class="hljs-number">1</span>, r, v, res);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-function">vector <span class="hljs-title">ans</span><span class="hljs-params">(q, <span class="hljs-literal">false</span>)</span></span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        res.<span class="hljs-built_in">reserve</span>(n);<br><br>        function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">const</span> <span class="hljs-type">int</span> u, <span class="hljs-type">const</span> <span class="hljs-type">int</span> p) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> [l, r, i]: query[u]) _add(<span class="hljs-number">1</span>, n, l, r, i);<br>            _find(<span class="hljs-number">1</span>, n, pos[u], res);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; i: res) &#123;<br>                ans[i] = <span class="hljs-literal">true</span>;<br>                _del(<span class="hljs-number">1</span>, n, qs[i].first, qs[i].second, i);<br>            &#125;<br>            res.<span class="hljs-built_in">clear</span>();<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[u]; ~i; i = edge[i].n) &#123;<br>                <span class="hljs-keyword">if</span> (edge[i].v == p) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-built_in">dfs</span>(edge[i].v, u);<br>            &#125;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> [l, r, i]: query[u]) <span class="hljs-keyword">if</span> (_del(<span class="hljs-number">1</span>, n, l, r, i)) ans[i] = <span class="hljs-literal">false</span>;<br>        &#125;;<br><br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; i: ans) cout &lt;&lt; (i ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 908 (Div. 2)</title>
    <link href="/2024/01/03/acm/codeforces/CodeforcesRound908/"/>
    <url>/2024/01/03/acm/codeforces/CodeforcesRound908/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Secret-Sport"><a href="#A-Secret-Sport" class="headerlink" title="A. Secret Sport"></a>A. Secret Sport</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有 A 和 B 两个人，他们在比赛，每一局比赛中，率先赢得 $n$ 小场的人获胜，最终赢得 $m$ 局的人获胜，给出每一小场的获胜情况，问最终谁获胜了</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>没有那么麻烦，说白了最后一个获胜的人，必定是最终获胜的人</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        string str;<br>        str.<span class="hljs-built_in">reserve</span>(n);<br>        cin &gt;&gt; str;<br>        cout &lt;&lt; str.<span class="hljs-built_in">back</span>() &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Two-Out-of-Three"><a href="#B-Two-Out-of-Three" class="headerlink" title="B. Two Out of Three"></a>B. Two Out of Three</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组 $a$，希望构建一个数组 $b$，满足下面三条中的任意两条，且仅满足两条</p><ul><li>存在一个 $i,j \in [1, n]$，满足 $a_i = a_j, b_i = 1, b_j = 2$</li><li>存在一个 $i,j \in [1, n]$，满足 $a_i = a_j, b_i = 1, b_j = 3$</li><li>存在一个 $i,j \in [1, n]$，满足 $a_i = a_j, b_i = 2, b_j = 3$</li></ul><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>注意是要仅满足两条，所以只需要满足任意两组相同的数值对即可。即存在两个数字，他们出现次数至少两次，即可</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) cin &gt;&gt; i;<br>        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; i: data) ++cnt[i];<br>        vector&lt;<span class="hljs-type">int</span>&gt; two;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [fst, snd]: cnt) &#123;<br>            <span class="hljs-keyword">if</span> (snd &gt;= <span class="hljs-number">2</span>) two.<span class="hljs-built_in">push_back</span>(fst);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (two.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> flag[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                <span class="hljs-keyword">if</span> (data[i] == two[<span class="hljs-number">0</span>]) &#123;<br>                    cout &lt;&lt; (flag[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>                    ++flag[<span class="hljs-number">0</span>];<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data[i] == two[<span class="hljs-number">1</span>]) &#123;<br>                    cout &lt;&lt; (flag[<span class="hljs-number">1</span>] == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">3</span>) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>                    ++flag[<span class="hljs-number">1</span>];<br>                &#125; <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>            &#125;<br>            cout &lt;&lt; endl;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Anonymous-Informant"><a href="#C-Anonymous-Informant" class="headerlink" title="C. Anonymous Informant"></a>C. Anonymous Informant</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个初始的数组，未知长什么样子，但是经过 $n$ 次，操作后得到了当前数组，问是否存在原来的数组</p><p>操作的方式是，选择一个 $i$，满足 $a_i = i$，并将整个数组左移 $i$ 次</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>每个值，当其恰好满足 $a_i = i$ 的时候，即可完成一次固定的移动，从最终结果我们来看，说白了就是可以从某个固定的旋转次数到另外某个固定的移动次数</p><p>那么说白了就是一个图，这样我们就可以根据旋转次数作为图的下标，建图</p><p>接下来需要找的就是拓扑后，最终旋转次数为 0 次的时候，拓扑长度最多为多少次，或者存在包含 0 节点的环即可</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) cin &gt;&gt; i;<br><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>            <span class="hljs-type">int</span> v, n;<br>        &#125;;<br>        <span class="hljs-function">vector&lt;node&gt; <span class="hljs-title">edge</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-function">vector <span class="hljs-title">head</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span>, <span class="hljs-title">deg</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (data[i] &gt; n) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">const</span> <span class="hljs-type">int</span> u = (i + <span class="hljs-number">1</span> - data[i] + n) % n;<br>            <span class="hljs-type">const</span> <span class="hljs-type">int</span> v = (u + data[i]) % n;<br>            edge[i] = &#123;v, head[u]&#125;;<br>            head[u] = i;<br>            ++deg[v];<br>        &#125;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-type">bool</span> circle = <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> maxLen = <span class="hljs-number">-1</span>;<br>        queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (!deg[i]) q.<span class="hljs-built_in">emplace</span>(i, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> [fst, snd] = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (fst == <span class="hljs-number">0</span>) maxLen = <span class="hljs-built_in">max</span>(maxLen, snd);<br>            vis[fst] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[fst]; ~i; i = edge[i].n) &#123;<br>                --deg[edge[i].v];<br>                <span class="hljs-keyword">if</span> (!deg[edge[i].v]) q.<span class="hljs-built_in">emplace</span>(edge[i].v, snd + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (deg[<span class="hljs-number">0</span>]) circle = <span class="hljs-literal">true</span>;<br><br>        cout &lt;&lt; (circle || maxLen &gt;= k ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Neutral-Tonality"><a href="#D-Neutral-Tonality" class="headerlink" title="D. Neutral Tonality"></a>D. Neutral Tonality</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>两个数组，数组 $a$ 是固定顺序，数组 $b$ 可以按照任意顺序插入到 $a$ 数组中，使得整个数组的 LIS 最短</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>这题应该才是 C 题，很简单，插入的顺序按照从大到小插入，每次插入的时候，插入到右边没有比当前值小的值处即可</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, m;<br>        cin &gt;&gt; n &gt;&gt; m;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span>, <span class="hljs-title">b</span><span class="hljs-params">(m)</span>, <span class="hljs-title">ma</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: a) cin &gt;&gt; i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: b) cin &gt;&gt; i;<br>        <span class="hljs-built_in">sort</span>(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>(), greater&lt;&gt;());<br>        ma[n - <span class="hljs-number">1</span>] = a[n - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i) ma[i] = <span class="hljs-built_in">max</span>(ma[i + <span class="hljs-number">1</span>], a[i]);<br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (j &lt; m &amp;&amp; b[j] &gt;= ma[i]) cout &lt;&lt; b[j++] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>            cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (j &lt; m) cout &lt;&lt; b[j++] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Educational Codeforces Round 157 (Rated for Div. 2)</title>
    <link href="/2024/01/01/acm/codeforces/EducationalCodeforcesRound157/"/>
    <url>/2024/01/01/acm/codeforces/EducationalCodeforcesRound157/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Treasure-Chest"><a href="#A-Treasure-Chest" class="headerlink" title="A. Treasure Chest"></a>A. Treasure Chest</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一条路上，有一个宝箱(x)和一个钥匙(y)，开始人在  0  号位置，可以携带钥匙、宝箱进行移动，但是最多只能同时携带宝箱走 $k$ 步</p><p>问最多需要走几步才能同时拥有宝箱和钥匙</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>说白了就是钥匙可以在 $[y, \inf]$ 范围内移动，而宝箱只能在 $[x-k, x+k]$ 范围内，所以需要至少走到 $max(x, y)$ 后 ，再回到 $[x-k, x+k]$ 区间内</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> x, y , k;<br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;<br>        cout &lt;&lt; <span class="hljs-built_in">max</span>(x, y) + <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, y - x - k) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Points-and-Minimum-Distance"><a href="#B-Points-and-Minimum-Distance" class="headerlink" title="B. Points and Minimum Distance"></a>B. Points and Minimum Distance</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一堆的数字，需要两两组合，变成平面上的点，然后在再逐个通过棋盘距离来连接所有点，要尽可能让线短</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>就是要避免反复走，即一会往左一会往右，另外要尽可能短。</p><p>我的构造方法是这样的，将数组按照大小拆成两半，小一点的一半和大一点的一半，然后 x 只取小一点的，然后从最小开始取，y 则从大一点的开始，然后从最小开始取即可</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n * <span class="hljs-number">2</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) cin &gt;&gt; i;<br>        <span class="hljs-built_in">sort</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>());<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">res</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) res[i] = &#123;data[i], data[n + i]&#125;;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) ans += <span class="hljs-built_in">abs</span>(res[i].first - res[i - <span class="hljs-number">1</span>].first) + <span class="hljs-built_in">abs</span>(res[i].second - res[i - <span class="hljs-number">1</span>].second);<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [fst, snd]: res) cout &lt;&lt; fst &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; snd &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Torn-Lucky-Ticket"><a href="#C-Torn-Lucky-Ticket" class="headerlink" title="C. Torn Lucky Ticket"></a>C. Torn Lucky Ticket</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个字符串组，每个字母都是数字，每个字符串的最大长度不超过 $5$ 个。</p><p>任选两个字符串连在一块，使得整个字符串的长度恰好为偶数，且拆成两半之后，再把两边的每一个数字加起来，使得两边相等</p><p>问有多少种可能</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>看数组量级，说明需要查找的方式来找匹配的值</p><p>两个字符串相同长度的时候，非常的简单统计一下即可</p><p>如果不等长，那么就有几种组合 $1+3,1+5,2+4,3+5$</p><p>最简单的方式就是枚举所有的拆法，去枚举那些长度较长的部分，并将结果写入到统计表里，然后查找即可</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) cin &gt;&gt; i;<br>    map&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, <span class="hljs-type">int</span>&gt; cnt;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) &#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-type">char</span> l: i) sum += l - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        cnt[&#123;sum, i.<span class="hljs-built_in">size</span>()&#125;]++;<br>        <span class="hljs-keyword">if</span> (i.<span class="hljs-built_in">size</span>() == <span class="hljs-number">3</span> || i.<span class="hljs-built_in">size</span>() == <span class="hljs-number">5</span> || i.<span class="hljs-built_in">size</span>() == <span class="hljs-number">4</span>) &#123;<br>            cnt[&#123;sum - (i.<span class="hljs-built_in">front</span>() - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">2</span>, i.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>&#125;]++;<br>            cnt[&#123;sum - (i.<span class="hljs-built_in">back</span>() - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">2</span>, i.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>&#125;]++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i.<span class="hljs-built_in">size</span>() == <span class="hljs-number">5</span>) &#123;<br>            cnt[&#123;sum - (i[<span class="hljs-number">4</span>] - <span class="hljs-string">&#x27;0&#x27;</span> + i[<span class="hljs-number">3</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;]++;<br>            cnt[&#123;sum - (i[<span class="hljs-number">0</span>] - <span class="hljs-string">&#x27;0&#x27;</span> + i[<span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;]++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) &#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-type">char</span> l: i) sum += l - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> iter = cnt.<span class="hljs-built_in">find</span>(&#123;sum, i.<span class="hljs-built_in">length</span>()&#125;); iter != cnt.<span class="hljs-built_in">end</span>()) ans += iter-&gt;second;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-XOR-Construction"><a href="#D-XOR-Construction" class="headerlink" title="D. XOR Construction"></a>D. XOR Construction</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组 $a$，长度 $n-1$，需要构造出一个数组长度为 $n$ 的数组，满足数组是 $[0,n-1]$ 的排列，且 $b_i \oplus b_{i+1} = a_i$</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>显然可以得到，$b_i = b_1 \oplus a_1 \oplus a_2 \oplus a_3 \dots \oplus a_{i-1}$</p><p>那么只需要枚举 $b_1$ 的值，然后去判断是否能够保证所有的 $b_i \le n$ 即可</p><p>如果找到了，那么就是答案，并不需要判断是否满足是 $[0,n-1]$ 的排列。</p><p>原因也很简单</p><ul><li>题目说明必定有答案，那么必然有一个解</li><li>假如当前值能够满足所有结果值都在 $[0, n-1]$ 后并不是正确的解（即存在重复的值了）<ul><li>那么必然还存在另外一个解不存在重复的解，假定错误的解为 $b_1$，正确的为 $b_1’$</li><li>那么必定存在一个 $i,j(i \le j)$，满足 $b_i = b_j$</li><li>那么可以得到 $b_j = b_i \oplus a_{i} \oplus a_{i+1} \oplus a_{i+2} \dots \oplus a_{j-1} = b_i$</li><li>即 $a_{i} \oplus a_{i+1} \oplus a_{i+2} \dots \oplus a_{j-1}$</li><li>那么必然就可以得到 $b_i’ \oplus a_{i} \oplus a_{i+1} \oplus a_{i+2} \dots \oplus a_{j-1} = b_j’$</li><li>即两个解都不是正确的解</li></ul></li></ul><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n - <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) cin &gt;&gt; i;<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>        <span class="hljs-type">int</span> cnt, n[<span class="hljs-number">2</span>];<br>    &#125;;<br><br>    <span class="hljs-function">vector&lt;node&gt; <span class="hljs-title">tree</span><span class="hljs-params">(n * <span class="hljs-number">32</span>)</span></span>;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">auto</span> build = [&amp;] &#123;<br>        tree[len] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-keyword">return</span> len++;<br>    &#125;;<br><br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> root = <span class="hljs-built_in">build</span>();<br><br>    <span class="hljs-keyword">auto</span> add = [&amp;](<span class="hljs-type">const</span> <span class="hljs-type">int</span> x) &#123;<br>        <span class="hljs-type">int</span> cur = root;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">30</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> v = x &amp; (<span class="hljs-number">1</span> &lt;&lt; i) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (tree[cur].n[v] == <span class="hljs-number">-1</span>) tree[cur].n[v] = <span class="hljs-built_in">build</span>();<br>            cur = tree[cur].n[v];<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">auto</span> find = [&amp;](<span class="hljs-type">const</span> <span class="hljs-type">int</span> x) &#123;<br>        <span class="hljs-type">int</span> cur = root, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">30</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> v = x &amp; <span class="hljs-number">1</span> &lt;&lt; i ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> u = v ^ <span class="hljs-number">1</span>; tree[cur].n[u] != <span class="hljs-number">-1</span>) &#123;<br>                cur = tree[cur].n[u];<br>                ans += <span class="hljs-number">1</span> &lt;&lt; i;<br>            &#125; <span class="hljs-keyword">else</span> cur = tree[cur].n[v];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;;<br><br>    <span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; i: data) &#123;<br>        tmp ^= i;<br>        <span class="hljs-built_in">add</span>(tmp);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        tmp = <span class="hljs-built_in">find</span>(i);<br>        <span class="hljs-keyword">if</span> (tmp &gt;= n) <span class="hljs-keyword">continue</span>;<br>        tmp = i;<br>        cout &lt;&lt; tmp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; j: data) &#123;<br>            tmp ^= j;<br>            cout &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; tmp;<br>        &#125;<br>        cout &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++自定义的字面量</title>
    <link href="/2024/01/01/cpp/user-defined-literals/"/>
    <url>/2024/01/01/cpp/user-defined-literals/</url>
    
    <content type="html"><![CDATA[<p>最近在看 CPP 的一些东西的时候，发现了一个非常有意思的特性。不得不说，CPP 的特性总是朝着一些奇奇怪怪的方向发展，整出了一堆奇奇怪怪的语法糖</p><p>这个特性叫 <strong><a href="https://en.cppreference.com/w/cpp/language/user_literal">User-defined literals</a></strong></p><p>非常简单的一种特性，例如很多时候我们会用一些结构体来表示内存/磁盘等大小，比如这种</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-type">size_t</span> B = <span class="hljs-number">1</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">size_t</span> KB = <span class="hljs-number">1000</span> * B;<br><span class="hljs-type">static</span> <span class="hljs-type">size_t</span> MB = <span class="hljs-number">1000</span> * KB;<br><span class="hljs-type">static</span> <span class="hljs-type">size_t</span> GB = <span class="hljs-number">1000</span> * MB;<br><span class="hljs-type">static</span> <span class="hljs-type">size_t</span> KiB = <span class="hljs-number">1024</span> * B;<br><span class="hljs-type">static</span> <span class="hljs-type">size_t</span> MiB = <span class="hljs-number">1024</span> * KiB;<br><span class="hljs-type">static</span> <span class="hljs-type">size_t</span> GiB = <span class="hljs-number">1024</span> * MiB;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Size</span> &#123;<br>    <span class="hljs-type">size_t</span> value;<br>&#125;;<br><br><span class="hljs-keyword">inline</span> std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; o, <span class="hljs-type">const</span> Size&amp; size) &#123;<br>    <span class="hljs-keyword">if</span> (size.value &lt; KiB) o &lt;&lt; size.value &lt;&lt; <span class="hljs-string">&#x27;B&#x27;</span>;<br>        <span class="hljs-comment">// NOLINTNEXTLINE(*-narrowing-conversions)</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (size.value &lt; MiB)o &lt;&lt; std::fixed &lt;&lt; std::<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-number">1.0</span> * size.value / KiB &lt;&lt; <span class="hljs-string">&quot;KiB&quot;</span>;<br>        <span class="hljs-comment">// NOLINTNEXTLINE(*-narrowing-conversions)</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (size.value &lt; GiB)o &lt;&lt; std::fixed &lt;&lt; std::<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-number">1.0</span> * size.value / MiB &lt;&lt; <span class="hljs-string">&quot;MiB&quot;</span>;<br>        <span class="hljs-comment">// NOLINTNEXTLINE(*-narrowing-conversions)</span><br>    <span class="hljs-keyword">else</span> o &lt;&lt; std::fixed &lt;&lt; std::<span class="hljs-built_in">setprecision</span>(<span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-number">1.0</span> * size.value / GiB &lt;&lt; <span class="hljs-string">&quot;GiB&quot;</span>;<br>    <span class="hljs-keyword">return</span> o;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就可以有一个表示占用大小的类型了，但是这样并不方便，因为初始化的时候还需要明确表示这个类型。但是用上这个特性之后就可以非常简单，只需要再定义几个方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">inline</span> Size <span class="hljs-keyword">operator</span> <span class="hljs-string">&quot;&quot;</span>_B(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> v) &#123;<br>    <span class="hljs-keyword">return</span> &#123;v * B&#125;;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> region 1000</span><br><br><span class="hljs-keyword">inline</span> Size <span class="hljs-keyword">operator</span> <span class="hljs-string">&quot;&quot;</span>_KB(<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> v) &#123;<br>    <span class="hljs-keyword">return</span> &#123;v * KB&#125;;<br>&#125;<br><br><span class="hljs-keyword">inline</span> Size <span class="hljs-keyword">operator</span> <span class="hljs-string">&quot;&quot;</span>_MB(<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> v) &#123;<br>    <span class="hljs-keyword">return</span> &#123;v * MB&#125;;<br>&#125;<br><br><span class="hljs-keyword">inline</span> Size <span class="hljs-keyword">operator</span> <span class="hljs-string">&quot;&quot;</span>_GB(<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> v) &#123;<br>    <span class="hljs-keyword">return</span> &#123;v * GB&#125;;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> endregion</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> region 1024</span><br><br><span class="hljs-keyword">inline</span> Size <span class="hljs-keyword">operator</span> <span class="hljs-string">&quot;&quot;</span>_KiB(<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> v) &#123;<br>    <span class="hljs-keyword">return</span> &#123;v * KiB&#125;;<br>&#125;<br><br><span class="hljs-keyword">inline</span> Size <span class="hljs-keyword">operator</span> <span class="hljs-string">&quot;&quot;</span>_MiB(<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> v) &#123;<br>    <span class="hljs-keyword">return</span> &#123;v * MiB&#125;;<br>&#125;<br><br><span class="hljs-keyword">inline</span> Size <span class="hljs-keyword">operator</span> <span class="hljs-string">&quot;&quot;</span>_GiB(<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> v) &#123;<br>    <span class="hljs-keyword">return</span> &#123;v * GiB&#125;;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> endregion</span><br></code></pre></td></tr></table></figure><p>这样之后就可以直接用字面量初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> v = <span class="hljs-number">123435245</span>_KiB;<br>std::cout &lt;&lt; v &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习&amp;开发&amp;实现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 907 (Div. 2)</title>
    <link href="/2023/12/23/acm/codeforces/CodeforcesRound907/"/>
    <url>/2023/12/23/acm/codeforces/CodeforcesRound907/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Sorting-with-Twos"><a href="#A-Sorting-with-Twos" class="headerlink" title="A. Sorting with Twos"></a>A. Sorting with Twos</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>每次可以从前往后选择 $2^x$ 个值，每个值减少一，问进行无数次操作后，是否可能让整个数组变成无递减</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>简单题，只要原数组中，那些盲区仍然保持非递减即可。例如 $[3, 4]$ 这种区间，要么一起减少要么一起不减少</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) cin &gt;&gt; i;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>        pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; arr[<span class="hljs-number">4</span>] = &#123;&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">7</span>&#125;, &#123;<span class="hljs-number">8</span>, <span class="hljs-number">15</span>&#125;, &#123;<span class="hljs-number">16</span>, <span class="hljs-number">31</span>&#125;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [l, r]: arr) &#123;<br>            <span class="hljs-keyword">for</span> (; l &lt; <span class="hljs-built_in">min</span>(r, n - <span class="hljs-number">1</span>); ++l) &#123;<br>                <span class="hljs-keyword">if</span> (data[l] &gt; data[l + <span class="hljs-number">1</span>]) &#123;<br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        cout &lt;&lt; (flag ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Deja-Vu"><a href="#B-Deja-Vu" class="headerlink" title="B. Deja Vu"></a>B. Deja Vu</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>给出两个数组，对于第一个数组 $a$ 的每一个值，进行如下操作：</p><ul><li>从前往后遍历数组 $b$</li><li>若 $a_i \space mod \space 2^{b_i} = 0$ 则 $a_i \leftarrow a_i + 2^{b_i - 1}$</li></ul><p>求最终数组</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>数据量很大，但是有技巧</p><p>因为一旦满足 $a_i \space mod \space 2^{b_i} = 0$ 之后，会加上的是 $2^{b_i - 1}$。<br>这也就意味着，如此操作之后，其必然可以被 $2^{b_i - 1}$ 整除，且最大只能被它整除了。<br>也就是说，每次能够加上的值一定是不断变小的</p><p>题目中给出的 $b_i \in [1, 30]$ 所以其实第二个数组最多只能有 30 个有效值。处理之后暴力即可</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, q;<br>        cin &gt;&gt; n &gt;&gt; q;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span>, query</span>;<br>        query.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">30</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) cin &gt;&gt; i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || tmp &lt; query.<span class="hljs-built_in">back</span>()) query.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> j: query) <span class="hljs-keyword">if</span> (i % (<span class="hljs-number">1</span> &lt;&lt; j) == <span class="hljs-number">0</span>) i += <span class="hljs-number">1</span> &lt;&lt; j - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cout &lt;&lt; data[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Smilo-and-Monsters"><a href="#C-Smilo-and-Monsters" class="headerlink" title="C. Smilo and Monsters"></a>C. Smilo and Monsters</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一堆怪物窝，每个怪物窝里有一定数量的怪物。你有一个累计的技能点数，初始值为 0，每次可以选择不同的技能</p><ul><li>找一个怪物窝，打死里面的一只怪物，积累一点技能点数</li><li>找一个怪物窝，里面的怪物数量不大于你的技能点数，消耗全部的技能点数释放大招，消灭这个窝里的全部怪物</li></ul><p>问最少需要几次操作</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>对于一个窝而言，只需要打死里面的一半的怪物，再加上一次使用技能，就可以实现打败这个窝了，此时成本为 $\left \lceil \frac{x}{2} \right \rceil + 1$</p><p>如果有两个窝，假设都这样操作，那么代价就是 $\left \lceil \frac{x}{2} \right \rceil + \left \lceil \frac{y}{2} \right \rceil + 2$</p><p>假如我将小一点的那个窝全部一只只打死，然后打几只大窝里的怪，再对大一点对窝释放大招，也就是只使用一次技能，代价就是 $x + (\left \lceil \frac{y+x}{2} \right \rceil - x) + 1 = \left \lceil \frac{y+x}{2} \right \rceil + 1$</p><p>显然，后者价值更高，所以要考虑按照后者的操作进行，即多用小窝的怪刷技能点，然后对大窝放技能。用双指针做就行了</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: data) cin &gt;&gt; i;<br>        <span class="hljs-built_in">sort</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>, x = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>            <span class="hljs-keyword">if</span> (x &gt;= data[r]) &#123;<br>                data[r] = <span class="hljs-number">0</span>;<br>                x = <span class="hljs-number">0</span>;<br>                --r;<br>                ++ans;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">const</span> <span class="hljs-type">int</span> tmp = l == r ? (x + data[l] + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> - x : <span class="hljs-built_in">min</span>(data[l], data[r] - x);<br>                x += tmp;<br>                ans += tmp;<br>                data[l] -= tmp;<br>                <span class="hljs-keyword">if</span> (!data[l]) ++l;<br>            &#125;<br>        &#125;<br><br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Suspicious-logarithms"><a href="#D-Suspicious-logarithms" class="headerlink" title="D. Suspicious logarithms"></a>D. Suspicious logarithms</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>定义两个函数，$f(x) = y, g(x) = z$，满足 $2^y \leq x, y^z \leq z$，且 $y, z$ 都尽可能大</p><p>给出一个区间，求 $\sum_{i=l}^{r} g(i)$</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>虽然看起来很难，但是观察可以发现，$y \in [1, 64]$，而 $z \in [0, 10]$，所以只需要枚举所有的 $y, z$ 即可</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    map&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, <span class="hljs-type">int</span>&gt; mp;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; <span class="hljs-number">60</span>; ++i) &#123;<br>        <span class="hljs-type">const</span> __int128 ml = <span class="hljs-number">1ll</span> &lt;&lt; i, mr = <span class="hljs-number">1ll</span> &lt;&lt; i + <span class="hljs-number">1</span>;<br>        __int128 base = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">10</span>; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (base &gt;= mr) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span> (base * i &lt;= ml) &#123;<br>                base *= i;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            mp.<span class="hljs-built_in">insert</span>(&#123;&#123;<span class="hljs-built_in">max</span>(ml, base), <span class="hljs-built_in">min</span>(mr, base * i) - <span class="hljs-number">1</span>&#125;, j&#125;);<br>            base *= i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> l, r;<br>        cin &gt;&gt; l &gt;&gt; r;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [fst, snd]: mp) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-type">int</span> len = <span class="hljs-built_in">min</span>(fst.second, r) - <span class="hljs-built_in">max</span>(fst.first, l) + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            ans = (ans + len * snd % mod) % mod;<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 916 (Div. 3)</title>
    <link href="/2023/12/20/acm/codeforces/CodeforcesRound916/"/>
    <url>/2023/12/20/acm/codeforces/CodeforcesRound916/</url>
    
    <content type="html"><![CDATA[<p>这场本来是想在比赛的时候写的，可惜写到一半突然有公司的电话进来了，就只好先去处理点事情了</p><h1 id="A-Problemsolving-Log"><a href="#A-Problemsolving-Log" class="headerlink" title="A. Problemsolving Log"></a>A. Problemsolving Log</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>写出 A 题需要思考 1min，写出 B 题需要思考 2min，以此类推，给出一个人每分钟在思考的题，问最终有几道题能写出来</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>简单题，统计一下每个字母出现次数就行了</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        string str;<br>        str.<span class="hljs-built_in">reserve</span>(n);<br>        cin &gt;&gt; str;<br>        map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp;c: str) mp[c]++;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> i = <span class="hljs-string">&#x27;A&#x27;</span>; i &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>; ++i)<br>            <span class="hljs-keyword">if</span> (mp[i] &gt;= i - <span class="hljs-string">&#x27;A&#x27;</span> + <span class="hljs-number">1</span>) ans++;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Preparing-for-the-Contest"><a href="#B-Preparing-for-the-Contest" class="headerlink" title="B. Preparing for the Contest"></a>B. Preparing for the Contest</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>需要构造一个长度为 n 的序列，使得其满足所有相邻两个值中，存在恰好 k 个前者大于后者的对数</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>也是简单题，想清楚怎么构造就行。比如我的思路是把最大的 k 个值按照递增序放在后面</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n &gt;&gt; k;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - k; i &gt; <span class="hljs-number">0</span>; --i) cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - k + <span class="hljs-number">1</span>; i &lt;= n; ++i) cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Quests"><a href="#C-Quests" class="headerlink" title="C. Quests"></a>C. Quests</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一堆问题，第一次写出来可以得到 $a_i$ 的分数，第二次及之后写出来可以得到 $b_i$ 的分数</p><p>每道题写出来的前提是前面的所有题至少都写出来一次</p><p>问最多写 $x$ 道题，最多可以得到多少分</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>由于每道题必须要前面的所有题都写出来才能写，所以可以考虑枚举最终写到了哪道题，然后把剩下的所有写题的机会给那个 $b_i$ 最大的题即可</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span>, <span class="hljs-title">b</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp;i: a) cin &gt;&gt; i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp;i: b) cin &gt;&gt; i;<br><br>        <span class="hljs-type">int</span> ma = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>, suf = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">min</span>(n, k); ++i) &#123;<br>            suf += a[i];<br>            ma = <span class="hljs-built_in">max</span>(ma, b[i]);<br>            ans = <span class="hljs-built_in">max</span>(ans, suf + (k - i - <span class="hljs-number">1</span>) * ma);<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Three-Activities"><a href="#D-Three-Activities" class="headerlink" title="D. Three Activities"></a>D. Three Activities</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>有三种活动，且有 $n$ 天，每一天最多参加一个活动，每一个活动最多只能有一天参加。</p><p>每个活动每天都有其他伙伴一起来参加，数量都不相同。问应该挑哪三天去参加活动，能够使得一起参加的伙伴数量最多</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>由于总共就只有三种活动，所以只需要挑选三天。对于每一个活动而言，他们只需要考虑参加伙伴最多的那三天即可</p><p>所以在每一个活动下单独排序参加的伙伴数量，选择每个活动下伙伴最多的三天，暴力找下答案即可</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">a</span>(n), <span class="hljs-built_in">b</span>(n), <span class="hljs-built_in">c</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp;i: a) cin &gt;&gt; i.first;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp;i: b) cin &gt;&gt; i.first;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp;i: c) cin &gt;&gt; i.first;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) a[i].second = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) b[i].second = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) c[i].second = i;<br><br>        <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), greater&lt;&gt;());<br>        <span class="hljs-built_in">sort</span>(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>(), greater&lt;&gt;());<br>        <span class="hljs-built_in">sort</span>(c.<span class="hljs-built_in">begin</span>(), c.<span class="hljs-built_in">end</span>(), greater&lt;&gt;());<br><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (b[j].second == a[i].second) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">3</span>; ++k) &#123;<br>                    <span class="hljs-keyword">if</span> (c[k].second == a[i].second || c[k].second == b[j].second) <span class="hljs-keyword">continue</span>;<br>                    ans = <span class="hljs-built_in">max</span>(ans, a[i].first + b[j].first + c[k].first);<br>                &#125;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="E2-Game-with-Marbles-Hard-Version"><a href="#E2-Game-with-Marbles-Hard-Version" class="headerlink" title="E2. Game with Marbles (Hard Version)"></a>E2. Game with Marbles (Hard Version)</h1><h2 id="大致题意-4"><a href="#大致题意-4" class="headerlink" title="大致题意"></a>大致题意</h2><p>直接看 Hard Version</p><p>Alice 和 Bob 做游戏，有 $n$ 种颜色的石头，每个人都有所有颜色的石头若干个</p><p>每轮，当前的选手需要选择一种颜色，然后当前选手丢掉一个这种颜色的石头，对方丢掉全部的</p><p>目标是让自己的石头数量之和尽可能多，问最后剩下多少个</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>假如一种颜色的石头，Alice 有 $a$ 个，Bob 有 $b$ 个。如果是 Alice 选择，那么 Alice 会剩下 $a-1$ 个，差值是 $a-1$。如果是 Bob 选择，则是 $-(b-1)$</p><p>这样可以得到，不选择这个颜色的代价就是 $(a-1)-(-(b-1)) = (a+b-2)$，同时选择它的收益也是这个</p><p>按照代价排序，从最大的代价依次开始操作即可</p><h2 id="AC-code-4"><a href="#AC-code-4" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span>, <span class="hljs-title">b</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp;i: a) cin &gt;&gt; i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp;i: b) cin &gt;&gt; i;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">d</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            d[i].first = a[i] + b[i] - <span class="hljs-number">2</span>;<br>            d[i].second = i;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(d.<span class="hljs-built_in">begin</span>(), d.<span class="hljs-built_in">end</span>(), greater&lt;&gt;());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) &#123;<br>                b[d[i].second]--;<br>                a[d[i].second] = <span class="hljs-number">0</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                a[d[i].second]--;<br>                b[d[i].second] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) ans += a[i] - b[i];<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="F-Programming-Competition"><a href="#F-Programming-Competition" class="headerlink" title="F. Programming Competition"></a>F. Programming Competition</h1><h2 id="大致题意-5"><a href="#大致题意-5" class="headerlink" title="大致题意"></a>大致题意</h2><p>一个公司，其上级或者间接的上级都是他老板，现在需要两两组队，但是有老板关系的不能组，问最多可以组几个队伍</p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>树上 dfs 搜索即可，每次传给当前节点，外面不属于他的员工的节点数量还有多少，有就用掉即可</p><h2 id="AC-code-5"><a href="#AC-code-5" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(n)</span>, <span class="hljs-title">d</span><span class="hljs-params">(n)</span></span>;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">tree</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            tree[tmp - <span class="hljs-number">1</span>].<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br><br>        function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>)&gt; deep = [&amp;](<span class="hljs-type">const</span> <span class="hljs-type">int</span> v) &#123;<br>            d[v] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; i: tree[v]) d[v] += <span class="hljs-built_in">deep</span>(i);<br>            <span class="hljs-keyword">return</span> d[v];<br>        &#125;;<br><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">const</span> <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> cnt) &#123;<br>            ans += cnt &gt; <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (cnt &gt; <span class="hljs-number">0</span>) --cnt;<br><br>            <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: tree[v]) sum += d[i];<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: tree[v]) <span class="hljs-built_in">dfs</span>(i, sum - d[i] + cnt);<br>        &#125;;<br><br>        <span class="hljs-comment">// ReSharper disable once CppExpressionWithoutSideEffects</span><br>        <span class="hljs-built_in">deep</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        cout &lt;&lt; ans / <span class="hljs-number">2</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="G2-Light-Bulbs-Hard-Version"><a href="#G2-Light-Bulbs-Hard-Version" class="headerlink" title="G2. Light Bulbs (Hard Version)"></a>G2. Light Bulbs (Hard Version)</h1><h2 id="大致题意-6"><a href="#大致题意-6" class="headerlink" title="大致题意"></a>大致题意</h2><p>这题还是挺有意思的</p><p>有一排灯，其中每种颜色的灯恰好有两个，可以选择开始的时候，点亮一部分灯，之后可以无限次进行如下操作</p><ul><li>点亮一盏灯，前提是和他相同颜色的另一盏灯已经点亮了</li><li>选择一种颜色，其两盏灯都已经点亮了，将这两盏灯中间的所有灯点亮</li></ul><p>问开始的时候最少选择几盏灯，就可以把所有灯都点亮。同时给出可以选择的数量</p><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>首先，如果存在一个 $a$ 夹在两个 $b$ 之间，那么只需要点亮 $b$ 就可以点亮 $a$，我们可以进行建图来做</p><p>但是如果这样完整建图的成本会很高，所以得考虑优化一下<br>例如 $1,2,3,4,1,2,3,4$ 这种，就会变成一个全连接的图，而点数量有 $2 \times 10^5$，故不太行</p><p>由于这个图并不是传统的拓扑排序，而是只要上游任意一个点满足则满足（传统拓扑是上游均满足才满足）所以可以做反向路径压缩，即“别压缩”</p><p>例如上面的例子，仅实现与最后出现的那个区间进行连接，例如上图，则仅有 $1 \rightarrow 2 \rightarrow 3 \rightarrow 4 \rightarrow 1$，<br>容易的得到这样建图也是可以满足要求的，因为不是传统拓扑</p><p>那么只需要在创建完成图之后，将拓扑的首个节点序列拿出来即可，这些节点是必选。因为有两个相同颜色的灯，所以是 $2^x$ 种选择</p><p>接下来考虑成环的情况，我们只需要找出最初试图进入环的那个节点（最左边的节点，因为它必然可以连接到剩下所有的节点）<br>看剩下环内的节点是否能够反向到达它即可。可以反向建图来做。至于最初进入环的节点，可以用并查集</p><h2 id="AC-code-6"><a href="#AC-code-6" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>            <span class="hljs-type">int</span> v, n;<br>        &#125;;<br>        stack&lt;<span class="hljs-type">int</span>&gt; st;<br>        vector&lt;node&gt; edge, redge;<br>        <span class="hljs-function">vector <span class="hljs-title">head</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)</span>, <span class="hljs-title">rhead</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)</span>, <span class="hljs-title">deg</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span>, <span class="hljs-title">fa</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span>, <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        edge.<span class="hljs-built_in">reserve</span>(n);<br>        redge.<span class="hljs-built_in">reserve</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; fa.<span class="hljs-built_in">size</span>(); ++i) fa[i] = i;<br>        function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>)&gt; finds = [&amp;](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> fa[x] == x ? x : fa[x] = <span class="hljs-built_in">finds</span>(fa[x]); &#125;;<br>        function join = [&amp;](<span class="hljs-type">const</span> <span class="hljs-type">int</span> x, <span class="hljs-type">const</span> <span class="hljs-type">int</span> y) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-type">int</span> rx = <span class="hljs-built_in">finds</span>(x), ry = <span class="hljs-built_in">finds</span>(y);<br>            <span class="hljs-keyword">if</span> (rx == ry) <span class="hljs-keyword">return</span>;<br>            fa[rx] = ry;<br>        &#125;;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n * <span class="hljs-number">2</span>; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; vis[st.<span class="hljs-built_in">top</span>()] == <span class="hljs-number">2</span>) st.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; st.<span class="hljs-built_in">top</span>() != tmp) &#123;<br>                <span class="hljs-built_in">join</span>(tmp, st.<span class="hljs-built_in">top</span>());<br>                edge.<span class="hljs-built_in">push_back</span>(&#123;tmp, head[st.<span class="hljs-built_in">top</span>()]&#125;);<br>                head[st.<span class="hljs-built_in">top</span>()] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(edge.<span class="hljs-built_in">size</span>()) - <span class="hljs-number">1</span>;<br>                deg[tmp]++;<br><br>                redge.<span class="hljs-built_in">push_back</span>(&#123;st.<span class="hljs-built_in">top</span>(), rhead[tmp]&#125;);<br>                rhead[tmp] = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(redge.<span class="hljs-built_in">size</span>()) - <span class="hljs-number">1</span>;<br>            &#125;<br>            st.<span class="hljs-built_in">push</span>(tmp);<br>            ++vis[tmp];<br>        &#125;<br><br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) <span class="hljs-keyword">if</span> (deg[i] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(i);<br>        <span class="hljs-keyword">constexpr</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> mod = <span class="hljs-number">998244353</span>;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> res = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(q.<span class="hljs-built_in">size</span>());<br><br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            ans &lt;&lt;= <span class="hljs-number">1</span>;<br>            ans %= mod;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-type">int</span> cur = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (vis[cur] == <span class="hljs-number">3</span>) <span class="hljs-keyword">continue</span>;<br>            ++vis[cur];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[cur]; ~i; i = edge[i].n) q.<span class="hljs-built_in">push</span>(edge[i].v);<br>        &#125;<br><br>        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; superCnt;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) <span class="hljs-keyword">if</span> (vis[i] != <span class="hljs-number">3</span> &amp;&amp; <span class="hljs-built_in">finds</span>(i) == i) q.<span class="hljs-built_in">push</span>(i);<br><br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-type">int</span> cur = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (vis[cur] == <span class="hljs-number">3</span>) <span class="hljs-keyword">continue</span>;<br>            ++vis[cur];<br>            superCnt[<span class="hljs-built_in">finds</span>(cur)]++;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = rhead[cur]; ~i; i = redge[i].n)<br>                q.<span class="hljs-built_in">push</span>(redge[i].v);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [k, v]: superCnt) ans = ans * <span class="hljs-number">2</span> * v % mod;<br><br>        cout &lt;&lt; (res + superCnt.<span class="hljs-built_in">size</span>()) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于 LRU map 的一些灵感</title>
    <link href="/2023/12/18/thoughts/lru-map/"/>
    <url>/2023/12/18/thoughts/lru-map/</url>
    
    <content type="html"><![CDATA[<p>最近在折腾一些小项目，让我突然有了一些对 LRU map 的想法</p><h3 id="传统的-LRU-map-的实现"><a href="#传统的-LRU-map-的实现" class="headerlink" title="传统的 LRU map 的实现"></a>传统的 LRU map 的实现</h3><p>一般常见的 LRU map 的实现大概是长这样</p><p><img src="/image/thoughts/lru-map/LRUMap.png" alt="LRUMap"></p><p>通过一个 HashMap 来实现对值的快速访问，但是 Map 中记录的值并不是原始的值， 当然也有可能包含原始的值，但是至少会记录一个链表的节点地址</p><p>每次进行读取/写入操作的时候， 需要将对应链表的那个节点，移动到链表的尾部</p><p>当需要进行逐出值的时候，就从链表的头部取出值进行逐出，因为链表的头处的值必然是最久没有访问过的值了</p><h3 id="一些新的想法"><a href="#一些新的想法" class="headerlink" title="一些新的想法"></a>一些新的想法</h3><p>最近想到了一种新的解决 LRU map 的方法，即不再需要链表来做关联映射。而是准备一个队列。HashMap 中的值不再携带链表的地址，而是记录实际的最后访问时间</p><p>每次进行读取/写入操作的时候，都修改 HashMap 中的此节点的最后操作时间，然后同时将这次读取/写入操作的 key 和时间写入队列</p><p>每次需要逐出值的时候，就重复从队列里取值，然后判断一下队列中节点记录的操作时间和实际在 HashMap 中的时间是否一致，如果一致的话那就可以逐出，否则就不逐出，继续从队列中取值</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随想</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023 杭州站 ICPC 现场赛</title>
    <link href="/2023/12/11/acm/2023-XCPC-offline/2023-12-10-Hangzhou/"/>
    <url>/2023/12/11/acm/2023-XCPC-offline/2023-12-10-Hangzhou/</url>
    
    <content type="html"><![CDATA[<h1 id="背景故事"><a href="#背景故事" class="headerlink" title="背景故事"></a>背景故事</h1><h2 id="故事的开始"><a href="#故事的开始" class="headerlink" title="故事的开始"></a>故事的开始</h2><p>大概在 7-8 月份的时候，得知了杭州站要开的消息，开玩笑的问我的一个退役了好多好多年的同事说，要不要去申请一下当志愿者去玩一下。结果同事说：要不我们申请个外卡名额去玩一场吧</p><p>而后，就组成了三个已经退役多年的队伍，甚至已经有人退役了 6 年之久</p><p>嗯，就是这样一个没有板子没有脑子没有训练的队伍，甚至没有人会数论，准备参加 2023 的杭州站</p><h2 id="开赛前的准备"><a href="#开赛前的准备" class="headerlink" title="开赛前的准备"></a>开赛前的准备</h2><p>虽然说都是退役多年，但我最近也一直在刷 codeforces，虽然也就周末写两场 codeforces，而且也是点到为止，不过多深入写题，难题就直接摆烂的那种，毕竟我写题的目的也只是为了消遣</p><p>但是我们没有板子，我倒是可以折腾一些板子出来，但是毕竟是一个数论基础为 0 的队伍，得整点数论的板子吧，于是开始找学弟找找我当年的板子去哪了，然后就领到了一份他们多余的纯英文的板子……可惜我英语也不好啊，本来还想让他们帮忙带一份字典之类的</p><p>有一个比较重要的插曲就是，这两天恰好是双十二，于是热身赛打到一半，就又回公司去值班双十二了，结果就导致杭师大给我打的 84 块钱一分钱没花</p><h1 id="比赛"><a href="#比赛" class="headerlink" title="比赛"></a>比赛</h1><p>比赛开始之后就是找签到题，我从 A 题开始看起来的，看了一眼 A 题感觉就是个简单的模拟题，想法是把每一个队伍改到最好或者改到最差两种情况下，金牌队伍有哪些，然后统计就行</p><p>直到我看到了样例：TS1</p><p>只能说不愧是出题人，还很好的暗示了一下宁理</p><h2 id="M"><a href="#M" class="headerlink" title="M"></a>M</h2><p><a href="https://codeforces.com/gym/492111/problem/M">题面</a></p><p>然后就看到开始有人过了 M 题，果断刷了一眼 M 题的题意，发现其实很简单，只需要考虑三种情况就行了</p><ul><li>整个数组都要</li><li>V 图左边只取最小的，右边取全部</li><li>V 图右边只取最小的，左边取全部</li></ul><p>然后对这三种情况找最优解就行了</p><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p><a href="https://codeforces.com/gym/492111/problem/D">题面</a></p><p>很快就发现了 D 题也有很多人过了，于是决定投入一个人去解决，剩下的继续看看别的题</p><h2 id="J"><a href="#J" class="headerlink" title="J"></a>J</h2><p><a href="https://codeforces.com/gym/492111/problem/J">题面</a></p><p>然后就两个人去跟榜了 J 题，一开始确实很难有头绪，不过自从有了热身赛的 C 题的经验之后，很快就有一个解决想法：</p><ul><li>每两个相邻节点做一次询问，比如 <code>1, 2</code> 询问一下，然后再 <code>3, 4</code> 如此询问</li><li>如果都没有边，说明了绝对不可能是菊花<ul><li>毕竟菊花一定有一个点与所有点相连，那么必然在这次遍历中一定会出现菊花中心点和其他点的连接情况询问</li></ul></li><li>如果有任何一条边的情况下，那么就可以考虑一下是否是菊花了（因为我们找到一条边了）<ul><li>随便再找两个点，看看是否和得到的这条边的某个点是否都连接，如果是的话，那么就是菊花</li><li>如果有任何一个点不是的话，那么就看看另外一个点是否有这个特性</li><li>如果都没有这个特性，那么就是链</li></ul></li></ul><h2 id="H"><a href="#H" class="headerlink" title="H"></a>H</h2><p><a href="https://codeforces.com/gym/492111/problem/H">题面</a></p><p>H 题队友看了之后表示是一道概率题，大概率是写不出来的，毕竟三个完全不会数论了，加之过的人也不多。所以决定都去刷刷 D 题，看看能不能写出来</p><p>研究了一个多小时之后，我放弃了，决定去瞄一眼 H 题看看怎么样。稍微看了一会，感觉好像不是很难，是一道图论题</p><ul><li>建图<ul><li>若 A 依赖 B，且当前 A 的糖果比 B 多，但是在 B 获得糖果之后，A 就比 B 少的情况下，建立 B 到 A 的边</li><li>若 A 依赖 B，且无论 B 是否获得糖果，当前 A 的糖果比 B 多的情况下，将 A 的概率(p)标记为 0</li><li>若 A 依赖 B，且无论 B 是否获得糖果，当前 A 的糖果比 B 少的情况下，将 A 的概率(p)标记为 1</li></ul></li><li>拓扑遍历所有的点<ul><li>若这个点已经被标记为 0，则不再继续拓扑接下来的节点</li><li>若这个节点已经被标记为 x，则为其下面的节点的概率(p)标记为 (x+1)</li></ul></li></ul><p>最后，再求解每一个值，为 $(a_i + w_i * \frac{1}{A^p_p}) mod M$</p><p>为什么是这样算的：</p><p>假定 A 通过和 B 进行比较糖果，才能确定其是否能拿到糖果的场景下</p><ul><li>无论 B 是否获得糖果，当前 A 的糖果比 B 多的情况下，那么必然一定拿不到糖果，那么 A 的拿到概率就是 0，那么答案就是 $a_i$</li><li>无论 B 是否获得糖果，当前 A 的糖果比 B 少的情况下，那么必然一定拿得到糖果，那么 A 的拿到概率就是 1，那么答案就是 $a_i + w_i$</li></ul><p>上面两种情况都挺容易解决的，接下来是剩下的那种情况：B 要是拿到了糖果，那么 A 也可以拿到糖果，否则 A 也拿不到糖果</p><ul><li>在这种情况下，我们希望得到的是，让整个随机排列顺序的时候，尽可能让 B 在 A 之前被处理，这样的话，我们就可以得到 A 的概率就是 $\frac{1}{A^2_2}$（这非常容易证明，因为这需要最终排序的结果中，仅出现 B 在 A 前面的排列）</li><li>当然，一般依赖也不可能只有那么简单，B 可能也会依赖 C，这个时候 A 的结果就变成了必须要出现 C、B、A 这样的顺序，也就是 $\frac{1}{A^3_3}$</li><li>依次类推，可以得到距离最终的根节点有 $x$ 步，则就是 $\frac{1}{A^x_x}$ 的概率</li><li>如果成环了怎么办？也非常简单，当真的成环了之后，那么必然环内有一个节点是最终排序后，最先被处理的，那么必然不能拿到糖果，然后其依赖的节点也就拿不到糖果了，也就等于所有人都拿不到糖果了</li></ul><h2 id="G"><a href="#G" class="headerlink" title="G"></a>G</h2><p><a href="https://codeforces.com/gym/492111/problem/G">题面</a></p><p>写出 H 后感觉状态大好，看到 G 题也有不少人过了，决定也热热手，稍后再去看 D 题</p><p>去了个厕所回来看了一会 G 题，感觉就非常的简单，出题人很巧的把题意隐藏了，实际上是非常简单的题目，可以说是最简单的 BFS 练习题了</p><p>这道题最重要的是理解蛇缩短的能力，因为蛇本体会阻碍移动，所以可以通过缩短的方式去“等待”蛇身体离开想要到达的点，然后再走过去</p><p>接下来就是要考虑等多久的问题，同时需要注意的是，蛇的每一步移动都是会让蛇往前走一步。即每经过一个时间单位，无论做什么，蛇身就会缩短一节，使得释放出一个格子被允许走到，释放的顺序就是蛇的反向顺序</p><p>为什么不用考虑因为额外移动带来新的节点被阻塞的问题：因为新的节点如果被阻塞了，那么必然是已经到达过的节点了，无需重复到达</p><p>故可以得到如下结论：蛇身初始所在的每一个格子都有一个基本的费用，其费用等于这个点距离蛇尾巴的蛇上距离，即需要到达这些个节点就必须要满足实际时间大于等于这个基本费用才能到达，其他格子毫无限制，可以直接 bfs 到达，搞个优先队列即可</p><h2 id="D-1"><a href="#D-1" class="headerlink" title="D"></a>D</h2><p>最后还是回到 D 题</p><p>最终想到了一个问题，对于 $a_1 \times (a_2 + a_3) \times (a_4 + a_5) \dots$ 这个式子，如果这其中存在两对相加起来的值不为 $1, -1$ 的值的情况下，那么必然就会越乘越大，无法救回来，也难以构造</p><p>那么必然，$(a_{x} + a_{x+1})$ 的结果一定是 $1, -1$ 的，或者至少最多只有一个不是！</p><p>那么继续构造，如果要满足这种情况下，最简单的就是 $2, -1$ 和 $1, -2$ 这两组了，这个时候，可以得到乘积结果都是在 $2, -2$ 之间了，那么不妨就尽可能相加的结果接近 $0$，这样的情况下，$0 + x = 1 \times x$，这是最优雅的解决方案</p><p>所以给出下面的解决方案：</p><ul><li>若给出的 $n$ 是奇数，则最开头的两个值是 $1, 1$</li><li>若给出的 $n$ 是偶数，则最开头的四个值是 $1, 1, 1, 1$</li></ul><p>接下来根据情况进行补充</p><ul><li>如果前一个值是 $-2$，那么为了保证下面的和是 $1, -1$ 的话，就必须补充 $1$</li><li>如果前一个值是 $2$，那么为了保证下面的和是 $1, -1$ 的话，就必须补充 $-1$</li><li>如果前一个值是 $-1$，那么为了保证上面的乘积是 $2/-2$ 的话，就应当看情况补充 $-1,1$，比如之前构造了一个 $2$ 出来，那么就要补充一个 $2$ 来生成一个乘积为 $-2$ 的结果去抵消前一个构造得到的 $2$</li><li>如果前一个值是 $1$，那么为了保证上面的乘积是 $2/-2$ 的话，就应当看情况补充 $-1,1$，比如之前构造了一个 $2$ 出来，那么就要补充一个 $-2$ 来生成一个乘积为 $-2$ 的结果去抵消前一个构造得到的 $2$</li></ul><h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p><a href="https://codeforces.com/gym/492111/problem/A">题面</a></p><p>最后还是非常可惜没有能在时间内写出 A 题，本来还是有机会金的，但是毕竟大家都是很久没有写过 C 的人了，最终的结果还是让人非常满意的</p>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反复横跳的 Clang-Tidy(cert-dcl21-cpp)</title>
    <link href="/2023/12/04/cpp/cpp-cert-dcl21-cpp/"/>
    <url>/2023/12/04/cpp/cpp-cert-dcl21-cpp/</url>
    
    <content type="html"><![CDATA[<p>今天早上有些发烧，就没去上班，下午稍微好点了之后就爬起来折腾会代码，写着写着就发现了一个奇怪的东西。把代码抽出核心部分类似如下的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-type">int</span> v;<br><br>    A <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) <span class="hljs-keyword">noexcept</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">A</span>(v++); &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里返回的值是一个自身为 <code>A</code> 的右值，理论上并不需要明确指明右值（即返回值写 <code>A&amp;&amp;</code>），因为返回值本身肯定是右值，在原来的栈中如果进行赋值操作的时候，会先尝试进行移动构造，如果没有提供移动构造的情况下才会尝试进行引用构造甚至是复制构造</p><p>但是这段代码，Clang-Tidy 却给我报了 Warning: <code>Clang-Tidy: Overloaded &#39;operator++&#39; returns a non-constant object instead of a constant object type</code></p><p>大致意思是说，<code>operator++</code> 方法返回了一个非 <code>const</code> 的变量。看了下样例，大概意思是说，因为返回值是一个”临时”的类型（毕竟是一个右值，用完应该就要丢掉的）故需要 <code>const</code> 一下，避免会出现 <code>(i++)++;</code> 这种离谱的代码（后者的 <code>++</code> 是作用在返回的右值上的，实际上不会对原来的值生效）</p><p>一听，好像有点道理，自动修复一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-type">int</span> v;<br><br>    <span class="hljs-type">const</span> A <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) <span class="hljs-keyword">noexcept</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">A</span>(v++); &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>嗯，这样应该就行了吧。然后 Clang-Tidy 又给我报了个 Warning：<code>Clang-Tidy: Return type &#39;const A&#39; is &#39;const&#39;-qualified at the top level, which may reduce code readability without improving const correctness</code></p><p>蛤？又告诉我不能带 <code>const</code>，因为这可能会导致不必要的代码理解？看了下例子，也非常好理解，因为返回值是一个右值，最终（指代通常情况下）都应该被移动构造，这样的话，实际上 <code>const</code> 仅仅是对右值进行了 <code>const</code> 标识，并没有什么用处</p><p>也就是说，加也不对，不加也不对……</p><p>在翻找了一堆资料后，发现了这两个 checker 的文档：</p><ul><li><a href="https://clang.llvm.org/extra/clang-tidy/checks/cert/dcl21-cpp.html">cert-dcl21-cpp</a></li><li><a href="https://clang.llvm.org/extra/clang-tidy/checks/readability/const-return-type.html">readability-const-return-type</a></li></ul><p>其中，在前者有这样一句：</p><blockquote><p>It will be removed in clang-tidy version 19.</p></blockquote><p>嗯，再一看自己的 clang-tidy，恰好是 <code>18.0.0</code></p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 906 (Div. 2)</title>
    <link href="/2023/12/03/acm/codeforces/CodeforcesRound906/"/>
    <url>/2023/12/03/acm/codeforces/CodeforcesRound906/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Doremy’s-Paint-3"><a href="#A-Doremy’s-Paint-3" class="headerlink" title="A. Doremy’s Paint 3"></a>A. Doremy’s Paint 3</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组，重排之后，是否能够满足任意两个相邻值的只和都相同</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>只有两种可能，只有两个值，且数量相同或者恰好差一个，或者只有一个值</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            mp[tmp]++;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (mp.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mp.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">2</span>) cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> &#123;<br>            cout &lt;&lt; (<span class="hljs-built_in">abs</span>(mp.<span class="hljs-built_in">begin</span>()-&gt;second - mp.<span class="hljs-built_in">rbegin</span>()-&gt;second) &lt;= <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>)&lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Qingshan-Loves-Strings"><a href="#B-Qingshan-Loves-Strings" class="headerlink" title="B. Qingshan Loves Strings"></a>B. Qingshan Loves Strings</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有两个 $01$ 字符串，希望把 $A$ 字符串变成任意相邻两个字母不同的，每次操作允许将 $B$ 字符串插入到 $A$ 字符串的任意位置，问是否有可能</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><ul><li>首先，如果 $A$ 本来就是，那么就不用插入了</li><li>其次，若 $B$ 本身不是，那肯定不行，毕竟最后插入的字符串一定是完整的，那么最终必然会不是</li><li>然后，如果要插入，那必然是插入到两个相邻的字符内，那么必然 $B$ 的前后必须相同，且与要插入的部分不同</li></ul><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, m;<br>        cin &gt;&gt; n &gt;&gt; m;<br>        string str1, str2;<br>        str1.<span class="hljs-built_in">reserve</span>(n);<br>        str2.<span class="hljs-built_in">reserve</span>(m);<br>        cin &gt;&gt; str1 &gt;&gt; str2;<br><br>        <span class="hljs-comment">// check str 1</span><br>        <span class="hljs-type">bool</span> f[<span class="hljs-number">2</span>] = &#123;<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (str1[i] == str1[i - <span class="hljs-number">1</span>]) f[str1[i] - <span class="hljs-string">&#x27;0&#x27;</span>] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (f[<span class="hljs-number">0</span>] &amp;&amp; f[<span class="hljs-number">1</span>]) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!f[<span class="hljs-number">0</span>] &amp;&amp; !f[<span class="hljs-number">1</span>]) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// check str 2</span><br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; ++i) <span class="hljs-keyword">if</span> (str2[i] == str2[i - <span class="hljs-number">1</span>]) flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (!flag) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (f[str2[<span class="hljs-number">0</span>] - <span class="hljs-string">&#x27;0&#x27;</span>]) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (f[str2[m - <span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>]) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Qingshan-Loves-Strings-2"><a href="#C-Qingshan-Loves-Strings-2" class="headerlink" title="C. Qingshan Loves Strings 2"></a>C. Qingshan Loves Strings 2</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个 $01$ 字符串，希望将这个字符串的中间对称位置字符不同，每次操作允许往任何位置插入一个 $01$ 字符串</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>用 <code>list</code> 模拟一下就行了</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        string str;<br>        str.<span class="hljs-built_in">reserve</span>(n);<br>        cin &gt;&gt; str;<br><br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        list&lt;<span class="hljs-type">char</span>&gt; l;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item : str) l.<span class="hljs-built_in">push_back</span>(item);<br>        <span class="hljs-type">int</span> lp = <span class="hljs-number">0</span>, rp = n;<br>        <span class="hljs-keyword">auto</span> li = l.<span class="hljs-built_in">begin</span>(), ri = l.<span class="hljs-built_in">end</span>();<br>        --ri;<br><br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-keyword">while</span> (li != ri &amp;&amp; lp &lt; rp) &#123;<br>            <span class="hljs-keyword">if</span> (*li != *ri) &#123;<br>                ++li;<br>                --ri;<br>                ++lp;<br>                --rp;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (*li == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(rp);<br>                l.<span class="hljs-built_in">insert</span>(++ri, <span class="hljs-string">&#x27;0&#x27;</span>);<br>                l.<span class="hljs-built_in">insert</span>(ri, <span class="hljs-string">&#x27;1&#x27;</span>);<br>                --ri;<br>                rp += <span class="hljs-number">2</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (*ri == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(lp);<br>                l.<span class="hljs-built_in">insert</span>(li, <span class="hljs-string">&#x27;1&#x27;</span>);<br>                --li;<br>                l.<span class="hljs-built_in">insert</span>(li, <span class="hljs-string">&#x27;0&#x27;</span>);<br>                --li;<br>                rp += <span class="hljs-number">2</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (ans.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">300</span>) &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!flag) &#123;<br>            cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cout &lt;&lt; ans.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ans.<span class="hljs-built_in">size</span>(); ++i) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == ans.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Doremy’s-Connecting-Plan"><a href="#D-Doremy’s-Connecting-Plan" class="headerlink" title="D. Doremy’s Connecting Plan"></a>D. Doremy’s Connecting Plan</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个城市，每个城市都有一定的人数，现在希望在城市之间建立连接，如果满足 $\sum_{k \in S} a_k \geq i \times j \times c$，则可以建立链接，其中 $S$ 为节点 $i$ 和 $j$ 已经连通部分的所有节点集合</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>考虑所有的节点按照一定顺序和 $1$ 城市建连</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, c;<br>        cin &gt;&gt; n &gt;&gt; c;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">data</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp;item: data) cin &gt;&gt; item.first;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) data[i].second = i + <span class="hljs-number">1</span>;<br><br>        <span class="hljs-type">int</span> tot = data[<span class="hljs-number">0</span>].first;<br><br>        <span class="hljs-built_in">sort</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>(), [&amp;](<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp;lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp;rhs) &#123;<br>            <span class="hljs-keyword">return</span> lhs.first - lhs.second * c &gt; rhs.first - rhs.second * c;<br>        &#125;);<br><br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp;item: data) &#123;<br>            <span class="hljs-keyword">if</span> (item.second == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (tot + item.first &gt;= item.second * c) tot += item.first;<br>            <span class="hljs-keyword">else</span> flag = <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        cout &lt;&lt; (flag ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="E1-Doremy’s-Drying-Plan-Easy-Version"><a href="#E1-Doremy’s-Drying-Plan-Easy-Version" class="headerlink" title="E1. Doremy’s Drying Plan (Easy Version)"></a>E1. Doremy’s Drying Plan (Easy Version)</h1><h2 id="大致题意-4"><a href="#大致题意-4" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个城市，天气预报会预报未来 $m$ 天的下雨情况，允许选择其中两天不下雨，问最多可以有多少个城市这 $m$ 天不下雨</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>根据起始和结束位置的下雨，标记数组，然后统计即可。因为只能选择两天，所以基本上是半暴力即可</p><h2 id="AC-code-4"><a href="#AC-code-4" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, m, k;<br>        cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">start</span>(n + <span class="hljs-number">1</span>), <span class="hljs-built_in">end</span>(n + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-type">int</span> u, v;<br>            cin &gt;&gt; u &gt;&gt; v;<br>            start[u].<span class="hljs-built_in">push_back</span>(i);<br>            end[v].<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br><br>        set&lt;<span class="hljs-type">int</span>&gt; s;<br>        map&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, <span class="hljs-type">int</span>&gt; ans1;<br>        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; ans2;<br>        <span class="hljs-type">int</span> ans3 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp;item: start[i]) s.<span class="hljs-built_in">insert</span>(item);<br><br>            <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">empty</span>())<br>                ans3++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)<br>                ans2[*s.<span class="hljs-built_in">begin</span>()]++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>)<br>                ans1[&#123;*s.<span class="hljs-built_in">begin</span>(), *s.<span class="hljs-built_in">rbegin</span>()&#125;]++;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp;item: end[i]) s.<span class="hljs-built_in">erase</span>(item);<br>        &#125;<br><br>        <span class="hljs-type">int</span> res = ans3;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp;item: ans1) &#123;<br>            <span class="hljs-type">int</span> tmp = item.second + ans3;<br>            <span class="hljs-keyword">auto</span> l = ans2.<span class="hljs-built_in">find</span>(item.first.first), r = ans2.<span class="hljs-built_in">find</span>(item.first.second);<br>            <span class="hljs-keyword">if</span> (l != ans2.<span class="hljs-built_in">end</span>()) tmp += l-&gt;second;<br>            <span class="hljs-keyword">if</span> (r != ans2.<span class="hljs-built_in">end</span>()) tmp += r-&gt;second;<br>            res = <span class="hljs-built_in">max</span>(res, tmp);<br>        &#125;<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; ans2v;<br>        ans2v.<span class="hljs-built_in">reserve</span>(ans2.<span class="hljs-built_in">size</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp;item: ans2) ans2v.<span class="hljs-built_in">push_back</span>(item.second);<br>        <span class="hljs-built_in">sort</span>(ans2v.<span class="hljs-built_in">begin</span>(), ans2v.<span class="hljs-built_in">end</span>(), greater&lt;&gt;());<br>        <span class="hljs-keyword">if</span> (ans2v.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) res = <span class="hljs-built_in">max</span>(res, ans2v[<span class="hljs-number">0</span>] + ans3);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ans2v.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>) res = <span class="hljs-built_in">max</span>(res, ans2v[<span class="hljs-number">0</span>] + ans2v[<span class="hljs-number">1</span>] + ans3);<br><br>        cout &lt;&lt; res &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一段奇怪的 CPP 代码</title>
    <link href="/2023/12/03/cpp/cpp-list-insert/"/>
    <url>/2023/12/03/cpp/cpp-list-insert/</url>
    
    <content type="html"><![CDATA[<p>最近发现了一个奇怪的代码，在 C++17 下。使用的 cmake 命令是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">&quot;~/Applications/CLion Nova.app/Contents/bin/cmake/mac/aarch64/bin/cmake&quot; -DCMAKE_BUILD_TYPE=Debug &quot;-DCMAKE_MAKE_PROGRAM=~/Applications/CLion Nova.app/Contents/bin/ninja/mac/aarch64/ninja&quot; -G Ninja -S ~/Code/ClionProject -B ~/Code/ClionProject/cmake-build-debug<br></code></pre></td></tr></table></figure><p>而这段代码则是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">list&lt;<span class="hljs-type">int</span>&gt; l;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) l.<span class="hljs-built_in">push_back</span>(i);<br><span class="hljs-keyword">auto</span> iter = l.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">-10</span>; --i) l.<span class="hljs-built_in">insert</span>(iter--, i);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>&amp;v: l) cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br></code></pre></td></tr></table></figure><p>这段代码的结果却是</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-string">-1</span> 0 1 <span class="hljs-string">-10</span> 2 <span class="hljs-string">-9</span> 3 <span class="hljs-string">-8</span> 4 <span class="hljs-string">-7</span> 5 <span class="hljs-string">-6</span> 6 <span class="hljs-string">-5</span> 7 <span class="hljs-string">-4</span> 8 <span class="hljs-string">-3</span> 9 <span class="hljs-string">-2</span> <br></code></pre></td></tr></table></figure><p>如果稍微调整一下，比如这样的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">list&lt;<span class="hljs-type">int</span>&gt; l;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) l.<span class="hljs-built_in">push_back</span>(i);<br><span class="hljs-keyword">auto</span> iter = l.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">-10</span>; --i) &#123;<br>    l.<span class="hljs-built_in">insert</span>(iter, i);<br>    --iter;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>&amp;v: l) cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br></code></pre></td></tr></table></figure><p>得到的结果却是</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-string">-10</span> <span class="hljs-string">-9</span> <span class="hljs-string">-8</span> <span class="hljs-string">-7</span> <span class="hljs-string">-6</span> <span class="hljs-string">-5</span> <span class="hljs-string">-4</span> <span class="hljs-string">-3</span> <span class="hljs-string">-2</span> <span class="hljs-string">-1</span> 0 1 2 3 4 5 6 7 8 9 <br></code></pre></td></tr></table></figure><p>如果调整成这样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">list&lt;<span class="hljs-type">int</span>&gt; l;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) l.<span class="hljs-built_in">push_back</span>(i);<br><span class="hljs-keyword">auto</span> iter = l.<span class="hljs-built_in">begin</span>();<br>++iter;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">-10</span>; --i) &#123;<br>    l.<span class="hljs-built_in">insert</span>(--iter, i);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>&amp;v: l) cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br></code></pre></td></tr></table></figure><p>得到的结果也是</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-string">-10</span> <span class="hljs-string">-9</span> <span class="hljs-string">-8</span> <span class="hljs-string">-7</span> <span class="hljs-string">-6</span> <span class="hljs-string">-5</span> <span class="hljs-string">-4</span> <span class="hljs-string">-3</span> <span class="hljs-string">-2</span> <span class="hljs-string">-1</span> 0 1 2 3 4 5 6 7 8 9 <br></code></pre></td></tr></table></figure><p>这似乎有点不太符合预期。至少后两个是符合预期的，而第一个就有点奇怪了。第一反应是不是踩到 UB 了，但是很快在文档里找到了不符合预期的描述</p><p><img src="/image/cpp/cpp-list-insert/docs.png" alt="docs"></p><p>既然如此，那么就写一段测试代码看看</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp">list&lt;<span class="hljs-type">int</span>&gt; l;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(list&lt;<span class="hljs-type">int</span>&gt;::iterator iter, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    cout &lt;&lt; *iter &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    l.<span class="hljs-built_in">insert</span>(iter, v);<br>    cout &lt;&lt; *iter &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) l.<span class="hljs-built_in">push_back</span>(i);<br>    <span class="hljs-keyword">auto</span> iter = l.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">-10</span>; --i) &#123;<br>        <span class="hljs-built_in">f</span>(iter--, i);<br>        cout &lt;&lt; (iter == l.<span class="hljs-built_in">begin</span>()) &lt;&lt; endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>&amp;v: l) cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此处进行了一下代理，将每次试图写入钱，通过 <code>f</code> 函数进行代理后，再执行插入操作。结果发现</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs tap">0 0<br>0<br>-1<span class="hljs-number"> 0 </span>1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>5<span class="hljs-number"> 6 </span>7<span class="hljs-number"> 8 </span>9 <br>11 12<br>0<br>-1<span class="hljs-number"> 0 </span>1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>5<span class="hljs-number"> 6 </span>7<span class="hljs-number"> 8 </span>9 -2 <br>9 9<br>0<br>-1<span class="hljs-number"> 0 </span>1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>5<span class="hljs-number"> 6 </span>7<span class="hljs-number"> 8 </span>-3<span class="hljs-number"> 9 </span>-2 <br>8 8<br>0<br>-1<span class="hljs-number"> 0 </span>1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>5<span class="hljs-number"> 6 </span>7 -4<span class="hljs-number"> 8 </span>-3<span class="hljs-number"> 9 </span>-2 <br>7 7<br>0<br>-1<span class="hljs-number"> 0 </span>1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>5<span class="hljs-number"> 6 </span>-5<span class="hljs-number"> 7 </span>-4<span class="hljs-number"> 8 </span>-3<span class="hljs-number"> 9 </span>-2 <br>6 6<br>0<br>-1<span class="hljs-number"> 0 </span>1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>5 -6<span class="hljs-number"> 6 </span>-5<span class="hljs-number"> 7 </span>-4<span class="hljs-number"> 8 </span>-3<span class="hljs-number"> 9 </span>-2 <br>5 5<br>0<br>-1<span class="hljs-number"> 0 </span>1<span class="hljs-number"> 2 </span>3<span class="hljs-number"> 4 </span>-7<span class="hljs-number"> 5 </span>-6<span class="hljs-number"> 6 </span>-5<span class="hljs-number"> 7 </span>-4<span class="hljs-number"> 8 </span>-3<span class="hljs-number"> 9 </span>-2 <br>4 4<br>0<br>-1<span class="hljs-number"> 0 </span>1<span class="hljs-number"> 2 </span>3 -8<span class="hljs-number"> 4 </span>-7<span class="hljs-number"> 5 </span>-6<span class="hljs-number"> 6 </span>-5<span class="hljs-number"> 7 </span>-4<span class="hljs-number"> 8 </span>-3<span class="hljs-number"> 9 </span>-2 <br>3 3<br>0<br>-1<span class="hljs-number"> 0 </span>1<span class="hljs-number"> 2 </span>-9<span class="hljs-number"> 3 </span>-8<span class="hljs-number"> 4 </span>-7<span class="hljs-number"> 5 </span>-6<span class="hljs-number"> 6 </span>-5<span class="hljs-number"> 7 </span>-4<span class="hljs-number"> 8 </span>-3<span class="hljs-number"> 9 </span>-2 <br>2 2<br>0<br>-1<span class="hljs-number"> 0 </span>1 -10<span class="hljs-number"> 2 </span>-9<span class="hljs-number"> 3 </span>-8<span class="hljs-number"> 4 </span>-7<span class="hljs-number"> 5 </span>-6<span class="hljs-number"> 6 </span>-5<span class="hljs-number"> 7 </span>-4<span class="hljs-number"> 8 </span>-3<span class="hljs-number"> 9 </span>-2 <br></code></pre></td></tr></table></figure><p>仍然有这个奇奇怪怪的问题。</p><p>正当我想要搜索一些文档来看看是不是什么奇奇怪怪的 bug 的时候，突然意识到一个问题：<code>i++;</code> 等价于下面这三行代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> tmp = i;<br>++i;<br><span class="hljs-keyword">return</span> tmp;<br></code></pre></td></tr></table></figure><p>这似乎就能解释为什么了！因为在试图进行 <code>iter--</code> 操作的时候，又进行了插入操作，实际上导致了 <code>iter</code> 本身先移动到了前一个指针的位置，而在 STL 标准库实现的 <code>list</code> 中，这个链表是一个双向带头循环链表，故实际上此时 <code>iter</code> 是先被移动到了 <code>end()</code> 的位置，然后再返回了 <code>begin()</code> 的位置，并在 <code>begin()</code> 前插入了一个值，使得实际上的 <code>begin()</code> 发生了更新。而实际上我们的 <code>iter</code> 早就被移动到 <code>end()</code> 的位置。</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 905 (Div. 3)</title>
    <link href="/2023/11/27/acm/codeforces/CodeforcesRound905/"/>
    <url>/2023/11/27/acm/codeforces/CodeforcesRound905/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Morning"><a href="#A-Morning" class="headerlink" title="A. Morning"></a>A. Morning</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>需要依次打出四个数字，键盘上有十个按钮，每个按钮对应一个数字，每次允许按下当前按钮，或者移动到相邻的按钮上，问至少需要多少次才能打出来</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>暴力扫都行，模拟顺序然后找路径即可</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin &gt;&gt; x;<br><br>        <span class="hljs-type">int</span> d[<span class="hljs-number">5</span>], ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> &amp;i: d) &#123;<br>            i = x % <span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) i = <span class="hljs-number">10</span>;<br>            x /= <span class="hljs-number">10</span>;<br>        &#125;<br>        d[<span class="hljs-number">4</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &gt;= <span class="hljs-number">0</span>; --i) ans += <span class="hljs-built_in">abs</span>(d[i] - d[i + <span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Chemistry"><a href="#B-Chemistry" class="headerlink" title="B. Chemistry"></a>B. Chemistry</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>给你一个字符串，在恰好删除掉 $k$ 个字母之后，再重新排列，能否得到一个回文串</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>只要 $k$ 至少比字母出现次数为基数次的字母个数 $- 1$ 还要多就行了</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br><br>    string str;<br>    str.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n &gt;&gt; k &gt;&gt; str;<br>        map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; cnt;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: str) cnt[item]++;<br>        <span class="hljs-type">int</span> edd = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: cnt) edd += item.second % <span class="hljs-number">2</span>;<br>        cout &lt;&lt; ((k &gt;= edd - <span class="hljs-number">1</span>) ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Raspberries"><a href="#C-Raspberries" class="headerlink" title="C. Raspberries"></a>C. Raspberries</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组，和一个 $k$，每次操作可以将数组上的某一个值 $+ 1$，问至少需要操作几次，才能让数组的所有值乘积是 $k$ 的倍数</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>注意题目给出的 $k$ 的范围，仅有可能是 $[2, 5]$，这其中还恰好基本都是素数，仅 $4$ 不是，所以基本上都是其中单个值满足倍数关系了</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: data) cin &gt;&gt; i;<br>        <span class="hljs-keyword">if</span> (k != <span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-type">int</span> mi = k, ma = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: data) &#123;<br>                mi = <span class="hljs-built_in">min</span>(mi, i % k);<br>                ma = <span class="hljs-built_in">max</span>(ma, i % k);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (mi == <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">else</span> cout &lt;&lt; (k - ma) &lt;&lt; endl;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> even = <span class="hljs-number">0</span>, ma = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: data) &#123;<br>                even += i % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> ? <span class="hljs-number">2</span> : i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;<br>                ma = <span class="hljs-built_in">max</span>(ma, i % <span class="hljs-number">4</span>);<br>            &#125;<br>            cout &lt;&lt; <span class="hljs-built_in">min</span>(<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span> - even), <span class="hljs-number">4</span> - ma) &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-In-Love"><a href="#D-In-Love" class="headerlink" title="D. In Love"></a>D. In Love</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个线段的集合，每次往里面加一个线段或者删除一个线段，问每次操作后，是否存在两个线段他们不重叠</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>也很简单，维护好线段右边最小的和线段左边最大的两个堆即可</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, less&lt;&gt;&gt; prq1;<br>    priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, greater&lt;&gt;&gt; prq2;<br>    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mvd1, mvd2;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-type">char</span> op;<br>        <span class="hljs-type">int</span> l, r;<br>        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>            prq1.<span class="hljs-built_in">emplace</span>(l, i);<br>            prq2.<span class="hljs-built_in">emplace</span>(r, i);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mvd1[l]++;<br>            mvd2[r]++;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (!prq1.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> item = prq1.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">auto</span> iter = mvd1.<span class="hljs-built_in">find</span>(item.first);<br>            <span class="hljs-keyword">if</span> (iter != mvd1.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-keyword">while</span> (iter-&gt;second--) prq1.<span class="hljs-built_in">pop</span>();<br>                mvd1.<span class="hljs-built_in">erase</span>(iter);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!prq2.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> item = prq2.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">auto</span> iter = mvd2.<span class="hljs-built_in">find</span>(item.first);<br>            <span class="hljs-keyword">if</span> (iter != mvd2.<span class="hljs-built_in">end</span>()) &#123;<br>                <span class="hljs-keyword">while</span> (iter-&gt;second--) prq2.<span class="hljs-built_in">pop</span>();<br>                mvd2.<span class="hljs-built_in">erase</span>(iter);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (prq1.<span class="hljs-built_in">empty</span>() || prq2.<span class="hljs-built_in">empty</span>() || prq1.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span> || prq2.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; (prq1.<span class="hljs-built_in">top</span>().first &gt; prq2.<span class="hljs-built_in">top</span>().first ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="E-Look-Back"><a href="#E-Look-Back" class="headerlink" title="E. Look Back"></a>E. Look Back</h1><h2 id="大致题意-4"><a href="#大致题意-4" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组，每次可以让其中一个值翻倍，问至少操作多少次，才能让整个数组不递减</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>这道题从二进制角度考虑就很简单。</p><p>翻倍其实就是左移一位，所以如果两个值本身的最高的比特位置相同，那么如果这两个值仍然存在前者大于后者的情况，那么后者需要在前者左移的基础上，再左移一位即可。反之则和前者左移次数相同即可</p><p>问题是如何构造最高比特位相同的数组。我们可以先人工把所有值都左移到某个位置，到时候再右移回来即可</p><h2 id="AC-code-4"><a href="#AC-code-4" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span>, <span class="hljs-title">p</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span>, <span class="hljs-title">ans</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: data) cin &gt;&gt; i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (data[i] &lt;= INT_MAX) &#123;<br>                p[i]++;<br>                data[i] &lt;&lt;= <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) ans[i] = ans[i - <span class="hljs-number">1</span>] + (data[i] &gt;= data[i - <span class="hljs-number">1</span>] ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> last = p[<span class="hljs-number">0</span>] + ans[<span class="hljs-number">0</span>], tot = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            ans[i] += p[i];<br>            last = <span class="hljs-built_in">min</span>(ans[i], last);<br>            ans[i] -= last;<br>            tot += ans[i];<br>        &#125;<br><br>        cout &lt;&lt; tot &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="F-You-Are-So-Beautiful"><a href="#F-You-Are-So-Beautiful" class="headerlink" title="F. You Are So Beautiful"></a>F. You Are So Beautiful</h1><h2 id="大致题意-5"><a href="#大致题意-5" class="headerlink" title="大致题意"></a>大致题意</h2><p>给你一个数组，问是否存在这样的一个<strong>子串</strong>，满足不同时存在两个<strong>子序列</strong>和这个子串相同，问有多少个这样的<strong>子串</strong></p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>注意题目要找的是子串。说白了也很简单，只需要这个子串最左边的值是原串中这个值最左边的，右边也同样，即可</p><h2 id="AC-code-5"><a href="#AC-code-5" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: data) cin &gt;&gt; i;<br>        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: data) cnt[<span class="hljs-number">1</span>][i]++;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: data) &#123;<br>            <span class="hljs-keyword">auto</span> iter = cnt[<span class="hljs-number">1</span>].<span class="hljs-built_in">find</span>(i);<br>            iter-&gt;second--;<br>            <span class="hljs-keyword">if</span> (iter-&gt;second == <span class="hljs-number">0</span>) cnt[<span class="hljs-number">1</span>].<span class="hljs-built_in">erase</span>(iter);<br><br>            <span class="hljs-comment">// left has</span><br>            <span class="hljs-keyword">if</span> (cnt[<span class="hljs-number">0</span>].<span class="hljs-built_in">count</span>(i)) <span class="hljs-keyword">continue</span>;<br>            ans += (<span class="hljs-type">int</span>) cnt[<span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>();<br><br>            <span class="hljs-comment">// single</span><br>            <span class="hljs-keyword">if</span> (iter-&gt;second == <span class="hljs-number">0</span>) ans++;<br><br>            cnt[<span class="hljs-number">0</span>][i]++;<br>        &#125;<br><br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="G2-Dances-Hard-Version"><a href="#G2-Dances-Hard-Version" class="headerlink" title="G2. Dances (Hard Version)"></a>G2. Dances (Hard Version)</h1><p>直接看 hard 版本吧，其实都挺简单的，感觉这场最有意思的应该是是 E 题</p><h2 id="大致题意-6"><a href="#大致题意-6" class="headerlink" title="大致题意"></a>大致题意</h2><p>有两个数组，其中数组 $a$ 的某一个值可以是 $[1, m]$ 中任意一个。允许你每次操作同时从数组中删除掉一个值，操作完成后再重新排列数组，问是否可以满足数组 $b$ 的每一项都 $&gt; a$</p><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>贪心一下就行了，说白了就是从 $b$ 里找第一个大于等于每一个 $a$ 的值即可。然后剩下的值都删掉</p><p>至于那个特殊的值？可以在剩下要删掉的里面取最大的那个，如果那个特殊值小于它的时候，则不用删，否则删除</p><h2 id="AC-code-6"><a href="#AC-code-6" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, m;<br>        cin &gt;&gt; n &gt;&gt; m;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n - <span class="hljs-number">1</span>)</span>, <span class="hljs-title">b</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: a) cin &gt;&gt; i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: b) cin &gt;&gt; i;<br>        <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-type">int</span> lastB = <span class="hljs-number">-1</span>, base = <span class="hljs-number">0</span>, cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> &amp;i: a) &#123;<br>            <span class="hljs-keyword">while</span> (cur &lt; n &amp;&amp; i &gt;= b[cur]) lastB = b[cur++];<br>            <span class="hljs-keyword">if</span> (cur &gt;= n) base++;<br>            cur++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (lastB == <span class="hljs-number">-1</span>) lastB = b.<span class="hljs-built_in">back</span>();<br><br>        cout &lt;&lt; <span class="hljs-number">1LL</span> * base * m + <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, m - lastB + <span class="hljs-number">1</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 904 (Div. 2)</title>
    <link href="/2023/11/25/acm/codeforces/CodeforcesRound904/"/>
    <url>/2023/11/25/acm/codeforces/CodeforcesRound904/</url>
    
    <content type="html"><![CDATA[<p><em>D 题有点难，数论确实不会，本着只是为了练习回复脑子的角度考虑，就不写了</em></p><h1 id="A-Simple-Design"><a href="#A-Simple-Design" class="headerlink" title="A. Simple Design"></a>A. Simple Design</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有两值，$x, k$，找到最小的 $y$ 满足 $y \geq x, y \space mod \space k = 0$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为 $k$ 很小，所以暴力枚举就行</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> x, k;<br>        cin &gt;&gt; x &gt;&gt; k;<br><br>        <span class="hljs-keyword">auto</span> cal = [&amp;](<span class="hljs-type">int</span> x) &#123;<br>            <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (x) &#123;<br>                ans += x % <span class="hljs-number">10</span>;<br>                x /= <span class="hljs-number">10</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">int</span> tmp = <span class="hljs-built_in">cal</span>(x);<br>            <span class="hljs-keyword">if</span> (tmp % k == <span class="hljs-number">0</span>) &#123;<br>                cout &lt;&lt; x &lt;&lt; endl;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            x++;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Haunted-House"><a href="#B-Haunted-House" class="headerlink" title="B. Haunted House"></a>B. Haunted House</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个 $01$ 字符串，每次允许交换两个相邻的值，问交换多少次，就可以是 $2^i$ 的倍数（对于所有可能的 $i$）</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>都告诉你二进制了，保证最后几个为 $0$ 的方案而已，简单模拟一下就行了</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    string str;<br>    str.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">1e5</span>);<br><br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n &gt;&gt; str;<br>        <span class="hljs-type">int</span> l = (<span class="hljs-type">int</span>) str.<span class="hljs-built_in">size</span>(), ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r = (<span class="hljs-type">int</span>) str.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; r &gt;= <span class="hljs-number">0</span>; --r) &#123;<br>            l--;<br>            <span class="hljs-keyword">while</span> (l &gt;= <span class="hljs-number">0</span> &amp;&amp; str[l] == <span class="hljs-string">&#x27;1&#x27;</span>) l--;<br>            <span class="hljs-keyword">if</span> (l &gt;= <span class="hljs-number">0</span>) ans += r - l;<br>            <span class="hljs-keyword">if</span> (l &lt; <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>            <span class="hljs-keyword">else</span> cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Medium-Design"><a href="#C-Medium-Design" class="headerlink" title="C. Medium Design"></a>C. Medium Design</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一堆区间，可以选出其中一部分，对这些区间内的值 +1 问这样操作之后的区间的最大值降去最小值的最大差值可以是多少</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>排序一下，然后遍历，因为最小值一定出现在第一个值或者最后一个值</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; v;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, m;<br>        cin &gt;&gt; n &gt;&gt; m;<br>        v.<span class="hljs-built_in">resize</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: v) cin &gt;&gt; i.first &gt;&gt; i.second;<br><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span> &#123;<br>            <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;lhs, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;rhs)</span> <span class="hljs-type">const</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> v[lhs].second &gt; v[rhs].second;<br>            &#125;<br>        &#125;;<br><br>        priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, cmp&gt; prq;<br>        <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>, cur = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; v.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">auto</span> &amp;item = v[i];<br>            prq.<span class="hljs-built_in">push</span>(i);<br>            cur++;<br>            <span class="hljs-keyword">if</span> (item.first &lt;= <span class="hljs-number">1</span>) l++;<br>            <span class="hljs-keyword">if</span> (item.second &gt;= m) r++;<br>            <span class="hljs-keyword">while</span> (!prq.<span class="hljs-built_in">empty</span>()) &#123;<br>                <span class="hljs-keyword">if</span> (v[prq.<span class="hljs-built_in">top</span>()].second &lt; item.first) &#123;<br>                    <span class="hljs-keyword">if</span> (v[prq.<span class="hljs-built_in">top</span>()].first &lt;= <span class="hljs-number">1</span>) l--;<br>                    prq.<span class="hljs-built_in">pop</span>();<br>                    cur--;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">max</span>(cur - l, cur - r));<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 903 (Div. 3)</title>
    <link href="/2023/11/21/acm/codeforces/CodeforcesRound903/"/>
    <url>/2023/11/21/acm/codeforces/CodeforcesRound903/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Don’t-Try-to-Count"><a href="#A-Don’t-Try-to-Count" class="headerlink" title="A. Don’t Try to Count"></a>A. Don’t Try to Count</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给出两个字符串 $n, m$，允许 $n$ 每次往自己拼接在自己后面，使得 $n$ 中出现 $m$ 字符串，问最少需要几次操作</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为 $n, m$ 都很小，所以直接保留就行了</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, m;<br>        string str1, str2;<br>        str1.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">25</span>);<br>        str2.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">25</span>);<br>        cin &gt;&gt; n &gt;&gt; m &gt;&gt; str1 &gt;&gt; str2;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">5</span>; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (str1.<span class="hljs-built_in">find</span>(str2) != <span class="hljs-number">-1</span>) &#123;<br>                flag = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            str1 += str1;<br>        &#125;<br>        cout &lt;&lt; (flag ? i : <span class="hljs-number">-1</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Three-Threadlets"><a href="#B-Three-Threadlets" class="headerlink" title="B. Three Threadlets"></a>B. Three Threadlets</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有三根木棍，允许最多切三刀，问能否使得所有木棍都一样长</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>因为只能切三刀，所以就很局限了</p><ul><li>如果一个棍子切一刀的方案下，那么必然只能中间切开，那么肯定最初大家都是一样的，故不可能存在这个情况</li><li>如果分别为切 $0, 1, 2$ 的方案下，那么必然第二根棒子的长度得是第一根的两倍，第三根则为三倍</li><li>如果分别为切 $0, 0, 3$ 的方案下，那么必然第三个棒子的长度得是前两根的四倍，同时第二根和第一个等长</li><li>如果分别为切 $0, 1, 1$ 的方案下，那么必然第二个和第三个棒子的长度得是第一根的两倍</li><li>如果分别为切 $0, 0, 2$ 的方案下，那么必然第三个棒子的长度得是前两根的三倍，同时第二根和第一个等长</li><li>如果分别为切 $0, 0, 1$ 的方案下，那么必然第三个棒子的长度得是前两根的两倍，同时第二根和第一个等长</li></ul><p>嗯，枚举所有情况即可</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;<br>        cin &gt;&gt; data[<span class="hljs-number">0</span>] &gt;&gt; data[<span class="hljs-number">1</span>] &gt;&gt; data[<span class="hljs-number">2</span>];<br>        <span class="hljs-built_in">sort</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">if</span> (data[<span class="hljs-number">0</span>] == data[<span class="hljs-number">2</span>]) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (data[<span class="hljs-number">0</span>] == data[<span class="hljs-number">1</span>])<br>        cout &lt;&lt; (data[<span class="hljs-number">2</span>] == data[<span class="hljs-number">0</span>] * <span class="hljs-number">2</span> || data[<span class="hljs-number">2</span>] == data[<span class="hljs-number">0</span>] * <span class="hljs-number">3</span> || data[<span class="hljs-number">2</span>] == data[<span class="hljs-number">0</span>] * <span class="hljs-number">4</span> ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span><br>        cout &lt;&lt; (data[<span class="hljs-number">1</span>] == data[<span class="hljs-number">0</span>] * <span class="hljs-number">2</span> &amp;&amp; (data[<span class="hljs-number">2</span>] == data[<span class="hljs-number">0</span>] * <span class="hljs-number">2</span> || data[<span class="hljs-number">2</span>] == data[<span class="hljs-number">0</span>] * <span class="hljs-number">3</span>) ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Perfect-Square"><a href="#C-Perfect-Square" class="headerlink" title="C. Perfect Square"></a>C. Perfect Square</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>矩阵旋转 $90$ 度后仍然相同，每次允许把矩阵中的一个值加一，问最少需要改多少次</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>搞清楚旋转后，的每个位置映射的地方即可，很简单</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item : data) item.<span class="hljs-built_in">resize</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item : data) cin &gt;&gt; item;<br><br>        <span class="hljs-keyword">auto</span> trans = [&amp;](<span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y) &#123;<br>            <span class="hljs-built_in">swap</span>(x, y);<br>            y = n - y - <span class="hljs-number">1</span>;<br>        &#125;;<br><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-type">char</span> tmp[<span class="hljs-number">4</span>];<br>                <span class="hljs-type">int</span> x = i, y = j;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>; l &lt; <span class="hljs-number">4</span>; ++l) &#123;<br>                    tmp[l] = data[x][y];<br>                    <span class="hljs-built_in">trans</span>(x, y);<br>                &#125;<br>                <span class="hljs-built_in">sort</span>(tmp, tmp + <span class="hljs-number">4</span>);<br>                ans += tmp[<span class="hljs-number">3</span>] * <span class="hljs-number">3</span> - tmp[<span class="hljs-number">0</span>] - tmp[<span class="hljs-number">1</span>] - tmp[<span class="hljs-number">2</span>];<br>            &#125;<br>        &#125;<br><br>        cout &lt;&lt; ans / <span class="hljs-number">4</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Divide-and-Equalize"><a href="#D-Divide-and-Equalize" class="headerlink" title="D. Divide and Equalize"></a>D. Divide and Equalize</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>有 $n$ 个数字，每次允许你从中挑选两个数字，将其中一个数字除以 $x$，另外一个数字乘以 $x$。注意操作后两数仍然是正整数，问是否能让所有数字相同</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>简单题，把所有数字质因子分解了，然后看看每个质因子的出现次数是不是数组长度的倍数就行了</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">notPrime</span><span class="hljs-params">(<span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>, <span class="hljs-literal">false</span>)</span></span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; prime;<br>    notPrime[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (notPrime[i]) <span class="hljs-keyword">continue</span>;<br>        prime.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i * i; j &lt;= <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>; j += i) notPrime[j] = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: data) cin &gt;&gt; item;<br>        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> item: data) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : prime) &#123;<br>                <span class="hljs-keyword">while</span> (item % p == <span class="hljs-number">0</span>) &#123;<br>                    mp[p]++;<br>                    item /= p;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (item == <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">if</span> (!notPrime[item]) &#123;<br>                    mp[item]++;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = mp.<span class="hljs-built_in">begin</span>(); iter != mp.<span class="hljs-built_in">end</span>(); ++iter)<br>        <span class="hljs-keyword">if</span> (iter-&gt;second % n != <span class="hljs-number">0</span>) flag = <span class="hljs-literal">false</span>;<br><br>        cout &lt;&lt; (flag ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="E-Block-Sequence"><a href="#E-Block-Sequence" class="headerlink" title="E. Block Sequence"></a>E. Block Sequence</h1><h2 id="大致题意-4"><a href="#大致题意-4" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组，希望能删掉一些值，使得整个数组满足一个特征：</p><p>整个数组可以拆分成几个连续的块，每个块第一个数字表示这个块内后面的数字个数</p><p>问最少需要删掉几个</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>很容易想到用 dp 解决</p><p>假定当前位置为某个块的开头，那么带来的价值就是 <code>dp[i + a[i]] = dp[i]</code></p><h2 id="AC-code-4"><a href="#AC-code-4" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; _; ++i) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span>, <span class="hljs-title">ans</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, INT_MAX)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item : data) cin &gt;&gt; item;<br>        ans[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (data[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span> &lt;= n) ans[data[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            ans[i] = <span class="hljs-built_in">min</span>(ans[i], ans[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (i + data[i] + <span class="hljs-number">1</span> &lt;= n) ans[i + data[i] + <span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(ans[i], ans[i + data[i] + <span class="hljs-number">1</span>]);<br>        &#125;<br>        ans[n] = <span class="hljs-built_in">min</span>(ans[n], ans[n - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>        cout &lt;&lt; ans[n] &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="F-Minimum-Maximum-Distance"><a href="#F-Minimum-Maximum-Distance" class="headerlink" title="F. Minimum Maximum Distance"></a>F. Minimum Maximum Distance</h1><h2 id="大致题意-5"><a href="#大致题意-5" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一棵树，有些节点是红色的。求算树上的每一个节点到达最远的那个红色节点所需要的距离中，最小的那个值是多少</p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>树上做两次 dfs 就行了，第一次求出每个节点它下面最深的红色节点距离的位置，第二次做类似换根操作即可</p><h2 id="AC-code-5"><a href="#AC-code-5" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, k, ans = INT_MAX;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">deep</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">mDeep</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        set&lt;<span class="hljs-type">int</span>&gt; mark;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">edge</span>(n + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            mark.<span class="hljs-built_in">insert</span>(tmp);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-type">int</span> u, v;<br>            cin &gt;&gt; u &gt;&gt; v;<br>            edge[u].<span class="hljs-built_in">push_back</span>(v);<br>            edge[v].<span class="hljs-built_in">push_back</span>(u);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs1 = [&amp;](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> p) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: edge[x]) &#123;<br>                <span class="hljs-keyword">if</span> (p == i) <span class="hljs-keyword">continue</span>;<br>                deep[i] = deep[x] + <span class="hljs-number">1</span>;<br>                <span class="hljs-built_in">dfs1</span>(i, x);<br>            &#125;<br>            mDeep[x] = mark.<span class="hljs-built_in">count</span>(x) ? <span class="hljs-number">0</span> : INT_MIN;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: edge[x]) &#123;<br>                <span class="hljs-keyword">if</span> (p == i) <span class="hljs-keyword">continue</span>;<br>                mDeep[x] = <span class="hljs-built_in">max</span>(mDeep[x], mDeep[i] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;;<br>        function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs2 = [&amp;](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> v) &#123;<br>            ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">max</span>(v, mDeep[x]));<br>            <span class="hljs-keyword">if</span> (edge[x].<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span> &amp;&amp; p != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span>;<br>            <span class="hljs-keyword">if</span> (p != <span class="hljs-number">-1</span> &amp;&amp; edge[x].<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-built_in">dfs2</span>(edge[x][<span class="hljs-number">0</span>] == p ? edge[x][<span class="hljs-number">1</span>] : edge[x][<span class="hljs-number">0</span>], x, mark.<span class="hljs-built_in">count</span>(x) ? <span class="hljs-built_in">max</span>(v + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) : v + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (p == <span class="hljs-number">-1</span> &amp;&amp; edge[x].<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-built_in">dfs2</span>(edge[x][<span class="hljs-number">0</span>], x, mark.<span class="hljs-built_in">count</span>(x) ? <span class="hljs-built_in">max</span>(v + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) : v + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-built_in">sort</span>(edge[x].<span class="hljs-built_in">begin</span>(), edge[x].<span class="hljs-built_in">end</span>(), [&amp;](<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;u, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;v) &#123;<br>                <span class="hljs-keyword">if</span> (u == p) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">if</span> (v == p) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">return</span> mDeep[u] &gt; mDeep[v];<br>            &#125;);<br>            <span class="hljs-type">int</span> base = mark.<span class="hljs-built_in">count</span>(x) ? <span class="hljs-number">1</span> : INT_MIN;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; edge[x].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; ++i)<br>            <span class="hljs-built_in">dfs2</span>(edge[x][i], x, <span class="hljs-built_in">max</span>(base, <span class="hljs-built_in">max</span>(v, mDeep[(i == <span class="hljs-number">0</span> ? edge[x][<span class="hljs-number">1</span>] : edge[x][<span class="hljs-number">0</span>])] + <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>));<br>        &#125;;<br><br>        deep[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, INT_MIN);<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="G-Anya-and-the-Mysterious-String"><a href="#G-Anya-and-the-Mysterious-String" class="headerlink" title="G. Anya and the Mysterious String"></a>G. Anya and the Mysterious String</h1><h2 id="大致题意-6"><a href="#大致题意-6" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个字符串，每次可以选择其中一段区间，为每一个字母加上一个值，即 <code>a + 1 = b, b + 2 = d</code> 这种循环编码，然后同时询问某一段内是否存在回文串</p><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>回文串可以考虑最小单位，即两个相邻的相同字母就是回文，或者间隔一个的相同字母，目的就是查找到这些</p><p>由于有区间加法操作，所以考虑到线段树</p><p>在线段树上每个节点，都记录它下面最前面两个字母和最后两个字母，然后合并的时候可以计算因为合并，贴在一起的那一段内是否出现了回文即可</p><h2 id="AC-code-6"><a href="#AC-code-6" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegTree</span> &#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; data1, data2, data3, data4, lazy;<br>    vector&lt;<span class="hljs-type">bool</span>&gt; flag;<br>    <span class="hljs-type">int</span> atom;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">SegTree</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> : data1((n &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">10</span>), data2((n &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">10</span>),</span><br><span class="hljs-function">    data3((n &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">10</span>), data4((n &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">10</span>),</span><br><span class="hljs-function">    lazy((n &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">10</span>), flag((n &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">10</span>, false), atom(<span class="hljs-number">-1</span>) &#123;</span>&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (l + r) | (l != r);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> cur = <span class="hljs-built_in">get</span>(l, r), lx = <span class="hljs-built_in">get</span>(l, mid), rx = <span class="hljs-built_in">get</span>(mid + <span class="hljs-number">1</span>, r);<br>        flag[cur] = flag[lx] || flag[rx];<br>        data1[cur] = data1[lx];<br>        data2[cur] = data2[lx];<br>        data3[cur] = data3[rx];<br>        data4[cur] = data4[rx];<br>        <span class="hljs-keyword">if</span> (data2[cur] &lt; <span class="hljs-number">0</span>) data2[cur] = data1[rx];<br>        <span class="hljs-keyword">if</span> (data3[cur] &lt; <span class="hljs-number">0</span>) data3[cur] = data4[lx];<br>        <span class="hljs-keyword">if</span> (flag[cur]) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-keyword">if</span> (data4[lx] == data1[rx] || data4[lx] == data2[rx] || data3[lx] == data1[rx]) flag[cur] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">else</span> flag[cur] = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-type">int</span> cur = <span class="hljs-built_in">get</span>(l, r);<br>        lazy[cur] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (l == r) &#123;<br>            data2[cur] = atom--;<br>            data3[cur] = atom--;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">build</span>(l, mid);<br>        <span class="hljs-built_in">build</span>(mid + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-built_in">up</span>(l, r);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-type">int</span> cur = <span class="hljs-built_in">get</span>(l, r);<br>        <span class="hljs-keyword">if</span> (!lazy[cur]) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> lx = <span class="hljs-built_in">get</span>(l, mid), rx = <span class="hljs-built_in">get</span>(mid + <span class="hljs-number">1</span>, r);<br>        data1[lx] = (data1[lx] + lazy[cur]) % <span class="hljs-number">26</span>;<br>        data2[lx] = data2[lx] &lt; <span class="hljs-number">0</span> ? data2[lx] : (data2[lx] + lazy[cur]) % <span class="hljs-number">26</span>;<br>        data3[lx] = data3[lx] &lt; <span class="hljs-number">0</span> ? data3[lx] : (data3[lx] + lazy[cur]) % <span class="hljs-number">26</span>;<br>        data4[lx] = (data4[lx] + lazy[cur]) % <span class="hljs-number">26</span>;<br>        lazy[lx] = (lazy[lx] + lazy[cur]) % <span class="hljs-number">26</span>;<br><br>        data1[rx] = (data1[rx] + lazy[cur]) % <span class="hljs-number">26</span>;<br>        data2[rx] = data2[rx] &lt; <span class="hljs-number">0</span> ? data2[rx] : (data2[rx] + lazy[cur]) % <span class="hljs-number">26</span>;<br>        data3[rx] = data3[rx] &lt; <span class="hljs-number">0</span> ? data3[rx] : (data3[rx] + lazy[cur]) % <span class="hljs-number">26</span>;<br>        data4[rx] = (data4[rx] + lazy[cur]) % <span class="hljs-number">26</span>;<br>        lazy[rx] = (lazy[rx] + lazy[cur]) % <span class="hljs-number">26</span>;<br><br>        lazy[cur] = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> w)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == x &amp;&amp; y == r) &#123;<br>            <span class="hljs-type">int</span> cur = <span class="hljs-built_in">get</span>(l, r);<br>            data1[cur] = (data1[cur] + w) % <span class="hljs-number">26</span>;<br>            data2[cur] = data2[cur] &lt; <span class="hljs-number">0</span> ? data2[cur] : (data2[cur] + w) % <span class="hljs-number">26</span>;<br>            data3[cur] = data3[cur] &lt; <span class="hljs-number">0</span> ? data3[cur] : (data3[cur] + w) % <span class="hljs-number">26</span>;<br>            data4[cur] = (data4[cur] + w) % <span class="hljs-number">26</span>;<br>            lazy[cur] = (lazy[cur] + w) % <span class="hljs-number">26</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">push</span>(l, r);<br>        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (y &lt;= mid) <span class="hljs-built_in">update</span>(l, mid, x, y, w);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt; mid) <span class="hljs-built_in">update</span>(mid + <span class="hljs-number">1</span>, r, x, y, w);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">update</span>(l, mid, x, mid, w);<br>            <span class="hljs-built_in">update</span>(mid + <span class="hljs-number">1</span>, r, mid + <span class="hljs-number">1</span>, y, w);<br>        &#125;<br>        <span class="hljs-built_in">up</span>(l, r);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == x &amp;&amp; y == r) &#123;<br>            <span class="hljs-keyword">return</span> flag[<span class="hljs-built_in">get</span>(l, r)];<br>        &#125;<br>        <span class="hljs-built_in">push</span>(l, r);<br>        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (y &lt;= mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(l, mid, x, y);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt; mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(mid + <span class="hljs-number">1</span>, r, x, y);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">bool</span> tmp = <span class="hljs-built_in">query</span>(l, mid, x, mid) || <span class="hljs-built_in">query</span>(mid + <span class="hljs-number">1</span>, r, mid + <span class="hljs-number">1</span>, y);<br>            <span class="hljs-keyword">if</span> (tmp) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-type">int</span> lx = <span class="hljs-built_in">get</span>(l, mid), rx = <span class="hljs-built_in">get</span>(mid + <span class="hljs-number">1</span>, r);<br>            <span class="hljs-keyword">if</span> (data4[lx] == data1[rx]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (x &lt;= mid - <span class="hljs-number">1</span> &amp;&amp; data3[lx] == data1[rx]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (y &gt; mid + <span class="hljs-number">1</span> &amp;&amp; data4[lx] == data2[rx]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ACM_LOCAL</span><br>        <span class="hljs-type">int</span> cur = <span class="hljs-built_in">get</span>(l, r);<br>        cerr &lt;&lt; <span class="hljs-string">&#x27;[&#x27;</span> &lt;&lt; l &lt;&lt; <span class="hljs-string">&#x27;-&#x27;</span> &lt;&lt; r &lt;&lt; <span class="hljs-string">&quot;]: &quot;</span> &lt;&lt; flag[cur] &lt;&lt; <span class="hljs-string">&quot;\t&quot;</span><br>        &lt;&lt; (data1[cur] &gt;= <span class="hljs-number">0</span> ? <span class="hljs-built_in">char</span>(data1[cur] + <span class="hljs-string">&#x27;a&#x27;</span>) : <span class="hljs-string">&#x27; &#x27;</span>)<br>        &lt;&lt; (data2[cur] &gt;= <span class="hljs-number">0</span> ? <span class="hljs-built_in">char</span>(data2[cur] + <span class="hljs-string">&#x27;a&#x27;</span>) : <span class="hljs-string">&#x27; &#x27;</span>)<br>        &lt;&lt; (data3[cur] &gt;= <span class="hljs-number">0</span> ? <span class="hljs-built_in">char</span>(data3[cur] + <span class="hljs-string">&#x27;a&#x27;</span>) : <span class="hljs-string">&#x27; &#x27;</span>)<br>        &lt;&lt; (data4[cur] &gt;= <span class="hljs-number">0</span> ? <span class="hljs-built_in">char</span>(data4[cur] + <span class="hljs-string">&#x27;a&#x27;</span>) : <span class="hljs-string">&#x27; &#x27;</span>) &lt;&lt; endl;<br>        <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">debug</span>(l, mid);<br>        <span class="hljs-built_in">debug</span>(mid + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, q;<br>        cin &gt;&gt; n &gt;&gt; q;<br>        string str;<br>        str.<span class="hljs-built_in">reserve</span>(n);<br>        <span class="hljs-function">SegTree <span class="hljs-title">tree</span><span class="hljs-params">(n)</span></span>;<br>        cin &gt;&gt; str;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) tree.data4[(i + <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span>] = tree.data1[(i + <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span>] = (str[i] - <span class="hljs-string">&#x27;a&#x27;</span>);<br>        tree.<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; ++i) &#123;<br>            <span class="hljs-type">int</span> o, l, r, w;<br>            cin &gt;&gt; o &gt;&gt; l &gt;&gt; r;<br>            <span class="hljs-keyword">if</span> (o == <span class="hljs-number">1</span>) &#123;<br>                cin &gt;&gt; w;<br>                tree.<span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>, n, l, r, w % <span class="hljs-number">26</span>);<br>            &#125; <span class="hljs-keyword">else</span><br>            cout &lt;&lt; (tree.<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, n, l, r) ? <span class="hljs-string">&quot;NO&quot;</span> : <span class="hljs-string">&quot;YES&quot;</span>) &lt;&lt; endl;<br>        &#125;<br>        tree.<span class="hljs-built_in">debug</span>(<span class="hljs-number">1</span>, n);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Educational Codeforces Round 156 (Rated for Div. 2)</title>
    <link href="/2023/11/20/acm/codeforces/EducationalCodeforcesRound156/"/>
    <url>/2023/11/20/acm/codeforces/EducationalCodeforcesRound156/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Sum-of-Three"><a href="#A-Sum-of-Three" class="headerlink" title="A. Sum of Three"></a>A. Sum of Three</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>将一个数拆成三个数，要求这三个数不同且都不是 $3$ 的倍数，给出一种拆法即可</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>要拆成三个不同的数，且都不是 $3$ 的倍数，那么最小之能拆成 $1, 2, x$ 且 $x \geq 4$，而且还得保证 $x$ 不是 $3$ 的倍数。若这样拆了之后 $x$ 还是 $3$ 的倍数，那就只能 $1, 4, x$ 这样拆</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">6</span> || n == <span class="hljs-number">9</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n % <span class="hljs-number">3</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>            cout &lt;&lt; <span class="hljs-string">&quot;1 2 &quot;</span> &lt;&lt; n - <span class="hljs-number">3</span> &lt;&lt; endl;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>            cout &lt;&lt; <span class="hljs-string">&quot;1 4 &quot;</span> &lt;&lt; n - <span class="hljs-number">5</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Fear-of-the-Dark"><a href="#B-Fear-of-the-Dark" class="headerlink" title="B. Fear of the Dark"></a>B. Fear of the Dark</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>笛卡尔坐标系上有两个灯，一个目标点，现在需要从 $(0, 0)$ 出发，走到目标点，路径完全任意，但是必须在灯光下走，问这两盏灯的最小灯光范围是多少</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>比较简单，只有两种可能：1、只用一盏灯，2、同时用两盏灯</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> px, py, ax, ay, bx, by;<br>        cin &gt;&gt; px &gt;&gt; py &gt;&gt; ax &gt;&gt; ay &gt;&gt; bx &gt;&gt; by;<br>        <span class="hljs-keyword">auto</span> dist = [&amp;](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>((a - x) * (a - x) + (b - y) * (b - y));<br>        &#125;;<br><br>        <span class="hljs-type">double</span> a0 = <span class="hljs-built_in">dist</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, ax, ay);<br>        <span class="hljs-type">double</span> b0 = <span class="hljs-built_in">dist</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, bx, by);<br>        <span class="hljs-type">double</span> ap = <span class="hljs-built_in">dist</span>(px, py, ax, ay);<br>        <span class="hljs-type">double</span> bp = <span class="hljs-built_in">dist</span>(px, py, bx, by);<br>        <span class="hljs-type">double</span> ab = <span class="hljs-built_in">dist</span>(ax, ay, bx, by);<br><br>        <span class="hljs-type">double</span> ans = <span class="hljs-built_in">max</span>(ap, a0);<br>        ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">max</span>(bp, b0));<br>        ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(<span class="hljs-built_in">min</span>(a0, b0), <span class="hljs-built_in">min</span>(ap, bp)), ab / <span class="hljs-number">2</span>));<br>        cout &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">10</span>) &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Decreasing-String"><a href="#C-Decreasing-String" class="headerlink" title="C. Decreasing String"></a>C. Decreasing String</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个初始的字符串，每次删除一个，使其每次都保证是字典序最小的方案，将每一次的结果字符串拼接，得到一个最终结果字符串，问这个字符串的第 $x$ 位的字母是什么</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>也是比较简单的题，要保证字典序最小，那就得使得字符串前缀尽可能保证非递减即可。用单调栈模拟一下就行</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br><br>    string str;<br>    str.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> pos;<br>        cin &gt;&gt; str &gt;&gt; pos;<br><br>        <span class="hljs-comment">// bs</span><br>        <span class="hljs-keyword">if</span> (pos &lt;= str.<span class="hljs-built_in">size</span>()) &#123;<br>            cout &lt;&lt; str[pos - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = str.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span> (l + <span class="hljs-number">1</span> &lt; r) &#123;<br>            <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> tot = (str.<span class="hljs-built_in">size</span>() + (str.<span class="hljs-built_in">size</span>() - mid)) * (mid + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (tot &lt; pos) l = mid;<br>            <span class="hljs-keyword">else</span> r = mid;<br>        &#125;<br>        pos -= (str.<span class="hljs-built_in">size</span>() + (str.<span class="hljs-built_in">size</span>() - l)) * (l + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br><br>        vector&lt;<span class="hljs-type">char</span>&gt; st;<br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>;<br>        l++;<br>        <span class="hljs-keyword">while</span> (l--) &#123;<br>            <span class="hljs-keyword">while</span> (cur &lt; str.<span class="hljs-built_in">size</span>() &amp;&amp; (st.<span class="hljs-built_in">empty</span>() || st.<span class="hljs-built_in">back</span>() &lt;= str[cur])) st.<span class="hljs-built_in">push_back</span>(str[cur++]);<br>            <span class="hljs-keyword">if</span> (cur == str.<span class="hljs-built_in">size</span>()) st.<span class="hljs-built_in">pop_back</span>();<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; st.<span class="hljs-built_in">back</span>() &gt; str[cur]) st.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        <span class="hljs-keyword">while</span> (cur &lt; str.<span class="hljs-built_in">size</span>()) st.<span class="hljs-built_in">push_back</span>(str[cur++]);<br><br>        cout &lt;&lt; st[pos];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 902 (Div. 2, based on COMPFEST 15 - Final Round)</title>
    <link href="/2023/10/29/acm/codeforces/CodeforcesRound902/"/>
    <url>/2023/10/29/acm/codeforces/CodeforcesRound902/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Goals-of-Victory"><a href="#A-Goals-of-Victory" class="headerlink" title="A. Goals of Victory"></a>A. Goals of Victory</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有 $n$ 只队伍，所有队伍两两对战，两个队伍因此得分之和一定为 0。将每个队伍的所有得分之和相加，现在已知其中 $n-1$ 个队伍的得分情况，问最后一个队伍的得分情况是</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>简单题，说白了就是所有人分数之和肯定是 $0$，那就把剩下的人都加起来，取负数就行了</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            tot += tmp;<br>        &#125;<br>        cout &lt;&lt; -tot &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Helmets-in-Night-Light"><a href="#B-Helmets-in-Night-Light" class="headerlink" title="B. Helmets in Night Light"></a>B. Helmets in Night Light</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>村长需要通知村里的所有人一个消息，村长每通知一个人，就要花费 $k$ 的成本，而听到消息的村民也可以相互通知，每个村民最多再通知 $a_i$ 个其他村民，同时每通知一个其他村民就要花费 $b_i$ 的费用，问最少的费用</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>村长可以无限通知，但是成本固定，所以能让成本低的村民通知的情况下，村长只需要通知一次即可，当成本低的村民的通知机会都用完了之后，剩下的都村长通知一下就行了</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, p;<br>        cin &gt;&gt; n &gt;&gt; p;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">data</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: data) cin &gt;&gt; i.second;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: data) cin &gt;&gt; i.first;<br>        <span class="hljs-type">int</span> cost = p, cnt = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">sort</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: data) &#123;<br>            <span class="hljs-keyword">if</span> (i.first &gt;= p) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-type">int</span> c = <span class="hljs-built_in">min</span>(n - cnt, i.second);<br>            cnt += c;<br>            cost += c * i.first;<br>            <span class="hljs-keyword">if</span> (cnt == n) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        cost += p * (n - cnt);<br>        cout &lt;&lt; cost &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Joyboard"><a href="#C-Joyboard" class="headerlink" title="C. Joyboard"></a>C. Joyboard</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组 $a$，其长度为 $n+1$，现在需要往第 $n+1$ 这个位置上放上一个在 $[0, m]$ 的整数，然后对于每一个 $a_i = a_{i+1} % i$ 问，如果希望整个数组中恰好有 $k$ 种不同的数字，则 $n+1$ 这个位置上的选择有多少</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>首先，无论最终填上的值有多大，最终只要经过第一层 $mod$ 操作后，其值一定在 $[0, n)$ 之间了，且经历第二次 $mod$ 操作后，一定会变成 $0$（因为计算是从大到小进行计算的，所以一定会遇到相同的值，否则都是大于当前值的，不会改变 $mod$ 的结果）。所以最终一定最多只能存在 $3$ 个不同的数字。</p><p>那么什么时候为 $1$ 个呢，也很简单，因为最终一定为 $0$，故开始值也必须为 $0$</p><p>然后是两个的情况，那么如果我一开始的值就是在 $[0, n)$ 之内，那么必然也可以满足，因为遇到的第一个可以 $mod$ 的值就是它自己</p><p>但是要考虑一种特殊情况，那就是恰好是 ${n, 2 \times n, 3 \times n \dots}$ 的情况，因为虽然不在 $[0, n)$ 之内，但是第一次 $mod$ 会直接变成 $0$</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, m, k;<br>        cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">2</span>) cout &lt;&lt; <span class="hljs-built_in">min</span>(m, n) + (m &gt; n ? (m / n) - <span class="hljs-number">1</span> : <span class="hljs-number">0</span>) &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (k == <span class="hljs-number">3</span>) cout &lt;&lt; <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, m - n) - (m &gt; n ? (m / n) - <span class="hljs-number">1</span> : <span class="hljs-number">0</span>) &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Effects-of-Anti-Pimples"><a href="#D-Effects-of-Anti-Pimples" class="headerlink" title="D. Effects of Anti Pimples"></a>D. Effects of Anti Pimples</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组 $a$，开始的时候都是白色，每次可以任意选择一个或者几个数字，将其染上黑色。然后将每个黑色的位置下标的倍数处，染成绿色。最后从不是白色的块中选出值最高的。问所有的选择情况下，所有得到的值之和是多少</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>看起来很简单，但是实际上也非常简单的题</p><p>如果一个值被染成黑色，那么其能够带来的效果是确定的，即其倍数上的节点中最大的那个，我们将其先成为可能最大值</p><p>接下来是统计每个最大值的出现的次数，简单来说就是相同的可能最大值中挑选任意几个（至少一个），然后在剩下的可能最大值小于当前值中挑选 $0$ 个或者多个即可，即 $\sum<em>{i=1}^{t} \binom{i}{t} * \sum</em>{i=0}^{n-t} \binom{i}{n-t}$</p><p>而这里的求和又非常的简单，因为 $\sum_{i=0}^{x} \binom{i}{x} = 2^x$，所以，就非常简单了</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">c0</span><span class="hljs-params">(<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>)</span>, <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>)</span></span>;<br>    c0[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    c1[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; c0.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        c0[i] = (c0[i - <span class="hljs-number">1</span>] * <span class="hljs-number">2</span>) % mod;<br>        c1[i] = (c0[i] + mod - <span class="hljs-number">1</span>) % mod;<br>    &#125;<br><br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span>, <span class="hljs-title">top</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: data) cin &gt;&gt; i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        top[i] = data[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= n; j += i + <span class="hljs-number">1</span>)<br>            top[i] = <span class="hljs-built_in">max</span>(top[i], data[j - <span class="hljs-number">1</span>]);<br>    &#125;<br>    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: top) cnt[i]++;<br>    <span class="hljs-type">int</span> last = n, ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = cnt.<span class="hljs-built_in">rbegin</span>(); iter != cnt.<span class="hljs-built_in">rend</span>(); ++iter) &#123;<br>        last -= iter-&gt;second;<br>        ans = (ans + ((iter-&gt;first * ((c1[iter-&gt;second] * c0[last]) % mod)) % mod)) % mod;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 901 (Div. 2)</title>
    <link href="/2023/10/28/acm/codeforces/CodeforcesRound901/"/>
    <url>/2023/10/28/acm/codeforces/CodeforcesRound901/</url>
    
    <content type="html"><![CDATA[<p><em>最近双十一加班严重，难得有一个完整的周末假期，来写点题稍微恢复一下脑子吧</em></p><h1 id="A-Jellyfish-and-Undertale"><a href="#A-Jellyfish-and-Undertale" class="headerlink" title="A. Jellyfish and Undertale"></a>A. Jellyfish and Undertale</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个炸弹，有倒计时在缓慢减少，你有 $n$ 个道具，每次你可以花费 1s 的时间来使用，使得倒计时增加 $v_i$<br>秒，但是由于一些故障，每次加完后，不能超过上限 $a$，否则就会变成 $a$。问最多可以让炸弹坚持到几秒</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>注意操作可以是任何时候进行的，所以当每次只剩下 1s 的时候操作就是最好的，不然就炸了，因为是先完成加时间，再扣除当前操作的<br>1s，故只需要考虑每个都在 1s 的时候操作即可，即对每个值取 $min(v_i, a - 1)$ 然后求和就行了</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> a, b, n;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            b += <span class="hljs-built_in">min</span>(tmp, a - <span class="hljs-number">1</span>);<br>        &#125;<br>        cout &lt;&lt; b &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Jellyfish-and-Game"><a href="#B-Jellyfish-and-Game" class="headerlink" title="B. Jellyfish and Game"></a>B. Jellyfish and Game</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>A 有 $n$ 个苹果，每个都有重量，B 有 $m$ 个，每次交换，A 或者 B 可以选择自己的一个苹果给对方，同时从对方那边拿来一个苹果，两人都希望自己的苹果重量之和最大，问依次交换<br>$x$ 次后，$A$ 的苹果重量之和是多少</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>模拟就行了，说白了交换了两次之后，就是纯粹的互换相同的那两个苹果，只需要考虑最开始的两次即可</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, m, k;<br>        cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span>, <span class="hljs-title">b</span><span class="hljs-params">(m)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: a) cin &gt;&gt; i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: b) cin &gt;&gt; i;<br>        <span class="hljs-keyword">auto</span> sort_all = [&amp;]() &#123;<br>            <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>());<br>            <span class="hljs-built_in">sort</span>(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>());<br>        &#125;;<br>        <span class="hljs-built_in">sort_all</span>();<br>        <span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">front</span>() &lt; b.<span class="hljs-built_in">back</span>()) &#123;<br>            <span class="hljs-built_in">swap</span>(a.<span class="hljs-built_in">front</span>(), b.<span class="hljs-built_in">back</span>());<br>        &#125;<br>        <span class="hljs-keyword">if</span> (k &gt;= <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-built_in">sort_all</span>();<br>            <span class="hljs-keyword">if</span> (b.<span class="hljs-built_in">front</span>() &lt; a.<span class="hljs-built_in">back</span>()) &#123;<br>                <span class="hljs-built_in">swap</span>(b.<span class="hljs-built_in">front</span>(), a.<span class="hljs-built_in">back</span>());<br>            &#125;<br>            <span class="hljs-keyword">if</span> (k % <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-built_in">sort_all</span>();<br>                <span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">front</span>() &lt; b.<span class="hljs-built_in">back</span>()) &#123;<br>                    <span class="hljs-built_in">swap</span>(a.<span class="hljs-built_in">front</span>(), b.<span class="hljs-built_in">back</span>());<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i : a) tot += i;<br>        cout &lt;&lt; tot &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Jellyfish-and-Green-Apple"><a href="#C-Jellyfish-and-Green-Apple" class="headerlink" title="C. Jellyfish and Green Apple"></a>C. Jellyfish and Green Apple</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有 $n$ 个苹果，要平均分给 $m$ 个人，每次可以把一片苹果平均切成两份，问至少要切几刀才能平分</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>其实是一个小数二进制问题，根据小数二进制方式去解决，从高位开始，一步步减去需要的苹果块，每一步减完之后，就可以将剩下来的苹果块全部对切开，因为不会再用到更大的苹果块了</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, m;<br>        cin &gt;&gt; n &gt;&gt; m;<br>        n %= m;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">// check m is or not the power of 2</span><br>        <span class="hljs-type">int</span> tmp = <span class="hljs-built_in">gcd</span>(m, n);<br>        tmp = m / tmp;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (tmp != <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (tmp % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            tmp &gt;&gt;= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!flag) &#123;<br>            cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> ans = n;<br>        n &lt;&lt;= <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (n) &#123;<br>            n %= m;<br>            ans += n;<br>            n &lt;&lt;= <span class="hljs-number">1</span>;<br>        &#125;<br><br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Jellyfish-and-Mex"><a href="#D-Jellyfish-and-Mex" class="headerlink" title="D. Jellyfish and Mex"></a>D. Jellyfish and Mex</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组，每次可以从中删除一个值，然后得到对应的 $mex$，问直到整个数组被完整删除后，所有得到的 $mex$，相加最小可能是多少</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>举个例子来看</p><blockquote><p>0 0 0 1 1 2 3 3 3 4 4 4 5 5 5</p></blockquote><p>首先要让 $mex$ 尽可能小，那么就应该尽量挑小的开始删除，显然，如果我把 $0$ 删除完那就会使得后面所有的操作都是无代价的，即随便删的<br>$mex$ 都是 $0$。但是直接删除 $0$ 的代价非常大，因为前两次删除都会导致代价为 $6$ 的 $mex$。这是因为 $0$ 出现了 $3$ 次。如果我们先删除<br>$2$，然后再删除 $0$ 那么就会发现，只需要额外增加 $2$ 的代价，就能让后面删除 $0$ 的两次操作的代价从 $6$ 减少到 $2$。</p><p>所以可以得到，我们尽量应该删除越少越小的值，即如果值增加的情况下，数量还不减少，那么肯定没有必要优先做删除了，可以等 $mex$ 变成<br>$0$ 之后再动手。而对于这些值，当然也应该从较大者开始删除，这样可以尽快减小 $mex$<br>的值（因为在上面的前提下，最大值的出现次数一定比较小值少）但是不能每个值都要操作，例如例子中的 $1$<br>就是不需要操作的，即使其恰好在这条单调栈上，即需要从一个序列中取出最优的子序列</p><p>我们考虑最多会出现多少个这样的需要考虑的数字，假设刚好递减的情况，且数量为 $n$，那么总占用的数字数量就是 $n * (n + 1) /<br>2$。故对于长度为 $5000$ 的数组，实际上 $n &lt; 100$。即 $n^2$ 暴力去找子序列是可以的</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            mp[tmp]++;<br>        &#125;<br><br>        <span class="hljs-type">int</span> mex = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (mp.<span class="hljs-built_in">count</span>(mex)) mex++;<br><br>        <span class="hljs-keyword">if</span> (mex == <span class="hljs-number">0</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; data;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;iter: mp) &#123;<br>            <span class="hljs-keyword">if</span> (iter.first &gt; mex) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">empty</span>() || data.<span class="hljs-built_in">back</span>().second &gt; iter.second)<br>                data.<span class="hljs-built_in">emplace_back</span>(iter);<br>        &#125;<br>        <span class="hljs-built_in">reverse</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(data.size())</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; data.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            dp[i] = (data[i].second - <span class="hljs-number">1</span>) * mex + data[i].first;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j)<br>                dp[i] = <span class="hljs-built_in">min</span>(dp[i], (data[i].second - <span class="hljs-number">1</span>) * data[j].first + data[i].first + dp[j]);<br>        &#125;<br><br>        cout &lt;&lt; dp.<span class="hljs-built_in">back</span>() &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 900 (Div. 3)</title>
    <link href="/2023/10/05/acm/codeforces/CodeforcesRound900/"/>
    <url>/2023/10/05/acm/codeforces/CodeforcesRound900/</url>
    
    <content type="html"><![CDATA[<h1 id="A-How-Much-Does-Daytona-Cost"><a href="#A-How-Much-Does-Daytona-Cost" class="headerlink" title="A. How Much Does Daytona Cost?"></a>A. How Much Does Daytona Cost?</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给出一个数组和一个数字，问数组内是否存在某个子区间，使得给出的值出现次数最多</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>只有一个值也是子区间，只有它出现也是出现，所以只需要判断是否存在即可</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            <span class="hljs-keyword">if</span> (tmp == k) flag = <span class="hljs-literal">true</span>;<br>        &#125;<br>        cout &lt;&lt; (flag ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Aleksa-and-Stack"><a href="#B-Aleksa-and-Stack" class="headerlink" title="B. Aleksa and Stack"></a>B. Aleksa and Stack</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>要求你构造一个数组，长度为 $n$，严格递增，且满足 $3 \times a_{i+2} \space mod \space (a_{i+1} + a_{i+2}) \neq 0$</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>随便递增就行，要是成立了，就把 $a_{i+2}$ 再加一不就行了。注意开头两个值不可以是 $1, 2$</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>, b = <span class="hljs-number">3</span>;<br>        cout &lt;&lt; <span class="hljs-string">&quot;1 3&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> cur = b + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> ((cur * <span class="hljs-number">3</span>) % (a + b) == <span class="hljs-number">0</span>) cur++;<br>            cout &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; cur;<br>            a = b;<br>            b = cur;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Vasilije-in-Cacak"><a href="#C-Vasilije-in-Cacak" class="headerlink" title="C. Vasilije in Cacak"></a>C. Vasilije in Cacak</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>给出一个 $n$，问能否在 $[1, n]$ 内选出 $k$ 个值，其和恰好为 $x$</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>初始区间是 $[1, n]$，那么肯定最终能够构造出的值必定也是完全连续的，所以只需要考虑最大可能和最小可能即可</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, k, x;<br>        cin &gt;&gt; n &gt;&gt; k &gt;&gt; x;<br>        <span class="hljs-type">int</span> mi = (<span class="hljs-number">1</span> + k) * k / <span class="hljs-number">2</span>, ma = (n + (n - k + <span class="hljs-number">1</span>)) * k / <span class="hljs-number">2</span>;<br>        cout &lt;&lt; (x &gt;= mi &amp;&amp; x &lt;= ma ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Reverse-Madness"><a href="#D-Reverse-Madness" class="headerlink" title="D. Reverse Madness"></a>D. Reverse Madness</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>这题的题意隐藏得很好，就不写大致题意了，看原文会更有味道一些</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>首先要理清楚题目到底要我们做什么，如果直接按照题目的要求去做，反而完全不知道如何下手</p><p>在给出一个 $x$ 后，查找到一个对应的 $i$ 满足 $l_i \leq x \leq r_i$，然后翻转 $[min(x, l_i + r_i - x), max(x, l_i + r_i - x)]$ 这个区间的字符串，问最终结果</p><p>首先回来看给出的两个数组的特点，比较有意思的一条 $l_i = r_{i-1}+1$。如果把每个 $i$ 对应的区间 $[l_i, r_i]$ 单独拎出来看，会发现这些所有的区间是不会重合的，是恰好完美覆盖整个字符串的，所以，查找到一个对应的 $i$ 满足 $l_i \leq x \leq r_i$，实际上就是要找到此时的 $x$ 处于哪个区间上</p><p>再来看后面的 $[min(x, l_i + r_i - x), max(x, l_i + r_i - x)]$。因为我们已经知道 $l_i \leq x \leq r_i$，所以设 $x = l + m, r = x + n$，故可以得到 $l_i + r_i - x \rightarrow l_i + x + n - x \rightarrow l_i + n \rightarrow r_i - m - n + n \rightarrow r_i - m$，而注意到 $x = l_i + m$，所以实际上最终的区间恰好是 $[l + m, r - m]$（假定 $m$ 较小的情况下，反之也可以得到类似结果）</p><p>很显然，实际上无论怎么翻转，大家的翻转区间要么不会有交集，要么是基于同一个点进行的翻转，所以实际上只需要记录下每个点被翻转了几次即可</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        string str;<br>        str.<span class="hljs-built_in">reserve</span>(n);<br>        cin &gt;&gt; str;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(k)</span>, <span class="hljs-title">b</span><span class="hljs-params">(k)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: a) cin &gt;&gt; i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: b) cin &gt;&gt; i;<br><br>        <span class="hljs-type">int</span> q;<br>        cin &gt;&gt; q;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">flag</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; ++i) &#123;<br>            <span class="hljs-type">int</span> x;<br>            cin &gt;&gt; x;<br>            <span class="hljs-type">int</span> index = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">upper_bound</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), x) - a.<span class="hljs-built_in">begin</span>()) - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> l = <span class="hljs-built_in">min</span>(a[index] + b[index] - x, x), r = <span class="hljs-built_in">max</span>(a[index] + b[index] - x, x);<br>            flag[l] = !flag[l];<br>            <span class="hljs-keyword">if</span> (r != b[index]) flag[r + <span class="hljs-number">1</span>] = !flag[r + <span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            <span class="hljs-type">bool</span> f = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = a[i]; l &lt;= b[i]; ++l) &#123;<br>                f ^= flag[l];<br>                <span class="hljs-keyword">if</span> (!f) cout &lt;&lt; str[l - <span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">else</span> cout &lt;&lt; str[b[i] - (l - a[i]) - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="E-Iva-amp-Pav"><a href="#E-Iva-amp-Pav" class="headerlink" title="E. Iva &amp; Pav"></a>E. Iva &amp; Pav</h1><h2 id="大致题意-4"><a href="#大致题意-4" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组，每次给出一个下标 $l$ 和一个目标值 $x$，问能够找到另外一个尽可能大的下标 $r$，满足 $[l, r]$ 内所有值进行 $\&amp;$ 计算后仍然大于 $x$</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>建了一棵线段树，然后二分答案，然后没了</p><h2 id="AC-code-4"><a href="#AC-code-4" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegTree</span> &#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; data;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">SegTree</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span> : data((size &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">10</span>) &#123;</span>&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123; <span class="hljs-keyword">return</span> (l + r) | (l != r); &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        data[<span class="hljs-built_in">get</span>(l, r)] = data[<span class="hljs-built_in">get</span>(l, mid)] &amp; data[<span class="hljs-built_in">get</span>(mid + <span class="hljs-number">1</span>, r)];<br>    &#125;<br><br>    <span class="hljs-comment">// NOLINTNEXTLINE(*-no-recursion)</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">build</span>(l, mid);<br>        <span class="hljs-built_in">build</span>(mid + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-built_in">up</span>(l, r);<br>    &#125;<br><br>    <span class="hljs-comment">// NOLINTNEXTLINE(*-no-recursion)</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == x &amp;&amp; r == y) <span class="hljs-keyword">return</span> data[<span class="hljs-built_in">get</span>(l, r)];<br>        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (y &lt;= mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(l, mid, x, y);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt; mid) <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(mid + <span class="hljs-number">1</span>, r, x, y);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(l, mid, x, mid) &amp; <span class="hljs-built_in">query</span>(mid + <span class="hljs-number">1</span>, r, mid + <span class="hljs-number">1</span>, y);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">SegTree <span class="hljs-title">tree</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cin &gt;&gt; tree.data[(i + <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span>];<br>        tree.<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, n);<br>        <span class="hljs-type">int</span> q;<br>        cin &gt;&gt; q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; ++i) &#123;<br>            <span class="hljs-type">int</span> l, k;<br>            cin &gt;&gt; l &gt;&gt; k;<br>            <span class="hljs-keyword">if</span> (tree.data[l &lt;&lt; <span class="hljs-number">1</span>] &lt; k) &#123;<br>                cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-type">int</span> ll = l, rr = n + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (ll + <span class="hljs-number">1</span> &lt; rr) &#123;<br>                <span class="hljs-type">int</span> mid = (ll + rr) &gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (tree.<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, n, l, mid) &gt;= k) ll = mid;<br>                <span class="hljs-keyword">else</span> rr = mid;<br>            &#125;<br>            cout &lt;&lt; ll &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="F-Vasilije-Loves-Number-Theory"><a href="#F-Vasilije-Loves-Number-Theory" class="headerlink" title="F. Vasilije Loves Number Theory"></a>F. Vasilije Loves Number Theory</h1><h2 id="大致题意-5"><a href="#大致题意-5" class="headerlink" title="大致题意"></a>大致题意</h2><p>初始有一个值 $n$，有两种操作</p><ul><li>给出一个 $x$，使得 $n \leftarrow n \times x$，然后询问是否存在数字 $a$，满足 $gcd(a, n) = 1$ 的同时 $d(n \times a) = n$</li><li>将 $n$ 改为初始值</li></ul><p>其中 $d(x)$ 表示 $x$ 的因子数（非质因子数）</p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>首先，$n$ 几乎可以增长到非常大，所以肯定不能保存下来，当然，麻烦的事情肯定不止这个。</p><p>首先是 $d(n \times a)$ 如何计算，已知两个数的所有因子，且因子没有重复（$gcd(a, n) = 1$）则此时 $d(n \times a) = d(n) \times d(a)$，而这个等式还需要 $=n$，故得到 $d(a) = \frac{n}{d(n)}$，而因为 $d(a)$ 一定是正整数，所以只需要满足右边的分数是整数即可。至于 $a$ 具体如何构造，可以直接拿一个足够大的素数的 $\frac{n}{d(n)} - 1$ 次幂即可</p><p>计算 $d(n)$ 则只需要对 $n$ 进行质因子分解即可，根据每次的乘法，进行累加质因子。而需要计算 $\frac{n}{d(n)}$ 是否是整数，则可以再对 $d(n)$ 进行质因子分解，看看两边的质因子是否有包含关系即可</p><h2 id="AC-code-5"><a href="#AC-code-5" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; prime;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">flag</span><span class="hljs-params">(<span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>, <span class="hljs-literal">true</span>)</span></span>;<br>    flag[<span class="hljs-number">0</span>] = flag[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; flag.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (!flag[i]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i * i; j &lt; flag.<span class="hljs-built_in">size</span>(); j += i) flag[j] = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; flag.<span class="hljs-built_in">size</span>(); ++i) <span class="hljs-keyword">if</span> (flag[i]) prime.<span class="hljs-built_in">push_back</span>(i);<br>    <span class="hljs-keyword">auto</span> div = [&amp;](<span class="hljs-type">int</span> x, <span class="hljs-type">const</span> function&lt;<span class="hljs-built_in">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; &amp;callback) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i: prime) &#123;<br>            <span class="hljs-keyword">if</span> (x % i != <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (x % i == <span class="hljs-number">0</span>) &#123;<br>                cnt++;<br>                x /= i;<br>            &#125;<br>            <span class="hljs-built_in">callback</span>(i, cnt);<br>            <span class="hljs-keyword">if</span> (flag[x]) &#123;<br>                <span class="hljs-built_in">callback</span>(x, <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, q;<br>        cin &gt;&gt; n &gt;&gt; q;<br>        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt;<br>        <span class="hljs-type">int</span> dn = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">auto</span> add = [&amp;](<span class="hljs-type">int</span> v, <span class="hljs-type">int</span> c) &#123;<br>            <span class="hljs-keyword">auto</span> iter = cnt.<span class="hljs-built_in">find</span>(v);<br>            <span class="hljs-keyword">if</span> (iter == cnt.<span class="hljs-built_in">end</span>()) &#123;<br>                cnt.<span class="hljs-built_in">insert</span>(&#123;v, <span class="hljs-number">0</span>&#125;);<br>                iter = cnt.<span class="hljs-built_in">find</span>(v);<br>            &#125;<br>            dn /= iter-&gt;second + <span class="hljs-number">1</span>;<br>            iter-&gt;second += c;<br>            dn *= iter-&gt;second + <span class="hljs-number">1</span>;<br>        &#125;;<br>        <span class="hljs-built_in">div</span>(n, add);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; ++i) &#123;<br>            <span class="hljs-type">int</span> o;<br>            cin &gt;&gt; o;<br>            <span class="hljs-keyword">switch</span> (o) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">1LL</span>: &#123;<br>                    <span class="hljs-type">int</span> x;<br>                    cin &gt;&gt; x;<br>                    <span class="hljs-built_in">div</span>(x, add);<br>                    <span class="hljs-type">bool</span> f = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-built_in">div</span>(dn, [&amp;](<span class="hljs-type">int</span> v, <span class="hljs-type">int</span> c) &#123;<br>                        <span class="hljs-keyword">if</span> (cnt[v] &lt; c) f = <span class="hljs-literal">false</span>;<br>                    &#125;);<br>                    cout &lt;&lt; (f ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">2LL</span>:<br>                    cnt.<span class="hljs-built_in">clear</span>();<br>                    dn = <span class="hljs-number">1</span>;<br>                    <span class="hljs-built_in">div</span>(n, add);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="G-wxhtzdy-ORO-Tree"><a href="#G-wxhtzdy-ORO-Tree" class="headerlink" title="G. wxhtzdy ORO Tree"></a>G. wxhtzdy ORO Tree</h1><h2 id="大致题意-6"><a href="#大致题意-6" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一棵树，树上每个点上都有值，每次询问给出两个点 $u, v$，需要寻找一个 $z$，使得</p><ul><li>$z$ 在 $u, v$ 的树上路径上，即最短路径上</li><li>$g(u, z) + g(z, v)$ 的值尽可能大</li></ul><p>其中 $g(x, y)$ 表示在树上的 $x, y$ 两点的最短路径上的所有值进行或运算，得到的结果的值在二进制上，有多少个 bit 位是 <code>1</code></p><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>首先要找树上路径，大概率会用到 lca 算法。接下来因为要求算树上路径的或和，所以还可以在 lca 上加一个父节点的或运算的倍增表</p><p>而要寻找的点一定在两者的倍增节点上，由于目标节点一定是恰好可以产生一个比特位从 $o \rightarrow 1$ 的变化的，所以可以再记录下一个点的所有比特位，在其的最近的哪个父亲那完成了 $o \rightarrow 1$ 的变化</p><p>然后遍历所有的可能计算即可</p><h2 id="AC-code-6"><a href="#AC-code-6" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i];<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>            <span class="hljs-type">int</span> v, n;<br>        &#125;;<br>        <span class="hljs-function">vector&lt;node&gt; <span class="hljs-title">edge</span><span class="hljs-params">(n * <span class="hljs-number">2</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">head</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-type">int</span> u, v;<br>            cin &gt;&gt; u &gt;&gt; v;<br>            edge[i &lt;&lt; <span class="hljs-number">1</span>] = &#123;v, head[u]&#125;;<br>            edge[(i &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>] = &#123;u, head[v]&#125;;<br>            head[u] = i &lt;&lt; <span class="hljs-number">1</span>;<br>            head[v] = (i &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// dep is the depth of node</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dep</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-comment">// fa for lca, orFa for calculate &#x27;or sum&#x27; faster, miB for the deepest node `x` which (x &amp; (1 &lt;&lt; i)) is true</span><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">fa</span>(n + <span class="hljs-number">1</span>), <span class="hljs-built_in">orFa</span>(n + <span class="hljs-number">1</span>), <span class="hljs-built_in">miB</span>(n + <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: fa) i.<span class="hljs-built_in">resize</span>(<span class="hljs-number">20</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: orFa) i.<span class="hljs-built_in">resize</span>(<span class="hljs-number">20</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: miB) i.<span class="hljs-built_in">resize</span>(<span class="hljs-number">30</span>);<br><br>        <span class="hljs-comment">// build lca</span><br>        function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> p) &#123;<br>            dep[u] = dep[p] + <span class="hljs-number">1</span>;<br><br>            fa[u][<span class="hljs-number">0</span>] = p;<br>            orFa[u][<span class="hljs-number">0</span>] = a[p];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">20</span>; ++i) &#123;<br>                fa[u][i] = fa[fa[u][i - <span class="hljs-number">1</span>]][i - <span class="hljs-number">1</span>];<br>                orFa[u][i] = orFa[u][i - <span class="hljs-number">1</span>] | orFa[fa[u][i - <span class="hljs-number">1</span>]][i - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; ++i) miB[u][i] = (a[p] &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) ? p : miB[p][i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[u]; ~i; i = edge[i].n) <span class="hljs-keyword">if</span> (edge[i].v != p) <span class="hljs-built_in">dfs</span>(edge[i].v, u);<br>        &#125;;<br>        <span class="hljs-comment">// lca</span><br>        function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; lca = [&amp;](<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v) &#123;<br>            <span class="hljs-keyword">if</span> (dep[u] &lt; dep[v]) <span class="hljs-built_in">swap</span>(u, v);<br>            <span class="hljs-type">int</span> diff = dep[u] - dep[v];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; ++i) <span class="hljs-keyword">if</span> (diff &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) u = fa[u][i];<br>            <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> u;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">19</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>                <span class="hljs-keyword">if</span> (fa[u][i] == fa[v][i]) <span class="hljs-keyword">continue</span>;<br>                u = fa[u][i];<br>                v = fa[v][i];<br>            &#125;<br>            <span class="hljs-keyword">return</span> fa[u][<span class="hljs-number">0</span>];<br>        &#125;;<br>        <span class="hljs-comment">// calculate the &#x27;or sum&#x27; from u to v</span><br>        function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; ors = [&amp;](<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v) &#123;<br>            <span class="hljs-type">int</span> p = <span class="hljs-built_in">lca</span>(u, v);<br>            <span class="hljs-comment">// -1 to avoid &#x27;or&#x27; the parent double times</span><br>            <span class="hljs-type">int</span> ld = dep[u] - dep[p] - <span class="hljs-number">1</span>, rd = dep[v] - dep[p] - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> ls = <span class="hljs-number">0</span>, rs = <span class="hljs-number">0</span>, ru = u, rv = v;<br><br>            <span class="hljs-keyword">if</span> (ld &gt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; ++i)<br>                    <span class="hljs-keyword">if</span> (ld &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) &#123;<br>                        ls |= orFa[ru][i];<br>                        ru = fa[ru][i];<br>                    &#125;<br>            <span class="hljs-keyword">if</span> (rd &gt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; ++i)<br>                    <span class="hljs-keyword">if</span> (rd &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) &#123;<br>                        rs |= orFa[rv][i];<br>                        rv = fa[rv][i];<br>                    &#125;<br>            <span class="hljs-keyword">return</span> ls | rs | a[p] | (p == u ? <span class="hljs-number">0</span> : a[u]) | (p == v ? <span class="hljs-number">0</span> : a[v]);<br>        &#125;;<br>        <span class="hljs-comment">// calculate the bit count</span><br>        function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>)&gt; bitCount = [&amp;](<span class="hljs-type">int</span> u) &#123;<br>            <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (u) &#123;<br>                res += u &amp; <span class="hljs-number">1</span>;<br>                u &gt;&gt;= <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;;<br>        <span class="hljs-comment">// find on the path (u -&gt; p)</span><br>        function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; cal = [&amp;](<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> p) &#123;<br>            <span class="hljs-type">int</span> ans = <span class="hljs-built_in">bitCount</span>(a[u]) + <span class="hljs-built_in">bitCount</span>(<span class="hljs-built_in">ors</span>(u, v));<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; ++i) &#123;<br>                <span class="hljs-keyword">if</span> (miB[u][i] == <span class="hljs-number">0</span> || miB[u][i] == u) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> (dep[p] &gt; dep[miB[u][i]]) <span class="hljs-keyword">continue</span>;<br>                ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">bitCount</span>(<span class="hljs-built_in">ors</span>(u, miB[u][i])) + <span class="hljs-built_in">bitCount</span>(<span class="hljs-built_in">ors</span>(v, miB[u][i])));<br>            &#125;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-type">int</span> q;<br>        cin &gt;&gt; q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; ++i) &#123;<br>            <span class="hljs-type">int</span> u, v;<br>            cin &gt;&gt; u &gt;&gt; v;<br>            <span class="hljs-type">int</span> p = <span class="hljs-built_in">lca</span>(u, v);<br>            cout &lt;&lt; <span class="hljs-built_in">max</span>(<span class="hljs-built_in">cal</span>(u, v, p), <span class="hljs-built_in">cal</span>(v, u, p)) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 899 (Div. 2)</title>
    <link href="/2023/10/04/acm/codeforces/CodeforcesRound899/"/>
    <url>/2023/10/04/acm/codeforces/CodeforcesRound899/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Increasing-Sequence"><a href="#A-Increasing-Sequence" class="headerlink" title="A. Increasing Sequence"></a>A. Increasing Sequence</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个初始的数组，要求构造另外一个数组，使得新数组严格递增，同时任何一项不与原来的数组的对应项相同，问这个数组最后一个值最小是多少</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由于严格递增，所以最小的方式就是 $1, 2, 3, 4 \dots$，再考虑一下不能相同的这个情况，容易得到如果按照上述的方式撞上了相同，那么就再加一即可</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: data) cin &gt;&gt; i;<br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i: data) &#123;<br>            cur++;<br>            <span class="hljs-keyword">if</span> (cur == i) cur++;<br>        &#125;<br>        cout &lt;&lt; cur &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Sets-and-Union"><a href="#B-Sets-and-Union" class="headerlink" title="B. Sets and Union"></a>B. Sets and Union</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一堆集合，需要选出几个集合，使得这几个集合合并后的集合的元素数量尽可能多的同时，与全部集合直接合并的结果不同，问最大的集合元素数量</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>因为数据量比较小，所以可以暴力解决，最简单的方式就是直接遍历所有可能的最终不出现在答案中的某个值，然后尝试最大化最终结果即可</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">data</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: data) &#123;<br>            <span class="hljs-type">int</span> s;<br>            cin &gt;&gt; s;<br>            i.<span class="hljs-built_in">resize</span>(s);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;j: i) cin &gt;&gt; j;<br>        &#125;<br>        <span class="hljs-type">int</span> cnt[<span class="hljs-number">52</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: data) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;j: i) cnt[j]++;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">52</span>; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (cnt[i] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            set&lt;<span class="hljs-type">int</span>&gt; st;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;a: data) &#123;<br>                <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;b: a) <span class="hljs-keyword">if</span> (b == i) flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">if</span> (!flag) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;b: a) st.<span class="hljs-built_in">insert</span>(b);<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, (<span class="hljs-type">int</span>) st.<span class="hljs-built_in">size</span>());<br>        &#125;<br><br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Card-Game"><a href="#C-Card-Game" class="headerlink" title="C. Card Game"></a>C. Card Game</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组，每一个值可能是任何整数，允许你每次选择一个当前在奇数位置的值，并得到对应的分数，或者删除掉一个当前在偶数位置的值。数组被取走值后会重新获得新的下标（不留出空位）问最多可以得到多少总分</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>假定某个位置，我们对它进行了操作，无论是删除 or 得到对应的分数，总之其后面的所有值的下标都会经历奇数和偶数的两种可能，意味着对于后面的值，如果它是负数，那我一定能找到一个时间将其直接删除，否则我一定可以计算进入我的分数</p><p>所以只要知道第一个被操作的值是谁就行，其后面的所有正数都可以加入到分数中，而负数都可以删除。故直接从后往前遍历即可</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp">```<br><br><br># D. Tree XOR<br><br>## 思路<br><br>快可以说是树上换根 dp 模版题了，不解释了<br><br>## AC code<br><br>```cpp<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i];<br><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>            <span class="hljs-type">int</span> v, n;<br>        &#125;;<br>        <span class="hljs-function">vector&lt;node&gt; <span class="hljs-title">edge</span><span class="hljs-params">(n * <span class="hljs-number">2</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">head</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-type">int</span> u, v;<br>            cin &gt;&gt; u &gt;&gt; v;<br>            edge[i &lt;&lt; <span class="hljs-number">1</span>].v = u;<br>            edge[i &lt;&lt; <span class="hljs-number">1</span>].n = head[v];<br>            head[v] = i &lt;&lt; <span class="hljs-number">1</span>;<br><br>            edge[(i &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>].v = v;<br>            edge[(i &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>].n = head[u];<br>            head[u] = (i &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span>, <span class="hljs-title">cost</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs1 = [&amp;](<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> f) &#123;<br>            cnt[u] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[u]; ~i; i = edge[i].n) &#123;<br>                <span class="hljs-type">int</span> v = edge[i].v;<br>                <span class="hljs-keyword">if</span> (v == f) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-built_in">dfs1</span>(v, u);<br>                cnt[u] += cnt[v];<br>                cost[u] += cost[v];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (f) cost[u] += (a[u] ^ a[f]) * cnt[u];<br>        &#125;;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs2 = [&amp;](<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> f) &#123;<br>            ans[u] = ans[f];<br>            ans[u] -= cnt[u] * (a[u] ^ a[f]);<br>            ans[u] += (n - cnt[u]) * (a[u] ^ a[f]);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[u]; ~i; i = edge[i].n) &#123;<br>                <span class="hljs-keyword">if</span> (edge[i].v == f) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-built_in">dfs2</span>(edge[i].v, u);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        ans[<span class="hljs-number">1</span>] = cost[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[<span class="hljs-number">1</span>]; ~i; i = edge[i].n) <span class="hljs-built_in">dfs2</span>(edge[i].v, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Educational Codeforces Round#155 (Div. 2)</title>
    <link href="/2023/10/02/acm/codeforces/EducationalCodeforcesRound155/"/>
    <url>/2023/10/02/acm/codeforces/EducationalCodeforcesRound155/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Rigged"><a href="#A-Rigged" class="headerlink" title="A. Rigged!"></a>A. Rigged!</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有 $n$ 个人，每个人都可以举起最高一定重量的哑铃 $b_i$ 次，而每个人举的哑铃是同一个，最终举起次数最多的人获胜，裁判希望第一个人获胜，问应该陪多少的哑铃，或者不可能</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>简单题，只要没有人既能举起比第一个人更重的同时，能够举起更多次就行，重量很直接选第一个人能举起的上线就行</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, s, e;<br>        cin &gt;&gt; n &gt;&gt; s &gt;&gt; e;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-type">int</span> u, v;<br>            cin &gt;&gt; u &gt;&gt; v;<br>            <span class="hljs-keyword">if</span> (u &gt;= s &amp;&amp; v &gt;= e) &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        cout &lt;&lt; (flag ? s : <span class="hljs-number">-1</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Chips-on-the-Board"><a href="#B-Chips-on-the-Board" class="headerlink" title="B. Chips on the Board"></a>B. Chips on the Board</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个棋盘，每个位置的价值是对应的横坐标价格和纵坐标价格相加。现在可以往棋盘上放棋子，费用上位置的价值。放上数个后，使得棋盘上每一个位置，其所在的行或者所在的列中至少存在一个棋子，问最小费用</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>简单题，容易得出，必定每一行或者每一列都有一个棋子，这是最低的要求，然后就很简单了</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-type">int</span> ma = LONG_LONG_MAX, mb = LONG_LONG_MAX, sa = <span class="hljs-number">0</span>, sb = <span class="hljs-number">0</span>, tmp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            cin &gt;&gt; tmp;<br>            ma = <span class="hljs-built_in">min</span>(ma, tmp);<br>            sa += tmp;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            cin &gt;&gt; tmp;<br>            mb = <span class="hljs-built_in">min</span>(mb, tmp);<br>            sb += tmp;<br>        &#125;<br><br>        cout &lt;&lt; <span class="hljs-built_in">min</span>(sa + n * mb, sb + n * ma) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Make-it-Alternating"><a href="#C-Make-it-Alternating" class="headerlink" title="C. Make it Alternating"></a>C. Make it Alternating</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个 $01$ 串，允许按照一定顺序删除掉一些字符，使得整个字符串没有连续的相同字符，问有多少种删除方式</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>拿一个例子进行考虑，比如 $11000$，明显，我们需要在前两个中删除一个，在后面三个中删除两个，然后这三个值的顺序任意都可，所以就是</p>$$\begin{pmatrix}2 \\ 1\end{pmatrix} \times\begin{pmatrix}3 \\ 2\end{pmatrix} \timesA^3_3$$<p>看懂了公式就能算出来了</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>)</span></span>;<br>    p[<span class="hljs-number">0</span>] = p[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; p.<span class="hljs-built_in">size</span>(); ++i) p[i] = (i * p[i - <span class="hljs-number">1</span>]) % mod;<br><br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    string str;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        str.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>);<br>        cin &gt;&gt; str;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>, tot = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; str.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (str[i] != str[i - <span class="hljs-number">1</span>]) &#123;<br>                ans = (ans * cnt) % mod;<br>                cnt = <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cnt++;<br>                tot++;<br>            &#125;<br>        &#125;<br><br>        ans = (ans * cnt) % mod;<br>        ans = (ans * p[tot]) % mod;<br><br>        cout &lt;&lt; tot &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Sum-of-XOR-Functions"><a href="#D-Sum-of-XOR-Functions" class="headerlink" title="D. Sum of XOR Functions"></a>D. Sum of XOR Functions</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组，需要求算 $\sum^n_{l=1}\sum^n_{r=l} f(l,r) \times (r-l+1)$，其中 $f(l,r)$ 表示 $[l, r]$ 区间的异或和</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>首先要明确异或和的本质，对于任意一个比特位而言，若所有值中此比特位为 <code>1</code> 的数量为奇数，则最终为奇数。所以需要统计任意区间内的某个比特位的奇偶情况，故可以先做一次前缀异或和，这样得到的就是累积的奇偶情况了。</p><p>对于一个区间，如果其左区间（前一个）的前缀异或和的某个位的结果是 <code>1</code>（奇数），而右区间则为 <code>0</code>（偶数），则说明这个区间内这个比特位出现奇数次，那么就可以计算其贡献，为 $(r-l+1) \times 2^p)$，拆解一下公式可以得到 $r \times 2^p - (l-1) \times 2^p$。</p><p>对于每一个比特位，我们考虑遍历所有可能的右区间，对于每一个右区间，要找出左边出现了几次和右区间的前缀和的比特位结果不同的次数，那么就是这个 $r \times 2^p$ 部分的价值出现的次数，同时减去左边所有不同的 $(l-1) \times 2^p$ 的价值，就可以得到当前位置作为右区间的时候，能够带来的价值。而计算后的 $r \times 2^p$ 部分，恰好是其作为左区间的时候的 $(l-1) \times 2^p$ 的价值。</p><p>所以只需要遍历一遍，记录左边出现了几次 $0$ 和几次 $1$，同时对于 $0$ 而言，产生了多少价值，同理对 $1$ 也一样，然后作为下一个节点的计算输入</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: data) cin &gt;&gt; i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) data[i] = data[i] ^ data[i - <span class="hljs-number">1</span>];<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<br><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e = <span class="hljs-number">0</span>; e &lt;= <span class="hljs-number">32</span>; ++e) &#123;<br>        <span class="hljs-type">int</span> s1 = <span class="hljs-number">0</span>, c1 = <span class="hljs-number">0</span>, s0 = <span class="hljs-number">0</span>, c0 = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> rp = ((i + <span class="hljs-number">1</span>) * (<span class="hljs-number">1LL</span> &lt;&lt; e)) % mod;<br>            <span class="hljs-keyword">if</span> (data[i] &amp; (<span class="hljs-number">1LL</span> &lt;&lt; e)) &#123;<br>                ans = (ans + rp * c0 - s0) % mod;<br>                s1 = (s1 + rp) % mod;<br>                c1++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans = (ans + rp * c1 - s1) % mod;<br>                s0 = (s0 + rp) % mod;<br>                c0++;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 898 (Div. 4)</title>
    <link href="/2023/09/23/acm/codeforces/CodeforcesRound898/"/>
    <url>/2023/09/23/acm/codeforces/CodeforcesRound898/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Short-Sort"><a href="#A-Short-Sort" class="headerlink" title="A. Short Sort"></a>A. Short Sort</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有三张卡片，分别为 $a, b, c$，已经在桌面上乱序排好，最多交换两张卡片的位置，问是否能够变成有序的 $a, b, c$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>简单题，判断一下是不是至少有一位是保持 $a, b, c$ 的顺序即可</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        string  str;<br>        str.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">3</span>);<br>        cin &gt;&gt; str;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) cnt += str[i] == i + <span class="hljs-string">&#x27;a&#x27;</span>;<br>        cout &lt;&lt; (cnt == <span class="hljs-number">1</span> || cnt == <span class="hljs-number">3</span> ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Good-Kid"><a href="#B-Good-Kid" class="headerlink" title="B. Good Kid"></a>B. Good Kid</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组，允许你给其中一个值加一，问最终所有值的乘积最大是多少</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>简单题，如果有两个及以上的 $0$，那么最终结果一定还是 $0$。如果只有一个 $0$，那就等于忽略这个 $0$ 即可，剩下的情况，因为加了之后的效果是 $\frac{x+1}{x}$，所以 $x$ 越小越好，那么让最小的值 $+1$ 即可</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-type">int</span> p = <span class="hljs-number">1</span>, zero = <span class="hljs-number">0</span>, mi = INT_MAX;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            p *= (tmp == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : tmp);<br>            zero += tmp == <span class="hljs-number">0</span>;<br>            mi = <span class="hljs-built_in">min</span>(mi, tmp);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (zero &gt;= <span class="hljs-number">2</span>) cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (zero == <span class="hljs-number">1</span>) cout &lt;&lt; p &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; (p / mi * (mi + <span class="hljs-number">1</span>)) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Target-Practice"><a href="#C-Target-Practice" class="headerlink" title="C. Target Practice"></a>C. Target Practice</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个飞镖靶，根据结果计算总分</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>简单题，根据当前的下标距离四个边最小值是多少即可</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        string str;<br>        str.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">10</span>);<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>            cin &gt;&gt; str;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (str[j] == <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-type">int</span> code = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(i + <span class="hljs-number">1</span>, <span class="hljs-number">10</span> - i), <span class="hljs-built_in">min</span>(j + <span class="hljs-number">1</span>, <span class="hljs-number">10</span> - j));<br>                ans += code;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-1D-Eraser"><a href="#D-1D-Eraser" class="headerlink" title="D. 1D Eraser"></a>D. 1D Eraser</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个串，其中有白色和黑色方块，每次可以选择连续 $k$ 个块让其变成白色，问最少几步可以全部变成白色</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>简单题，从左往右考虑即可，毕竟最左边遇到的第一个黑色方块肯定需要消耗一次操作，为了最大化使用必定会让 $k$ 个的左边界是当前的黑色方块</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        string str;<br>        str.<span class="hljs-built_in">reserve</span>(n);<br>        cin &gt;&gt; str;<br>        <span class="hljs-type">int</span> last = -k - <span class="hljs-number">1</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;W&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (i - last + <span class="hljs-number">1</span> &lt;= k) <span class="hljs-keyword">continue</span>;<br>            last = i;<br>            ans++;<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="E-Building-an-Aquarium"><a href="#E-Building-an-Aquarium" class="headerlink" title="E. Building an Aquarium"></a>E. Building an Aquarium</h1><h2 id="大致题意-4"><a href="#大致题意-4" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个线性水池，水池底部形状已知，最多可以使用 $x$ 个单位的水，问水池两边应该造多高才能尽可能容纳更多的水的同时，在水池满的时候不会使用超过给出的水</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>简单题，二分答案即可</p><h2 id="AC-code-4"><a href="#AC-code-4" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, x;<br>        cin &gt;&gt; n &gt;&gt; x;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: data) cin &gt;&gt; item;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">2e9</span> + <span class="hljs-number">10LL</span>;<br>        <span class="hljs-keyword">while</span> (l + <span class="hljs-number">1</span> &lt; r) &#123;<br>            <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: data) sum += item &gt;= mid ? <span class="hljs-number">0</span> : mid - item;<br>            <span class="hljs-keyword">if</span> (sum &gt; x) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid;<br>        &#125;<br>        cout &lt;&lt; l &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="F-Money-Trees"><a href="#F-Money-Trees" class="headerlink" title="F. Money Trees"></a>F. Money Trees</h1><h2 id="大致题意-5"><a href="#大致题意-5" class="headerlink" title="大致题意"></a>大致题意</h2><p>给出一个数组，其每个值都有两个属性：$a, h$，需要找到一个连续的子数组，使得这个连续的子数组 $[l, r]$的 $h$ 值满足 $\forall i \in [l, r], h_{i-1} \space mod \space h_i = 0$，同时 $\sum_{i=l}^{r} a_i \leq x$</p><p>问最长的子数组的长度</p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>也是二分答案即可，毕竟在确定要找的最终串的长度的情况下，只需要 $O(n)$ 即可求出是否符合预期，注意平移区间的时候状态的转化</p><h2 id="AC-code-5"><a href="#AC-code-5" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, k, ans = <span class="hljs-number">0</span>;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span>, <span class="hljs-title">h</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: a) cin &gt;&gt; item;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: h) cin &gt;&gt; item;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: a) <span class="hljs-keyword">if</span> (item &lt;= k) ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l + <span class="hljs-number">1</span> &lt; r) &#123;<br>            <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (mid == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">if</span> (ans &gt;= <span class="hljs-number">1</span>) l = mid;<br>                <span class="hljs-keyword">else</span> r = mid;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br><br>            <span class="hljs-keyword">auto</span> findNext = [&amp;]() &#123;<br>                x = y;<br>                y += <span class="hljs-number">1</span>;<br>                sum = a[x];<br>                <span class="hljs-keyword">while</span> (y - x != mid &amp;&amp; x &lt; n &amp;&amp; y &lt; n) &#123;<br>                    <span class="hljs-keyword">if</span> (h[y - <span class="hljs-number">1</span>] % h[y] != <span class="hljs-number">0</span>) &#123;<br>                        x = y;<br>                        y += <span class="hljs-number">1</span>;<br>                        sum = a[x];<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        sum += a[y];<br>                        y++;<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (y - x == mid &amp;&amp; sum &lt;= k) &#123;<br>                    ans = <span class="hljs-built_in">max</span>(ans, mid);<br>                    flag = <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">return</span> y - x == mid;<br>            &#125;;<br>            <span class="hljs-keyword">auto</span> move = [&amp;]() &#123;<br>                <span class="hljs-keyword">if</span> (y == n) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">if</span> (h[y - <span class="hljs-number">1</span>] % h[y] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                sum -= a[x];<br>                sum += a[y];<br>                y++;<br>                x++;<br>                <span class="hljs-keyword">if</span> (sum &lt;= k) &#123;<br>                    ans = <span class="hljs-built_in">max</span>(ans, mid);<br>                    flag = <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;;<br><br>            <span class="hljs-keyword">while</span> (<span class="hljs-built_in">findNext</span>()) <span class="hljs-keyword">while</span> (<span class="hljs-built_in">move</span>());<br>            <span class="hljs-keyword">if</span> (flag) l = mid;<br>            <span class="hljs-keyword">else</span> r = mid;<br>        &#125;<br><br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="G-ABBC-or-BACB"><a href="#G-ABBC-or-BACB" class="headerlink" title="G. ABBC or BACB"></a>G. ABBC or BACB</h1><h2 id="大致题意-6"><a href="#大致题意-6" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个字符串，由 $A, B$ 两个字母组成，每次可以将 $AB$ 转为 $BC$，或者将 $BA$ 转为 $CB$，问最多可以操作几次</p><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>很显然，如果是一串联系的 $A$，然后其中一侧有一个 $B$，那么这种情况下的答案就是 $A$ 的数量</p><p>那么将整个数组拆成所有连续的 $A$ 段，然后为每个 $A$ 段找合理的 $B$ 即可。比如如果整个字符串开头或者结尾是 $B$，那么必然可以为每个 $A$ 段找到一个 $B$。除开上面的情况，只需要看看 $B 的数量是否大于等于 $A$ 段的数量即可，因为如果等于或者超过也必然可以分割。如果还不行，那么只能舍弃价值最低的 $A$ 串了</p><h2 id="AC-code-6"><a href="#AC-code-6" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    string str;<br>    str.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        cin &gt;&gt; str;<br>        <span class="hljs-keyword">if</span> (str.<span class="hljs-built_in">front</span>() == <span class="hljs-string">&#x27;B&#x27;</span> || str.<span class="hljs-built_in">back</span>() == <span class="hljs-string">&#x27;B&#x27;</span>) &#123;<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: str) cnt += item == <span class="hljs-string">&#x27;A&#x27;</span>;<br>            cout &lt;&lt; cnt &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">part</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-type">int</span> cntB = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> &amp;i: str) &#123;<br>            cntB += i == <span class="hljs-string">&#x27;B&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (i == <span class="hljs-string">&#x27;B&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (part.<span class="hljs-built_in">back</span>() != <span class="hljs-number">0</span>) part.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>            &#125; <span class="hljs-keyword">else</span> part.<span class="hljs-built_in">back</span>()++;<br>        &#125;<br><br>        <span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>, mi = INT_MAX;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: part) &#123;<br>            tot += item;<br>            mi = <span class="hljs-built_in">min</span>(mi, item);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (cntB &lt; part.<span class="hljs-built_in">size</span>()) tot -= mi;<br>        cout &lt;&lt; tot &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="H-Mad-City"><a href="#H-Mad-City" class="headerlink" title="H. Mad City"></a>H. Mad City</h1><h2 id="大致题意-7"><a href="#大致题意-7" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个图，$n$ 个点，$n$ 条边，有两个人分别从 $a, b$ 出发，其中前者希望追赶后者，而后者希望摆脱前者的追捕，问能否追上</p><h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><p>首先，$n$ 个点和 $n$ 条边，那就意味着必然图中必然存在环。而两人速度相同，如果同时都在环上，那肯定追不到。所以必须要在后者进入环之前抓到，也就是提前或者刚好到达环上的某一个点。所以只需要找出后者刚进入环的时间点和位置，看看前者能否在指定时间内达到即可</p><h2 id="AC-code-7"><a href="#AC-code-7" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, a, b;<br>        cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">deg</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>            <span class="hljs-type">int</span> v, n;<br>        &#125;;<br>        <span class="hljs-function">vector&lt;node&gt; <span class="hljs-title">edge</span><span class="hljs-params">(n * <span class="hljs-number">2</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">head</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> u, v;<br>            cin &gt;&gt; u &gt;&gt; v;<br>            edge[i &lt;&lt; <span class="hljs-number">1</span>] = &#123;v, head[u]&#125;;<br>            edge[(i &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>] = &#123;u, head[v]&#125;;<br>            head[u] = i &lt;&lt; <span class="hljs-number">1</span>;<br>            head[v] = (i &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>;<br>            deg[u]++;<br>            deg[v]++;<br>        &#125;<br><br>        <span class="hljs-comment">// find circle</span><br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) <span class="hljs-keyword">if</span> (deg[i] == <span class="hljs-number">1</span>) q.<span class="hljs-built_in">push</span>(i);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> cur = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            vis[cur] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[cur]; i != <span class="hljs-number">-1</span>; i = edge[i].n)<br>                <span class="hljs-keyword">if</span> ((--deg[edge[i].v]) == <span class="hljs-number">1</span> &amp;&amp; !vis[edge[i].v]) q.<span class="hljs-built_in">push</span>(edge[i].v);<br>        &#125;<br><br>        <span class="hljs-comment">// begin for b run away</span><br>        <span class="hljs-type">int</span> cost1, cost2 = INT_MAX, target;<br>        queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; qs;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">flag</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>        qs.<span class="hljs-built_in">emplace</span>(b, <span class="hljs-number">0</span>);<br>        flag[b] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (!qs.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> cur = qs.<span class="hljs-built_in">front</span>();<br>            qs.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (!vis[cur.first]) &#123;<br>                cost1 = cur.second;<br>                target = cur.first;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[cur.first]; i != <span class="hljs-number">-1</span>; i = edge[i].n)<br>                <span class="hljs-keyword">if</span> (!flag[edge[i].v]) &#123;<br>                    qs.<span class="hljs-built_in">emplace</span>(edge[i].v, cur.second + <span class="hljs-number">1</span>);<br>                    flag[edge[i].v] = <span class="hljs-literal">true</span>;<br>                &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (!qs.<span class="hljs-built_in">empty</span>()) qs.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) flag[i] = <span class="hljs-literal">false</span>;<br><br>        qs.<span class="hljs-built_in">emplace</span>(a, <span class="hljs-number">0</span>);<br>        flag[a] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (!qs.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> cur = qs.<span class="hljs-built_in">front</span>();<br>            qs.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (cur.first == target) &#123;<br>                cost2 = cur.second;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[cur.first]; i != <span class="hljs-number">-1</span>; i = edge[i].n)<br>                <span class="hljs-keyword">if</span> (!flag[edge[i].v]) &#123;<br>                    qs.<span class="hljs-built_in">emplace</span>(edge[i].v, cur.second + <span class="hljs-number">1</span>);<br>                    flag[edge[i].v] = <span class="hljs-literal">true</span>;<br>                &#125;<br>        &#125;<br><br>        cout &lt;&lt; (cost1 &lt; cost2 ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeTON Round 6 (Div. 2)</title>
    <link href="/2023/09/22/acm/codeforces/CodeTONRound6/"/>
    <url>/2023/09/22/acm/codeforces/CodeTONRound6/</url>
    
    <content type="html"><![CDATA[<h1 id="A-MEXanized-Array"><a href="#A-MEXanized-Array" class="headerlink" title="A. MEXanized Array"></a>A. MEXanized Array</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>构造一个数组，其长度为 $n$，最大值为 $x$，$MEX$ 为 $k$，问这个数组的所有值的和最大是多少</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>简单题，在 $k &gt; x + 1$ 或 $n &lt; k$ 的场景下无解（不可能构造一个 $MEX$ 不可达的数组），然后就随便构造就行了，保证 $MEX$ 之后，剩下所有值取最大就行</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, k, x;<br>        cin &gt;&gt; n &gt;&gt; k &gt;&gt; x;<br>        <span class="hljs-keyword">if</span> (k &gt; x + <span class="hljs-number">1</span> || n &lt; k) &#123;<br>            cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) sum += i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k; i &lt; n; ++i) sum += (x == k ? x - <span class="hljs-number">1</span> : x);<br>        cout &lt;&lt; sum &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Friendly-Arrays"><a href="#B-Friendly-Arrays" class="headerlink" title="B. Friendly Arrays"></a>B. Friendly Arrays</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>给出两个数组 $a, b$，允许选择任意次的 $b$ 数组中的任意一个 $b_j$，然后让 $\forall i \in [1, len(a)], a_i = a_i | b_j$，问最终得到的数组 $a$ 中所有的异或和最大和最小的可能</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>某个比特为是 $1$ 的情况下，在奇数个值异或和的结果则也是 $1$，而偶数个则为 $0$。而或运算可以让 $a$ 数组的每一个值的某些个位都变成 $1$。基于此，只需要关心 $a$ 的长度即可，若 $a$ 为奇数，那么选尽可能多的 $b$ 使得每个位都尽可能是 $1$，反之则尽可能不选，这样才能达到最大，同理可以得到最小的方案</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, m;<br>        cin &gt;&gt; n &gt;&gt; m;<br>        <span class="hljs-type">int</span> sa = <span class="hljs-number">0</span>, sb = <span class="hljs-number">0</span>, tmp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            cin &gt;&gt; tmp;<br>            sa ^= tmp;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            cin &gt;&gt; tmp;<br>            sb |= tmp;<br>        &#125;<br>        cout &lt;&lt; (n % <span class="hljs-number">2</span> ? sa : sa &amp; ~sb) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; (n % <span class="hljs-number">2</span> ? sa | sb : sa) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Colorful-Table"><a href="#C-Colorful-Table" class="headerlink" title="C. Colorful Table"></a>C. Colorful Table</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组 $a$，长度为 $n$，然后有一个对应的矩阵 $b$，为 $n \times n$，其每一个位置的值 $b_{i,j}=min(a_i, a_j)$</p><p>问对于每个数字 $x$，在矩阵 $b$，中能够找到对应一个最小的矩形，此矩形包含了所有出现 $x$ 的位置，求出这个矩形的大小</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>对于任意一个值，假定其第一次在 $a$ 中出现的位置为 $i$，它第一次出现在 $b$ 地点一定是 $b_{i,i}$，同时其最后一次在矩阵中的位置一定是 $b_{j,j}$，其中 $j$ 是在数组 $a$，中出现的，最后一个比当前值更大的下标</p><p>根据上面的规律，可以求出实际上每个值的位置，一定可以包裹比他大的那个值对应的矩阵，所以只需要根据值的大小排序一下他们在数组中第一次出现的位置，和最后一次出现的位置，然后从大到小遍历，保证小的值的区间能够覆盖到大的值的区间即可</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">flag</span><span class="hljs-params">(k, <span class="hljs-literal">false</span>)</span></span>;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">data</span>(k, &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            data[tmp - <span class="hljs-number">1</span>].first == <span class="hljs-number">-1</span> ? data[tmp - <span class="hljs-number">1</span>].first = data[tmp - <span class="hljs-number">1</span>].second = i : data[tmp - <span class="hljs-number">1</span>].second = i;<br>            flag[tmp - <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            data[i].first = !flag[i] ? data[i + <span class="hljs-number">1</span>].first : (data[i + <span class="hljs-number">1</span>].first != <span class="hljs-number">-1</span> ? <span class="hljs-built_in">min</span>(data[i].first, data[i + <span class="hljs-number">1</span>].first) : data[i].first);<br>            data[i].second = !flag[i] ? data[i + <span class="hljs-number">1</span>].second : (data[i + <span class="hljs-number">1</span>].first != <span class="hljs-number">-1</span> ? <span class="hljs-built_in">max</span>(data[i].second, data[i + <span class="hljs-number">1</span>].second) : data[i].second);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i)<br>            cout &lt;&lt; (!flag[i] ? <span class="hljs-number">0</span> : (data[i].second - data[i].first + <span class="hljs-number">1</span>) + (data[i].second - data[i].first + <span class="hljs-number">1</span>)) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br><br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Prefix-Purchase"><a href="#D-Prefix-Purchase" class="headerlink" title="D. Prefix Purchase"></a>D. Prefix Purchase</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个初始数组，每一个值都是 $0$，每次你可以选择花费 $c_i$ 元，使得这个数组前 $i$ 个元素加一，最多只能花费 $k$ 元，问能够得到最大字典序的数组是什么</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>首先需把 $c$ 的值进行单调递增栈处理一下，毕竟价格相同或更低的同时 $i$ 更大肯定有优势</p><p>回到题目中的字典序，意味着只有越前面的值越大即可，所以要尽可能满足最前面的值最大，所以直接把 $k$ 丢给处理后的第一个值，看看最多第一个值可以到多少</p><p>处理完成第一个值后，那就意味着后面无论怎么贪心，第一个值一定要达到这个，否则肯定不如现在更好。另外，对于字典序而言，约前面的值价值越高，所以要尽可能让前面的值大，贪心一下即可</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; data;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            <span class="hljs-keyword">while</span> (!data.<span class="hljs-built_in">empty</span>() &amp;&amp; data.<span class="hljs-built_in">back</span>().first &gt;= tmp) data.<span class="hljs-built_in">pop_back</span>();<br>            data.<span class="hljs-built_in">emplace_back</span>(tmp, i);<br>        &#125;<br>        data.<span class="hljs-built_in">emplace_back</span>(INT_MAX, n - <span class="hljs-number">1</span>);<br>        cin &gt;&gt; k;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(data.size())</span></span>;<br>        ans[<span class="hljs-number">0</span>] = k / data.<span class="hljs-built_in">front</span>().first;<br>        k %= data.<span class="hljs-built_in">front</span>().first;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; data.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-type">int</span> diff = data[i].first - data[i - <span class="hljs-number">1</span>].first;<br>            <span class="hljs-keyword">if</span> (k &lt; diff) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            ans[i] = <span class="hljs-built_in">min</span>(ans[i - <span class="hljs-number">1</span>], k / diff);<br>            k -= diff * ans[i];<br>        &#125;<br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (data[cur].second &lt; i) cur++;<br>            cout &lt;&lt; ans[cur] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 897 (Div. 2)</title>
    <link href="/2023/09/16/acm/codeforces/CodeforcesRound897/"/>
    <url>/2023/09/16/acm/codeforces/CodeforcesRound897/</url>
    
    <content type="html"><![CDATA[<h1 id="A-green-gold-dog-array-and-permutation"><a href="#A-green-gold-dog-array-and-permutation" class="headerlink" title="A. green_gold_dog, array and permutation"></a>A. green_gold_dog, array and permutation</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>已知一个数组 $a$，长度为 $n$，需要给出一个 $n$ 的排列 $b$，使得得到的新数组 $c_i = a_i - b_i$ 中不同的值尽可能多，问数组 $b$ 的结果可能是</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>简单来说就是要差值差异大，而且没有取 $abs$，所以可以直接排序一下，一个递增一个递减配对即可</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">data</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: data) cin &gt;&gt; item.first;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) data[i].second = i;<br>        <span class="hljs-built_in">sort</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>(), greater&lt;&gt;());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) data[i].first = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">sort</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;lhs, <span class="hljs-type">const</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;rhs) &#123;<br>            <span class="hljs-keyword">return</span> lhs.second &lt; rhs.second;<br>        &#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cout &lt;&lt; data[i].first &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-XOR-Palindromes"><a href="#B-XOR-Palindromes" class="headerlink" title="B. XOR Palindromes"></a>B. XOR Palindromes</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>已经存在一个二进制的字符串 $a$，长度为 $n$，若存在另外一个字符串 $b$，其长度也为 $n$，其中 <code>1</code> 的数量恰好为 $x$，使得 $a \oplus b$ 恰好是一个回文串。则称 $x$ 是一个好值，问在 $[0, n]$ 中哪些值是好值</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>首先，在异或操作中，若其中一方为 <code>1</code> 已知，那么相当于对对方进行了翻转操作。</p><p>而要回文串，那么必然可以将初始串先按位分割，只看左右的其中一半，若这个位置本来就会回文（和后半对应的位置相同），那么需要寻找的串必定这两位要相同，否则必须不同，由此可以计算出至少要 <code>1</code> 的数量和最多能够用上的 <code>1</code> 的数量。</p><p>另外关注字符串本身是否是奇数长度的，这样意味着如果恰好多一个，就可以放到中间解决问题，如果不是的话，那么满足条件的值会间隔开</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        string str;<br>        cin &gt;&gt; str;<br>        str.<span class="hljs-built_in">reserve</span>(n);<br>        <span class="hljs-type">int</span> diff = <span class="hljs-number">0</span>, same = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; ++i) &#123;<br>            diff += str[i] != str[n - <span class="hljs-number">1</span> - i];<br>            same += str[i] == str[n - <span class="hljs-number">1</span> - i];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt; diff || i &gt; n - diff) cout &lt;&lt; <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span>) cout &lt;&lt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> ((i - diff) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Salyg1n-and-the-MEX-Game"><a href="#C-Salyg1n-and-the-MEX-Game" class="headerlink" title="C. Salyg1n and the MEX Game"></a>C. Salyg1n and the MEX Game</h1><p>交互题（这场交互题真多）</p><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个初始的集合，里面有一些值，你可以每次往里面加一个不存在的值，然后机器会每次往里面删除一个存在的值，且每次删除的值一定比你加入的值小。如果无法删除值了（没有满足条件的值了）那么就结束，问如何使得 <code>MEX</code> 最大化</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>实际上对于删除方，第一优先级的肯定是删除掉最小的值，因为只有这样能最有效的降低 <code>MEX</code>。</p><p>对于你而言，一旦试图添加 <code>0</code> 这种最低值的时候，游戏就会结束，此时 <code>MEX</code> 就取决于往后的第一个空档。可以发现一旦被删除掉的值是最小的，那么就再也不能救回比那个值更小的可能性了。而因为最终一次操作一定是加入的，所以只需要对方删除啥你就加入什么即可，保证不要被删掉小的值。而第一次加入，就可以选择当前的 <code>MEX</code>，来增加最终的 <code>MEX</code> 的结果</p><p>题非常简单易懂，但是解释起来又有些难</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: data) cin &gt;&gt; item;<br>        <span class="hljs-built_in">sort</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> mex = n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            <span class="hljs-keyword">if</span> (data[i] != i) &#123;<br>                mex = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        cout &lt;&lt; mex &lt;&lt; endl;<br>        cout.<span class="hljs-built_in">flush</span>();<br>        <span class="hljs-keyword">while</span> (cin &gt;&gt; mex &amp;&amp; mex != <span class="hljs-number">-1</span>) &#123;<br>            cout &lt;&lt; mex &lt;&lt; endl;<br>            cout.<span class="hljs-built_in">flush</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Cyclic-Operations"><a href="#D-Cyclic-Operations" class="headerlink" title="D. Cyclic Operations"></a>D. Cyclic Operations</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个初始每一个值都是 <code>0</code> 的数组 $a$，长度为 $n$，希望变成目标数组 $b$，可以进行如下操作</p><ul><li>构造任意一个长度恰好为 $k$ 的数组 $c$，$k$ 为给出的固定数字</li><li>$\forall i \in [1, k], a_{l_i} \rightarrow l_{(i \space mod \space k) + 1}$</li></ul><p>允许进行无数次操作，问是否有可能变成 $b$</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>首先仔细模拟一下这个看起来很恐怖的公式，发现其实就是 $a_{l_i} \rightarrow l_{i+1}$ 注意这里可以看成是循环数组，否则会越界</p><p>然后考虑一下特殊情况，就是 $k = 1$ 的情况，这个时候必须每个值的下标等于自己，否则肯定不行，这里就不过多解释了，模拟一下就行。</p><p>然后是其他情况下，模拟一下就会发现有点类似有向图一样，而且比较显而易见必然会产生环</p><p>所以只需要让有向图上的环的大小都恰好等于 $k$ 即可，对于分支链路，他们可以直接临时占用环的一部分，而后通过环本身将其覆盖即可</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">circle</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">level</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: data) cin &gt;&gt; item;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (data[i] != i + <span class="hljs-number">1</span>) flag = <span class="hljs-literal">false</span>;<br>            cout &lt;&lt; (flag ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (circle[i] != <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            cur++;<br>            <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>, index = i;<br>            <span class="hljs-keyword">while</span> (circle[index] == <span class="hljs-number">0</span>) &#123;<br>                circle[index] = cur;<br>                level[index] = len++;<br>                index = data[index] - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (circle[index] != cur) &#123;<br>                <span class="hljs-comment">// other circle, no matter how len it is, always OK</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (len - level[index] != k) &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; (flag ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="E2-Salyg1n-and-Array-hard-version"><a href="#E2-Salyg1n-and-Array-hard-version" class="headerlink" title="E2. Salyg1n and Array (hard version)"></a>E2. Salyg1n and Array (hard version)</h1><p>easy version 要求更低，所以直接做 hard</p><h2 id="大致题意-4"><a href="#大致题意-4" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个未知的数组，长度为 $n$，需要求出整个数组的异或和是多少</p><p>每次可以询问一个区间的异或和，这个区间长度一定为给定的 $k$，询问后，整个区间将会翻转</p><p>最多只能请求 57 次</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>很显然，可以知道至多 $50$ 就可以保证覆盖到所有的区间，如果恰好 $k$ 是 $n$ 的因子，那么就可以恰好满覆盖，循环一遍直接可以得到答案了</p><p>如果不满足的情况，就需要考虑一种方案了，这里给出我的一个方案，接下来会参考下面的图进行讲解，图中，$a, b$ 两段之和（蓝色部分）是不满足完美分配后，余下的部分，其他的黑色部分则是可以完美分配的部分，其中 $len(a) = len(b) = len(d) = len(e)$（注意题目中描述了 $n, k$ 必定都是偶数，所以肯定可以这样分配），同时 $len(a) + len(b) + len(c) + len(d) = k$，且 同时 $len(b) + len(c) + len(d) + len(e) = k$</p><p><img src="/image/acm/codeforces/CodeforcesRound897/E2.jpeg" alt="E2"></p><p>先要求算出 $a,b,c,d$ 这个区间的异或和，假设记为 $x$，如此操作后，必定迎来翻转操作，即区间变成 $d, (c+b), a, e$ 的顺序，其中因为 $c$ 区间长度不确定，故和 $b$ 放在一块，不做区分。</p><p>然后再计算 $(c+b), a, e$ 的区间异或和，得到 $y$，同时翻转后得到 $d, e | (a+b+c)$，此处同理，此时无法完美区分 (a+b+c) 的区间长度到底是多少，只是大概知道个顺序罢了，因为我们也不关心顺序，故合并起来写，注意中间的其，其表示原来图中的蓝色和黑色部分的分割线。第一次翻转后，这根线无法进行绘制故没有标出，此时可以标出了</p><p>接着计算 $x \oplus y = (a \oplus b \oplus c \oplus d) \oplus (c \oplus b \oplus a \oplus e) = d \oplus e$，这不是正好是翻转后的外面部分的，那么问题好像就解决了</p><h2 id="AC-code-4"><a href="#AC-code-4" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, k, ans = <span class="hljs-number">0</span>, tmp;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        <span class="hljs-keyword">if</span> (n % k != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> len = n % k;<br>            cout &lt;&lt; <span class="hljs-string">&quot;? 1&quot;</span> &lt;&lt; endl;<br>            cout.<span class="hljs-built_in">flush</span>();<br>            cin &gt;&gt; tmp;<br>            ans ^= tmp;<br>            cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span> &lt;&lt; (len / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) &lt;&lt; endl;<br>            cout.<span class="hljs-built_in">flush</span>();<br>            cin &gt;&gt; tmp;<br>            ans ^= tmp;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n % k; i &lt; n; i += k) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;? &quot;</span> &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; endl;<br>            cout.<span class="hljs-built_in">flush</span>();<br>            cin &gt;&gt; tmp;<br>            ans ^= tmp;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;! &quot;</span> &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 896 (Div. 2)</title>
    <link href="/2023/09/16/acm/codeforces/CodeforcesRound896/"/>
    <url>/2023/09/16/acm/codeforces/CodeforcesRound896/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Make-It-Zero"><a href="#A-Make-It-Zero" class="headerlink" title="A. Make It Zero"></a>A. Make It Zero</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组，允许你每次选择一个区间，然后将这个区间内的所有值变成他们异或和的结果，问给出一种最多只进行 8 次的操作的可能方法使得整个数组变成 0</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>不要求最小，只要能就行，简单了很多很多</p><p>首先，偶数个相同的值进行异或和，结果为 0，如果整个数组长度为偶数，那么直接异或和两次即可</p><p>如果为奇数，那么先把前 $n - 1$ 个异或和一下，最后再异或和两次最后两个值即可</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, tmp;<br>        cin &gt;&gt; n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cin &gt;&gt; tmp;<br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-number">4</span> &lt;&lt; endl;<br>            cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; n &lt;&lt; endl;<br>            cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; n - <span class="hljs-number">1</span> &lt;&lt; endl;<br>            cout &lt;&lt; n - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; n &lt;&lt; endl;<br>            cout &lt;&lt; n - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; n &lt;&lt; endl;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cout &lt;&lt; <span class="hljs-number">2</span> &lt;&lt; endl;<br>            cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; n &lt;&lt; endl;<br>            cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; n &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-2D-Traveling"><a href="#B-2D-Traveling" class="headerlink" title="B. 2D Traveling"></a>B. 2D Traveling</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个棋盘，开始在 $a$ 点，要前往 $b$ 点，只能中途停留在固定的 $n$ 个节点中任意一个</p><p>任意两个节点之间的成本是他们的棋盘距离，但是有 $k$ 个节点，他们之间相互的成本是 $0$</p><p>问最少成本是多少</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>棋盘距离就意味着，其实中间停留是毫无意义的，直接到终点就行了，没必要停留</p><p>但是有一些特殊节点，所以只需要找到距离 $a$ 最近的特殊节点，并计算成本，和距离 $b$ 的特殊节点，并计算成本，然后将两个成本相加和直接前往的成本差异，求较小值就行</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, k, a, b;<br>        cin &gt;&gt; n &gt;&gt; k &gt;&gt; a &gt;&gt; b;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">data</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: data) cin &gt;&gt; item.first &gt;&gt; item.second;<br>        <span class="hljs-keyword">auto</span> dist = [&amp;](<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(data[l].first - data[r].first) + <span class="hljs-built_in">abs</span>(data[l].second - data[r].second);<br>        &#125;;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-built_in">dist</span>(a - <span class="hljs-number">1</span>, b - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> ak = INT_MAX * <span class="hljs-number">2LL</span>, bk = INT_MAX * <span class="hljs-number">2LL</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            ak = <span class="hljs-built_in">min</span>(ak, <span class="hljs-built_in">dist</span>(i, a - <span class="hljs-number">1</span>));<br>            bk = <span class="hljs-built_in">min</span>(bk, <span class="hljs-built_in">dist</span>(i, b - <span class="hljs-number">1</span>));<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-built_in">min</span>(ans, ak + bk) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Fill-in-the-Matrix"><a href="#C-Fill-in-the-Matrix" class="headerlink" title="C. Fill in the Matrix"></a>C. Fill in the Matrix</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个 $n \times m$ 的矩阵，将其每一行填充为 $m$ 的一个排列，求出每一列的 <code>MEX</code>，然后将每一列的 <code>MEX</code> 再求一次 <code>MEX</code>，问最终结果最大是多少，并给出矩阵</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>构造题，比较简单，如果想看我的构造方案就运行一下打印出来看看吧</p><p>需要注意的是，因为矩阵比较大，不能存下来，所以需要提前算出答案输出了，不能等构造完成了再去算</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, m;<br>        cin &gt;&gt; n &gt;&gt; m;<br>        <span class="hljs-keyword">if</span> (m == <span class="hljs-number">1</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &gt;= m - <span class="hljs-number">1</span>) &#123;<br>            cout &lt;&lt; m &lt;&lt; endl;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cout &lt;&lt; n + <span class="hljs-number">1</span> &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">min</span>(n, m - <span class="hljs-number">1</span>); ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>                cout &lt;&lt; (j - i - <span class="hljs-number">1</span> + m) % m &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>            &#125;<br>            cout &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-built_in">min</span>(n, m - <span class="hljs-number">1</span>); i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>                cout &lt;&lt; (j + <span class="hljs-number">1</span>) % m &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>            &#125;<br>            cout &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D1-Candy-Party-Easy-Version"><a href="#D1-Candy-Party-Easy-Version" class="headerlink" title="D1. Candy Party (Easy Version)"></a>D1. Candy Party (Easy Version)</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>有 $n$ 个人，每个人手上都有一些糖果，现在每个人都必需要给另外一个人 $2^x$ 个糖果，$x$ 可以是任意自然数，且每个人必须从另外一个人那里拿到他给出的糖果，问是否存在一种可能，经过这样一次操作后，所有人糖果数量相同</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>首先，糖果没有新增或者丢弃，那么必然总糖果数量不变，所以很容易计算出最终每个人应该是多少糖果。那么就可以算出差值（应该最终增加/减少多少）</p><p>其次思考一个问题，由于给出/收到的糖果数量满足 $2^x$ 的形式，那么必然差值定是两个 $2^x$ 之差。例如 $3 = 4 - 1$，$7 = 8 - 1$，$4 = 8 - 4$ 等等就是合法的值，而例如 $5$ 就是一个非法的值。所以这样就可以先排除掉一部分了</p><p>很显然，每个值都只有一种可能的拆法，又因为每个人只能从一个人那里拿到糖果，那么必然所有的给出和拿到的可能性只有这些，他们必然完全相等</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mi</span><span class="hljs-params">(<span class="hljs-number">40</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">40</span>; ++i) mi[i] = <span class="hljs-number">1LL</span> &lt;&lt; i;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: data) cin &gt;&gt; item;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: data) sum += item;<br>        <span class="hljs-keyword">if</span> (sum % n != <span class="hljs-number">0</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        sum /= n;<br><br>        <span class="hljs-keyword">auto</span> lowBit = [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> x &amp; -x; &#125;;<br>        vector&lt;<span class="hljs-type">int</span>&gt; p[<span class="hljs-number">2</span>];<br>        p[<span class="hljs-number">0</span>].<span class="hljs-built_in">reserve</span>(n);<br>        p[<span class="hljs-number">1</span>].<span class="hljs-built_in">reserve</span>(n);<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> diff = data[i] - sum;<br>            <span class="hljs-keyword">if</span> (diff == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> l = diff &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>, r = <span class="hljs-number">1</span> ^ l;<br>            diff = <span class="hljs-built_in">abs</span>(diff);<br>            <span class="hljs-type">int</span> b = *<span class="hljs-built_in">upper_bound</span>(mi.<span class="hljs-built_in">begin</span>(), mi.<span class="hljs-built_in">end</span>(), diff);<br>            <span class="hljs-type">int</span> s = b - diff;<br>            <span class="hljs-keyword">if</span> (*<span class="hljs-built_in">lower_bound</span>(mi.<span class="hljs-built_in">begin</span>(), mi.<span class="hljs-built_in">end</span>(), s) != s) &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            p[l].<span class="hljs-built_in">push_back</span>(b);<br>            p[r].<span class="hljs-built_in">push_back</span>(s);<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(p[<span class="hljs-number">0</span>].<span class="hljs-built_in">begin</span>(), p[<span class="hljs-number">0</span>].<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(p[<span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>(), p[<span class="hljs-number">1</span>].<span class="hljs-built_in">end</span>());<br>        cout &lt;&lt; (flag &amp;&amp; p[<span class="hljs-number">0</span>] == p[<span class="hljs-number">1</span>] ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D2-Candy-Party-Hard-Version"><a href="#D2-Candy-Party-Hard-Version" class="headerlink" title="D2. Candy Party (Hard Version)"></a>D2. Candy Party (Hard Version)</h1><h2 id="大致题意-4"><a href="#大致题意-4" class="headerlink" title="大致题意"></a>大致题意</h2><p>和上一题类似，只不过从必须给一个人改成了至多给一个人，从一个人那拿到变成了至多从一个那里拿到。即可以不再一定要给出/收到了</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>那么唯一的区别就在于那些差值本来就符合 $2^x$ 的人，因为他们既可以选择同时有给出收到，也可以选择只给出/收到。而那些不满足的则必定有给出和收到阶段</p><p>而那些本来就符合 $2^x$ 的值，如果它又同时选择有给出收到，那么称其为拆开后的，而拆开后必然得到一个更大的值。</p><p>那么可以按照下面的步骤进行模拟</p><ol><li>将所有值分成两类：已经拆过了的，没有拆过的</li><li>对于每个差值，如果它满足 $2^x$，那么放入到没有拆过的组里，而不满足的，则将拆开后的两个 $2^x$ 值放入已经拆过的组里</li><li>判断一下，已经拆过的里面 $abs$ 最大的值和没有拆过的里面 $abs$ 最大的值，哪个大，如果后者大，那么就把那些大的值放入已经拆过的队列（因为他们再拆开就会创造更大的值，没有必要再拆了）</li><li>每次取出 $abs$ 最大的拆过的值，然后尝试在已经拆过里面为它找配对上的，即 $abs$ 相同，但是正负号相反的值，并将其消除</li><li>如果找不到，那么就再去没有拆过里面找相同的条件的，并消除</li><li>如果还找不到，那么再去没有拆过里面找符号相同但是值恰好为 $abs$ 的一半的，将其拆开，将 $abs$ 较大的删除，较小的放入已经拆开的队列中</li><li>回到 3 步，除非两个队列都空了</li></ol><h2 id="AC-code-4"><a href="#AC-code-4" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mi</span><span class="hljs-params">(<span class="hljs-number">40</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">40</span>; ++i) mi[i] = <span class="hljs-number">1LL</span> &lt;&lt; i;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: data) cin &gt;&gt; item;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: data) sum += item;<br>        <span class="hljs-keyword">if</span> (sum % n != <span class="hljs-number">0</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        sum /= n;<br><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">cmp</span> &#123;<br>            <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;lhs, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;rhs)</span> <span class="hljs-type">const</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(lhs) &lt; <span class="hljs-built_in">abs</span>(rhs);<br>            &#125;<br>        &#125;;<br><br>        priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, cmp&gt; depart;<br>        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, greater&lt;&gt;&gt; pos, neg;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> dif = data[i] - sum;<br>            <span class="hljs-keyword">if</span> (dif == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(dif) == *<span class="hljs-built_in">lower_bound</span>(mi.<span class="hljs-built_in">begin</span>(), mi.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">abs</span>(dif))) &#123;<br>                <span class="hljs-comment">// good gay</span><br>                (dif &gt; <span class="hljs-number">0</span> ? pos : neg)[<span class="hljs-built_in">abs</span>(dif)]++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// bad gay</span><br>                <span class="hljs-type">int</span> b = *<span class="hljs-built_in">upper_bound</span>(mi.<span class="hljs-built_in">begin</span>(), mi.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">abs</span>(dif));<br>                b *= dif &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<br>                <span class="hljs-type">int</span> s = dif - b;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">abs</span>(s) != *<span class="hljs-built_in">lower_bound</span>(mi.<span class="hljs-built_in">begin</span>(), mi.<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">abs</span>(s))) &#123;<br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                depart.<span class="hljs-built_in">push</span>(b);<br>                depart.<span class="hljs-built_in">push</span>(s);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!flag) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (!depart.<span class="hljs-built_in">empty</span>() || !pos.<span class="hljs-built_in">empty</span>() || !neg.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (depart.<span class="hljs-built_in">empty</span>()) &#123;<br>                <span class="hljs-keyword">auto</span> posIter = pos.<span class="hljs-built_in">begin</span>(), negIter = neg.<span class="hljs-built_in">begin</span>();<br>                <span class="hljs-keyword">if</span> (posIter-&gt;first == negIter-&gt;first) &#123;<br>                    <span class="hljs-type">int</span> tmp = <span class="hljs-built_in">min</span>(posIter-&gt;second, negIter-&gt;second);<br>                    posIter-&gt;second -= tmp;<br>                    negIter-&gt;second -= tmp;<br>                    <span class="hljs-keyword">if</span> (posIter-&gt;second == <span class="hljs-number">0</span>) pos.<span class="hljs-built_in">erase</span>(posIter);<br>                    <span class="hljs-keyword">if</span> (negIter-&gt;second == <span class="hljs-number">0</span>) neg.<span class="hljs-built_in">erase</span>(negIter);<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">auto</span> &amp;iter = posIter-&gt;first &gt; negIter-&gt;first ? posIter : negIter;<br>                <span class="hljs-keyword">auto</span> mx = posIter-&gt;first &gt; negIter-&gt;first ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">auto</span> &amp;u = posIter-&gt;first &gt; negIter-&gt;first ? pos : neg;<br>                <span class="hljs-keyword">auto</span> &amp;v = posIter-&gt;first &gt; negIter-&gt;first ? neg : pos;<br>                <span class="hljs-keyword">auto</span> tIter = v.<span class="hljs-built_in">find</span>(iter-&gt;first / <span class="hljs-number">2</span>);<br>                <span class="hljs-keyword">if</span> (tIter == v.<span class="hljs-built_in">end</span>()) &#123;<br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-type">int</span> tmp = <span class="hljs-built_in">min</span>(iter-&gt;second, tIter-&gt;second);<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; tmp; ++i) depart.<span class="hljs-built_in">push</span>(mx * iter-&gt;first / <span class="hljs-number">2</span>);<br>                iter-&gt;second -= tmp;<br>                tIter-&gt;second -= tmp;<br>                <span class="hljs-keyword">if</span> (iter-&gt;second == <span class="hljs-number">0</span>) u.<span class="hljs-built_in">erase</span>(iter);<br>                <span class="hljs-keyword">if</span> (tIter-&gt;second == <span class="hljs-number">0</span>) v.<span class="hljs-built_in">erase</span>(tIter);<br>            &#125;<br><br>            <span class="hljs-keyword">while</span> (!pos.<span class="hljs-built_in">empty</span>() || !neg.<span class="hljs-built_in">empty</span>()) &#123;<br>                <span class="hljs-keyword">auto</span> posIter = pos.<span class="hljs-built_in">begin</span>();<br>                <span class="hljs-keyword">auto</span> negIter = neg.<span class="hljs-built_in">begin</span>();<br><br>                <span class="hljs-type">bool</span> posWin = negIter == neg.<span class="hljs-built_in">end</span>() || (posIter != pos.<span class="hljs-built_in">end</span>() &amp;&amp; posIter-&gt;first &gt; negIter-&gt;first);<br>                <span class="hljs-keyword">auto</span> &amp;maxIter = posWin ? posIter : negIter;<br>                <span class="hljs-keyword">auto</span> &amp;maxLink = posWin ? pos : neg;<br>                <span class="hljs-keyword">auto</span> mx = posWin ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">if</span> (maxIter-&gt;first &gt; <span class="hljs-built_in">abs</span>(depart.<span class="hljs-built_in">top</span>())) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; maxIter-&gt;second; ++i) depart.<span class="hljs-built_in">push</span>(mx * maxIter-&gt;first);<br>                    maxLink.<span class="hljs-built_in">erase</span>(maxIter);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-type">int</span> cnt[<span class="hljs-number">2</span>] = &#123;depart.<span class="hljs-built_in">top</span>() &lt; <span class="hljs-number">0</span>, depart.<span class="hljs-built_in">top</span>() &gt; <span class="hljs-number">0</span>&#125;;<br>            <span class="hljs-type">int</span> cur = <span class="hljs-built_in">abs</span>(depart.<span class="hljs-built_in">top</span>());<br>            depart.<span class="hljs-built_in">pop</span>();<br><br>            <span class="hljs-keyword">while</span> (!depart.<span class="hljs-built_in">empty</span>() &amp;&amp; <span class="hljs-built_in">abs</span>(depart.<span class="hljs-built_in">top</span>()) == cur) &#123;<br>                cnt[<span class="hljs-number">0</span>] += depart.<span class="hljs-built_in">top</span>() &lt; <span class="hljs-number">0</span>;<br>                cnt[<span class="hljs-number">1</span>] += depart.<span class="hljs-built_in">top</span>() &gt; <span class="hljs-number">0</span>;<br>                depart.<span class="hljs-built_in">pop</span>();<br>            &#125;<br><br>            <span class="hljs-comment">// receives from not good gay</span><br>            <span class="hljs-type">int</span> tmp = <span class="hljs-built_in">min</span>(cnt[<span class="hljs-number">0</span>], cnt[<span class="hljs-number">1</span>]);<br>            cnt[<span class="hljs-number">0</span>] -= tmp;<br>            cnt[<span class="hljs-number">1</span>] -= tmp;<br>            <span class="hljs-keyword">if</span> (cnt[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> &amp;&amp; cnt[<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-type">int</span> left = cnt[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">auto</span> &amp;link = cnt[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span> ? pos : neg;<br>            <span class="hljs-type">int</span> mx = cnt[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">-1</span> : <span class="hljs-number">1</span>;<br><br>            <span class="hljs-comment">// find in pos which is equals to this gay</span><br>            <span class="hljs-keyword">auto</span> iter = link.<span class="hljs-built_in">find</span>(cur);<br>            <span class="hljs-keyword">if</span> (iter != link.<span class="hljs-built_in">end</span>()) &#123;<br>                tmp = <span class="hljs-built_in">min</span>(cnt[left], iter-&gt;second);<br>                iter-&gt;second -= tmp;<br>                cnt[left] -= tmp;<br>                <span class="hljs-keyword">if</span> (iter-&gt;second == <span class="hljs-number">0</span>) link.<span class="hljs-built_in">erase</span>(iter);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cnt[left] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-comment">// not enough, find in pos which is half of this gay</span><br>            iter = link.<span class="hljs-built_in">find</span>(cur / <span class="hljs-number">2</span>);<br>            <span class="hljs-keyword">if</span> (iter != link.<span class="hljs-built_in">end</span>()) &#123;<br>                tmp = <span class="hljs-built_in">min</span>(cnt[left], iter-&gt;second);<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; tmp; ++i) depart.<span class="hljs-built_in">push</span>(mx * cur / <span class="hljs-number">2</span>);<br>                iter-&gt;second -= tmp;<br>                cnt[left] -= tmp;<br>                <span class="hljs-keyword">if</span> (iter-&gt;second == <span class="hljs-number">0</span>) link.<span class="hljs-built_in">erase</span>(iter);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (cnt[left] != <span class="hljs-number">0</span>) &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        cout &lt;&lt; (flag ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 887 (Div. 2)</title>
    <link href="/2023/09/09/acm/codeforces/CodeforcesRound887/"/>
    <url>/2023/09/09/acm/codeforces/CodeforcesRound887/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Desorting"><a href="#A-Desorting" class="headerlink" title="A. Desorting"></a>A. Desorting</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个非递减数列，每次可以选择一个下标 $i$，使得 $\forall i \in [1, i], a_i \rightarrow a_i + 1$，同时 $\forall i \in [i + 1, n], a_i \rightarrow a_i - 1$</p><p>问最少需要几次操作</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>简单题，找到差一点最小的，和 $2$ 做向上取整的除法就行了</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, last, diff = INT_MAX;<br>        cin &gt;&gt; n;<br>        cin &gt;&gt; last;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            diff = <span class="hljs-built_in">min</span>(diff, tmp - last);<br>            last = tmp;<br>        &#125;<br><br>        cout &lt;&lt; <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, (diff + <span class="hljs-number">2</span>) / <span class="hljs-number">2</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Fibonaccharsis"><a href="#B-Fibonaccharsis" class="headerlink" title="B. Fibonaccharsis"></a>B. Fibonaccharsis</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个 $k$ 的长度的数组，已知 $a_k = n$，问这个数组满足斐波那契数列的种数有多少</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>在长度较长的情况下，$k \le n$ 是显然的，那么就可以排除掉一些</p><p>然后暴力计算出，假定初项 $x, y$，计算 $n = ax + by$ 中的 $a, b$，然后在暴力遍历所有可能即可</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        <span class="hljs-keyword">if</span> (k &gt;= n &amp;&amp; k &gt; <span class="hljs-number">10</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> x[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;, y[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; k; ++i) &#123;<br>            x[<span class="hljs-number">0</span>] = x[<span class="hljs-number">1</span>];<br>            x[<span class="hljs-number">1</span>] = x[<span class="hljs-number">2</span>];<br>            y[<span class="hljs-number">0</span>] = y[<span class="hljs-number">1</span>];<br>            y[<span class="hljs-number">1</span>] = y[<span class="hljs-number">2</span>];<br><br>            x[<span class="hljs-number">2</span>] = x[<span class="hljs-number">0</span>] + x[<span class="hljs-number">1</span>];<br>            y[<span class="hljs-number">2</span>] = y[<span class="hljs-number">0</span>] + y[<span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-type">int</span> tx = x[<span class="hljs-number">2</span>], ty = y[<span class="hljs-number">2</span>], ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (tx * i &gt; n) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span> ((n - tx * i) % ty == <span class="hljs-number">0</span> &amp;&amp; (n - tx * i) / ty &gt;= i) ans++;<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Ntarsis’-Set"><a href="#C-Ntarsis’-Set" class="headerlink" title="C. Ntarsis’ Set"></a>C. Ntarsis’ Set</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个无限长的数组，然后每次报数然后去掉其中一部分，去掉的报数下标为给出的 $a$ 数组，总共进行 $k$ 轮，问最终剩下的第一个值是原来下标多少的</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>模拟一下，假设 $a = [1, 5, 10]$，且 $k$ 无限大，那么可以得到</p><div class="table-container"><table><thead><tr><th style="text-align:center">下标</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center">9</th><th style="text-align:center">10</th><th style="text-align:center">11</th><th style="text-align:center">12</th><th style="text-align:center">13</th><th style="text-align:center">14</th><th style="text-align:center">15</th><th style="text-align:center">16</th><th style="text-align:center">17</th><th style="text-align:center">18</th><th style="text-align:center">19</th><th style="text-align:center">20</th></tr></thead><tbody><tr><td style="text-align:center">被去掉的报数</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">5</td><td style="text-align:center">1</td><td style="text-align:center">5</td><td style="text-align:center">1</td><td style="text-align:center">5</td><td style="text-align:center">10</td><td style="text-align:center">1</td><td style="text-align:center">5</td><td style="text-align:center">10</td><td style="text-align:center">1</td><td style="text-align:center">5</td><td style="text-align:center">10</td><td style="text-align:center">1</td><td style="text-align:center">5</td><td style="text-align:center">10</td><td style="text-align:center">1</td></tr></tbody></table></div><p>规律就是当只有一个值的时候，都是 <code>1</code> 的循环，然后两个值的时候变成两个值的循环，依次类推。</p><p>因为每次 <code>1</code> 就意味着一个新的开始，所以当 <code>1</code> 不能再覆盖的地方就是答案</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];<br><br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>, x = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (k--) &#123;<br>            <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; a[j] &lt;= x + j) j++;<br>            x += j;<br>        &#125;<br><br>        cout &lt;&lt; x &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Imbalanced-Arrays"><a href="#D-Imbalanced-Arrays" class="headerlink" title="D. Imbalanced Arrays"></a>D. Imbalanced Arrays</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>给出一个数组 $a$，长度为 $n$，构造一个数组 $b$，其长度为 $n$，使得满足如下条件</p><ul><li>$\forall i \in [1, n], -n \leq b_i \leq n$</li><li>$\forall i \in [1, n], j \in [1, n], b_i + b_j \neq 0$</li><li>对于 $i$，计算 $\forall j \in [1, n]$，满足 $b_i + b_j &gt; 0$ 的数量恰好为 $a_i$</li></ul><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>我也不知道咋过的，只是冥冥之中写了这个构造方案，过了，但是实在没能证明出来我是怎么对的</p><p>为了满足第一条和第二条，定下一个简答的原则：$b$ 数组的每一项取 $abs$ 后，得到的新数组恰好是 $n$ 的排列，这样可以直接满足前两项了</p><p>而后根据 $a$ 的大小，从大到小排序后遍历，如果当前值和上一个值相同，那么就取上一个值 $-1$，否则再减去它们两个值的差值（因为中间这些跳过的值肯定是负数，这样恰好可以满足对应的整数部分的要求），直到试图给当前值赋值为非正整数时，停止即可</p><p>然后再根据 $a$ 的大小，从小到大排序后遍历，取出剩下没有给的值中最大的，将其变成负值后就是对应的值，同时验证一下是否准确，若不准确就是无解</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: data) cin &gt;&gt; item;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n)</span></span>;<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; usePos;<br>        set&lt;<span class="hljs-type">int</span>&gt; notUse;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) notUse.<span class="hljs-built_in">insert</span>(i);<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">sorted</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) sorted[i] = &#123;data[i], i&#125;;<br>        <span class="hljs-built_in">sort</span>(sorted.<span class="hljs-built_in">begin</span>(), sorted.<span class="hljs-built_in">end</span>(), greater&lt;&gt;());<br>        <span class="hljs-type">int</span> cur = n, last = n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: sorted) &#123;<br>            cur -= last - item.first;<br>            <span class="hljs-keyword">if</span> (cur &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>            ans[item.second] = cur;<br>            notUse.<span class="hljs-built_in">erase</span>(cur);<br>            usePos.<span class="hljs-built_in">push_back</span>(cur);<br>            --cur;<br>            last = item.first;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(usePos.<span class="hljs-built_in">begin</span>(), usePos.<span class="hljs-built_in">end</span>(), greater&lt;&gt;());<br>        <span class="hljs-built_in">sort</span>(sorted.<span class="hljs-built_in">begin</span>(), sorted.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = notUse.<span class="hljs-built_in">rbegin</span>(); iter != notUse.<span class="hljs-built_in">rend</span>(); ++iter) &#123;<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">upper_bound</span>(usePos.<span class="hljs-built_in">begin</span>(), usePos.<span class="hljs-built_in">end</span>(), *iter, greater&lt;&gt;()) - usePos.<span class="hljs-built_in">begin</span>());<br>            <span class="hljs-keyword">if</span> (cnt != sorted[i].first) &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            ans[sorted[i].second] = -*iter;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!flag) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item : ans) cout &lt;&lt; item &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 895 (Div. 3)</title>
    <link href="/2023/09/08/acm/codeforces/CodeforcesRound895/"/>
    <url>/2023/09/08/acm/codeforces/CodeforcesRound895/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Two-Vessels"><a href="#A-Two-Vessels" class="headerlink" title="A. Two Vessels"></a>A. Two Vessels</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有 A，B 两个水池，用大小为 $c$ 的勺子舀，最少需要几次才能让这两个水池相同</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>简单题，每次变化 $2c$，不要求平均数，不然精度不好算</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        <span class="hljs-type">int</span> diff = <span class="hljs-built_in">abs</span>(a - b);<br>        cout &lt;&lt; (diff + <span class="hljs-number">2</span> * c - <span class="hljs-number">1</span>) / (<span class="hljs-number">2</span> * c) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-The-Corridor-or-There-and-Back-Again"><a href="#B-The-Corridor-or-There-and-Back-Again" class="headerlink" title="B. The Corridor or There and Back Again"></a>B. The Corridor or There and Back Again</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一条射线，射线上有一些点有夹子，夹子会在人经过后 $x$ 秒触发，问从顶点出发，然后折返，问最远可以到哪里</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>也是简单题，每个夹子就意味着单独的最远可达距离，然后取最小就行了</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-type">int</span> ans = INT_MAX;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> a, b;<br>            cin &gt;&gt; a &gt;&gt; b;<br>            ans = <span class="hljs-built_in">min</span>(ans, a + (b - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Non-coprime-Split"><a href="#C-Non-coprime-Split" class="headerlink" title="C. Non-coprime Split"></a>C. Non-coprime Split</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>给出 $[l, r]$ 这个区间，目的找到两个值 $a, b$，满足</p><ul><li>$a + b \in [l, r]$</li><li>$gcd(a, b) \neq 1$</li></ul><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>第一反应就是偶数，毕竟任意两个偶数很容易达到，而且可以足够小，只要 $[l, r]$ 中存在偶数区间即可。当然，同时 $r \geq 4$，否则肯定没戏</p><p>如果还不行怎么办，那此时必然满足 $l = r, r \space mod \space 2 == 1$。这个时候，反正也只有一个数可以选了，强行找因子吧，找不到就算失败</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> l, r;<br>        cin &gt;&gt; l &gt;&gt; r;<br>        <span class="hljs-keyword">if</span> (r &lt; <span class="hljs-number">4</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (l != r || r % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; ((r &gt;&gt; <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-number">1</span>) - <span class="hljs-number">2</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> mid = (<span class="hljs-type">int</span>) <span class="hljs-built_in">sqrt</span>(r) + <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> gcd = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= mid; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (r - i &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span> (r % i == <span class="hljs-number">0</span>) &#123;<br>                gcd = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (gcd == <span class="hljs-number">-1</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cout &lt;&lt; gcd &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; r - gcd &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Plus-Minus-Permutation"><a href="#D-Plus-Minus-Permutation" class="headerlink" title="D. Plus Minus Permutation"></a>D. Plus Minus Permutation</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>给定 $n, x, y$，你需要找到一个 $n$ 的排列，满足</p>$$((p_{1x}+p_{2x}+p_{3x}+ \dots + p_{\left \lfloor \frac{n}{x} \right \rfloor x}) - (p_{1y}+p_{2y}+p_{3y}+ \dots + p_{\left \lfloor \frac{n}{y} \right \rfloor y})$$<p>尽可能大，问最终结果是</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>计算出 $x$ 单独占了几个，$y$ 单独占了几个，然后把大数给 $x$，小数给 $y$ 即可</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, x, y;<br>        cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;<br>        <span class="hljs-type">int</span> g = <span class="hljs-built_in">gcd</span>(x, y), l = (x * y) / g;<br>        <span class="hljs-type">int</span> cntL = n / l, cntX = n / x - cntL, cntY = n / y - cntL;<br>        <span class="hljs-type">int</span> sumX = (n + (n - cntX + <span class="hljs-number">1</span>)) * cntX / <span class="hljs-number">2</span>, sumY = (<span class="hljs-number">1</span> + cntY) * cntY / <span class="hljs-number">2</span>;<br>        cout &lt;&lt; sumX - sumY &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="E-Data-Structures-Fan"><a href="#E-Data-Structures-Fan" class="headerlink" title="E. Data Structures Fan"></a>E. Data Structures Fan</h1><h2 id="大致题意-4"><a href="#大致题意-4" class="headerlink" title="大致题意"></a>大致题意</h2><p>这题实在不想写题意了，已经把线段树这三个字拍脸上了</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>维护两个值即可，为 $0$ 的异或和，为 $1$ 的异或和，然后每次改就是交换这两个值</p><h2 id="AC-code-4"><a href="#AC-code-4" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegTree</span> &#123;<br><br>    <span class="hljs-type">int</span> cnt[<span class="hljs-number">2</span>][N &lt;&lt; <span class="hljs-number">1</span>];<br>    <span class="hljs-type">bool</span> lazy[N &lt;&lt; <span class="hljs-number">1</span>];<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-type">static</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (l + r) | (l != r);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        cnt[<span class="hljs-number">0</span>][<span class="hljs-built_in">get</span>(l, r)] = cnt[<span class="hljs-number">0</span>][<span class="hljs-built_in">get</span>(l, mid)] ^ cnt[<span class="hljs-number">0</span>][<span class="hljs-built_in">get</span>(mid + <span class="hljs-number">1</span>, r)];<br>        cnt[<span class="hljs-number">1</span>][<span class="hljs-built_in">get</span>(l, r)] = cnt[<span class="hljs-number">1</span>][<span class="hljs-built_in">get</span>(l, mid)] ^ cnt[<span class="hljs-number">1</span>][<span class="hljs-built_in">get</span>(mid + <span class="hljs-number">1</span>, r)];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123; <span class="hljs-comment">// NOLINT(*-no-recursion)</span><br>        lazy[<span class="hljs-built_in">get</span>(l, r)] = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (l == r) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">build</span>(l, mid);<br>        <span class="hljs-built_in">build</span>(mid + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-built_in">up</span>(l, r);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-type">int</span> k = <span class="hljs-built_in">get</span>(l, r);<br>        <span class="hljs-keyword">if</span> (lazy[k]) &#123;<br>            <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> left = <span class="hljs-built_in">get</span>(l, mid), right = <span class="hljs-built_in">get</span>(mid + <span class="hljs-number">1</span>, r);<br>            <span class="hljs-built_in">swap</span>(cnt[<span class="hljs-number">0</span>][left], cnt[<span class="hljs-number">1</span>][left]);<br>            <span class="hljs-built_in">swap</span>(cnt[<span class="hljs-number">0</span>][right], cnt[<span class="hljs-number">1</span>][right]);<br>            lazy[left] = !lazy[left];<br>            lazy[right] = !lazy[right];<br>            lazy[k] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-comment">// NOLINT(*-no-recursion)</span><br>        <span class="hljs-keyword">if</span> (l == x &amp;&amp; y == r) &#123;<br>            <span class="hljs-built_in">swap</span>(cnt[<span class="hljs-number">0</span>][<span class="hljs-built_in">get</span>(l, r)], cnt[<span class="hljs-number">1</span>][<span class="hljs-built_in">get</span>(l, r)]);<br>            lazy[<span class="hljs-built_in">get</span>(l, r)] = !lazy[<span class="hljs-built_in">get</span>(l, r)];<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">push</span>(l, r);<br>        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (y &lt;= mid) &#123;<br>            <span class="hljs-built_in">update</span>(l, mid, x, y);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt; mid) &#123;<br>            <span class="hljs-built_in">update</span>(mid + <span class="hljs-number">1</span>, r, x, y);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">update</span>(l, mid, x, mid);<br>            <span class="hljs-built_in">update</span>(mid + <span class="hljs-number">1</span>, r, mid + <span class="hljs-number">1</span>, y);<br>        &#125;<br>        <span class="hljs-built_in">up</span>(l, r);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> p)</span> </span>&#123; <span class="hljs-comment">// NOLINT(*-no-recursion)</span><br>        <span class="hljs-keyword">if</span> (l == x &amp;&amp; y == r) &#123;<br>            <span class="hljs-keyword">return</span> cnt[p][<span class="hljs-built_in">get</span>(l, r)];<br>        &#125;<br>        <span class="hljs-built_in">push</span>(l, r);<br>        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (y &lt;= mid) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(l, mid, x, y, p);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt; mid) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(mid + <span class="hljs-number">1</span>, r, x, y, p);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(l, mid, x, mid, p) ^ <span class="hljs-built_in">query</span>(mid + <span class="hljs-number">1</span>, r, mid + <span class="hljs-number">1</span>, y, p);<br>        &#125;<br>    &#125;<br>&#125; seg;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            cin &gt;&gt; seg.cnt[<span class="hljs-number">0</span>][SegTree::<span class="hljs-built_in">get</span>(i, i)];<br>            seg.cnt[<span class="hljs-number">1</span>][SegTree::<span class="hljs-built_in">get</span>(i, i)] = <span class="hljs-number">0</span>;<br>        &#125;<br>        string str;<br>        str.<span class="hljs-built_in">reserve</span>(n);<br>        cin &gt;&gt; str;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;1&#x27;</span>)<br>                <span class="hljs-built_in">swap</span>(seg.cnt[<span class="hljs-number">0</span>][SegTree::<span class="hljs-built_in">get</span>(i + <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>)], seg.cnt[<span class="hljs-number">1</span>][SegTree::<span class="hljs-built_in">get</span>(i + <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>)]);<br>        seg.<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, n);<br><br>        <span class="hljs-type">int</span> q;<br>        cin &gt;&gt; q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; ++i) &#123;<br>            <span class="hljs-type">int</span> o;<br>            cin &gt;&gt; o;<br>            <span class="hljs-keyword">if</span> (o == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-type">int</span> l, r;<br>                cin &gt;&gt; l &gt;&gt; r;<br>                seg.<span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>, n, l, r);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> x;<br>                cin &gt;&gt; x;<br>                cout &lt;&lt; seg.<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, n, <span class="hljs-number">1</span>, n, x) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="F-Selling-a-Menagerie"><a href="#F-Selling-a-Menagerie" class="headerlink" title="F. Selling a Menagerie"></a>F. Selling a Menagerie</h1><h2 id="大致题意-5"><a href="#大致题意-5" class="headerlink" title="大致题意"></a>大致题意</h2><p>你决定逐个出售动物园里的动物，每个动物都有其价格，出售可以获得对应价格。</p><p>每个动物都有其唯一害怕的动物，如果你出售的时候，其害怕的动物还没有被出售，那么你可以获得双倍的价格奖励</p><p>给出一个出售顺序，使得最终价值最高</p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>很明显是一个 dag 的拓扑排序问题。可惜的是，这个并不是 dag，是有环的。而每次解开一个环，就要消耗一定代价。</p><p>可以直接将原来拓扑用的入度改成代价，即所有指向（害怕）这个节点的价格之和，因为如果这个节点先被拓扑了，那么这些指向它的节点就拿不到双倍的价值了，即损失了他们价格之和的代价</p><p>然后搞个优先队列拓扑就好了</p><h2 id="AC-code-5"><a href="#AC-code-5" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>            <span class="hljs-type">int</span> v, n;<br>        &#125;;<br><br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cost</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">link</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">deg</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            link[i] = tmp - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: cost) cin &gt;&gt; item;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) deg[link[i]] += cost[i];<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">visit</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span></span>;<br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, greater&lt;&gt;&gt; prq;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) prq.<span class="hljs-built_in">emplace</span>(deg[i], i);<br>        <span class="hljs-keyword">while</span> (!prq.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> cur = prq.<span class="hljs-built_in">top</span>();<br>            prq.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (visit[cur.second]) <span class="hljs-keyword">continue</span>;<br>            visit[cur.second] = <span class="hljs-literal">true</span>;<br>            cout &lt;&lt; cur.second + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>            <span class="hljs-type">int</span> nxt = link[cur.second];<br>            <span class="hljs-keyword">if</span> (visit[nxt]) <span class="hljs-keyword">continue</span>;<br>            deg[nxt] -= cost[cur.second];<br>            prq.<span class="hljs-built_in">emplace</span>(deg[nxt], nxt);<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="G-Replace-With-Product"><a href="#G-Replace-With-Product" class="headerlink" title="G. Replace With Product"></a>G. Replace With Product</h1><h2 id="大致题意-6"><a href="#大致题意-6" class="headerlink" title="大致题意"></a>大致题意</h2><p>给你一个数组，允许你选择其中一段，将其换成这些值的乘积，问数组最大的和是多少。需要给出选择的那一段</p><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>由于乘法的增长通常都会远大于求和，我们需要寻找一个临界点，使得 $\prod_{i=1}^n a_i \geq \sum_{i=1}^n a_i$，这样就可以无脑乘起来了</p><p>假定数组中只有两个值是 $&gt; 1$ 的，为 $x, y$，那么可以得到</p>$$\begin{align*}xy       & \geq n+x+y-2 \\         & \geq n+2\sqrt{xy}-2 \\let \space t & \rightarrow \sqrt{xy} \\t^2-2t+1 & \geq n - 1 \\t-1      & \geq \sqrt{n-1} \\t        & \geq \sqrt{n-1}+1 \\xy       & \geq n-1+2\sqrt{n-1}+1 \\         & \geq n+2\sqrt{n-1}  \\         & \geq n+n-1+1 \\         & \geq 2n\end{align*}$$<p>所以只要对于 $xy &gt; 2n$ 的情况，则可以无脑选尽可能全部的即可，因为相加一定不如相乘，当然，是尽可能，不是一定全部</p><p>那对于那些不满足的，可以得到 $\prod_{i=1}^n a_i &lt; 2n$，这是一个很难达到的，假定有 $x$ 个数值不为 $1$ 的值，那么必然平均值为 $\sqrt[x]{2n}$，当 $x = 100$ 的时候，平均值就一定 $&lt; 2$ 了，就意味着有 $1$ 的存在，那更不可能乘起来达到目标值了，所以此时非 $1$ 的值数量极少，可以暴力求解</p><h2 id="AC-code-6"><a href="#AC-code-6" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: data) cin &gt;&gt; item;<br>        <span class="hljs-type">int</span> tot = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item : data) &#123;<br>            tot *= item;<br>            <span class="hljs-keyword">if</span> (tot &gt; <span class="hljs-number">2</span> * n) <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (tot &gt; <span class="hljs-number">2</span> * n) &#123;<br>            <span class="hljs-comment">// make 1 less</span><br>            <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (data[l] == <span class="hljs-number">1</span>) l++;<br>            <span class="hljs-keyword">while</span> (data[r] == <span class="hljs-number">1</span>) r--;<br>            cout &lt;&lt; l + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; r + <span class="hljs-number">1</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; not1;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (data[i] != <span class="hljs-number">1</span>) not1.<span class="hljs-built_in">push_back</span>(i);<br><br>        <span class="hljs-keyword">if</span> (not1.<span class="hljs-built_in">empty</span>()) &#123;<br>            cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> mx = <span class="hljs-number">0</span>, l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; not1.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-type">int</span> curP = data[not1[i]], curS = data[not1[i]] - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; not1.<span class="hljs-built_in">size</span>(); ++j) &#123;<br>                curP *= data[not1[j]];<br>                curS += data[not1[j]] - <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> realS = curS + not1[j] - not1[i] + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (mx &lt; curP - realS) &#123;<br>                    mx = curP - realS;<br>                    l = not1[i];<br>                    r = not1[j];<br>                &#125;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; l + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; r + <span class="hljs-number">1</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>左值-右值-将亡值</title>
    <link href="/2023/09/03/cpp/lvalue-xvalue-prvalue/"/>
    <url>/2023/09/03/cpp/lvalue-xvalue-prvalue/</url>
    
    <content type="html"><![CDATA[<h1 id="最初概念"><a href="#最初概念" class="headerlink" title="最初概念"></a>最初概念</h1><blockquote><p>如何确定一个值是左值还是右值？<br>通常有一个比较简单的判断方案：有地址的值被称为左值，没有地址的值称为右值</p></blockquote><p>但是事实好像并非如此，特别是写了一些相关代码的时候，比如下面的这段</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;&amp;a)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> &amp;b = a;<br>    <span class="hljs-type">int</span> &amp;&amp;c = <span class="hljs-number">1</span>;<br><br>    cout &lt;&lt; <span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>) &lt;&lt; endl; <span class="hljs-comment">// 2</span><br>    cout &lt;&lt; <span class="hljs-built_in">f</span>(a) &lt;&lt; endl; <span class="hljs-comment">// 1</span><br>    cout &lt;&lt; <span class="hljs-built_in">f</span>(b) &lt;&lt; endl; <span class="hljs-comment">// 1</span><br>    cout &lt;&lt; <span class="hljs-built_in">f</span>(c) &lt;&lt; endl; <span class="hljs-comment">// 1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对应的输出结果也写在每一行的后面了，这似乎有一些意料之外的情况</p><ul><li>第一行，一个单独的数字 <code>1</code>，很明显的确实是一个右值，符合预期</li><li>第二行，变量 <code>a</code> 明显也是一个合情合理的左值，那么也是符合预期的</li><li>接下来第三行，变量 <code>b</code> 作为 <code>a</code> 的一个引用，那毫无意义也是一个左值（<code>b</code> 只是引用了 <code>a</code> 的值，实际上仍然是 <code>a</code> 本身），符合预期</li><li>但是第四行，却让人摸不着头脑，明明 <code>c</code> 是一个明确的右值引用，为什么也是一个 <code>1</code></li></ul><p>这似乎表明了，<code>c</code> 是一个合法的左值，而非右值</p><p>尝试做一些看起来非法的操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> &amp;&amp;c = <span class="hljs-number">1</span>;<br>c += <span class="hljs-number">10</span>;<br>cout &lt;&lt; c &lt;&lt; endl; <span class="hljs-comment">// 11</span><br></code></pre></td></tr></table></figure><p>看起来非常的合法合理，就像是一个活灵活现的左值，而并非它类型那样描述的右值。即然是左值，那么必然有地址，输出看看</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">cout &lt;&lt; &amp;a &lt;&lt; endl; <span class="hljs-comment">// 0x7fff1ba1f724</span><br>cout &lt;&lt; &amp;b &lt;&lt; endl; <span class="hljs-comment">// 0x7fff1ba1f724</span><br>cout &lt;&lt; &amp;c &lt;&lt; endl; <span class="hljs-comment">// 0x7fff1ba1f72c</span><br></code></pre></td></tr></table></figure><p>从上面的数字可以看出来，<code>c</code> 确实是在栈上，即拥有一个合理合法的地址，这是发生了什么？</p><h1 id="调查"><a href="#调查" class="headerlink" title="调查"></a>调查</h1><p>如果把上述的代码改成汇编语言后，再看看结果</p><ul><li>汇编前</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> &amp;b = a;<br>    <span class="hljs-type">int</span> &amp;&amp;c = <span class="hljs-number">1</span>;<br>    c += <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>汇编结果（仅摘录核心段）</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.cfi_startproc</span><br>pushq%rbp<br><span class="hljs-meta">.cfi_def_cfa_offset</span> <span class="hljs-number">16</span><br><span class="hljs-meta">.cfi_offset</span> <span class="hljs-number">6</span>, -<span class="hljs-number">16</span><br><span class="hljs-keyword">movq</span>%rsp, %rbp<br><span class="hljs-meta">.cfi_def_cfa_register</span> <span class="hljs-number">6</span><br>subq<span class="hljs-number">$32</span>, %rsp           <span class="hljs-comment">; 以上均为函数定义需要的一些基本操作，例如记录栈位置等，忽略</span><br><span class="hljs-keyword">movq</span>%fs:<span class="hljs-number">40</span>, %rax        <span class="hljs-comment">; 设置 canary 值，用于检测 stack overflow 现象</span><br><span class="hljs-keyword">movq</span>%rax, -<span class="hljs-number">8</span>(%rbp)      <span class="hljs-comment">; 将 canary 值保存到栈的前 8 个字节中</span><br>xorl%eax, %eax          <span class="hljs-comment">; 任何值 xor 自己必定为 0，此处相当于清理 eax 寄存器</span><br>movl<span class="hljs-number">$1</span>, -<span class="hljs-number">32</span>(%rbp)       <span class="hljs-comment">; 将 1 存储到 28-32 这几个字节中（int 占用 4 个字节）【变量 a】</span><br>leaq-<span class="hljs-number">32</span>(%rbp), %rax     <span class="hljs-comment">; 将【a】的地址拷贝到 rax</span><br><span class="hljs-keyword">movq</span>%rax, -<span class="hljs-number">24</span>(%rbp)     <span class="hljs-comment">; 将【a】的地址保存到 16-24 这几个字节中（64bit 上占用 8 个字节）【变量 b】</span><br>movl<span class="hljs-number">$1</span>, %eax            <span class="hljs-comment">; 将值 1 写入 eax</span><br>movl%eax, -<span class="hljs-number">28</span>(%rbp)     <span class="hljs-comment">; 将 eax 的值写入 24-28 这几个字节中【未知变量】</span><br>leaq-<span class="hljs-number">28</span>(%rbp), %rax     <span class="hljs-comment">; 将【未知变量】的地址拷贝到 rax</span><br><span class="hljs-keyword">movq</span>%rax, -<span class="hljs-number">16</span>(%rbp)     <span class="hljs-comment">; 将【未知变量】的地址写入到 8-16 这几个字节中【变量 c】</span><br><span class="hljs-keyword">movq</span>-<span class="hljs-number">16</span>(%rbp), %rax     <span class="hljs-comment">; 再读取【变量 c】的到 rax</span><br>movl(%rax), %eax        <span class="hljs-comment">; 将【变量 c】认为是一个地址，取出此地址中的值并写入到 eax 中</span><br>leal<span class="hljs-number">10</span>(%rax), %edx      <span class="hljs-comment">; edx = rax + 10</span><br><span class="hljs-keyword">movq</span>-<span class="hljs-number">16</span>(%rbp), %rax     <span class="hljs-comment">; 将【变量 c】的值拷贝到 rax 中</span><br>movl%edx, (%rax)        <span class="hljs-comment">; 将 edx 的结果保存到 rax 对应的值的地址中（即写入【变量 c】作为地址所在的位置）</span><br>movl<span class="hljs-number">$0</span>, %eax            <span class="hljs-comment">; 清空 eax</span><br><span class="hljs-keyword">movq</span>-<span class="hljs-number">8</span>(%rbp), %rax      <span class="hljs-comment">; 取出 canary 值</span><br>xorq%fs:<span class="hljs-number">40</span>, %rax<br><span class="hljs-keyword">je</span>.L3<br><span class="hljs-keyword">call</span>__stack_chk_fail@PLT<br></code></pre></td></tr></table></figure><p>可以注意到，对于引用而言，汇编仍然使用的是指针来解决，所以可以看到变量 <code>b</code> 记录下的是 <code>a</code> 的指针，而非真正的给 <code>a</code> 做了一个别名。而 <code>c</code> 也是一个指针，指向了一个未知的变量。这似乎就是我们寻找的答案</p><p>从内存本身而言，任何值都可以认为是左值，因为一个值存在，则必定存在具体的地址，即使它是作为常量的方式写在代码中，那起码它也应该存在于代码段，“存在即有地址”</p><p>但是对于这种在代码段“有地址”的值，又违背了代码段不可修改的原则，而具体操作的时候又未免会使用到这些值，这个时候，编译器会将代码段的这个值拷贝到栈空间，然后将其再赋给具体的对象，这个拷贝过来的值，像是一个右值，同时又具有着左值的特点，更确切的说，它属于“将亡值(xvalue)”。</p><h1 id="将亡值"><a href="#将亡值" class="headerlink" title="将亡值"></a>将亡值</h1><p><img src="/image/cpp/lvalue-xvalue-prvalue/value-type.webp" alt="value-type"></p><p>其中，lvalue 和 rvalue 就是我们一般认为上的左值和右值，而 glvalue 则是包含了将亡值的泛左值，而 prvalue 则是指那些纯右值，也就是那些在代码段里的值</p><p>将亡值则表示一种中间变量，例如使用了纯右值的时候，或者隐式类型转化，或者函数的返回值，这些都是将亡值充当的角色。实际上他们都有确切的栈上地址。</p><p>但是将亡值本身的含义是一个临时存在的变量，终是不可久留，这也就意味着编译器通常会限制对将亡值进行左值引用的方式。例如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> &amp;x = (<span class="hljs-type">double</span>)<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>此时编译器的报错是：<code>Non-const lvalue reference to type &#39;double&#39; cannot bind to a temporary of type &#39;double&#39;</code>，即无法通过一个非常量的左值引用指向一个将亡值。而当你改成 <code>const double &amp;x = (double)1;</code> 后，程序又可以通过编译了。这也说明了编译器实际上只是在做一些安全性的检查，并没有真正限制修改将亡值，甚至可以将将亡值变成长期存在的栈上的值（例如一开始的程序）</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>右值引用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Educational Codeforces Round#154 (Div. 2)</title>
    <link href="/2023/09/02/acm/codeforces/EducationalCodeforcesRound154/"/>
    <url>/2023/09/02/acm/codeforces/EducationalCodeforcesRound154/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Prime-Deletion"><a href="#A-Prime-Deletion" class="headerlink" title="A. Prime Deletion"></a>A. Prime Deletion</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一个 9 位数的数字，其中 $1-9$ 恰好各出现一次，允许删除一些位置，并保持原来的顺序不变，然后最终结果需要是一个素数。给出一个可能的素数，要求至少两位数</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看起来很难的问题，实际上很容易解决。因为至少两位数，且每个数字都有，那么我只要找到几个万能的解不就行了</p><p>我选择了 $13$ 和 $31$，只需要观察原数组中 $1, 3$ 的相对位置，选择其中一个输出即可</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        string str;<br>        str.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">9</span>);<br>        cin &gt;&gt; str;<br>        <span class="hljs-type">int</span> pos1 = <span class="hljs-number">0</span>, pos3 = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;1&#x27;</span>) pos1 = i;<br>            <span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;3&#x27;</span>) pos3 = i;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (pos1 &lt; pos3) cout &lt;&lt; <span class="hljs-string">&quot;13&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;31&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Two-Binary-Strings"><a href="#B-Two-Binary-Strings" class="headerlink" title="B. Two Binary Strings"></a>B. Two Binary Strings</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>给你两个 01 字符串 $s$，长度为 $n$，允许你对任何一个字符串进行无数次如下操作，问是否可能这两个字符串相同</p><ul><li>选择 $l, r$ 满足，$1 \leq l &lt; r \leq n$</li><li>且 $s_l = s_r$</li><li>使得 $\forall i \in [l, r], s_i \rightarrow s_l$</li></ul><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>看似很头痛的问题，实际上很简单</p><p>如果一个字符串首尾是相同的，那么直接全选，就可以让这个字符串变成完全相同的字符串了，那就不用那么操心了。而反过来可以发现，字符串的首尾是一定不会变化的，因为它必定是被选择的 $l, r$，所以这两个字符串的首尾必须相互映射。如果同时顺便首尾相同了，那也不用思考更多了</p><p>接下来考虑首尾不同的情况，也就是一定同时存在 $0, 1$</p><p>那么必定存在一个位置，出现 $01$ 或者 $10$ 相邻的情况，为了方便起见，也为了避免出现混乱，这里假定原字符串开头为 $0$，结束为 $1$，那么我们去找 $01$ 即可，因为必定存在。反之依然，证明同理</p><p>那么就有两种可能：1、两个字符串都在这个位置出现这个相邻，2、两个字符串不存在同时出现这个相邻情况</p><p>前者比较好办，直接从这个位置将字符串拆分成两半，每一半都是相同的即可</p><p>后者则可以证明无解决方案。方法也很简单：因为一旦有一个不相同，那么必然需要处理成相同的，而一旦需要处理，则需要外部的来把她们抹成相同（每次操作后 01 段数量一定减少，所以只能抹去）而外部本身也没有匹配上，故需要外部的外部来抹去，依此类推，可以得到无法解决</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        string a, b;<br>        a.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">5000</span>);<br>        b.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">5000</span>);<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">front</span>() != b.<span class="hljs-built_in">front</span>() || a.<span class="hljs-built_in">back</span>() != b.<span class="hljs-built_in">back</span>()) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (a.<span class="hljs-built_in">front</span>() == a.<span class="hljs-built_in">back</span>()) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (a[i] == a.<span class="hljs-built_in">front</span>() &amp;&amp; a[i + <span class="hljs-number">1</span>] == a.<span class="hljs-built_in">back</span>() &amp;&amp; b[i] == b.<span class="hljs-built_in">front</span>() &amp;&amp; b[i + <span class="hljs-number">1</span>] == b.<span class="hljs-built_in">back</span>()) &#123;<br>                flag = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        cout &lt;&lt; (flag ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Queries-for-the-Array"><a href="#C-Queries-for-the-Array" class="headerlink" title="C. Queries for the Array"></a>C. Queries for the Array</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>一个数组，开始的时候是空的，有三种操作</p><ul><li>在数组最后加一个值</li><li>移去数组最后的一个值</li><li>询问数组是否有序</li></ul><p>现在告诉你操作的顺序，以及是否有序的结果，但是不告诉你具体加了什么值，问是否可能</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>简单题，用栈模拟即可，只要记住两个原则即可</p><ul><li>若当前有序，那么删除最后一个值仍然有序</li><li>若当前无序，那么加入一个值仍然无序</li></ul><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    string str;<br>    str.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">200010</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        cin &gt;&gt; str;<br>        stack&lt;<span class="hljs-type">int</span>&gt; flag;<br>        <span class="hljs-type">bool</span> res = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> i : str) &#123;<br>            <span class="hljs-keyword">switch</span> (i) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br>                    <span class="hljs-keyword">if</span> (!flag.<span class="hljs-built_in">empty</span>() &amp;&amp; flag.<span class="hljs-built_in">top</span>() == <span class="hljs-number">2</span>) &#123;<br>                        flag.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        flag.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br>                    <span class="hljs-keyword">if</span> (flag.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">2</span> &amp;&amp; flag.<span class="hljs-built_in">top</span>() == <span class="hljs-number">1</span>) &#123;<br>                        flag.<span class="hljs-built_in">pop</span>();<br>                        flag.<span class="hljs-built_in">top</span>() = <span class="hljs-number">1</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        flag.<span class="hljs-built_in">pop</span>();<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>:<br>                    <span class="hljs-keyword">if</span> (!flag.<span class="hljs-built_in">empty</span>() &amp;&amp; flag.<span class="hljs-built_in">top</span>() == <span class="hljs-number">2</span>) &#123;<br>                        res = <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (!flag.<span class="hljs-built_in">empty</span>()) &#123;<br>                        flag.<span class="hljs-built_in">top</span>() = <span class="hljs-number">1</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;0&#x27;</span>:<br>                    <span class="hljs-keyword">if</span> (flag.<span class="hljs-built_in">empty</span>() || flag.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span> || flag.<span class="hljs-built_in">top</span>() == <span class="hljs-number">1</span>) &#123;<br>                        res = <span class="hljs-literal">false</span>;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (!flag.<span class="hljs-built_in">empty</span>()) &#123;<br>                        flag.<span class="hljs-built_in">top</span>() = <span class="hljs-number">2</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        cout &lt;&lt; (res ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Sorting-By-Multiplication"><a href="#D-Sorting-By-Multiplication" class="headerlink" title="D. Sorting By Multiplication"></a>D. Sorting By Multiplication</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>给你一个数组，开始的时候都是正整数，允许你进行如下操作，让整个数组变成严格递增，至少需要几次</p><ul><li>选择数组上任意的一个区间</li><li>选择一个任意整数，可以是负数</li><li>将区间内的每一个值都乘上选择的素数</li></ul><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>第一感觉是可以用 dp 解决，也索性从这个方向考虑了。</p><p>每个数字其实可以是正数 or 负数，这很明显，也是这个题目要考虑的重点</p><p>定义 $dp[i][j]$，其中 $i$ 表示位置，$j$ 表示当前值是正数还是负数，$0$ 表示正数，$1$ 表示负数</p><ul><li>任何一个值，如果它前面是负值，那么它自身不需要任何操作就能满足局部严格递增</li><li>如果当前值和前一个值在初始值上已经严格递增了，且前一个值不是负数的情况下，那么只需要跟着前一个值进行一样的乘 $x$ 运算即可，最终也保持严格递增</li><li>如果当前值和前一个值已经在初始值上递减了，那么要么让前一个值变成负数，要么就需要自身乘以一个更高的系数来放大</li></ul><p>根据上述三条，可以得到状态转移方程</p>$$\left\{\begin{matrix} dp_{i,0} = &\left\{\begin{matrix}min(dp_{i-1,0}, dp_{i-1,1}), & a_{i-1} < a_i \\min(dp_{i-1,0} + 1, dp_{i-1,1}), & a_{i-1} = a_i \\min(dp_{i-1,0} + 1, dp_{i-1,1}), & a_{i-1} > a_i\end{matrix}\right.\\dp_{i,1} = &\left\{\begin{matrix}dp_{i-1, 1} + 1, & a_{i-1} < a_idp_{i-1, 1} + 1, & a_{i-1} = a_idp_{i-1, 1}, & a_{i-1} > a_i\end{matrix}\right.\end{matrix}\right.$$<h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: data) cin &gt;&gt; item;<br>        vector&lt;<span class="hljs-type">int</span>&gt; dp[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;row: dp) row.<span class="hljs-built_in">resize</span>(n);<br><br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (data[i - <span class="hljs-number">1</span>] &lt; data[i]) &#123;<br>                dp[<span class="hljs-number">0</span>][i] = <span class="hljs-built_in">min</span>(dp[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>], dp[<span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>]);<br>                dp[<span class="hljs-number">1</span>][i] = dp[<span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data[i - <span class="hljs-number">1</span>] == data[i]) &#123;<br>                dp[<span class="hljs-number">0</span>][i] = <span class="hljs-built_in">min</span>(dp[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, dp[<span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>]);<br>                dp[<span class="hljs-number">1</span>][i] = dp[<span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[<span class="hljs-number">0</span>][i] = <span class="hljs-built_in">min</span>(dp[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, dp[<span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>]);<br>                dp[<span class="hljs-number">1</span>][i] = dp[<span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-built_in">min</span>(dp[<span class="hljs-number">0</span>][n - <span class="hljs-number">1</span>], dp[<span class="hljs-number">1</span>][n - <span class="hljs-number">1</span>]) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pinely Round 2 (Div. 1 + Div. 2)</title>
    <link href="/2023/09/01/acm/codeforces/PinelyRound2/"/>
    <url>/2023/09/01/acm/codeforces/PinelyRound2/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Channel"><a href="#A-Channel" class="headerlink" title="A. Channel"></a>A. Channel</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>你是一个频道的频道主，然后发了一条消息，同时你能知道订阅者上下线的消息（不知道具体是谁），上线的人必定看你的消息，问有没有可能所有人都看过你的消息了</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>简单题，统计最大同时在线，和最多多少在线，就可以了</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, a, q;<br>        cin &gt;&gt; n &gt;&gt; a &gt;&gt; q;<br>        string str;<br>        str.<span class="hljs-built_in">reserve</span>(q);<br>        cin &gt;&gt; str;<br>        <span class="hljs-type">int</span> ma = a, tot = a, cur = a;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: str) &#123;<br>            <span class="hljs-keyword">if</span> (item == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>                cur++;<br>                tot++;<br>                ma = <span class="hljs-built_in">max</span>(ma, cur);<br>            &#125; <span class="hljs-keyword">else</span> cur--;<br>        &#125;<br>        cout &lt;&lt; (ma &gt;= n ? <span class="hljs-string">&quot;YES&quot;</span> : tot &gt;= n ? <span class="hljs-string">&quot;MAYBE&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Split-Sort"><a href="#B-Split-Sort" class="headerlink" title="B. Split Sort"></a>B. Split Sort</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个 $n$ 的排列，每次选择一个数组中的一个值，将小于它的值放左边，大于等于的放右边，顺序不变，问最多操作几次后数组有序</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>第一反应就是归并排序，太像了，只需要算出归并排序需要几次就行了</p><p>但是这个值可以说是确定的，即几乎等于 $n$，这是归并的性质决定的。而实际上已经基本排序好的数组，压根不需要那么多次</p><p>再仔细思考操作带来的意义，实际上本身顺序并没有发生太大变动，假如移动的是 $x$，那么对于除开 $x$ 以外的所有值而言，在 $[1, x)$ 内都没有发生相对位置变化，同理对于 $[x, n]$ 也是，但是跨 $x$ 的相对位置都变成正确的了。即当对任意的 $x$ 进行操作后，实际上就解决掉了 $x$ 关联的全部的逆序对问题，以及跨越 $x$ 的逆序对。</p><p>综上可以得到，若不选择 $x$ 的情况下，那么若 $x - 1$ 在 $x$ 的右侧情况下，那么必然永远不能消除此逆序对。所以只需要找出这样的逆序对，然后进行操作即可。至于剩下的逆序对，在完成上述操作后，自然已经满足要求了，这里不再详细证明</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        set&lt;<span class="hljs-type">int</span>&gt; flag;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            <span class="hljs-keyword">if</span> (flag.<span class="hljs-built_in">count</span>(tmp + <span class="hljs-number">1</span>)) ans++;<br>            flag.<span class="hljs-built_in">insert</span>(tmp);<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-MEX-Repetition"><a href="#C-MEX-Repetition" class="headerlink" title="C. MEX Repetition"></a>C. MEX Repetition</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一个长度为 $n$ 的数组，其值在 $[0, n]$ 内，且没有重复</p><p>每次操作，需要依次对每一个值进行 $MEX$ 计算，并代替当前的值，问进行 $x$ 次操作后，数组变成什么样</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>在数组最后补上没有的那个值，然后你就会发现只是在旋转数组罢了</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        set&lt;<span class="hljs-type">int</span>&gt; flag;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) flag.<span class="hljs-built_in">insert</span>(i);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cin &gt;&gt; data[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) flag.<span class="hljs-built_in">erase</span>(data[i]);<br>        data[n] = *flag.<span class="hljs-built_in">begin</span>();<br>        k %= (n + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cout &lt;&lt; data[(i + n + <span class="hljs-number">1</span> - k) % (n + <span class="hljs-number">1</span>)] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Two-Colored-Dominoes"><a href="#D-Two-Colored-Dominoes" class="headerlink" title="D. Two-Colored Dominoes"></a>D. Two-Colored Dominoes</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个 $n \times m$ 的矩阵，矩阵上放着很多小木板，一块木板一定恰好占用两个相邻的格子，木板之间不重叠。</p><p>现在要给木板上色，黑色和白色，一块木板占用的两个格子，必须不同颜色。矩阵内任意一行一列都必须黑白色相同数量，给出一种上色法</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>要相同，必然占用的格子数量是偶数</p><p>结论很简单，竖着的木板在同行的数量（或者横着的木板在同列的数量）一定是偶数</p><p>可以简单画一下错开的情况，就会发现无解了</p><p>知道这个结论之后随便画一下就好了</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, m;<br>        cin &gt;&gt; n &gt;&gt; m;<br>        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;row: ans) &#123;<br>            row.<span class="hljs-built_in">reserve</span>(m);<br>            cin &gt;&gt; row;<br>        &#125;<br><br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> last = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>                <span class="hljs-comment">// for U</span><br>                <span class="hljs-keyword">if</span> (ans[i][j] != <span class="hljs-string">&#x27;U&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> (last == <span class="hljs-number">-1</span>) last = j;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    ans[i][j] = <span class="hljs-string">&#x27;W&#x27;</span>;<br>                    ans[i + <span class="hljs-number">1</span>][j] = <span class="hljs-string">&#x27;B&#x27;</span>;<br>                    ans[i][last] = <span class="hljs-string">&#x27;B&#x27;</span>;<br>                    ans[i + <span class="hljs-number">1</span>][last] = <span class="hljs-string">&#x27;W&#x27;</span>;<br>                    last = <span class="hljs-number">-1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (last != <span class="hljs-number">-1</span>) &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>            <span class="hljs-type">int</span> last = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                <span class="hljs-comment">// for L</span><br>                <span class="hljs-keyword">if</span> (ans[i][j] != <span class="hljs-string">&#x27;L&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> (last == <span class="hljs-number">-1</span>) last = i;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    ans[i][j] = <span class="hljs-string">&#x27;W&#x27;</span>;<br>                    ans[i][j + <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;B&#x27;</span>;<br>                    ans[last][j] = <span class="hljs-string">&#x27;B&#x27;</span>;<br>                    ans[last][j + <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;W&#x27;</span>;<br><br>                    last = <span class="hljs-number">-1</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (last != <span class="hljs-number">-1</span>) &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!flag) &#123;<br>            cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) cout &lt;&lt; ans[i][j];<br>            cout &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="E-Speedrun"><a href="#E-Speedrun" class="headerlink" title="E. Speedrun"></a>E. Speedrun</h1><h2 id="大致题意-4"><a href="#大致题意-4" class="headerlink" title="大致题意"></a>大致题意</h2><p>有 $n$ 个任务，每个任务完成需要的时间可以忽略不计，但是每个任务都有指定的完成时间点。时间是循环的，即类似自然时间，23 点之后又是 0 点。任务之间也有依赖关系</p><p>问最短需要多少时间完成这些任务</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>一开始写了一个拓扑排序找，然后三分了所有可能的开始时间点（$[0, k]$），理论上时间应该来得及，但是不知道为什么 TLE 了</p><p>后面开始仔细思考其他解决方案</p><p>实际上每个节点的时间可以看成是 $h_i + x * k$，即需要求出最大和最小值之差。然后对于第一批没有依赖的任务，他们可以是第一天完成的，也可以是第二天完成的，但是不可能是第三天完成的。故可以考枚举无依赖的任务是否是第二天完成的，然后计算此时最大的完成时间。由于无依赖任务本身也是有时间的，根据时间排序后遍历的话，若当前是第二天完成的，那么前面的也都是第二天完成的了，就不需要每次单独计算了，可以让下一次的状态是从上一次变化过来的，这样计算成本非常小</p><h2 id="AC-code-4"><a href="#AC-code-4" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, m, k;<br>        cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>            <span class="hljs-type">int</span> v, n;<br><br>            <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> node &amp;rhs) <span class="hljs-type">const</span> &#123;<br>                <span class="hljs-keyword">return</span> rhs.v &lt; v;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cost</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">head</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;node&gt; <span class="hljs-title">edge</span><span class="hljs-params">(m)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">deg</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: cost) cin &gt;&gt; item;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-type">int</span> u, v;<br>            cin &gt;&gt; u &gt;&gt; v;<br>            edge[i] = &#123;v - <span class="hljs-number">1</span>, head[u - <span class="hljs-number">1</span>]&#125;;<br>            head[u - <span class="hljs-number">1</span>] = i;<br>            deg[v - <span class="hljs-number">1</span>]++;<br>        &#125;<br><br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        vector&lt;<span class="hljs-type">int</span>&gt; begin;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>            <span class="hljs-keyword">if</span> (deg[i] == <span class="hljs-number">0</span>) &#123;<br>                q.<span class="hljs-built_in">push</span>(i);<br>                begin.<span class="hljs-built_in">push_back</span>(i);<br>            &#125;<br><br>        <span class="hljs-type">int</span> mx = <span class="hljs-number">0</span>, ans = LONG_LONG_MAX;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> cur = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br><br>            mx = <span class="hljs-built_in">max</span>(mx, cost[cur]);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[cur]; i != <span class="hljs-number">-1</span>; i = edge[i].n) &#123;<br>                --deg[edge[i].v];<br>                cost[edge[i].v] += ((<span class="hljs-built_in">max</span>(<span class="hljs-number">0LL</span>, cost[cur] - cost[edge[i].v]) + k - <span class="hljs-number">1</span>) / k) * k;<br>                <span class="hljs-keyword">if</span> (deg[edge[i].v] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(edge[i].v);<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(begin.<span class="hljs-built_in">begin</span>(), begin.<span class="hljs-built_in">end</span>(), [&amp;](<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;lhs, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;rhs) &#123;<br>            <span class="hljs-keyword">return</span> cost[lhs] &lt; cost[rhs];<br>        &#125;);<br><br>        ans = <span class="hljs-built_in">min</span>(ans, mx - cost[begin.<span class="hljs-built_in">front</span>()]);<br><br>        function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>)&gt; add = [&amp;](<span class="hljs-type">int</span> x) &#123;<br>            mx = <span class="hljs-built_in">max</span>(mx, cost[x]);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[x]; i != <span class="hljs-number">-1</span>; i = edge[i].n) &#123;<br>                <span class="hljs-keyword">if</span> (cost[edge[i].v] - cost[x] &gt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>                cost[edge[i].v] += ((<span class="hljs-built_in">max</span>(<span class="hljs-number">0LL</span>, cost[x] - cost[edge[i].v]) + k - <span class="hljs-number">1</span>) / k) * k;<br>                <span class="hljs-built_in">add</span>(edge[i].v);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item : begin) &#123;<br>            ans = <span class="hljs-built_in">min</span>(ans, mx - cost[item]);<br>            cost[item] += k;<br>            <span class="hljs-built_in">add</span>(item);<br>        &#125;<br><br>        ans = <span class="hljs-built_in">min</span>(ans, mx - cost[begin.<span class="hljs-built_in">front</span>()]);<br><br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Harbour.Space Scholarship Contest 2023-2024 (Div. 1 + Div. 2)</title>
    <link href="/2023/08/27/acm/codeforces/Harbour.SpaceScholarshipContest2023-2024/"/>
    <url>/2023/08/27/acm/codeforces/Harbour.SpaceScholarshipContest2023-2024/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Increasing-and-Decreasing"><a href="#A-Increasing-and-Decreasing" class="headerlink" title="A. Increasing and Decreasing"></a>A. Increasing and Decreasing</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给出数列的第一个和最后一个值，构造一个数列，保证</p><ul><li>数列严格递增</li><li>数列的递增速率严格递减</li></ul><p>找出任意一个即可</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>简单题，倒着构造即可，最后判断是否符合</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> x, y, n;<br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        data[<span class="hljs-number">0</span>] = x;<br>        data[n - <span class="hljs-number">1</span>] = y;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) data[n - i - <span class="hljs-number">1</span>] = data[n - i] - i;<br>        <span class="hljs-keyword">if</span> (data[<span class="hljs-number">0</span>] &gt;= data[<span class="hljs-number">1</span>] || data[<span class="hljs-number">1</span>] - data[<span class="hljs-number">0</span>] &lt;= data[<span class="hljs-number">2</span>] - data[<span class="hljs-number">1</span>]) &#123;<br>            cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cout &lt;&lt; data[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Swap-and-Reverse"><a href="#B-Swap-and-Reverse" class="headerlink" title="B. Swap and Reverse"></a>B. Swap and Reverse</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个字符串，长度为 $n$，允许你进行如下操作</p><ul><li>选择一个合理的 $i$，交换 $a_i$ 和 $a_{i + 2}$</li><li>选择一段连续的字符串，其长度为 $k$（为给出固定值），翻转这段字符串</li></ul><p>问操作无数次可以到达的最小字符串是什么</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>大胆猜测，小心求证。大概模拟了几个 case，猜测如果 $k$ 为奇数，则奇偶位置单独排序后输出就行了，否则就全部排序一下输出就好了</p><p>为奇数的情况比较简单，说白了就是奇偶位不会交换，就不再证明了</p><p>为偶数的情况，其实只需要隔一个位置进行翻转即可，因为题目说明了 $k &lt; n$。例如 $123456$，且 $k = 4$，则翻转一次后为 $432156$，再取 $1-5$ 翻转，得到 $451236$，可以观察到其实仅仅开头两位的奇偶得到了翻转，后面的奇偶性不变，故此可以实现任意连续两位的翻转，即全字符串都可以排序好</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        string str;<br>        str.<span class="hljs-built_in">reserve</span>(n);<br>        cin &gt;&gt; str;<br>        <span class="hljs-keyword">if</span> (k % <span class="hljs-number">2</span>) &#123;<br>            string tmp1, tmp2;<br>            tmp1.<span class="hljs-built_in">resize</span>((n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>);<br>            tmp2.<span class="hljs-built_in">resize</span>(n / <span class="hljs-number">2</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) tmp2[i / <span class="hljs-number">2</span>] = str[i];<br>                <span class="hljs-keyword">else</span> tmp1[(i + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>] = str[i];<br>            &#125;<br>            <span class="hljs-built_in">sort</span>(tmp1.<span class="hljs-built_in">begin</span>(), tmp1.<span class="hljs-built_in">end</span>());<br>            <span class="hljs-built_in">sort</span>(tmp2.<span class="hljs-built_in">begin</span>(), tmp2.<span class="hljs-built_in">end</span>());<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) cout &lt;&lt;  tmp2[i / <span class="hljs-number">2</span>];<br>                <span class="hljs-keyword">else</span> cout &lt;&lt; tmp1[(i + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>];<br>            &#125;<br>            cout &lt;&lt; endl;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">sort</span>(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">end</span>());<br>            cout &lt;&lt; str &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Divisor-Chain"><a href="#C-Divisor-Chain" class="headerlink" title="C. Divisor Chain"></a>C. Divisor Chain</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>给出一个初始值，每次可以减去它的整除数，直到其变成 $1$，给出一条合理的整除数路径，要求其中 $1$ 至多出现两次</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>首先第一反应就是偶数的一半，因为这样一定可以快速减少。但是免不了出现大量的奇数，导致很容易撞上多个 $1$ 的情况</p><p>由于实际上是减法，所以理论上一个偶数不断的减去偶数，那么肯定还是偶数。所以可以让初始值根据情况先减去 $1$，变成偶数，然后不断的减去偶数，最后变成 $2$ 了之后，再减去 $1$ 变成 $1$</p><p>之后就需要不断的找到可以作为整除数的偶数，当然首先 $2$ 肯定可以，毕竟 $2$ 一定是任何偶数的除数，但是只用 $2$ 的话又太多了，所以还得用大一点的。这就让人很容易想到 $2^x$。</p><p>从二进制的角度看，实际上任何一个值都可以被它的 <code>lowbit</code> 整除，不断的减去 <code>lowbit</code>，似乎就符合预期了。再只剩下最后一个 bit 位后，再持续减去 <code>lowbit / 2</code> 就可以实现不断减少</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> lb = [&amp;](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> x &amp; -x; &#125;;<br><br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        ans.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">1000</span>);<br><br>        ans.<span class="hljs-built_in">push_back</span>(n);<br>        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> tmp = <span class="hljs-built_in">lb</span>(n);<br>            <span class="hljs-keyword">if</span> (tmp != n) n -= tmp;<br>            <span class="hljs-keyword">else</span> n -= tmp &gt;&gt; <span class="hljs-number">1</span>;<br>            ans.<span class="hljs-built_in">push_back</span>(n);<br>        &#125;<br><br>        cout &lt;&lt; ans.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ans.<span class="hljs-built_in">size</span>(); ++i) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == ans.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Matrix-Cascade"><a href="#D-Matrix-Cascade" class="headerlink" title="D. Matrix Cascade"></a>D. Matrix Cascade</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个 $01$ 矩阵，每次可以选择一个位置，然后以这个位置作为三角形的顶点，向下所有三角形以内的的都进行翻转，问最少几次操作可以把这个矩阵都变成 $0$</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>想办法维护好下一行有哪些是被翻转了的，奇数次翻转才有意义，题目其实不难</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: data) item.<span class="hljs-built_in">reserve</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: data) cin &gt;&gt; item;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">l</span><span class="hljs-params">(n)</span>, <span class="hljs-title">r</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> flag = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                flag = (l[j] + r[j]) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? flag : !flag;<br>                <span class="hljs-keyword">if</span> (flag == (data[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    l[j]++;<br>                    <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; n) r[j + <span class="hljs-number">1</span>]++;<br>                    flag = !flag;<br>                    ans++;<br>                &#125;<br>            &#125;<br>            l[<span class="hljs-number">0</span>] += l[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; n - <span class="hljs-number">1</span>; ++j) l[j] = l[j + <span class="hljs-number">1</span>];<br>            l[n - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n - <span class="hljs-number">1</span>; j &gt; <span class="hljs-number">0</span>; --j) r[j] = r[j - <span class="hljs-number">1</span>];<br>            r[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        &#125;<br><br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="E-Guess-Game"><a href="#E-Guess-Game" class="headerlink" title="E. Guess Game"></a>E. Guess Game</h1><h2 id="大致题意-4"><a href="#大致题意-4" class="headerlink" title="大致题意"></a>大致题意</h2><p>Alice、Bob、Carol 玩游戏</p><p>首先有一个数组，仅 Carol 可见，然后 Carol 从中随机选出两个值 $x, y$，可以相同位置</p><p>Carol 将这两个值进行 OR 计算，计算后得到 $z$，然后将 $x, z$ 给 Alice 看，$y, z$ 给 Bob 看</p><p>然后 Alice 和 Bob 轮流猜测 $x &gt; y$ 还是 $x &lt; y$ 还是 $x = y$。若不确定，可以选择不知道，如果能够确定，那么一定需要答出来</p><p>问期望的猜测次数是多少</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>首先要理清楚，为什么回答不知道反而可以确定。比较好的是，题目中已经给出了比较详细的说明。这里也给一个例子</p><blockquote><p>例如 $x = 2, y = 3$，那么 Alice 可以拿到 $x = 2, z = 3$ 而 Bob 拿到的是 $y = 3, z = 3$。<br>那么此时，Alice 可以知道，Bob 只有可能是 $3, 1$ 其中一个，故判断不出来，Alice 只能回复不确定<br>轮到 Bob 的时候，Bob 知道 Alice 可以是 $3, 2, 1, 0$ 中任意一个。但是 Alice 回复不知道，对于 Bob 而言，如果 Alice 是 $1, 0$ 的话，当她看到 $z = 3$，说明 Bob 至少为 $2$，故 Alice 应该可以确定，故可以排除掉这两个，所以 Alice 可以是 $3, 2$ 其中一个，但是还是不确定是否是相同还是 Alice 的更小，故也回复不知道<br>再轮到 Alice 了，如果 Bob 无法判断的话，那么 Bob 一定不是 $1$，理由同上了。故此时 Alice 才可以确定 Bob 一定是 $3$，那么就可以确定了<br>综上，需要 3 轮</p></blockquote><p>这道题因为涉及到 OR 运算，所以很自然从二进制角度考虑问题，二进制的比较，无非就是从最高的 bit 位开始，谁先不是 1 了，谁就小了。</p><p>从 OR 运算考虑，若“我”拿到的那个值某一个 bit 位是 <code>0</code>，但是 OR 的结果是 <code>1</code>，那么显然，对方这一位是 <code>1</code>。同理，若 OR 的结果为 <code>0</code>，那么对方和我一样都是 <code>0</code>。问题就在“我”和 OR 的结果都是 <code>1</code> 的那些 bit 位。这个时候我并不确定对方是否是 <code>1</code>，这也是需要多轮博弈的地方。</p><p>如果这两个选择的值，在某个 bit 位之前都是相同的，且通过一段博弈之后相互确认相同了，但是在这个 bit 位下是是不同的，即一个为 <code>0</code>，一个是 <code>1</code>。那么对于那个为 <code>0</code> 的而言，必然可以立刻回答出答案，而那个为 <code>1</code> 的则仍然不确定，所以此时需要再加上 $1, 2$ 次判定，这取决于谁先回答。</p><p>而对于前面相同的部分，若为 <code>0</code> 的，不用猜疑也能知道对方的情况，故可以跳过，不需要猜，而为 <code>1</code> 的部分，则需要进行一次不确定的回答，才可以确认对方也是 <code>1</code>。注意，这里只需要一次回答，就可以让双方都知道对方那一位是 <code>1</code> 了。如果不确定，可以将上面的 case 反过来，让 Bob 先猜，则可以理解原因了。</p><p>综上，给出两个数字，这两个数字要猜需要的轮次就是：(第一个不同的位置中，<code>0</code> 先回答 ? $0$ : $1$) + 不同的位置前有多少个 <code>1</code></p><p>而因为要计算整个数列的情况，所以可以考虑建一棵 01字典树，然后在树上计算。树上每个节点表示如果当前节点就是那个不一样的位置，那么需要多少轮。结果就是：(当前节点上面为 1 的节点数量 <em> 2 + 1) </em> 当前节点为 <code>0</code> 的数量 * 当前节点为 <code>1</code> 的数量</p><p>需要考虑一下如果数字相同的情况，这里就不再详细说明了</p><h2 id="AC-code-4"><a href="#AC-code-4" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> cnt, zero, one;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, mod = <span class="hljs-number">998244353</span>;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;node&gt; <span class="hljs-title">tree</span><span class="hljs-params">(n * <span class="hljs-number">50</span>)</span></span>;<br>        <span class="hljs-type">int</span> mx = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">auto</span> newNode = [&amp;]() &#123;<br>            tree[mx].cnt = <span class="hljs-number">0</span>;<br>            tree[mx].zero = <span class="hljs-number">-1</span>;<br>            tree[mx].one = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">return</span> mx++;<br>        &#125;;<br><br>        <span class="hljs-type">int</span> root = <span class="hljs-built_in">newNode</span>();<br>        <span class="hljs-keyword">auto</span> add = [&amp;](<span class="hljs-type">int</span> x) &#123;<br>            <span class="hljs-type">int</span> cur = root;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">31</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>                <span class="hljs-keyword">if</span> (x &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) cur = tree[cur].one == <span class="hljs-number">-1</span> ? tree[cur].one = <span class="hljs-built_in">newNode</span>() : tree[cur].one;<br>                <span class="hljs-keyword">else</span> cur = tree[cur].zero == <span class="hljs-number">-1</span> ? tree[cur].zero = <span class="hljs-built_in">newNode</span>() : tree[cur].zero;<br>                tree[cur].cnt++;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            <span class="hljs-built_in">add</span>(tmp);<br>        &#125;<br><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, total = n * n;<br>        function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> cur, <span class="hljs-type">int</span> deep) &#123;<br>            <span class="hljs-keyword">if</span> (tree[cur].zero == <span class="hljs-number">-1</span> &amp;&amp; tree[cur].one == <span class="hljs-number">-1</span>) &#123;<br>                ans += deep * tree[cur].cnt * tree[cur].cnt;<br>                ans %= mod;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (tree[cur].zero == <span class="hljs-number">-1</span>) <span class="hljs-built_in">dfs</span>(tree[cur].one, deep + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tree[cur].one == <span class="hljs-number">-1</span>) <span class="hljs-built_in">dfs</span>(tree[cur].zero, deep);<br>            <span class="hljs-keyword">else</span> &#123;<br>                ans += (<span class="hljs-number">2</span> * deep + <span class="hljs-number">1</span>) * tree[tree[cur].one].cnt * tree[tree[cur].zero].cnt;<br>                ans %= mod;<br>                <span class="hljs-built_in">dfs</span>(tree[cur].one, deep + <span class="hljs-number">1</span>);<br>                <span class="hljs-built_in">dfs</span>(tree[cur].zero, deep);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-keyword">auto</span> qp = [&amp;](<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123;<br>            <span class="hljs-keyword">if</span> (b &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0LL</span>;<br>            <span class="hljs-type">int</span> ret = <span class="hljs-number">1</span>;<br>            a %= mod;<br>            <span class="hljs-keyword">while</span> (b) &#123;<br>                <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) ret = (ret * a) % mod;<br>                b &gt;&gt;= <span class="hljs-number">1</span>;<br>                a = (a * a) % mod;<br>            &#125;<br>            <span class="hljs-keyword">return</span> ret;<br>        &#125;;<br>        <span class="hljs-keyword">auto</span> inv = [&amp;](<span class="hljs-type">int</span> a) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">qp</span>(a, mod - <span class="hljs-number">2</span>); &#125;;<br><br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        cout &lt;&lt; (ans * <span class="hljs-built_in">inv</span>(total) % mod) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 894 (Div. 3)</title>
    <link href="/2023/08/25/acm/codeforces/CodeforcesRound894/"/>
    <url>/2023/08/25/acm/codeforces/CodeforcesRound894/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Gift-Carpet"><a href="#A-Gift-Carpet" class="headerlink" title="A. Gift Carpet"></a>A. Gift Carpet</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>从字符串矩阵中依次找出四列，满足依次包含 “vika” 四个字符</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>简单题，不过多赘述</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, m;<br>        cin &gt;&gt; n &gt;&gt; m;<br>        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item : data) item.<span class="hljs-built_in">reserve</span>(m);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item : data) cin &gt;&gt; item;<br><br>        string vika = <span class="hljs-string">&quot;vika&quot;</span>;<br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m &amp;&amp; cur &lt; vika.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (data[j][i] == vika[cur]) &#123;<br>                    cur++;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; (cur == vika.<span class="hljs-built_in">size</span>() ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Sequence-Game"><a href="#B-Sequence-Game" class="headerlink" title="B. Sequence Game"></a>B. Sequence Game</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个原始的序列，将其中的 $a_0$ 以及 $a_{i - 1} \leq a_i$ 的 $a_i$ 都提取出来给你，问可能的原始序列是什么</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>简单题，如果提取后的某个值不满足上述条件的，在其前面加个 $1$ 就行了</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cin &gt;&gt; data[i];<br><br>        <span class="hljs-type">int</span> add = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) add += data[i] &lt; data[i - <span class="hljs-number">1</span>];<br>        cout &lt;&lt; n + add &lt;&lt; endl;<br><br>        cout &lt;&lt; data[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (data[i] &lt; data[i - <span class="hljs-number">1</span>]) cout &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-number">1</span>;<br>            cout &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; data[i];<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Flower-City-Fence"><a href="#C-Flower-City-Fence" class="headerlink" title="C. Flower City Fence"></a>C. Flower City Fence</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>判定将木板排序后，横着和竖着放是否完全相同</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>简答题，第 $i$ 块木板的长度，是否恰好都等于 $\leq i$ 的模板数量</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cin &gt;&gt; data[i];<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-type">int</span> ptr = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">while</span> (ptr &gt;= <span class="hljs-number">0</span> &amp;&amp; data[ptr] &lt;= i) ptr--;<br>            <span class="hljs-keyword">if</span> (data[i] != ptr + <span class="hljs-number">1</span>) &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        cout &lt;&lt; (flag ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Ice-Cream-Balls"><a href="#D-Ice-Cream-Balls" class="headerlink" title="D. Ice Cream Balls"></a>D. Ice Cream Balls</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>制作出恰好 $n$ 个不同的包含两个冰球的冰淇淋，需要多少个冰球（同时制作，两个冰淇淋之间不共用冰球）</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>本题要求的恰好制作出，从最优方案上，肯定是不同的冰球更好，可以得到 $\frac{n \times (n - 1)}{2}$ 种冰淇淋，但是这样难以凑到恰好</p><p>通过上面的方案逼近答案后，再加一些重复的冰球，由于需要不同的冰淇淋，所以每种冰球的数量不能超过 $2$ 个，否则是溢出无意义的，不会带来更多方案</p><p>而每增加一个额外的重复冰球，仅能带来一种方案，即类似 ${1, 1}$ 这种重复冰球的方案。所以只需要一个简单的减法就行了</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, mid;<br>        cin &gt;&gt; n;<br>        mid = (<span class="hljs-type">int</span>)<span class="hljs-built_in">sqrt</span>(n * <span class="hljs-number">2</span>);<br>        <span class="hljs-type">int</span> ans = LONG_LONG_MAX;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-built_in">max</span>(<span class="hljs-number">2LL</span>, mid - <span class="hljs-number">10</span>); i &lt; mid + <span class="hljs-number">10</span>; ++i) <span class="hljs-keyword">if</span> (i * (i - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> &lt;= n)<br>            ans = <span class="hljs-built_in">min</span>(ans, i + n - (i * (i - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>));<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="E-Kolya-and-Movie-Theatre"><a href="#E-Kolya-and-Movie-Theatre" class="headerlink" title="E. Kolya and Movie Theatre"></a>E. Kolya and Movie Theatre</h1><h2 id="大致题意-4"><a href="#大致题意-4" class="headerlink" title="大致题意"></a>大致题意</h2><p>在 $n$ 天内选出 $m$ 天，其中每一天能够拿到一定的分数，还需要扣除任意两个选出的天之间的分数差（默认选出第 0 天），分数差仅取决于天数差，问最大能拿到多少分</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>这道题第一眼以为是需要 dp</p><p>但是仔细读题，会发现其实扣除的分数差就是最后选出的那一天的 $index$，因为恰好把所有区间加上了</p><p>那么就变得很简单了，只需要计算到达每天的位置，最大的 $m$ 个分数的值是哪些，用个堆就行了</p><h2 id="AC-code-4"><a href="#AC-code-4" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, m, d;<br>        cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, cur = <span class="hljs-number">0</span>;<br>        priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;&gt;&gt; prq;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            cur -= d;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            <span class="hljs-keyword">if</span> (tmp &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-keyword">if</span> (prq.<span class="hljs-built_in">size</span>() &lt; m) &#123;<br>                prq.<span class="hljs-built_in">push</span>(tmp);<br>                cur += tmp;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tmp &gt; prq.<span class="hljs-built_in">top</span>()) &#123;<br>                cur -= prq.<span class="hljs-built_in">top</span>();<br>                cur += tmp;<br>                prq.<span class="hljs-built_in">pop</span>();<br>                prq.<span class="hljs-built_in">push</span>(tmp);<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, cur);<br>        &#125;<br><br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="F-Magic-Will-Save-the-World"><a href="#F-Magic-Will-Save-the-World" class="headerlink" title="F. Magic Will Save the World"></a>F. Magic Will Save the World</h1><h2 id="大致题意-5"><a href="#大致题意-5" class="headerlink" title="大致题意"></a>大致题意</h2><p>有两种魔法，火魔法和水魔法，每种魔法每秒钟都会积攒对应的法力值，使用 $x$ 点法力值可以打败体力低于等于 $x$ 的怪，怪必须一次打死，问最多需要多少时间才能打死所有的怪</p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>题意中很容易看出是一个背包问题，类似均分为两堆，但是这里不是均分，而是有比例分，所以可以分别计算一次，避免出错</p><h2 id="AC-code-5"><a href="#AC-code-5" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> f, w;<br>        cin &gt;&gt; f &gt;&gt; w;<br>        <span class="hljs-type">int</span> n, sum = <span class="hljs-number">0</span>;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cin &gt;&gt; data[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) sum += data[i];<br><br>        <span class="hljs-keyword">if</span> (f &gt;= sum || w &gt;= sum) &#123;<br>            cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> p = (sum + f + w - <span class="hljs-number">1</span>) / (f + w), ans;<br>        &#123;<br>            <span class="hljs-type">int</span> target = f * p;<br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(target + <span class="hljs-number">1</span>)</span></span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = target; j &gt;= data[i]; --j)<br>                    dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - data[i]] + data[i]);<br><br>            <span class="hljs-type">int</span> maxDp = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= target; ++i) maxDp = <span class="hljs-built_in">max</span>(maxDp, dp[i]);<br>            <span class="hljs-keyword">if</span> (sum - maxDp &lt;= p * w) ans = p;<br>            <span class="hljs-keyword">else</span> ans = (sum - maxDp + w - <span class="hljs-number">1</span>) / w;<br>            dp.<span class="hljs-built_in">clear</span>();<br>        &#125;<br><br>        &#123;<br>            <span class="hljs-type">int</span> target = w * p;<br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(target + <span class="hljs-number">1</span>)</span></span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = target; j &gt;= data[i]; --j)<br>                    dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - data[i]] + data[i]);<br><br>            <span class="hljs-type">int</span> maxDp = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= target; ++i) maxDp = <span class="hljs-built_in">max</span>(maxDp, dp[i]);<br>            <span class="hljs-keyword">if</span> (sum - maxDp &lt;= p * f) ans = <span class="hljs-built_in">min</span>(ans, p);<br>            <span class="hljs-keyword">else</span> ans = <span class="hljs-built_in">min</span>(ans, (sum - maxDp + f - <span class="hljs-number">1</span>) / f);<br>            dp.<span class="hljs-built_in">clear</span>();<br>        &#125;<br><br>        cout &lt;&lt; ans &lt;&lt; endl;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="G-The-Great-Equalizer"><a href="#G-The-Great-Equalizer" class="headerlink" title="G. The Great Equalizer"></a>G. The Great Equalizer</h1><h2 id="大致题意-6"><a href="#大致题意-6" class="headerlink" title="大致题意"></a>大致题意</h2><p>每次，将数组排序后，为一个数组中的每个值加上 $n, n - 1, n - 2 \dots, 1$，然后去重，重复，直到只剩下一个值，问最后这个值是什么。</p><p>不直接需要原数组的答案，是依次回答的，每次会修改数组中的值，然后询问，修改操作是继承的</p><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>观察可以得到，最终结果实际上是 $max(a_i) - min(a_i) + max(a_i - a_{i-1}) + min(a_i)$，化简得到 $max(a_i) + max(a_i - a_{i-1})$。只需要维护好这两值即可</p><h2 id="AC-code-6"><a href="#AC-code-6" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item : data) cin &gt;&gt; item;<br><br>        vector&lt;<span class="hljs-type">int</span>&gt; copy = data;<br>        <span class="hljs-built_in">sort</span>(copy.<span class="hljs-built_in">begin</span>(), copy.<span class="hljs-built_in">end</span>());<br><br>        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; dif, cnt;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cnt[data[i]]++;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) dif[copy[i] - copy[i - <span class="hljs-number">1</span>]]++;<br><br>        <span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) total += copy[i] - copy[i - <span class="hljs-number">1</span>];<br><br>        <span class="hljs-type">int</span> q;<br>        cin &gt;&gt; q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; ++i) &#123;<br>            <span class="hljs-type">int</span> index, x;<br>            cin &gt;&gt; index &gt;&gt; x;<br>            <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>                data[<span class="hljs-number">0</span>] = x;<br>                cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> old = data[index - <span class="hljs-number">1</span>];<br><br>            <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> oldIter = cnt.<span class="hljs-built_in">find</span>(old);<br>            <span class="hljs-type">int</span> al, ar, am, bl, br, bm;<br>            <span class="hljs-keyword">if</span> (oldIter-&gt;second &gt; <span class="hljs-number">1</span>) &#123;<br>                oldIter-&gt;second--;<br>                bl = br = bm = <span class="hljs-number">0</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> lv, rv;<br>                <span class="hljs-keyword">if</span> (oldIter == cnt.<span class="hljs-built_in">begin</span>()) lv = <span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">auto</span> left = oldIter;<br>                    left--;<br>                    lv = left-&gt;first;<br>                &#125;<br>                <span class="hljs-keyword">auto</span> right = oldIter;<br>                right++;<br>                <span class="hljs-keyword">if</span> (right == cnt.<span class="hljs-built_in">end</span>()) rv = <span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">else</span> rv = right-&gt;first;<br>                bl = lv == <span class="hljs-number">-1</span> ? <span class="hljs-number">0</span> : old - lv;<br>                br = rv == <span class="hljs-number">-1</span> ? <span class="hljs-number">0</span> : rv - old;<br>                bm = lv == <span class="hljs-number">-1</span> || rv == <span class="hljs-number">-1</span> ? <span class="hljs-number">0</span> : bl + br;<br>                cnt.<span class="hljs-built_in">erase</span>(oldIter);<br>            &#125;<br>            data[index - <span class="hljs-number">1</span>] = x;<br><br>            <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> newIter = cnt.<span class="hljs-built_in">upper_bound</span>(x);<br>            <span class="hljs-keyword">if</span> (newIter == cnt.<span class="hljs-built_in">end</span>()) &#123;<br>                ar = am = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">auto</span> iter = newIter;<br>                iter--;<br>                al = x - iter-&gt;first;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (newIter == cnt.<span class="hljs-built_in">begin</span>()) &#123;<br>                al = am = <span class="hljs-number">0</span>;<br>                ar = newIter-&gt;first - x;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> lv, rv = newIter-&gt;first;<br>                <span class="hljs-keyword">auto</span> tmp = newIter;<br>                --tmp;<br>                lv = tmp-&gt;first;<br>                al = x - lv;<br>                ar = rv - x;<br>                am = rv - lv;<br>            &#125;<br>            cnt[x]++;<br><br>            <span class="hljs-keyword">auto</span> del = [&amp;](<span class="hljs-type">int</span> t) &#123;<br>                <span class="hljs-keyword">auto</span> iter = dif.<span class="hljs-built_in">find</span>(t);<br>                <span class="hljs-keyword">if</span> (iter == dif.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span>;<br>                <span class="hljs-keyword">if</span> (iter-&gt;second == <span class="hljs-number">1</span>) dif.<span class="hljs-built_in">erase</span>(iter);<br>                <span class="hljs-keyword">else</span> iter-&gt;second--;<br>            &#125;;<br><br>            dif[al]++;<br>            dif[ar]++;<br>            dif[bm]++;<br>            <span class="hljs-built_in">del</span>(bl);<br>            <span class="hljs-built_in">del</span>(br);<br>            <span class="hljs-built_in">del</span>(am);<br><br>            cout &lt;&lt; cnt.<span class="hljs-built_in">rbegin</span>()-&gt;first + dif.<span class="hljs-built_in">rbegin</span>()-&gt;first &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 888 (Div. 3)</title>
    <link href="/2023/08/20/acm/codeforces/CodeforcesRound888/"/>
    <url>/2023/08/20/acm/codeforces/CodeforcesRound888/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Escalator-Conversations"><a href="#A-Escalator-Conversations" class="headerlink" title="A. Escalator Conversations"></a>A. Escalator Conversations</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个 $n$ 级台阶，每级 $h$ 高，有 $t$ 个人，问高为 $H$ 的一个人，通过在台阶上的方式，可以和哪些人等高</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>简单题，差值 mod 一下恰好是台阶的倍数，且倍数恰好小于台阶数量，那么就可以了</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, m, k, h, ans = <span class="hljs-number">0</span>;<br>        cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; h;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            <span class="hljs-type">int</span> dif = <span class="hljs-built_in">abs</span>(tmp - h);<br>            <span class="hljs-keyword">if</span> (dif == <span class="hljs-number">0</span> || dif % k) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (dif / k &lt; m) ans++;<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Parity-Sort"><a href="#B-Parity-Sort" class="headerlink" title="B. Parity Sort"></a>B. Parity Sort</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有个数组，允许无限次交换两个位置，要求是交换的那两个数字奇偶性必须一致，问最终是否能有序</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>简单题，每个位置最开始是奇数，那么无论怎么换都是奇数，且任何奇数都可以换到这个位置，偶数同理，故所以只需要排序后的每个位置的奇偶性保持即可</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data1</span><span class="hljs-params">(n)</span>, <span class="hljs-title">data2</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cin &gt;&gt; data1[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) data2[i] = data1[i];<br>        <span class="hljs-built_in">sort</span>(data2.<span class="hljs-built_in">begin</span>(), data2.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">bool</span> check = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (data1[i] % <span class="hljs-number">2</span> != data2[i] % <span class="hljs-number">2</span>) check = <span class="hljs-literal">true</span>;<br>        cout &lt;&lt; (check ? <span class="hljs-string">&quot;NO&quot;</span> : <span class="hljs-string">&quot;YES&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Tiles-Comeback"><a href="#C-Tiles-Comeback" class="headerlink" title="C. Tiles Comeback"></a>C. Tiles Comeback</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>问能否在一个数列中找到一个子序列，满足</p><ul><li>长度恰好是 $k$ 的倍数</li><li>将序列每 $k$ 个一段，分成 $x$ 段，每一段内的数字相同</li><li>第一个和最后一个必须在序列中</li></ul><p>问是否存在即可</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>简单题，分两种情况，第一种，如果开头和结尾的数字相同。那能找到 $k$ 个和首尾相同的数字，直接选出这些数字即可</p><p>如果不同，那么只需要和首相同找出 $k$ 个，然后在这 $k$ 个之后再找出 $k$ 个和尾相同的即可</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cin &gt;&gt; data[i];<br>        <span class="hljs-keyword">if</span> (data.<span class="hljs-built_in">front</span>() == data.<span class="hljs-built_in">back</span>()) &#123;<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cnt += data[i] == data.<span class="hljs-built_in">front</span>();<br>            cout &lt;&lt; (cnt &gt;= k ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> cnt1 = <span class="hljs-number">0</span>, cnt2 = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>                <span class="hljs-keyword">if</span> (cnt1 &gt;= k) cnt2 += data[i] == data.<span class="hljs-built_in">back</span>();<br>                <span class="hljs-keyword">else</span> cnt1 += data[i] == data.<span class="hljs-built_in">front</span>();<br>            cout &lt;&lt; (cnt1 &gt;= k &amp;&amp; cnt2 &gt;= k ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Prefix-Permutation-Sums"><a href="#D-Prefix-Permutation-Sums" class="headerlink" title="D. Prefix Permutation Sums"></a>D. Prefix Permutation Sums</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>给你一个丢了一个数字的前缀和，原数组为 $n$ 的排列，问是否存在可能的原始串</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>前缀和相减就是原始数字了，直接算出所有的前缀差，找出重复的，和没有出现的，算一算加起来是否相同。或者只有一个没有出现的，恰好是最后那个值丢了的情况</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        set&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) st.<span class="hljs-built_in">insert</span>(i + <span class="hljs-number">1</span>);<br><br>        <span class="hljs-type">int</span> last = <span class="hljs-number">0</span>, out = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            <span class="hljs-keyword">auto</span> iter = st.<span class="hljs-built_in">find</span>(tmp - last);<br>            <span class="hljs-keyword">if</span> (iter == st.<span class="hljs-built_in">end</span>()) out = tmp - last;<br>            <span class="hljs-keyword">else</span> st.<span class="hljs-built_in">erase</span>(iter);<br>            last = tmp;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span> &amp;&amp; out == <span class="hljs-number">-1</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">size</span>() != <span class="hljs-number">2</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> a, b;<br>        a = *st.<span class="hljs-built_in">begin</span>();<br>        b = *(++st.<span class="hljs-built_in">begin</span>());<br>        cout &lt;&lt; (a + b == out ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="E-Nastya-and-Potions"><a href="#E-Nastya-and-Potions" class="headerlink" title="E. Nastya and Potions"></a>E. Nastya and Potions</h1><h2 id="大致题意-4"><a href="#大致题意-4" class="headerlink" title="大致题意"></a>大致题意</h2><p>有 $n$ 种药品，其中部分药品可以通过其他药品合成得到，每种药品的价格已知，且部分药品有库存，即免费，问得到每一种药品需要多少钱</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>其实这是一个 Dag 图，拓扑一下，然后不断计算更小的值，替换掉原来的价格即可</p><h2 id="AC-code-4"><a href="#AC-code-4" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cost</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) cin &gt;&gt; cost[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            cost[tmp] = <span class="hljs-number">0</span>;<br>        &#125;<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">from</span>(n + <span class="hljs-number">1</span>);<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">to</span>(n + <span class="hljs-number">1</span>);<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">in</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-type">int</span> cnt;<br>            cin &gt;&gt; cnt;<br>            <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(i);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cnt; ++j) &#123;<br>                <span class="hljs-type">int</span> tmp;<br>                cin &gt;&gt; tmp;<br>                from[i].<span class="hljs-built_in">push_back</span>(tmp);<br>                to[tmp].<span class="hljs-built_in">push_back</span>(i);<br>                in[i]++;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> cur = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (!from[cur].<span class="hljs-built_in">empty</span>()) &#123;<br>                <span class="hljs-type">int</span> c = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: from[cur]) c += cost[item];<br>                cost[cur] = <span class="hljs-built_in">min</span>(cost[cur], c);<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item : to[cur])<br>                <span class="hljs-keyword">if</span> (--in[item] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(item);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) cout &lt;&lt; cost[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="F-Lisa-and-the-Martians"><a href="#F-Lisa-and-the-Martians" class="headerlink" title="F. Lisa and the Martians"></a>F. Lisa and the Martians</h1><h2 id="大致题意-5"><a href="#大致题意-5" class="headerlink" title="大致题意"></a>大致题意</h2><p>给定一个 $k$，然后给出 $n$ 个数字，保证每个数字都是 $[1, 2^k)$ 内，需要找到一个值 $x$，并取出这些数字中的两个 $a, b$，计算 $(a \oplus x) \&amp; (b \oplus x)$ 的最大值</p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>根据公式，我们可以推导出：若 $a$ 和 $b$ 在二进制上重合度越大，则结果越大，相同即可以得到 $1$，否则这个 bit 只能是 $0$。而其中，高位的价值最高，故需要先满足高位相同</p><p>这时可以想到 01字典树，然后从根开始往下 dfs 找，找到重合度尽可能大的，然后再计算分歧部分的代价。</p><p>定义 01字典树的结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> zero = <span class="hljs-number">-1</span>, one = <span class="hljs-number">-1</span>, cnt = <span class="hljs-number">0</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; index;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中 <code>zero</code> 表示接下来为 <code>0</code> 的字典树节点，同样 <code>one</code> 为接下来为 <code>1</code> 的字典树节点。<code>cnt</code> 表示这个节点下有多少值，<code>index</code> 则是为了求解，需要保留下数值原始的下标</p><p>比如当前正在某个 01字典树的节点上，已知下面的 <code>0</code> 节点下至少有两个值，那么就可以考虑更具体的情况，<code>1</code> 也相同，此时并不需要考虑两个值分散在两边的可能，因为这样的话，下个 bit 就只能得到 <code>0</code>，而相同可以得到 <code>1</code>，故不需要考虑分散的情况</p><p>如果某个节点下面只有一个值，那就毫无意义，不需要考虑下去了，理论上也不应该走到这种分支</p><p>如果某个节点上恰好有两个值，且左边有一个右边有一个，这个时候是分歧点，故可以在此节点取出下面的那两个值，然后计算结果</p><h2 id="AC-code-5"><a href="#AC-code-5" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>            <span class="hljs-type">int</span> zero = <span class="hljs-number">-1</span>, one = <span class="hljs-number">-1</span>, cnt = <span class="hljs-number">0</span>;<br>            vector&lt;<span class="hljs-type">int</span>&gt; index;<br>        &#125;;<br><br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        <span class="hljs-function">vector&lt;node&gt; <span class="hljs-title">tree</span><span class="hljs-params">(n * <span class="hljs-number">40</span>)</span></span>;<br>        <span class="hljs-type">int</span> rNode = <span class="hljs-number">1</span>, root = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">auto</span> newNode = [&amp;]() &#123;<br>            <span class="hljs-keyword">return</span> rNode++;<br>        &#125;;<br>        <span class="hljs-keyword">auto</span> add = [&amp;](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> index) &#123;<br>            tree[root].cnt++;<br>            <span class="hljs-type">int</span> cur = root;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>                <span class="hljs-keyword">if</span> (x &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) &#123;<br>                    cur = tree[cur].one == <span class="hljs-number">-1</span> ? tree[cur].one = <span class="hljs-built_in">newNode</span>() : tree[cur].one;<br>                    tree[cur].cnt++;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    cur = tree[cur].zero == <span class="hljs-number">-1</span> ? tree[cur].zero = <span class="hljs-built_in">newNode</span>() : tree[cur].zero;<br>                    tree[cur].cnt++;<br>                &#125;<br>            &#125;<br>            tree[cur].index.<span class="hljs-built_in">push_back</span>(index);<br>        &#125;;<br><br>        <span class="hljs-keyword">auto</span> find = [&amp;](<span class="hljs-type">int</span> cur, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> deep) &#123;<br>            <span class="hljs-keyword">while</span> (cur != <span class="hljs-number">-1</span>) &#123;<br>                <span class="hljs-keyword">if</span> (tree[cur].zero == <span class="hljs-number">-1</span> &amp;&amp; tree[cur].one == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> tree[cur].index[<span class="hljs-number">0</span>];<br>                <span class="hljs-keyword">if</span> (tree[cur].zero == <span class="hljs-number">-1</span>) &#123;<br>                    x |= <span class="hljs-number">1</span> &lt;&lt; deep;<br>                    cur = tree[cur].one;<br>                &#125; <span class="hljs-keyword">else</span> cur = tree[cur].zero;<br>                deep--;<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;;<br><br>        <span class="hljs-type">int</span> res = INT_MIN, resX, l, r;<br>        function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> cur, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> deep) &#123;<br>            <span class="hljs-keyword">if</span> (tree[cur].zero == <span class="hljs-number">-1</span> &amp;&amp; tree[cur].one == <span class="hljs-number">-1</span>) &#123;<br>                <span class="hljs-built_in">assert</span>(tree[cur].cnt &gt;= <span class="hljs-number">2</span> &amp;&amp; tree[cur].index.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">2</span>);<br><br>                res = (<span class="hljs-number">1</span> &lt;&lt; k) - <span class="hljs-number">1</span>;<br>                l = tree[cur].index[<span class="hljs-number">0</span>];<br>                r = tree[cur].index[<span class="hljs-number">1</span>];<br>                resX = x;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (tree[cur].zero == <span class="hljs-number">-1</span>) <span class="hljs-built_in">dfs</span>(tree[cur].one, x, deep - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tree[cur].one == <span class="hljs-number">-1</span>) <span class="hljs-built_in">dfs</span>(tree[cur].zero, x | (<span class="hljs-number">1</span> &lt;&lt; deep), deep - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (tree[tree[cur].zero].cnt &gt;= <span class="hljs-number">2</span>) <span class="hljs-built_in">dfs</span>(tree[cur].zero, x | (<span class="hljs-number">1</span> &lt;&lt; deep), deep - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (tree[tree[cur].one].cnt &gt;= <span class="hljs-number">2</span>) <span class="hljs-built_in">dfs</span>(tree[cur].one, x, deep - <span class="hljs-number">1</span>);<br><br>                <span class="hljs-keyword">if</span> (tree[tree[cur].zero].cnt == <span class="hljs-number">1</span> &amp;&amp; tree[tree[cur].one].cnt == <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-type">int</span> lv = <span class="hljs-number">0</span>, rv = <span class="hljs-number">1</span> &lt;&lt; deep;<br>                    <span class="hljs-type">int</span> li = <span class="hljs-built_in">find</span>(tree[cur].zero, lv, deep - <span class="hljs-number">1</span>);<br>                    <span class="hljs-type">int</span> ri = <span class="hljs-built_in">find</span>(tree[cur].one, rv, deep - <span class="hljs-number">1</span>);<br>                    <span class="hljs-type">int</span> tmp = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k - <span class="hljs-number">1</span>; i &gt; deep; --i) tmp |= <span class="hljs-number">1</span> &lt;&lt; i;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = deep; i &gt;= <span class="hljs-number">0</span>; --i) <span class="hljs-keyword">if</span> ((lv &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) == (rv &amp; (<span class="hljs-number">1</span> &lt;&lt; i))) &#123;<br>                        tmp |= <span class="hljs-number">1</span> &lt;&lt; i;<br>                        x |= (lv &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span> &lt;&lt; i;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (tmp &gt; res) &#123;<br>                        l = li;<br>                        r = ri;<br>                        resX = x;<br>                        res = tmp;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            <span class="hljs-built_in">add</span>(tmp, i + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>);<br>        cout &lt;&lt; l &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; r &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; resX &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="G-Vlad-and-the-Mountains"><a href="#G-Vlad-and-the-Mountains" class="headerlink" title="G. Vlad and the Mountains"></a>G. Vlad and the Mountains</h1><h2 id="大致题意-6"><a href="#大致题意-6" class="headerlink" title="大致题意"></a>大致题意</h2><p>有 $n$ 座山，山之间有桥，从 $a$ 山到 $b$ 山的代价为 $h_b - h_a$，注意，可以为负数。代价超过上限则不能走</p><p>询问 $q$ 次，问能否从 $a$ 山到 $b$ 山，在能够消耗最大 $e$ 的代价情况下</p><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>首先不能在线做，只能离线，毕竟在线就只剩下预处理求出任意两点的代价了</p><p>题意解析也很简单的，就是需要找到一条路径，满足最大值小于等于 $h_a + e$ 即可</p><p>询问是否可达，很容易想到了并查集去做，毕竟在一个集合里就是可达</p><p>接下来，我们根据海拔的高低进行排序，然后从低海拔开始，将山加入集合，并将可以使用的边加入并查集</p><p>因为每个询问能够到达最大高度是确定的，所以同时可以遍历所有询问，若最大高度已经到达了，下一个加入的山会超出最大高度了，此时这两个山还没有在一个集合中，那么必然不可达</p><h2 id="AC-code-6"><a href="#AC-code-6" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>        <span class="hljs-type">int</span> v, n;<br>    &#125;;<br><br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, m;<br>        cin &gt;&gt; n &gt;&gt; m;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">h</span>(n + <span class="hljs-number">1</span>);<br>        <span class="hljs-function">vector&lt;node&gt; <span class="hljs-title">edge</span><span class="hljs-params">(m)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">head</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) cin &gt;&gt; h[i].first;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) h[i].second = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-type">int</span> u, v;<br>            cin &gt;&gt; u &gt;&gt; v;<br>            <span class="hljs-keyword">if</span> (h[u].first &gt; h[v].first) &#123;<br>                edge[i] = &#123;v, head[u]&#125;;<br>                head[u] = i;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                edge[i] = &#123;u, head[v]&#125;;<br>                head[v] = i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> q;<br>        cin &gt;&gt; q;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">query</span> &#123;<br>            <span class="hljs-type">int</span> u, v, e, i;<br>        &#125;;<br>        <span class="hljs-function">vector&lt;query&gt; <span class="hljs-title">ql</span><span class="hljs-params">(q)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(q)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; ++i) cin &gt;&gt; ql[i].u &gt;&gt; ql[i].v &gt;&gt; ql[i].e;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; ++i) ql[i].e += h[ql[i].u].first;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; ++i) ql[i].i = i;<br><br>        <span class="hljs-built_in">sort</span>(h.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, h.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">sort</span>(ql.<span class="hljs-built_in">begin</span>(), ql.<span class="hljs-built_in">end</span>(), [&amp;](<span class="hljs-type">const</span> query &amp;a, <span class="hljs-type">const</span> query &amp;b) &#123; <span class="hljs-keyword">return</span> a.e &lt; b.e; &#125;);<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fa</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; fa.<span class="hljs-built_in">size</span>(); ++i) fa[i] = i;<br>        function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>)&gt; find = [&amp;](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> fa[x] == x ? x : fa[x] = <span class="hljs-built_in">find</span>(fa[x]); &#125;;<br>        <span class="hljs-keyword">auto</span> join = [&amp;](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;<br>            <span class="hljs-type">int</span> rx = <span class="hljs-built_in">find</span>(x), ry = <span class="hljs-built_in">find</span>(y);<br>            <span class="hljs-keyword">if</span> (rx == ry) <span class="hljs-keyword">return</span>;<br>            fa[rx] = ry;<br>        &#125;;<br><br>        <span class="hljs-type">int</span> last = <span class="hljs-number">0</span>, qPtr = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (last != h[i].first) &#123;<br>                <span class="hljs-keyword">while</span> (qPtr &lt; q &amp;&amp; ql[qPtr].e &lt; h[i].first) &#123;<br>                    <span class="hljs-keyword">auto</span> &amp;que = ql[qPtr];<br>                    <span class="hljs-type">int</span> ru = <span class="hljs-built_in">find</span>(que.u), rv = <span class="hljs-built_in">find</span>(que.v);<br>                    ans[que.i] = ru == rv;<br>                    qPtr++;<br>                &#125;<br>            &#125;<br>            last = h[i].first;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = head[h[i].second]; j != <span class="hljs-number">-1</span>; j = edge[j].n) <span class="hljs-built_in">join</span>(h[i].second, edge[j].v);<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (qPtr &lt; q) &#123;<br>            <span class="hljs-keyword">auto</span> &amp;que = ql[qPtr];<br>            <span class="hljs-type">int</span> ru = <span class="hljs-built_in">find</span>(que.u), rv = <span class="hljs-built_in">find</span>(que.v);<br>            ans[que.i] = ru == rv &amp;&amp; ql[qPtr].e &gt;= last;<br>            qPtr++;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> item: ans) cout &lt;&lt; (item ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Educational Codeforces Round#153 (Div. 2)</title>
    <link href="/2023/08/19/acm/codeforces/EducationalCodeforcesRound153/"/>
    <url>/2023/08/19/acm/codeforces/EducationalCodeforcesRound153/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Not-a-Substring"><a href="#A-Not-a-Substring" class="headerlink" title="A. Not a Substring"></a>A. Not a Substring</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>需要构建一个只有小括号构成的字符串，既满足括号匹配，同时不存在一个子串等同于给出的一个字符串</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>实际上很简单，只需要取 <code>()()()()</code> 模式 和 <code>(((())))</code> 这两种即可，因为这两种模式的唯一相同的子串就只有一对 <code>()</code>，而若需要一个满足括号匹配的字符串，那么必然存在 <code>()</code>，故这两种模式就可以应对所有情况</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        string str, ans;<br>        cin &gt;&gt; str;<br>        ans.<span class="hljs-built_in">resize</span>(str.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); ++i) ans[i] = <span class="hljs-string">&#x27;(&#x27;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); ++i) ans[i + str.<span class="hljs-built_in">size</span>()] = <span class="hljs-string">&#x27;)&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(ans.<span class="hljs-built_in">c_str</span>(), str.<span class="hljs-built_in">c_str</span>()) == <span class="hljs-literal">nullptr</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>            cout &lt;&lt; ans &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); ++i) ans[i * <span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;(&#x27;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); ++i) ans[i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;)&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(ans.<span class="hljs-built_in">c_str</span>(), str.<span class="hljs-built_in">c_str</span>()) == <span class="hljs-literal">nullptr</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>            cout &lt;&lt; ans &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Fancy-Coins"><a href="#B-Fancy-Coins" class="headerlink" title="B. Fancy Coins"></a>B. Fancy Coins</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有 $a1$ 个 $1$ 元，$a2$ 个 $k$ 元，同时你可以“借来”无限量的 $1$ 元和 $k$ 元，问组成 $m$ 元最多需要借多少硬币</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>简单卡一下边界，多一个 $k$ 元和少一个 $k$ 元的两种情况考虑一下即可，比较简单</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> m, k, a1, a2;<br>        cin &gt;&gt; m &gt;&gt; k &gt;&gt; a2 &gt;&gt; a1;<br>        m -= <span class="hljs-built_in">min</span>(m / k, a1) * k;<br>        <span class="hljs-keyword">if</span> (m &lt;= a2) &#123;<br>            cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> ls = (m - a2) / k;<br>        <span class="hljs-type">int</span> ans = ls + (m - a2 - ls * k);<br>        <span class="hljs-keyword">if</span> (m - (ls + <span class="hljs-number">1</span>) * k &gt;= <span class="hljs-number">0</span>) ans = <span class="hljs-built_in">min</span>(ans, ls + <span class="hljs-number">1</span>);<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Game-on-Permutation"><a href="#C-Game-on-Permutation" class="headerlink" title="C. Game on Permutation"></a>C. Game on Permutation</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组，开始位置可以是任意的一个下标，每次可以移动到当前位置左边的任意一个值小于当前的位置。</p><p>两个人依次操作，谁最后无法进行操作了，谁胜利，问放在哪些位置，可以保证第二个开始操作的胜利</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>假如说我摆放在一个位置，然后可以通过 $3$ 个依次操作达到最终无法移动（例如 $a \rightarrow b \rightarrow c \rightarrow d$），那么此时应该说第二个移动的人胜利</p><p>但是这个操作是可跳过的，因为你可以移动 $3$ 次，那么就必然可以一次移动到底，因为一定也符合题意，那么第一个移动的人为什么要遵循一个个移动呢，他完全可以直接 $a \rightarrow c$，然后第二个操作的人只能移动到 $d$，然后输了游戏</p><p>所以必须卡在一些只能移动一次的地方，否则就有可乘之机。</p><p>那么就必须保证选择的点满足</p><ul><li>大于左边最小的值</li><li>小于左边之前确认的满足条件的点</li></ul><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, ans = <span class="hljs-number">0</span>, curMin = INT_MAX, curMax = INT_MAX;<br>        cin &gt;&gt; n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            <span class="hljs-keyword">if</span> (tmp &lt; curMin) curMin = tmp;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tmp &gt; curMin &amp;&amp; tmp &lt; curMax) &#123;<br>                ans++;<br>                curMax = tmp;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 893 (Div. 2)</title>
    <link href="/2023/08/19/acm/codeforces/CodeforcesRound893/"/>
    <url>/2023/08/19/acm/codeforces/CodeforcesRound893/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Buttons"><a href="#A-Buttons" class="headerlink" title="A. Buttons"></a>A. Buttons</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有 $1, 2, 3$ 三种按钮，其中 Anna 只能按 $1, 3$ 两种按钮，而 Katie 只能按 $2, 3$ 两种按钮。每个按钮只能按一次。</p><p>Anna 和 Katie 玩游戏，两人依次按按钮，Anna 先，直到谁没有按钮可以按，谁就输了，问谁会赢</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>明显大家先抢着把 $3$ 按完就行了，因为 Anna 先开始按，所以为偶数则恰好对半分，为奇数则 Anna 多分到一个，然后计算谁按钮多就行了</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        a += (c + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        b += c / <span class="hljs-number">2</span>;<br>        cout &lt;&lt; (a &gt; b ? <span class="hljs-string">&quot;First&quot;</span> : <span class="hljs-string">&quot;Second&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-The-Walkway"><a href="#B-The-Walkway" class="headerlink" title="B. The Walkway"></a>B. The Walkway</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一条路，路上有一些饼干店，饼干店的初始位置都确定，有一个人带着无限数量的饼干，从路的某一端匀速走到另外一端，每隔 $k$ 分钟没有吃饼干的情况下，他会吃掉背包里的一片饼干，如果刚刚遇到了饼干店的情况下，他也会吃掉一片饼干，在同一个时间点不会吃掉超过一片饼干，且在刚刚进入路的时候需要吃一片饼干。</p><p>你可以移除掉一个，最多一个饼干店，问最少只需要吃到多少饼干</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>通过饼干店，可以分割成 $n$ 段，每一段吃掉的饼干数量等于 $\left \lceil \frac{pos_{n} - pos_{n-1}}{t} \right \rceil$，那么对于每一个饼干店 $i$，若其被移除掉，可以带来减少的饼干数量为 $\left \lceil \frac{pos_{i + 1} - pos_{i - 1}}{t} \right \rceil - \left \lceil \frac{pos_{i} - pos_{i - 1}}{t} \right \rceil - \left \lceil \frac{pos_{i + 1} - pos_{i}}{t} \right \rceil$</p><p>所以只需要枚举所有可能被干掉的饼干店，找到能减少的最大值就行了，注意一下，这里输出的最小饼干数量和能满足这个最小饼干数量的饼干店数量，而不是唯一那个位置</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, m, d;<br>        cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(m)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) cin &gt;&gt; data[i];<br><br>        <span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = data[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp = (data[i] - l + d - <span class="hljs-number">1</span>) / d;<br>            tot += tmp;<br>            tmp += (r - data[i] + d - <span class="hljs-number">1</span>) / d;<br>            <span class="hljs-type">int</span> del = (r - l + d - <span class="hljs-number">1</span>) / d;<br>            <span class="hljs-keyword">if</span> (tmp - del &gt; ans) &#123;<br>                cnt = <span class="hljs-number">1</span>;<br>                ans = tmp - del;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tmp - del == ans) cnt++;<br>            l = data[i];<br>            r = i + <span class="hljs-number">2</span> &lt; m ? data[i + <span class="hljs-number">2</span>] : n + <span class="hljs-number">1</span>;<br>        &#125;<br>        tot += (r - data[m - <span class="hljs-number">1</span>] + d - <span class="hljs-number">1</span>) / d;<br>        cout &lt;&lt; tot - ans &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; cnt &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Yet-Another-Permutation-Problem"><a href="#C-Yet-Another-Permutation-Problem" class="headerlink" title="C. Yet Another Permutation Problem"></a>C. Yet Another Permutation Problem</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>给出一个 $n$ 的排列，使得所有相邻两个数的 $GCD$ 的值的种类足够多</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>若相邻两个数字存在 $GCD$，那么必然这个 $GCD$ 小于等于其中的任意一个。而因为恰好是 $n$ 的排列，那么必然此 $GCD$ 的值本身一定存在与序列中。那么如果我直接取每个值以及其两倍的值放在一起，那么必然可以保证这个值可以存在。而且每个值的一半一定唯一，那么就可以得到唯一确认的绑定关系，然后排列即可</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        res.<span class="hljs-built_in">reserve</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (vis[i]) <span class="hljs-keyword">continue</span>;<br>            res.<span class="hljs-built_in">push_back</span>(i);<br>            vis[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-type">int</span> tmp = i * <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">while</span> (tmp &lt;= n) &#123;<br>                vis[tmp] = <span class="hljs-literal">true</span>;<br>                res.<span class="hljs-built_in">push_back</span>(tmp);<br>                tmp *= <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cout &lt;&lt; res[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Trees-and-Segments"><a href="#D-Trees-and-Segments" class="headerlink" title="D. Trees and Segments"></a>D. Trees and Segments</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个长度为 $n$ 的 $01$ 串，允许你翻转其中 $k$ 个，求对于每个 $a \in [1, n]$，求算 $a \times len_0 + len_1$ 的最大值。</p><p>$len_x$ 的指在这个字符串内，最长的一段连续的 $x$ 的长度</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>这道题的难度跃升有点快，确实很难想清楚</p><p>首先考虑最暴力的情况，遍历每种 $a$，遍历所有可能的最长的 $0$ 的左右区间和 $1$ 的左右区间，然后计算是否满足并求解，那么总共需要 $n^6$</p><p>首先校验合法可以通过前缀和的方式预处理，这样就可以少一个 $n$</p><p>再考虑到不同的 $a$ 之和长度有关，而长度最多只有 $n$ 种可能（当 $len_0$ 为 $x$ 的时候，$max(len_1)$ 一定是唯一解），所以也不需要遍历所有 $a$，只需要计算出所有可能，然后再让 $a$ 和所有可能进行遍历即可，那么只需要一个单独的 $n^2$。</p><p>这样，我们只剩下了 $n^4$</p><p>为了达到目标，我们还需要拆分这两个 $n^2$，让找 $max(len_1)$ 变成近乎 $O(1)$ 的查找。那么很显然我们需要预处理，因为当前通过 $n^2$ 的方式确定 $len_0$ 的情况下，其实 $len_1$ 仅会出现在这个区间的左边或者右边，故预处理从 $1 \rightarrow n$ 的每一个位置，进行 $1 \rightarrow k$ 次操作的情况下 $max(len_1)$ 是多少，同时还有 $n \rightarrow 1$ 的也需要</p><p>这里很显然应该通过 dp 去解决，设定 $dp[i][j]$ 表示从 $1 \rightarrow i$ 这段区间内在保证 $i$ 被选入作为 $len_1$ 的情况下（即无论如何当前位置得是 $1$）当前的连续的 $1$ 的长度是多少，这非常简单，可以得到递推公式</p>$$dp\_{i,j} = \left\{ \begin{matrix} dp\_{i-1,j} & s[i] = 1 \\\\dp\_{i-1,j-1} & s[i] = 0 \\\\0 & j = 0 \end{matrix} \right.$$<p>然后再做一次取较大值 $dp_{i, j} = max(dp_{i, j}, dp_{i, j - 1}, dp_{i - 1, j})$，这样就可以 $O(1)$ 的方式快速得到在某个区间内，允许操作 $k$ 次的情况下，能够得到最长的 $1$ 串有多长了</p><p>然后暴力就好</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        string str;<br>        str.<span class="hljs-built_in">reserve</span>(n);<br>        cin &gt;&gt; str;<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">left</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item : left) item.<span class="hljs-built_in">resize</span>(k + <span class="hljs-number">1</span>);<br>        left[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = str[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;0&#x27;</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; ++i) left[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            left[i][<span class="hljs-number">0</span>] = str[i] == <span class="hljs-string">&#x27;0&#x27;</span> ? <span class="hljs-number">0</span> : (i == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : left[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= k; ++j) left[i][j] = str[i] == <span class="hljs-string">&#x27;0&#x27;</span> ? left[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span> : left[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) left[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(left[i][<span class="hljs-number">0</span>], left[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= k; ++j)<br>            left[i][j] = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(left[i - <span class="hljs-number">1</span>][j], left[i][j]), left[i][j - <span class="hljs-number">1</span>]);<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">right</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item : right) item.<span class="hljs-built_in">resize</span>(k + <span class="hljs-number">1</span>);<br>        right[n - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = str[n - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;0&#x27;</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; ++i) right[n - <span class="hljs-number">1</span>][i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            right[i][<span class="hljs-number">0</span>] = str[i] == <span class="hljs-string">&#x27;0&#x27;</span> ? <span class="hljs-number">0</span> : (i == n - <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : right[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= k; ++j) right[i][j] = str[i] == <span class="hljs-string">&#x27;0&#x27;</span> ? right[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span> : right[i + <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i) right[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(right[i][<span class="hljs-number">0</span>], right[i + <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= k; ++j)<br>                right[i][j] = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(right[i + <span class="hljs-number">1</span>][j], right[i][j]), right[i][j - <span class="hljs-number">1</span>]);<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preS</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) preS[i] = preS[i - <span class="hljs-number">1</span>] + (str[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>);<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)</span></span>;<br>        cnt[<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(left[n - <span class="hljs-number">1</span>][k], right[<span class="hljs-number">0</span>][k]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>; l &lt; n; ++l) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r = l; r &lt; n &amp;&amp; preS[r + <span class="hljs-number">1</span>] - preS[l] &lt;= k; ++r) &#123;<br>                <span class="hljs-type">int</span> cost = preS[r + <span class="hljs-number">1</span>] - preS[l];<br>                <span class="hljs-type">int</span> max1 = <span class="hljs-built_in">max</span>(l == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : left[l - <span class="hljs-number">1</span>][k - cost], r == n - <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : right[r + <span class="hljs-number">1</span>][k - cost]);<br>                cnt[r - l + <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(cnt[r - l + <span class="hljs-number">1</span>], max1);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= n; ++j)<br>            ans[i] = <span class="hljs-built_in">max</span>(ans[i], cnt[j] == <span class="hljs-number">-1</span> ? <span class="hljs-number">0</span> : i * j + cnt[j]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然写的挺丑，主要是不习惯写 dp，但是这段代码压根没有用到 <code>if</code></p>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OTPAUTH，两步验证中的通用协议</title>
    <link href="/2023/08/16/develop-note/otpauth/"/>
    <url>/2023/08/16/develop-note/otpauth/</url>
    
    <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>昨天突然 GitHub 给我发了一封邮件，要求我必须添加 2FA 的验证</p><p><img src="/image/other/otpauth/github-email.webp" alt="GitHub-email"></p><p>好吧好吧，那就创建吧。但是在创建的过程中，GitHub 问我是否有使用 1Password 之类的软件，如果有的话，可以扫码添加 2FA</p><p>嗯？？？因为我基本上是躺在 Apple 生态里的，所以选择让 Apple 自带的密码管理系统试试看，于是直接扫码了 GitHub 提供的二维码</p><p>结果扫码之后果真添加了 2FA 的能力</p><p><img src="/image/other/otpauth/password.webp" alt="password"></p><p>这个验证码很像 steam 使用的那种自生成的两步验证码，这让我觉得似乎有一种通用协议，来实现这样一套东西。立马开整</p><p>第一步，再搞到一份这样的二维码。我翻阅了 GitHub 的文档，最终找到了一份 GitHub 提供的示例二维码</p><p><img src="/image/other/otpauth/qr-code.webp" alt="qr-code"></p><p>接着直接读取二维码内的信息得到了这样一个地址: <code>otpauth://totp/GitHub:octocat-testing?secret=F76W4SX573PDRIDA&amp;issuer=GitHub</code></p><p>嗯，看起来是有一个用 OTPAUTH 的验证协议，其中 OTP 大概率就是 One Time Password 了。</p><h1 id="OTP-协议"><a href="#OTP-协议" class="headerlink" title="OTP 协议"></a>OTP 协议</h1><p>一般 OTP 有两种策略：</p><p>计次使用（HOTP）和计时使用（TOTP）。计次使用的密码使用过一次就失效；计时使用的密码过一段时间就失效。</p><blockquote><p>HOTP 的全称是 HMAC-based One Time Password，它是基于 HMAC 的一次性密码生成算法。HMAC 的全称是 Hash-based Message Authentication Code，是指密钥相关的哈希运算消息认证码。HMAC 利用 MD5、SHA-1 等哈希算法，针对输入的密钥和消息，输出消息摘要。HOTP 算法中，传入密钥 K 和计数器 C，得到数字校验码。</p><p>实际使用 HOTP 中，服务端会给用户生成密钥 K，并约定起始计数器 C。客户端根据 K 和 C 生成校验码，并在用户点击刷新按钮后将计数器加 1，同时更新校验码；而服务端会在每次校验成功后将计数器加 1，这就保证了校验码只能使用一次。但客户端刷新并不通知服务端，很可能出现客户端计数器大于服务端的情况。所以一般的实现里，服务端如果用 PASSWORD = HOTP(K, C) 验证失败，还会尝试 C+1、C+2…，如果匹配上了，就更新服务端的计数器，保证跟客户端步调一致。出于安全考虑，服务端会设置一个最大值，并不会无限制地尝试下去。</p><p>HOTP 的优点是可以事先算好一批校验码，用户可以把他们打印出来随身携带逐个使用，用一个划掉一个，达到客户端计数器累加的效果，这样可以完全不依赖于电子设备。HOTP 的缺点是计数器很容易不一致，服务端经常需要通过不断尝试来同步计数器，从而降低了安全性。</p><p>TOTP 的全称是 Time-based One-time Password，它是基于时间的一次性密码生成算法。TOTP 算法需要约定一个起始时间戳 T0，以及间隔时间 TS。把当前时间戳 now 减去 T0，用得到的时间差除以 TS 并取整，可以得到整数 TC。根据 PASSWORD = HOTP(K, TC) 就可以得到数字校验码。</p><p>TOTP 实际上只是把 HOTP 的递增计数器换成了与当前时间有关的 TS，从而在服务端 / 客户端时间一致的前提下，解决了 HOTP 需要同步计数器的问题。同时，TOTP 算法需要用到当前时间，需要现场计算，无法提前算好打印出来。默认情况下，TOTP 在间隔时间 TS 内都能通过校验，并不是一次有效。这个问题可以通过在服务端记录最后一次 TC 来解决，由于 TS 一般很短，通常也可以忽略。</p></blockquote><p>翻阅 <a href="https://github.com/google/google-authenticator/wiki/Key-Uri-Format">google-authenticator</a> 的 wiki 可以看到，这里有非常详细关于 URL 的参数的描述</p><h2 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h2><ul><li>REQUIRED: The secret parameter is an arbitrary key value encoded in Base32 according to RFC 3548. The padding specified in RFC 3548 section 2.2 is not required and should be omitted.</li></ul><h2 id="Issuer"><a href="#Issuer" class="headerlink" title="Issuer"></a>Issuer</h2><ul><li><p>STRONGLY RECOMMENDED: The issuer parameter is a string value indicating the provider or service this account is associated with, URL-encoded according to RFC 3986. If the issuer parameter is absent, issuer information may be taken from the issuer prefix of the label. If both issuer parameter and issuer label prefix are present, they should be equal.</p></li><li><p>Valid values corresponding to the label prefix examples above would be: issuer=Example, issuer=Provider1, and issuer=Big%20Corporation.</p></li><li><p>Older Google Authenticator implementations ignore the issuer parameter and rely upon the issuer label prefix to disambiguate accounts. Newer implementations will use the issuer parameter for internal disambiguation, it will not be displayed to the user. We recommend using both issuer label prefix and issuer parameter together to safely support both old and new Google Authenticator versions.</p></li></ul><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><ul><li>OPTIONAL: The algorithm may have the values:<ul><li>SHA1 (Default)</li><li>SHA256</li><li>SHA512</li></ul></li></ul><blockquote><p>Currently, the algorithm parameter is ignored by the Google Authenticator implementations.</p></blockquote><h2 id="Digits"><a href="#Digits" class="headerlink" title="Digits"></a>Digits</h2><ul><li>OPTIONAL: The digits parameter may have the values 6 or 8, and determines how long of a one-time passcode to display to the user. The default is 6.</li></ul><blockquote><p>Currently, on Android and Blackberry the digits parameter is ignored by the Google Authenticator implementation.</p></blockquote><h2 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h2><ul><li>REQUIRED if type is hotp: The counter parameter is required when provisioning a key for use with HOTP. It will set the initial counter value.</li></ul><h2 id="Period"><a href="#Period" class="headerlink" title="Period"></a>Period</h2><ul><li>OPTIONAL only if type is totp: The period parameter defines a period that a TOTP code will be valid for, in seconds. The default value is 30.</li></ul><blockquote><p>Currently, the period parameter is ignored by the Google Authenticator implementations.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>otpauth</tag>
      
      <tag>2FA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 892 (Div. 2)</title>
    <link href="/2023/08/13/acm/codeforces/CodeforcesRound892/"/>
    <url>/2023/08/13/acm/codeforces/CodeforcesRound892/</url>
    
    <content type="html"><![CDATA[<h1 id="A-United-We-Stand"><a href="#A-United-We-Stand" class="headerlink" title="A. United We Stand"></a>A. United We Stand</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组，你需要把里面的值分成两个数组 $a, b$，保证 $a$ 数组中不存在任何一个值，除 $b$ 数组中的任何一个值后，余数为 0</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这里强制要求 $a$ 除以 $b$，而且也没有要求数量均分之类的，只要得到任意解就行。那把最大的那个值放到 $b$，剩下的都放到 $a$ 就行了，因为除以一个比你大的值，那么一定没办法除尽的</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cin &gt;&gt; data[i];<br>        <span class="hljs-type">int</span> mx = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (data[i] == mx) cnt++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data[i] &gt; mx) &#123;<br>                cnt = <span class="hljs-number">1</span>;<br>                mx = data[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (n == cnt) &#123;<br>            cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        cout &lt;&lt; n - cnt &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; cnt &lt;&lt; endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (data[i] != mx) cout &lt;&lt; data[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        cout &lt;&lt; endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (data[i] == mx) cout &lt;&lt; data[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Olya-and-Game-with-Arrays"><a href="#B-Olya-and-Game-with-Arrays" class="headerlink" title="B. Olya and Game with Arrays"></a>B. Olya and Game with Arrays</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有 $n$ 个数组，允许你将每一个数组的其中一个值移动到另外一个数组，操作必须同时进行，即每个数字仅可以被移动一次，然后再将每个数组的最小值相加，问最大可以是多少</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>首先，每次移动一个值，要使这个数组的最小值提升，那么必定是移动最小的那个值，因为只能移动一次，所以必定是最小的那个值被移动，此时整个数组的最小值就是原来的次小值了</p><p>最终所有最小值都会被移动到其他的数组，而为了避免影响到整体最终结果值，那么肯定需要移动到一个数组本来的最小值就比这个被移动过来的小的数组上，而恰好的是，那个全局最小值所在的数组也需要移动最小值，那么必然这个全局最小值都会被移动到某个特定的数组，而其他数组的最小值如果也移动到那个数组，那么一定不会产生影响</p><p>所以需要计算最小值移动到哪个数组，那么应该选择移动后影响最小的，影响就是每个数组因为移动会减少的最小值差异，和不被移动所能够变成倒数第二小值带来的增量</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, mi = LONG_LONG_MAX;<br>        cin &gt;&gt; n;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">data</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> m, tmp;<br>            cin &gt;&gt; m;<br>            <span class="hljs-type">int</span> u = LONG_LONG_MAX, v = LONG_LONG_MAX;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>                cin &gt;&gt; tmp;<br>                mi = <span class="hljs-built_in">min</span>(mi, tmp);<br>                <span class="hljs-keyword">if</span> (tmp &lt; u) &#123;<br>                    v = u;<br>                    u = tmp;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tmp &lt; v) v = tmp;<br>            &#125;<br>            data[i] = &#123;u, v&#125;;<br>        &#125;<br>        <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> cur = (data[i].second - data[i].first) + (data[i].first - mi);<br>            <span class="hljs-type">int</span> lst = (data[t].second - data[t].first) + (data[t].first - mi);<br>            <span class="hljs-keyword">if</span> (cur &lt; lst) t = i;<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (i == t) ans += mi;<br>            <span class="hljs-keyword">else</span> ans += data[i].second;<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Another-Permutation-Problem"><a href="#C-Another-Permutation-Problem" class="headerlink" title="C. Another Permutation Problem"></a>C. Another Permutation Problem</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>一个 $n$ 的排列数组，将每一个值和它的下标（从 $1$ 开始）相乘，然后去掉最大的值之后求和，问在哪种排列下，这个求和的值最大可以是多少，不需要计算出具体的数组，只需要给出结果就行了</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>因为数据量级很小，所以可以暴力扫</p><p>假定当前计算乘积完成后，所有结果数中最大值为 $x$，然后从大到小遍历每一个值，计算出此时每个值下标可以是多少，尽可能取较大的，就可以算出当前情况下的结果是多少</p><p>然后暴力扫所有可能的最大值就行了</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">auto</span> cal = [&amp;](<span class="hljs-type">int</span> mx) &#123;<br>            <span class="hljs-type">int</span> total = <span class="hljs-number">0</span>, big = <span class="hljs-number">0</span>;<br>            set&lt;<span class="hljs-type">int</span>&gt; s;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) s.<span class="hljs-built_in">insert</span>(i);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>                <span class="hljs-type">int</span> mi = mx / i;<br>                <span class="hljs-keyword">auto</span> iter = s.<span class="hljs-built_in">upper_bound</span>(mi);<br>                <span class="hljs-keyword">if</span> (iter == s.<span class="hljs-built_in">begin</span>()) <span class="hljs-keyword">return</span>;<br>                iter--;<br>                total += *iter * i;<br>                big = <span class="hljs-built_in">max</span>(big, *iter * i);<br>                s.<span class="hljs-built_in">erase</span>(iter);<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, total - big);<br>        &#125;;<br><br>        <span class="hljs-type">int</span> mi = ((n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>) * ((n + <span class="hljs-number">2</span>) / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = (mi + i - <span class="hljs-number">1</span>) / i; j &lt;= n; ++j) &#123;<br>                <span class="hljs-type">int</span> maxValue = i * j;<br>                <span class="hljs-built_in">cal</span>(maxValue);<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Andrey-and-Escape-from-Capygrad"><a href="#D-Andrey-and-Escape-from-Capygrad" class="headerlink" title="D. Andrey and Escape from Capygrad"></a>D. Andrey and Escape from Capygrad</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一条射线，起点是 $0$</p><p>射线上有一些传送门，对于每一个传送门，可以用四个数字表示 $l, r, a, b$，表示如果你在 $[l, r]$ 这个区间内的话，就可以传送到 $[a, b]$ 这个区间的任意一个位置。问从某个点开始，可以使用无限次数传送门，最远可以到哪里</p><p>强调，对于任意一个传送门，都满足 $l \leq a \leq b \leq r$</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>很明显的是，实际上只有 $[l ,b]$ 这段传送门是有意义的，因为对于 $[b, r]$ 这段，实际上进入这个传送门之后，只能回到更小的值。当然有人可能会担心，是不是存在可以通过回到更小的值，导致可以进入实际上能够传送到更远的传送门了。假定当前传送门为 $l_0, r_0, a_0, b_0$ 另外一个可以进入且更好的传送门为 $l_1, r_1, a_1, b_1$，当前位置为 $x$，根据给出的现象可以得到 $b_0 &lt; b_1$，且 $l_1 \leq b_0$，且 $b_0 &lt; x \leq r_0$，这样才能满足进入之后能够进入到另外一个传送门，且更远。但是根据题意又可以得到 $b_0 \leq r_0$，所以组合上述的表达式就可以得到 $l_1 \leq b_0 \leq x \leq r_0$ 此时 $x$ 明明可以直接进入第二个传送门，压根不需要回来绕一下</p><p>明确这一点后，只需要维护所有传送门的 $l, b$ 这两个节点即可 $l$ 表示进入的节点，$b$ 表示出去的节点，做 hash 后按照从大到小的下标遍历，维护当前下标涉及到的传送门，若当前时间内有任何传送门，则进入，否则留在原地，若当前所有传送门都已经结束了，那么还在传送门中的都需要出来</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, q;<br>        cin &gt;&gt; n;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; event;<br>        event.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">4</span> * n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> l, r, a, b;<br>            cin &gt;&gt; l &gt;&gt; r &gt;&gt; a &gt;&gt; b;<br>            event.<span class="hljs-built_in">push_back</span>(&#123;l, &#123;<span class="hljs-number">1</span>, i&#125;&#125;);<br>            event.<span class="hljs-built_in">push_back</span>(&#123;b, &#123;<span class="hljs-number">2</span>, i&#125;&#125;);<br>        &#125;<br>        cin &gt;&gt; q;<br>        event.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">4</span> * n + q);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            event.<span class="hljs-built_in">push_back</span>(&#123;tmp, &#123;<span class="hljs-number">3</span>, i&#125;&#125;);<br>        &#125;<br><br>        <span class="hljs-built_in">sort</span>(event.<span class="hljs-built_in">begin</span>(), event.<span class="hljs-built_in">end</span>());<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(q)</span></span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; query;<br>        set&lt;<span class="hljs-type">int</span>&gt; len;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: event) &#123;<br>            <span class="hljs-keyword">switch</span> (item.second.first) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                    len.<span class="hljs-built_in">insert</span>(item.second.second);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                    len.<span class="hljs-built_in">erase</span>(item.second.second);<br>                    <span class="hljs-keyword">if</span> (len.<span class="hljs-built_in">empty</span>()) &#123;<br>                        <span class="hljs-keyword">while</span> (!query.<span class="hljs-built_in">empty</span>()) &#123;<br>                            ans[query.<span class="hljs-built_in">top</span>()] = item.first;<br>                            query.<span class="hljs-built_in">pop</span>();<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                    <span class="hljs-keyword">if</span> (len.<span class="hljs-built_in">empty</span>()) ans[item.second.second] = item.first;<br>                    <span class="hljs-keyword">else</span> query.<span class="hljs-built_in">push</span>(item.second.second);<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: ans) cout &lt;&lt; item &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 891 (Div. 3)</title>
    <link href="/2023/08/12/acm/codeforces/CodeforcesRound891/"/>
    <url>/2023/08/12/acm/codeforces/CodeforcesRound891/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Array-Coloring"><a href="#A-Array-Coloring" class="headerlink" title="A. Array Coloring"></a>A. Array Coloring</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>把一个数组里的值分成两组，让这两组的所有元素求和后，奇偶性一致</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>只要判定原数组中奇数的个数就行了，奇数个数的奇数就肯定不行</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, ans = <span class="hljs-number">0</span>;<br>        cin &gt;&gt; n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            ans += tmp % <span class="hljs-number">2</span>;<br>        &#125;<br>        cout &lt;&lt; (ans % <span class="hljs-number">2</span> ? <span class="hljs-string">&quot;NO&quot;</span> : <span class="hljs-string">&quot;YES&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Maximum-Rounding"><a href="#B-Maximum-Rounding" class="headerlink" title="B. Maximum Rounding"></a>B. Maximum Rounding</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>可以对一个数字进行无数次任意位置的四舍五入，问最大值可以是多少</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>也是比较简单的，只需要从左往右找到第一个 $\geq 5$ 的值，并从此值开始往前一致进位，然后再判断进位后的是否 $\geq 5$，然后无限制的进位即可</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        string str;<br>        cin &gt;&gt; str;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            str[i] -= <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (str[i] &gt;= <span class="hljs-number">5</span>) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>                    <span class="hljs-keyword">if</span> (str[j + <span class="hljs-number">1</span>] &gt;= <span class="hljs-number">5</span>) &#123;<br>                        str[j]++;<br>                        str[j + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; str.<span class="hljs-built_in">size</span>(); ++j) str[j] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (str[<span class="hljs-number">0</span>] == <span class="hljs-number">5</span>) str[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (str[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-string">&#x27;1&#x27;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> i : str) cout &lt;&lt; <span class="hljs-built_in">char</span>(i + <span class="hljs-string">&#x27;0&#x27;</span>);<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Assembly-via-Minimums"><a href="#C-Assembly-via-Minimums" class="headerlink" title="C. Assembly via Minimums"></a>C. Assembly via Minimums</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组长度为 $n$，暂时不知道具体的内容，通过这个数组得到一个新数组，其中的每一项为 $\forall i \in [1, n], \forall j \in [1, n], min(a_i, a_j)$，求出一个可能的原数组</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>反过来思考，假如一个原数组已经从小到大排序好了，那么通过这个方法会得到 $(n - 1)$ 个 $a_0$，$(n - 2)$ 个 $a_1$，$0$ 个 $a_n$……以此类推，所以按照此规律反推即可</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, n2;<br>        cin &gt;&gt; n;<br>        n2 = n * (n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n2; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            cnt[tmp]++;<br>        &#125;<br><br>        <span class="hljs-type">int</span> des = n - <span class="hljs-number">1</span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp; iter : cnt) &#123;<br>            <span class="hljs-keyword">while</span> (iter.second &gt; <span class="hljs-number">0</span>) &#123;<br>                iter.second -= des;<br>                res.<span class="hljs-built_in">push_back</span>(iter.first);<br>                des--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> re : res) cout &lt;&lt; re &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        cout &lt;&lt; res.<span class="hljs-built_in">back</span>() &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Strong-Vertices"><a href="#D-Strong-Vertices" class="headerlink" title="D. Strong Vertices"></a>D. Strong Vertices</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>给出两个数组 $a, b$，对于 $i \in [1, n], j \in [1, n], a_i - a_j \geq b_i - b_j$ 则在一个图中绘制边 $i \rightarrow j$ 的有向边，求问图中存在多少个点，满足这些点可以通过一条或者几条路径到达所有其他节点</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>这道题迷惑性很强</p><p>首先需要变形一下公式，得到 $a_i - b_i \geq a_j - b_j$，这样是否存在边的情况，就直接和当前下标相关了。根据公式容易可以得到，若存在一个节点的 $a_i - b_i \geq max_{j=1}^n(a_j - b_j)$ 的时候，那么就等于直接和所有其他点有边了</p><p>另外，通过上述公式还可以明显直到，压根不可能存在需要走两条路径的情况，因为所有点的可达点都必定满足 $a_i - b_i \leq a_j - b_j$（$i$ 为当前节点，$j$ 为可以达到的点），故只需要考虑最大的差值项即可</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data1</span><span class="hljs-params">(n)</span>, <span class="hljs-title">data2</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cin &gt;&gt; data1[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cin &gt;&gt; data2[i];<br>        vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>        <span class="hljs-type">int</span> tmp = LONG_LONG_MIN;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (data1[i] - data2[i] &gt; tmp) &#123;<br>                tmp = data1[i] - data2[i];<br>                ans.<span class="hljs-built_in">clear</span>();<br>                ans.<span class="hljs-built_in">push_back</span>(i);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data1[i] - data2[i] == tmp) ans.<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>        cout &lt;&lt; ans.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : ans) cout &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="E-Power-of-Points"><a href="#E-Power-of-Points" class="headerlink" title="E. Power of Points"></a>E. Power of Points</h1><h2 id="大致题意-4"><a href="#大致题意-4" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组 $a$</p><p>接下来需要计算一个值 <code>f(x)</code>，这个值的是这样计算的：</p><ul><li>对于数组中的每一项，求算一个区间 $[x, a_i]$，可以得到 $n$ 个区间</li><li>求出所有可能的正整数所命中的区间数量的和</li></ul><p>需要求算 $\sum_{i=0}^n f(a_i)$</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>排序一下</p><p>然后遍历数组，维护从这个值到下一个值，左右区间带来的贡献即可</p><h2 id="AC-code-4"><a href="#AC-code-4" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">data</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cin &gt;&gt; data[i].first;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) data[i].second = i;<br>        <span class="hljs-built_in">sort</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) right += <span class="hljs-built_in">abs</span>(data[i].first - data[<span class="hljs-number">0</span>].first) + <span class="hljs-number">1</span>;<br><br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; res;<br>        res.<span class="hljs-built_in">emplace_back</span>(data[<span class="hljs-number">0</span>].second, left + right);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            left += <span class="hljs-number">1</span>;<br>            right -= <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> cap = <span class="hljs-built_in">abs</span>(data[i].first - data[i - <span class="hljs-number">1</span>].first);<br>            left += cap * i;<br>            right -= cap * (n - i);<br>            res.<span class="hljs-built_in">emplace_back</span>(data[i].second, left + right);<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(res.<span class="hljs-built_in">begin</span>(), res.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : res) cout &lt;&lt; i.second &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="F-Sum-and-Product"><a href="#F-Sum-and-Product" class="headerlink" title="F. Sum and Product"></a>F. Sum and Product</h1><h2 id="大致题意-5"><a href="#大致题意-5" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组 $a$，给出 $q$ 次询问，每次询问 $x, y$ 两个值，问有多少对不同的 $i, j$ 满足 $i &lt; j, a_i + a_j = x, a_i \times a_j = y$</p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>把公式化简了，其实就是二元一次方程求解，实际上很简单</p><h2 id="AC-code-5"><a href="#AC-code-5" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bf</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">1e10</span> + <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">while</span> (l + <span class="hljs-number">1</span> &lt; r) &#123;<br>        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (mid * mid == x) <span class="hljs-keyword">return</span> mid;<br>        <span class="hljs-keyword">if</span> (mid * mid &lt; x) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            mp[tmp]++;<br>        &#125;<br><br>        <span class="hljs-type">int</span> q;<br>        cin &gt;&gt; q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; ++i) &#123;<br>            <span class="hljs-type">int</span> x, y;<br>            cin &gt;&gt; x &gt;&gt; y;<br>            <span class="hljs-type">int</span> inner = x * x - <span class="hljs-number">4</span> * y;<br><br>            <span class="hljs-type">int</span> outer = <span class="hljs-built_in">bf</span>(inner);<br>            <span class="hljs-keyword">if</span> (outer * outer != inner) &#123;<br>                cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> ((x + outer) % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br>                cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> l = (x + outer) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> r = (x - outer) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">auto</span> lIter = mp.<span class="hljs-built_in">find</span>(l);<br>            <span class="hljs-keyword">auto</span> rIter = mp.<span class="hljs-built_in">find</span>(r);<br>            <span class="hljs-keyword">if</span> (l == r) &#123;<br>                <span class="hljs-type">int</span> cnt = lIter == mp.<span class="hljs-built_in">end</span>() ? <span class="hljs-number">0</span> : lIter-&gt;second;<br>                cout &lt;&lt; cnt * (cnt - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>            &#125; <span class="hljs-keyword">else</span> cout &lt;&lt; (lIter == mp.<span class="hljs-built_in">end</span>() ? <span class="hljs-number">0</span> : lIter-&gt;second) * (rIter == mp.<span class="hljs-built_in">end</span>() ? <span class="hljs-number">0</span> : rIter-&gt;second) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="G-Counting-Graphs"><a href="#G-Counting-Graphs" class="headerlink" title="G. Counting Graphs"></a>G. Counting Graphs</h1><h2 id="大致题意-6"><a href="#大致题意-6" class="headerlink" title="大致题意"></a>大致题意</h2><p>这道题还是很不错的～</p><p>给出一颗树，树的边有权重</p><p>问在保证任意边权重不超过 $S$ 的情况下，有多少种不同的图，满足它的最小生成树一定是给出的树</p><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>最小生成树很容易让人想到是否和边排序后 + 并查集操作有关</p><p>我们需要往图里加入一些无意义的边，比如权值大于树上最大权值的情况下，无论怎么加都是合理的</p><p>而核心需要考虑的就是，当使用的边权值小于等于树上的最大权值的情况下，还能加到哪里</p><p>回到这里提到的第二段：无意义的边。如果我们提取出这个生成树的子树，对于每一个子树，是否都可以使用这一条，即使这个权值小于树上的最大权值，但是只要它大于子树本身的最大权值即可</p><p>如此“分治”，只需要根据权值从小到大排序边，然后一条条加入图中，然后通过并查集来确认新多了多少条可以加的边，然后再考虑上可以加的权值种类，得到解</p><h2 id="AC-code-6"><a href="#AC-code-6" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>        <span class="hljs-type">int</span> u, v, c;<br>    &#125;;<br><br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, s;<br>        cin &gt;&gt; n &gt;&gt; s;<br>        <span class="hljs-function">vector&lt;node&gt; <span class="hljs-title">data</span><span class="hljs-params">(n - <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) cin &gt;&gt; data[i].u &gt;&gt; data[i].v &gt;&gt; data[i].c;<br>        <span class="hljs-built_in">sort</span>(data.<span class="hljs-built_in">begin</span>(), data.<span class="hljs-built_in">end</span>(), [&amp;](node a, node b) &#123; <span class="hljs-keyword">return</span> a.c &lt; b.c; &#125;);<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fa</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; fa.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            fa[i] = i;<br>            cnt[i] = <span class="hljs-number">1</span>;<br>        &#125;<br><br>        function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>)&gt; find = [&amp;](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> fa[x] == x ? x : fa[x] = <span class="hljs-built_in">find</span>(fa[x]); &#125;;<br>        function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; join = [&amp;](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;<br>            <span class="hljs-type">int</span> fx = <span class="hljs-built_in">find</span>(x), fy = <span class="hljs-built_in">find</span>(y);<br>            <span class="hljs-keyword">if</span> (fx == fy) <span class="hljs-keyword">return</span> <span class="hljs-number">0ll</span>;<br><br>            fa[fx] = fy;<br>            <span class="hljs-type">int</span> res = (cnt[fx] * cnt[fy] - <span class="hljs-number">1</span>);<br>            cnt[fy] += cnt[fx];<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;;<br><br>        function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; pow = [&amp;](<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> p) &#123;<br>            <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>, buff = n;<br>            <span class="hljs-keyword">while</span> (p) &#123;<br>                <span class="hljs-keyword">if</span> (p &amp; <span class="hljs-number">1</span>) ans = (ans * buff) % mod;<br>                buff = (buff * buff) % mod;<br>                p &gt;&gt;= <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;;<br><br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>            <span class="hljs-type">int</span> cCap = s - data[i].c, nC = <span class="hljs-built_in">join</span>(data[i].u, data[i].v);<br>            ans *= <span class="hljs-built_in">pow</span>(cCap + <span class="hljs-number">1</span>, nC);<br>            ans %= mod;<br>        &#125;<br><br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 890 (Div. 2)</title>
    <link href="/2023/08/11/acm/codeforces/CodeforcesRound890/"/>
    <url>/2023/08/11/acm/codeforces/CodeforcesRound890/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Tales-of-a-Sort"><a href="#A-Tales-of-a-Sort" class="headerlink" title="A. Tales of a Sort"></a>A. Tales of a Sort</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有个数列，每次操作可以将所有值减少 $1$，除非它已经是 $0$ 了，问需要多少次操作，才能将整个数列变成非递减数列</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>很明显的一点，如果发现一对不满足条件的相邻对，即 $a_i &gt; a_{i + 1}$，如果不把他们都减少到 $0$ 的情况下，永远无法满足题目条件，故只需要找到不满足的对，然后取最大的那个值即可</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, last = <span class="hljs-number">0</span>, mx = <span class="hljs-number">0</span>, tmp;<br>        <span class="hljs-type">bool</span> ans = <span class="hljs-literal">false</span>;<br>        cin &gt;&gt; n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            cin &gt;&gt; tmp;<br>            <span class="hljs-keyword">if</span> (tmp &lt; last) mx = <span class="hljs-built_in">max</span>(mx, last);<br>            <span class="hljs-keyword">else</span> last = tmp;<br>        &#125;<br>        cout &lt;&lt; mx &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Good-Arrays"><a href="#B-Good-Arrays" class="headerlink" title="B. Good Arrays"></a>B. Good Arrays</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>题目给出一个数组 $a$，要你判定是否存在另外一个数组 $b$，满足 $\sum_{i=1}^n a_i = \sum_{i=1}^n b_i, \forall i \in [1, n], a_i \neq b_i, a_i &gt; 0, b_i &gt; 0$</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>读题易得：若原来的值是 $1$，那么必须找别的值借 $1$ 才能保证 $a_i \neq b_i$，而其他值则都可以简单变成 $1$ 解决。故只需要计算有多少可以冗余调配的值即可</p><p>需要特判一下只有一个值的情况</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, cnt = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;<br>        cin &gt;&gt; n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            cnt += tmp == <span class="hljs-number">1</span>;<br>            sum += tmp;<br>        &#125;<br>        cout &lt;&lt; (cnt + n &gt; sum || n == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;NO&quot;</span> : <span class="hljs-string">&quot;YES&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-To-Become-Max"><a href="#C-To-Become-Max" class="headerlink" title="C. To Become Max"></a>C. To Become Max</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个初始数组 $a$，每次可以选择一个 $i \in [1, n - 1]$，若 $a[i] \leq a[i + 1]$ 则使得 $a[i] = a[i] + 1$，问在最多操作 $k$ 次的情况下，数组的最大值可以为多少</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>注意到数据量，$n$ 仅有 $1000$，意味着复杂度可以达到 $n^2 log(1e9)$ 的级别，然后再做思考</p><p>按照公式，那么最终得到的数组，必定存在一个恰好递减的阶梯。另外很明显的是，数组的最后一个值必定不可动，那就意味着实际上最大值的可行性是被最后一个值限定的，最大值为 $a_n + n - 1$</p><p>由于复杂度有非常大的冗余，故可以作出如下的暴力搜索</p><ul><li>遍历所有可能为最大值的下标 $i$</li><li>二分查找最终的最大值</li><li>尝试构建最大值的可能性，是否能够在 $k$ 消耗内，完成构建一个阶梯</li></ul><p>这样下来恰好复杂度满足预期</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cin &gt;&gt; data[i];<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) ans = <span class="hljs-built_in">max</span>(ans, data[i]);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>; l &lt; n; ++l) &#123;<br>            <span class="hljs-type">int</span> b = ans, e = ans + k + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (b + <span class="hljs-number">1</span> &lt; e) &#123;<br>                <span class="hljs-type">int</span> mid = (b + e) / <span class="hljs-number">2</span>;<br>                <span class="hljs-type">int</span> cost = <span class="hljs-number">0</span>;<br>                <span class="hljs-type">bool</span> keyPoint = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &lt; n &amp;&amp; !keyPoint &amp;&amp; cost &lt;= k; ++i) &#123;<br>                    <span class="hljs-keyword">if</span> (data[i] &gt;= mid - (i - l)) keyPoint = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">else</span> cost += mid - data[i] - (i - l);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (keyPoint &amp;&amp; cost &lt;= k) b = mid;<br>                <span class="hljs-keyword">else</span> e = mid;<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, b);<br>        &#125;<br><br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-More-Wrong"><a href="#D-More-Wrong" class="headerlink" title="D. More Wrong"></a>D. More Wrong</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>交互题</p><p>有一个 $n$ 的排列 $a$，只知道长度 $n$，每次可以询问 $[l, r]$ 区间下，逆序对数量，每次询问的代价是 $(r - l)^2$，问如何在 $5 \times n^2$ 的代价下，找到最大值的下标</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>区间逆序对，很容易想到归并排序</p><p>先得到两个简单的结论：</p><ul><li>若已知一个区间的逆序对数量，再最后加入一个元素，且没有改变逆序对数量，那么这个加入的元素必定是当前区间的最大值</li><li>若已知一个区间的逆序对数量，再最前面加入一个元素，且增加了恰好等于原来元素个数的逆序对，则新加入的元素必定是当前区间的最大值</li></ul><p>这两个结论显而易见，就不再解释</p><p>从归并排序的视角看，我们假定找到了一个区间前半部分的最大值的下标，又找到了后半部分最大值的下标，那么需要判断这两个值谁更大的时候，就可以通过上面的定律来判定，只需要两次查询即可</p><p>如此递归下去，可以得到最终的查询费用为</p>$$\begin{cases}& 2(n - 1)^2 + 2 \times 2(0.5n - 1)^2 + 2 \times 4(0.25n - 1)^2 + \dots \\\leq & 2n^2 + 4(0.5n)^2 +  8(0.25n)^2 + \dots \\= & 2(n^2 + 0.5n^2 + 0.25n^2 + \dots) \leq 4n^2 \leq 5n^2\end{cases}$$<p>可以证得这个方法的消耗低于要求</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">map&lt;pair&lt;int, int&gt;, int&gt; m;</span><br><span class="language-xml"></span><br><span class="language-xml">int interactive(int l, int r) &#123;</span><br><span class="language-xml">    auto iter = m.find(&#123;l, r&#125;);</span><br><span class="language-xml">    if (iter != m.end()) &#123;</span><br><span class="language-xml">        return iter-&gt;second;</span><br><span class="language-xml">    &#125;</span><br><span class="language-xml">    int temp;</span><br><span class="language-xml">    cout &lt;&lt; &quot;? &quot; &lt;&lt; l &lt;&lt; &#x27; &#x27; &lt;&lt; r &lt;&lt; endl;</span><br><span class="language-xml">    cout.flush();</span><br><span class="language-xml">    cin &gt;&gt; temp;</span><br><span class="language-xml">    m.insert(</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">l</span>, r&#125;, temp&#125;);</span><br><span class="hljs-template-variable">    return temp;</span><br><span class="hljs-template-variable">&#125;</span><br><span class="hljs-template-variable"></span><br><span class="hljs-template-variable">int dfs(<span class="hljs-name">int</span> l, int r) &#123;</span><br><span class="hljs-template-variable">    if (<span class="hljs-name">l</span> == r) &#123;</span><br><span class="hljs-template-variable">        return l;</span><br><span class="hljs-template-variable">    &#125;</span><br><span class="hljs-template-variable">    if (<span class="hljs-name">l</span> + <span class="hljs-number">1</span> == r) &#123;</span><br><span class="hljs-template-variable">        return interactive(<span class="hljs-name">l</span>, r) == <span class="hljs-number">1</span> ? l : r;</span><br><span class="hljs-template-variable">    &#125;</span><br><span class="hljs-template-variable">    if (<span class="hljs-name">l</span> + <span class="hljs-number">2</span> == r) &#123;</span><br><span class="hljs-template-variable">        int lm = dfs(<span class="hljs-name">l</span>,  l + <span class="hljs-number">1</span>);</span><br><span class="hljs-template-variable">        if (<span class="hljs-name">lm</span> == l) &#123;</span><br><span class="hljs-template-variable">            return interactive(<span class="hljs-name">l</span>, r) == <span class="hljs-number">1</span> ? r : l;</span><br><span class="hljs-template-variable">        &#125; else return dfs(<span class="hljs-name">lm</span>, r);</span><br><span class="hljs-template-variable">    &#125;</span><br><span class="hljs-template-variable"></span><br><span class="hljs-template-variable">    int mid = (<span class="hljs-name">l</span> + r) &gt;&gt; <span class="hljs-number">1</span>;</span><br><span class="hljs-template-variable">    int lm = dfs(<span class="hljs-name">l</span>, mid);</span><br><span class="hljs-template-variable">    int rm = dfs(<span class="hljs-name">mid</span> + <span class="hljs-number">1</span>, r);</span><br><span class="hljs-template-variable">    if (<span class="hljs-name">lm</span> + <span class="hljs-number">2</span> &gt;= rm) return dfs(<span class="hljs-name">lm</span>, rm);</span><br><span class="hljs-template-variable"></span><br><span class="hljs-template-variable">    int t1 = interactive(<span class="hljs-name">lm</span> + <span class="hljs-number">1</span>, rm - <span class="hljs-number">1</span>);</span><br><span class="hljs-template-variable">    int t2 = interactive(<span class="hljs-name">lm</span>, rm);</span><br><span class="hljs-template-variable">    return t2 &gt;= t1 + rm - lm ? lm : rm;</span><br><span class="hljs-template-variable"></span><br><span class="hljs-template-variable">&#125;</span><br><span class="hljs-template-variable"></span><br><span class="hljs-template-variable">void solve() &#123;</span><br><span class="hljs-template-variable">    int _;</span><br><span class="hljs-template-variable">    cin &gt;&gt; _;</span><br><span class="hljs-template-variable">    for (<span class="hljs-name">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;</span><br><span class="hljs-template-variable">        m.clear();</span><br><span class="hljs-template-variable">        int n;</span><br><span class="hljs-template-variable">        cin &gt;&gt; n;</span><br><span class="hljs-template-variable">        int ans = dfs(<span class="hljs-name">1</span>, n);</span><br><span class="hljs-template-variable">        cout &lt;&lt; <span class="hljs-string">&quot;! &quot;</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="hljs-template-variable">    &#125;</span><br><span class="hljs-template-variable">&#125;</span><br></code></pre></td></tr></table></figure><h1 id="E1-PermuTree-easy-version"><a href="#E1-PermuTree-easy-version" class="headerlink" title="E1. PermuTree (easy version)"></a>E1. PermuTree (easy version)</h1><h2 id="大致题意-4"><a href="#大致题意-4" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个树和一个 $n$ 的排列 $a$，求出使得满足 $a_u &lt; a_{lca(u, v)} &lt; a_v$ 这个等式的最多的排列下，满足多少次</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>在树上并没有 $u, v$ 之分，实际上可以相互对掉，所以这棵树实际上需要尽可能满足二叉搜索树的结构才行，即每个节点下，左边的值都小于当前节点，右边的值都大于当前节点。</p><p>但是这不一定是一颗二叉树，而是多叉树，而在满足上述等式的情况下，则需要人为的将所有子节点划分为两份，一份大于一份小于。即，假如一个节点有 $3$ 个直接子节点，那么必定存在有两个直接的子节点的下的所有值都小于当前节点，同时另外一个直接子节点下的所有值都要大于此节点，那么最终的满足等式的量级为 $(cnt_1 + cnt_2) \times cnt_3$</p><p>而又因为划分的时候，总共的子节点数量之和是确定的，故需要尽可能对半分，那么就需要背包运算</p><p>而这又是树结构，所以只需要在树上 dp 上做背包 dp 即可</p><h2 id="AC-code-4"><a href="#AC-code-4" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> v, nxt;<br>&#125;;<br><br><span class="hljs-function">vector&lt;node&gt; <span class="hljs-title">edge</span><span class="hljs-params">(<span class="hljs-number">5010</span>)</span></span>;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">head</span><span class="hljs-params">(<span class="hljs-number">5010</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;pack)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (pack.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pack.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pack.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> pack[<span class="hljs-number">0</span>] * pack[<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : pack) sum += i;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(sum / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : pack)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> w = sum / <span class="hljs-number">2</span>; w &gt;= i; --w)<br>            dp[w] = <span class="hljs-built_in">max</span>(dp[w], dp[w - i] + i);<br><br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : dp) left = <span class="hljs-built_in">max</span>(left, i);<br>    <span class="hljs-keyword">return</span> left * (sum - left);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">tree</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> &amp;cal)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[index]; i != <span class="hljs-number">-1</span>; i = edge[i].nxt) &#123;<br>        temp.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">tree</span>(edge[i].v, cal));<br>    &#125;<br>    cal += <span class="hljs-built_in">dp</span>(temp);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : temp) res += i;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) head[i] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-type">int</span> tmp;<br>        cin &gt;&gt; tmp;<br>        edge[i] = &#123;i + <span class="hljs-number">1</span>, head[tmp]&#125;;<br>        head[tmp] = i;<br>    &#125;<br><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">tree</span>(<span class="hljs-number">1</span>, ans);<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Educational Codeforces Round#152 (Div. 2)</title>
    <link href="/2023/08/06/acm/codeforces/EducationalCodeforcesRound152/"/>
    <url>/2023/08/06/acm/codeforces/EducationalCodeforcesRound152/</url>
    
    <content type="html"><![CDATA[<h1 id="A-Morning-Sandwich"><a href="#A-Morning-Sandwich" class="headerlink" title="A. Morning Sandwich"></a>A. Morning Sandwich</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有 $a$ 个面包片，$b$ 个奶酪片，$c$ 个火腿片，要保证奶酪片和火腿片必须被两块面包片直接夹，问最多可以造多大的汉堡</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>很简单，就不讲了</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tss = <span class="hljs-number">0</span>; tss &lt; _; ++tss) &#123;<br>        <span class="hljs-type">int</span> a, b, c;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        <span class="hljs-type">int</span> m = <span class="hljs-built_in">min</span>(a - <span class="hljs-number">1</span>, b + c);<br>        cout &lt;&lt; m * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Monsters"><a href="#B-Monsters" class="headerlink" title="B. Monsters"></a>B. Monsters</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有 $n$ 个怪物，每个怪物有一定生命值 $a[i]$，每次攻击一定是对着生命值最高的怪物，并减少其生命值 $k$，若有多个则选择最左边的，问怪物的死亡顺序</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>当有任何怪物的生命值大于 $k$ 的时候，那就意味着不会有怪物死亡，所以可以先对所有怪物进行 <code>mod k</code> 操作</p><p>此时，就会有怪物出现死亡，因为会恰好降低到 $0$，需要先输出为 $0$ 的怪物，从左往右输出即可</p><p>后面，再根据剩余生命值从大到小，从左往右输出即可</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> tss = <span class="hljs-number">0</span>; tss &lt; _; ++tss) &#123;<br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        map&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            tmp %= k;<br>            res[tmp].<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">auto</span> zero = res[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : zero) cout &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter = res.<span class="hljs-built_in">rbegin</span>(); iter != res.<span class="hljs-built_in">rend</span>(); ++iter) &#123;<br>            <span class="hljs-keyword">if</span> (iter-&gt;first == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : iter-&gt;second) cout &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Binary-String-Copying"><a href="#C-Binary-String-Copying" class="headerlink" title="C. Binary String Copying"></a>C. Binary String Copying</h1><p><strong>这题老坑人了QAQ</strong></p><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个初始字符串 $s$，仅有 <code>0</code> 和 <code>1</code> 组成。</p><p>有 $k$ 次操作，每次操作都是在这个初始字符串上进行的。每次操作选择一个区间 $[l, r]$，并使得这个区间内的值进行排序，即 $0101010 \rightarrow 0000111$</p><p>问，得到的这 $k$ 个字符串，有多少种不同的</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>有点蒙，但还是得找找思路</p><p>考虑到字符串种类，第一反应是做字符串 hash，这非常简单，因为字符串仅有 <code>0</code> 和 <code>1</code>，为了方便，如果当前位为 <code>1</code> 则取这一位的权制，否则不取，这样就有点类似 $mod$ 进制数了</p><p>接下来是如何计算 $k$ 个字符串的 hash 值，根据题目给出的数据量，看起来必须在 O(sqrt(n)) 时间之内完成。我们可以发现，每次操作后实际上有三个区间</p><ul><li>$[1, l)$ 和原来的 hash 值相同</li><li>$[l, r]$ 不知道！</li><li>$(r, n]$ 和原来的 hash 值相同</li></ul><p>即然某段区间存在和之前 hash 值相同的情况，那么可以通过对 hash 值前缀和的方式，使得能够快速求出任意区间的 hash 值，那么就只剩下中间的区间了</p><p>有意思的是，排序后的值恰好是一个前面为 <code>0</code> 后面为 <code>1</code> 的字符串，所以计算单独计算这段区间内的 hash 结果非常简单，只需要有一个每一位的 hash 值的前缀和，并且知道 <code>1</code> 从哪一位开始即可，因为最后一个一定也是 <code>1</code>（当然需要排除一下压根没有 1 的情况）</p><p>而需要计算某个区间内的 <code>1</code> 的数量，好像又可以做一次前缀和</p><p>最终，只需要三个前缀和就可以简单解决问题了</p><p>但是试了两个 hash 值都不通过，一气之下直接同时计算两个 hash 值，然后就过了</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pw1</span><span class="hljs-params">(<span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pw2</span><span class="hljs-params">(<span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-type">int</span> tmp1 = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> tmp2 = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; pw1.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        pw1[i] = (pw1[i - <span class="hljs-number">1</span>] + tmp1) % mod;<br>        tmp1 *= <span class="hljs-number">131</span>;<br>        tmp1 %= mod;<br><br>        pw2[i] = (pw2[i - <span class="hljs-number">1</span>] + tmp2) % mod;<br>        tmp2 *= <span class="hljs-number">1331</span>;<br>        tmp2 %= mod;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">b1</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">b2</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-function">string <span class="hljs-title">str</span><span class="hljs-params">(n, <span class="hljs-string">&#x27;0&#x27;</span>)</span></span>;<br>        cin &gt;&gt; str;<br><br>        tmp1 = <span class="hljs-number">1</span>;<br>        tmp2 = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            a[i + <span class="hljs-number">1</span>] = a[i] + str[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            b1[i + <span class="hljs-number">1</span>] = (b1[i] + (str[i] == <span class="hljs-string">&#x27;1&#x27;</span> ? tmp1 : <span class="hljs-number">0</span>)) % mod;<br>            tmp1 *= <span class="hljs-number">131</span>;<br>            tmp1 %= mod;<br><br>            a[i + <span class="hljs-number">1</span>] = a[i] + str[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            b2[i + <span class="hljs-number">1</span>] = (b2[i] + (str[i] == <span class="hljs-string">&#x27;1&#x27;</span> ? tmp2 : <span class="hljs-number">0</span>)) % mod;<br>            tmp2 *= <span class="hljs-number">1331</span>;<br>            tmp2 %= mod;<br>        &#125;<br><br>        set&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            <span class="hljs-type">int</span> l, r;<br>            cin &gt;&gt; l &gt;&gt; r;<br><br>            <span class="hljs-type">int</span> ls, rs;<br>            &#123;<br>                <span class="hljs-type">int</span> left = b1[l - <span class="hljs-number">1</span>] % mod;<br>                <span class="hljs-type">int</span> right = (b1[n] - b1[r] + mod) % mod;<br>                <span class="hljs-type">int</span> one = a[r] - a[l - <span class="hljs-number">1</span>];<br>                <span class="hljs-type">int</span> zero = r - l + <span class="hljs-number">1</span> - one;<br>                <span class="hljs-type">int</span> from = l + zero, to = r;<br>                <span class="hljs-type">int</span> mid = (pw1[to] - pw1[from - <span class="hljs-number">1</span>] + mod) % mod;<br>                ls = (left + right + mid) % mod;<br>            &#125;<br>            &#123;<br>                <span class="hljs-type">int</span> left = b2[l - <span class="hljs-number">1</span>] % mod;<br>                <span class="hljs-type">int</span> right = (b2[n] - b2[r] + mod) % mod;<br>                <span class="hljs-type">int</span> one = a[r] - a[l - <span class="hljs-number">1</span>];<br>                <span class="hljs-type">int</span> zero = r - l + <span class="hljs-number">1</span> - one;<br>                <span class="hljs-type">int</span> from = l + zero, to = r;<br>                <span class="hljs-type">int</span> mid = (pw2[to] - pw2[from - <span class="hljs-number">1</span>] + mod) % mod;<br>                rs = (left + right + mid) % mod;<br>            &#125;<br>            res.<span class="hljs-built_in">insert</span>(&#123;ls, rs&#125;);<br>        &#125;<br><br>        cout &lt;&lt; res.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Array-Painting"><a href="#D-Array-Painting" class="headerlink" title="D. Array Painting"></a>D. Array Painting</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一段数组 $a$，每个值必定是 $0, 1, 2$ 其中一个，开始的时候所有值都是蓝色的，你可以进行如下操作</p><ul><li>选择一个蓝色的值，把它变成红色，同时支付一块钱</li><li>选择一个红色的值，若其大于 $0$，则将其减少 $1$，并将一个相邻它的值改为红色</li></ul><p>问，你最少需要支付多少钱才能把所有值变成红色</p><h2 id="大致思路"><a href="#大致思路" class="headerlink" title="大致思路"></a>大致思路</h2><p>容易明白的是，无论如何先随便找个 $2$ 染色的一定不亏，然后这个 $2$ 就会向两侧染色，直到遇到 $0$。那么这样处理完成后，再找下一个没有被染色的 $2$，直到 $2$ 被全部耗尽</p><p>然后是 $0, 1$ 的问题了，很明显的是，在一段连续没有被染色的区间下，可以分类讨论</p><ul><li>如果只有 $1$，那么恭喜，染色一个端点，就可以染色全部</li><li>如果只有 $0$，那么就得一个个染色</li><li>如果同时有 $1$ 和 $0$<ul><li>因为每一段连续的 $1$ 可以附带染色一个相邻的 $0$，实际上操作几个 $1$ 等于也染色了几个 $0$，所以最终结果一般还是得跟 $0$ 数量相同</li><li>但是从第一条种可以得到，因为一段 $1$ 就得花费一次染色，不能只看 $0$ 的数量，例如 $101$ 这种情况下，虽然只有一个 $0$，但是 $1$ 有两端，则至少需要染色 $2$ 次（实际上就是因为第二段 $1$ 不会染色任何其他 $0$）</li></ul></li></ul><p>所以结论为，每一段没有染色的区间，需要 $max(cnt_0, cnt_part1)$ 的花费</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span></span>;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cin &gt;&gt; data[i];<br><br>    <span class="hljs-comment">// 先处理 2 的情况</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (vis[i] || data[i] != <span class="hljs-number">2</span>) <span class="hljs-keyword">continue</span>;<br>        res++;<br>        vis[i] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>            <span class="hljs-keyword">if</span> (!vis[j]) &#123;<br>                vis[j] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span> (data[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (; i &lt; n; ++i) &#123;<br>            vis[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (data[i] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 再处理 1 的情况</span><br>    <span class="hljs-type">int</span> last = <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> zero = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> oneP = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (vis[i]) &#123;<br>            res += <span class="hljs-built_in">max</span>(oneP, zero);<br>            zero = <span class="hljs-number">0</span>;<br>            oneP = <span class="hljs-number">0</span>;<br>            last = <span class="hljs-number">-1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data[i] == <span class="hljs-number">0</span>) &#123;<br>            zero++;<br>            last = <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (last != <span class="hljs-number">1</span>) &#123;<br>            last = <span class="hljs-number">1</span>;<br>            oneP++;<br>        &#125;<br>    &#125;<br>    res += <span class="hljs-built_in">max</span>(oneP, zero);<br><br>    cout &lt;&lt; res &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round#889 (Div. 2)</title>
    <link href="/2023/08/05/acm/codeforces/CodeforcesRound889/"/>
    <url>/2023/08/05/acm/codeforces/CodeforcesRound889/</url>
    
    <content type="html"><![CDATA[<p><strong>退役入职后的首次刷题，确实感觉对题目的敏感度下降了很多</strong></p><h1 id="A-Dalton-the-Teacher"><a href="#A-Dalton-the-Teacher" class="headerlink" title="A. Dalton the Teacher"></a>A. Dalton the Teacher</h1><h2 id="题面概要"><a href="#题面概要" class="headerlink" title="题面概要"></a>题面概要</h2><p>有一个长度为 $n$ 的打乱序列 $a$，每次操作可以将 $a[i]$ 和 $a[j]$ 进行交换位置，问至少多少次操作才能让满足 $\forall i \in [1, n], i \ne a[i]$</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>因为每次操作会影响到两个位置的值，而本身已经满足条件的可以不用操作，故结果就是 $\left \lceil x / 2 \right \rceil $ 其中 $x$ 为仍然不满足条件的位置数量</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            <span class="hljs-keyword">if</span> (tmp == i + <span class="hljs-number">1</span>) cnt++;<br>        &#125;<br>        cout &lt;&lt; (cnt + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Longest-Divisors-Interval"><a href="#B-Longest-Divisors-Interval" class="headerlink" title="B. Longest Divisors Interval"></a>B. Longest Divisors Interval</h1><h2 id="题面概要-1"><a href="#题面概要-1" class="headerlink" title="题面概要"></a>题面概要</h2><p>一个大的整数 $n$，找到一个区间 $[l, r]$，满足 $\forall x \in [l, r], n \space mod \space x = 0$，求出最大的 $r - l + 1$</p><h2 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h2><p>因为一连串的数字，很容易产生很多大量的互质数，导致如果要满足条件的话，则需要非常非常大的值。因此，考虑互质数出现频率最低的区间，即从 $1$ 开始的区间，可以用测试代码得到，$[1, 100]$ 的情况下，目标值最小为 $9223372036854775807$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; cnt;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">100</span>; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i / <span class="hljs-number">2</span>; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (i % j == <span class="hljs-number">0</span>) &#123;<br>                cnt[j]++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> item : cnt) &#123;<br>        res *= <span class="hljs-built_in">pow</span>(item.first, item.second);<br>    &#125;<br>    cout &lt;&lt; res &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以最大区间长度不可能超过 100</p><p>我们假定此区间为 $[l, r]$，满足 $r - l + 1 = n$，那么我们容易得到，$\forall i \in [1, n], \exists j \in [l, r], j % i == 0$</p><p>而这个公式说明了，假定存在 $[l, r], l \ne 1$ 满足 $\forall x \in [l, r], n mod x = 0$上述条件，那么同时必然满足 $\forall x \in [1, r - l + 1], n mod x = 0$</p><p>所以我们只需要考虑从 $1$ 开始的区间内，最大能够满足到哪个值即可，此时得到的一定是最优解</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">100</span>; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) &#123;<br>                cnt++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; cnt &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C2-Dual-Hard-Version"><a href="#C2-Dual-Hard-Version" class="headerlink" title="C2. Dual (Hard Version)"></a>C2. Dual (Hard Version)</h1><p>题意完全一致，就直接做 Hard Version 了</p><h2 id="题面概要-2"><a href="#题面概要-2" class="headerlink" title="题面概要"></a>题面概要</h2><p>有 $n (n \leq 20)$ 个值的序列 $a$，每个值都在 $[-20, 20]$ 内，每次操作可以选择任意两个值，进行 $a[i] += a[j], i \in [1, n], j \in [1, n]$。求出一种可行的解，最多进行 31 次操作，使得整个序列不存在非递减对，即满足 $\forall i \in [1, n - 1], a[i] \leq a[i + 1]$</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最简单的方式就是将所有值变成非负数，做一次前缀和，或者所有值变成非正数，然后做一次后缀和。两种方案思路是完全相同的，最差情况下都需要 $n - 1$ 步操作</p><p>接下来就是需要考虑如何将所有值变成非负数（非正数，下同，后续只强调非负数）</p><p>如果需要将所有值变成非负数，前提是必须要有一个正数（不考虑都是 0 的情况，可以特判解决），需要在这个前提下考虑才有意义</p><p>那么最简单的方式就是将最大的正数通过累加的方式实现幂次放大，直到和最小值相加也能满足大于等于 $0$ 即可。此时可以得到最终需要的操作数：$n - 1 + \left \lceil log_2 \frac{abs(maxValue)}{abs(minValue)} \right \rceil + cnt_-$（其中的 $cnt_-$ 表示负数个数）</p><p>同样，可以得到非正数需要的操作数 $n-1+\left \lceil log_2 \frac{abs(minValue)}{abs(maxValue)} \right \rceil + cnt_+$（其中的 $cnt_+$ 表示负数个数）</p><p>最终，我们可以取其中的较小值，得到公式</p>$$\begin{align}= & min(n - 1 + \left \lceil log_2 \frac{abs(maxValue)}{abs(minValue)} \right \rceil + cnt_-, n - 1 + \left \lceil log_2 \frac{abs(minValue)}{abs(maxValue)} \right \rceil + cnt_+) \\\leq & n - 1 + min(\left \lceil log_2 \frac{abs(maxValue)}{abs(minValue)} \right \rceil + cnt_-, \left \lceil log_2 \frac{abs(minValue)}{abs(maxValue)} \right \rceil + n - cnt_-) \\= & n - 1 + min(\left \lceil log_2 abs(maxValue) - log_2 abs(minValue) \right \rceil + cnt_-, \left \lceil log_2 abs(minValue) - log_2 abs(maxValue) \right \rceil + n - cnt_-) \\= & \begin{cases}n - 1 + min(\left \lceil log_2 abs(maxValue) - log_2 abs(minValue) \right \rceil + cnt_-, 0 + n - cnt_-), abs(maxValue) >= abs(minValue) \\n - 1 + min(0 + cnt_-, \left \lceil log_2 abs(minValue) - log_2 abs(maxValue) \right \rceil + n - cnt_-), abs(maxValue) <= abs(minValue)\end{cases} \\\leq & \begin{cases}n - 1 + min(5 + cnt_-, 0 + n - cnt_-)\\n - 1 + min(0 + cnt_-, 5 + n - cnt_-)\end{cases} \because max(log_2 abs(maxValue) - log_2 abs(minValue)) = max(log_2 abs(minValue) - log_2 abs(maxValue)) \leq 5(2^5 = 32 > 20) \\\leq & \begin{cases}20 - 1 + min(5 + cnt_-, 20 - cnt_-) \\20 - 1 + min(cnt_-, 5 + 20 - cnt_-)\end{cases} \\= & \begin{cases}19 + min(5 + cnt_-, 20 - cnt_-) \\19 + min(cnt_-, 25 - cnt_-)\end{cases} \\\leq & \begin{cases}19 + 12 \\19 + 12\end{cases} \because \left \lceil cnt_- \right \rceil = cnt_- \\= & 31\end{align}$$<p>求的上述方法最大操作次数一定满足要求</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cin &gt;&gt; data[i];<br><br>        <span class="hljs-type">int</span> maxIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> minIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> maxValue = data[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> minValue = data[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (maxValue &lt;= data[i]) &#123;<br>                maxValue = data[i];<br>                maxIndex = i;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (minValue &gt; data[i]) &#123;<br>                minValue = data[i];<br>                minIndex = i;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (maxValue == minValue) &#123;<br>            cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (maxValue &gt; <span class="hljs-number">0</span>) &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; copy = data;<br>            vector&lt;pair&lt;<span class="hljs-type">signed</span>, <span class="hljs-type">signed</span>&gt;&gt; op;<br>            <span class="hljs-keyword">while</span> (maxValue + minValue &lt; <span class="hljs-number">0</span>) &#123;<br>                copy[maxIndex] += maxValue;<br>                maxValue += maxValue;<br>                op.<span class="hljs-built_in">emplace_back</span>(maxIndex, maxIndex);<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; copy.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>                <span class="hljs-keyword">if</span> (copy[i] &lt; <span class="hljs-number">0</span>) &#123;<br>                    copy[i] += maxValue;<br>                    op.<span class="hljs-built_in">emplace_back</span>(i, maxIndex);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; copy.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>                <span class="hljs-keyword">if</span> (copy[i] &lt; copy[i - <span class="hljs-number">1</span>]) &#123;<br>                    copy[i] += copy[i - <span class="hljs-number">1</span>];<br>                    op.<span class="hljs-built_in">emplace_back</span>(i, i - <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (op.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">31</span>) &#123;<br>                cout &lt;&lt; op.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> o : op) &#123;<br>                    cout &lt;&lt; o.first + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; o.second + <span class="hljs-number">1</span> &lt;&lt; endl;<br>                &#125;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (minValue &lt; <span class="hljs-number">0</span>) &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; copy = data;<br>            vector&lt;pair&lt;<span class="hljs-type">signed</span>, <span class="hljs-type">signed</span>&gt;&gt; op;<br>            <span class="hljs-keyword">while</span> (maxValue + minValue &gt; <span class="hljs-number">0</span>) &#123;<br>                copy[minIndex] += minValue;<br>                minValue += minValue;<br>                op.<span class="hljs-built_in">emplace_back</span>(minIndex, minIndex);<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; copy.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>                <span class="hljs-keyword">if</span> (copy[i] &gt; <span class="hljs-number">0</span>) &#123;<br>                    copy[i] += minValue;<br>                    op.<span class="hljs-built_in">emplace_back</span>(i, minIndex);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = (<span class="hljs-type">int</span>)copy.<span class="hljs-built_in">size</span>() - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>                <span class="hljs-keyword">if</span> (copy[i] &gt; copy[i + <span class="hljs-number">1</span>]) &#123;<br>                    copy[i] += copy[i + <span class="hljs-number">1</span>];<br>                    op.<span class="hljs-built_in">emplace_back</span>(i, i + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (op.<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">31</span>) &#123;<br>                cout &lt;&lt; op.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> o : op) &#123;<br>                    cout &lt;&lt; o.first + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; o.second + <span class="hljs-number">1</span> &lt;&lt; endl;<br>                &#125;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Earn-or-Unlock"><a href="#D-Earn-or-Unlock" class="headerlink" title="D. Earn or Unlock"></a>D. Earn or Unlock</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组 $a$，长度为 $n$，其中所有数字都是锁定状态，仅第一个（最左边的）是解锁状态。</p><p>你必须从左往右遍历这个数组，然后对于当前的值，如果是锁定状态，则结束，否则你可以选择</p><ol><li>获得等同于当前值的分数</li><li>从左往右依次解锁 m 张锁定状态的值，m 为当前值，直到所有值都被解锁</li></ol><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>假如最终解锁了 x 个值（数组长度无限的情况下考虑）那么最终的分数为 $prefixSum(x) - x + 1$，因为有 $x - 1$ 的分数被用来解锁了</p><p>可以发现，如果能够明确最终解锁的位置，那么就可以确定分数，而并不需要去关注到底哪些值用来解锁了，哪些值用来记分了</p><p>考虑 dp 的方式解决，定义 <code>dp[i]</code> 表示从第一位到第 $i$ 位时，能够解锁 <code>dp[i]</code> 内的所有位置的集合，那么可以得到状态转移公式 $dp[i + 1] = dp[i] \cup (dp[i] + a[i]) - i$，即下一个位置能够解锁到的位置就是当前能够解锁到的位置<em>并</em>如果当前值作为解锁使用能够到达的位置，再去除掉当前位置，毕竟不能回头走</p><p>由于可以解锁过头，为了方便计算，故需要 dp 的范围是 $max(a[i]) + n$</p><p>用 <code>bitset</code> 维护最终可以解锁到的位置即可</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cin &gt;&gt; data[i];<br><br>    bitset&lt;N&gt; bit;<br>    bit.<span class="hljs-built_in">set</span>(<span class="hljs-number">0</span>, <span class="hljs-literal">true</span>);<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> prefix = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n * <span class="hljs-number">2</span>; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; n) &#123;<br>            prefix += data[i];<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (bit.<span class="hljs-built_in">test</span>(i)) &#123;<br>            res = <span class="hljs-built_in">max</span>(res, prefix - i);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (i &lt; n) &#123;<br>            bit |= bit &lt;&lt; data[i];<br>            bit.<span class="hljs-built_in">set</span>(i, <span class="hljs-literal">false</span>);<br>        &#125;<br>    &#125;<br><br>    cout &lt;&lt; res &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java Script 的 null 和 undefined 随想</title>
    <link href="/2022/08/29/thoughts/java-script-null-undefine/"/>
    <url>/2022/08/29/thoughts/java-script-null-undefine/</url>
    
    <content type="html"><![CDATA[<p>有些时候感觉一些语言里看起来很蠢的设计，实际上却能解决一些很有意思的场景。比如 JavaScript 的 null 和 undefined，虽然看起来都是表示空的意思，但是实际上却解决了“没有这个值”，“这个值为空”这样两种语义。在缓存穿透的问题上，如果 redis、memcached 等数据库也有这样一层设计等话，是不是就能解决 null 穿透问题了呢</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随想</tag>
      
      <tag>缓存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次 SQL LEFT JOIN 没有得到预期结果的错误</title>
    <link href="/2022/05/29/develop-note/sql-left-join-fail/"/>
    <url>/2022/05/29/develop-note/sql-left-join-fail/</url>
    
    <content type="html"><![CDATA[<p>最近在业务中做数据开发的时候，写了一个 SQL 但是没有得到预期的结果，大致如下</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">表 a</span><br><span class="hljs-section">+----+------+-----+</span><br><span class="hljs-section">| id | name | tid |</span><br><span class="hljs-section">+----+------+-----+</span><br><span class="hljs-section">|  1 |  aaa | 101 |</span><br><span class="hljs-section">+----+------+-----+</span><br><span class="hljs-section">|  2 |  bbb | 102 |</span><br><span class="hljs-section">+----+------+-----+</span><br><span class="hljs-section">|  3 |  ccc | 103 |</span><br><span class="hljs-section">+----+------+-----+</span><br></code></pre></td></tr></table></figure><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">表 b</span><br><span class="hljs-section">+------+------+-------+</span><br><span class="hljs-section">|   id | nick |  type |</span><br><span class="hljs-section">+------+------+-------+</span><br><span class="hljs-section">| 1001 |  abc | false |</span><br><span class="hljs-section">+------+------+-------+</span><br><span class="hljs-section">| 1002 |  edf |  true |</span><br><span class="hljs-section">+------+------+-------+</span><br><span class="hljs-section">| 1003 |  xyz |  true |</span><br><span class="hljs-section">+------+------+-------+</span><br></code></pre></td></tr></table></figure><p>然后圈选的 SQL 的为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>    a.name<br>    b.nick<br><span class="hljs-keyword">FROM</span><br>    a<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span><br>    b<br><span class="hljs-keyword">ON</span><br>    a.tid <span class="hljs-operator">=</span> b.id<br><span class="hljs-keyword">WHERE</span><br>    b.type <span class="hljs-operator">=</span> &quot;true&quot;<br>;<br></code></pre></td></tr></table></figure><p>本意上，通过 <code>LEFT JOIN</code> ，即使没有找到，也应该正常返回数据，但是实际上没有返回任何数据</p><p>因为 WHERE 条件是在 <code>JOIN</code> 之后发生的，所以实际上，因为 <code>LEFT JOIN</code> 拿不到数据，所以所有列的 <code>b.type</code> 都是 <code>NULL</code>，当然就不是 <code>true</code></p><p>此时可以拆分这两个条件，例如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-variable">@true_b</span> :<span class="hljs-operator">=</span><br><span class="hljs-keyword">SELECT</span><br>    id,<br>    nick<br><span class="hljs-keyword">FROM</span><br>    b<br><span class="hljs-keyword">WHERE</span><br>    type <span class="hljs-operator">=</span> &quot;true&quot;<br>;<br><br>SELCT<br>    a.name<br>    c.nick<br><span class="hljs-keyword">FROM</span><br>    a<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span><br>    <span class="hljs-variable">@true_b</span> c<br><span class="hljs-keyword">ON</span><br>    a.tid <span class="hljs-operator">=</span> c.id<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round#789(Div. 2)</title>
    <link href="/2022/05/27/acm/codeforces/CodeforcesRound789-B2.%20Tokitsukaze%20and%20Good%2001-String%20(hard%20version)/"/>
    <url>/2022/05/27/acm/codeforces/CodeforcesRound789-B2.%20Tokitsukaze%20and%20Good%2001-String%20(hard%20version)/</url>
    
    <content type="html"><![CDATA[<h1 id="B2-Tokitsukaze-and-Good-01-String-hard-version"><a href="#B2-Tokitsukaze-and-Good-01-String-hard-version" class="headerlink" title="B2. Tokitsukaze and Good 01-String (hard version)"></a>B2. Tokitsukaze and Good 01-String (hard version)</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一段 01 组成的字符串，保证长度为偶数</p><p>你可以选择一个 0 或者 1，将其变为 1 或者 0</p><p>问至少需要操作几次，可以使得所有的 0 或者 1 段都为偶数长度。同时，此时，最少有多少段单独段 0 或 1 段</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先，因为总长度为偶数，所以奇数段一定是成对出现的，可以简单讨论五种情况</p><ul><li>改变一个奇数段内部，可以生成两个偶数段一个奇数段</li><li>改变一个偶数段内部，可以生成两个奇数段和一个偶数段</li><li>改变两个偶数段边缘，可以生成两个奇数段</li><li>改变两个奇数段边缘，可以生成两个偶数段</li><li>改变奇偶段边缘，可以交换奇偶关系</li></ul><p>这几种方法中，只有改变两个奇数段边缘是有意义的，但是并不一定每次都那么好运。所以必须选择一种方法去将两个离得很远的奇数段靠近</p><p>明显只有第一个和最后一个可选，在不产生新的奇数段的前提下改变位置。但是第一个明显有点蠢……因为生成的奇数段在原奇数段内部（仅一个 0 或者 1），所以只能选最后一种方案</p><p>所以我们需要选择两个奇数段，然后通过方法五将它们贴近到相邻，然后再用方法四消灭它们，所需要的数量也就是奇数段之间的偶数段个数 + 1</p><p>数量解决了，接下来就是分配如何变化使得数量最少了。因为对于每一个奇数段而言，只会改变一个，而对于偶数段而言，两侧边缘都需要发生变化，所以</p><p>当奇数段的长度为 1 的时候，变化此奇数段，当偶数段长度为 2 的时候，左右两侧都变化此偶数段。然后再统计不同的奇偶段数量即可</p><h2 id="AC-Code"><a href="#AC-Code" class="headerlink" title="AC Code"></a>AC Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        string str;<br>        str.<span class="hljs-built_in">resize</span>(n);<br>        cin &gt;&gt; str;<br>        vector&lt;<span class="hljs-type">int</span>&gt; st;<br>        <span class="hljs-type">char</span> last = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (str[i] == last) &#123;<br>                st.<span class="hljs-built_in">back</span>()++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                st.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>                last = str[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> isOdd = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; st.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (st[i] % <span class="hljs-number">2</span>) &#123;<br>                isOdd = !isOdd;<br>                <span class="hljs-keyword">if</span> (st[i] == <span class="hljs-number">1</span>) st[i] = <span class="hljs-number">0</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isOdd) &#123;<br>                <span class="hljs-keyword">if</span> (st[i] == <span class="hljs-number">2</span>) st[i] = <span class="hljs-number">0</span>;<br>            &#125;<br>            ans += isOdd;<br>        &#125;<br>        <span class="hljs-type">int</span> ls = <span class="hljs-number">-1</span>, cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; st.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            <span class="hljs-keyword">if</span> (st[i] == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (ls != (i % <span class="hljs-number">2</span>)) &#123;<br>                ls = i % <span class="hljs-number">2</span>;<br>                cnt++;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-built_in">max</span>(<span class="hljs-number">1LL</span>, cnt) &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios_base::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ACM_LOCAL</span><br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;in.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;out.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br>    <span class="hljs-type">signed</span> localTestCount = <span class="hljs-number">1</span>, localReadPos = (<span class="hljs-type">signed</span>) cin.<span class="hljs-built_in">tellg</span>();<br>    <span class="hljs-type">char</span> localTryReadChar;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">if</span> (localTestCount &gt; <span class="hljs-number">20</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Check the std input!!!&quot;</span>);<br>        <span class="hljs-keyword">auto</span> startClockForDebug = <span class="hljs-built_in">clock</span>();<br>        <span class="hljs-built_in">solve</span>();<br>        <span class="hljs-keyword">auto</span> endClockForDebug = <span class="hljs-built_in">clock</span>();<br>        cerr &lt;&lt; <span class="hljs-string">&quot;Test &quot;</span> &lt;&lt; localTestCount++ &lt;&lt; <span class="hljs-string">&quot; Run Time: &quot;</span><br>             &lt;&lt; <span class="hljs-built_in">double</span>(endClockForDebug - startClockForDebug) / CLOCKS_PER_SEC &lt;&lt; <span class="hljs-string">&quot;s&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">//        cout &lt;&lt; &quot;Test &quot; &lt;&lt; localTestCount &lt;&lt; &quot; successful&quot; &lt;&lt; endl;</span><br><span class="hljs-comment">//        cout &lt;&lt; &quot;--------------------------------------------------&quot; &lt;&lt; endl;</span><br>    &#125; <span class="hljs-keyword">while</span> (localReadPos != cin.<span class="hljs-built_in">tellg</span>() &amp;&amp; cin &gt;&gt; localTryReadChar &amp;&amp; localTryReadChar != <span class="hljs-string">&#x27;$&#x27;</span> &amp;&amp;<br>             cin.<span class="hljs-built_in">putback</span>(localTryReadChar));<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-built_in">solve</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GCC/G++ 预编译头性能优化</title>
    <link href="/2022/04/30/cpp/gcc-precompile/"/>
    <url>/2022/04/30/cpp/gcc-precompile/</url>
    
    <content type="html"><![CDATA[<p>最近一直在搞 OJ，为了一个高效的、安全的沙盒编译环境操碎了心，终于实现了一个安全的且对运行影响非常低的沙盒，但是发现程序的编译效率非常的低。</p><p>最后通过查阅各种的博客，终于发现了一个非常高效的解决方案</p><h1 id="万能头文件问题"><a href="#万能头文件问题" class="headerlink" title="万能头文件问题"></a>万能头文件问题</h1><p>在 OJ 的任务中，很多 ACMer 为了方便起见，经常使用万能头文件 <code>bits/stdc++.h</code>。</p><p>当然这个头文件之前也惹过一次麻烦，就是著名的银川线上赛的 5 元学生机 OJ 事件，使用了 <code>bits/stdc++.h</code> 的编译效率非常低，因为这个头文件本身包含了太多的东西，罗列如下</p><p>（推荐直接点目录跳转到下一章）</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">. <span class="hljs-string">/usr/include/x86_64-linux-gnu/c</span>++<span class="hljs-string">/7/bits/stdc</span>++<span class="hljs-string">.h</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cassert</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/c</span>++<span class="hljs-string">/7/bits/c</span>++config.h<br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/c</span>++<span class="hljs-string">/7/bits/os_defines.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/features.h</span><br><span class="hljs-string">......</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/sys/cdefs.h</span><br><span class="hljs-string">.......</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/wordsize.h</span><br><span class="hljs-string">.......</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/long-double.h</span><br><span class="hljs-string">......</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/gnu/stubs.h</span><br><span class="hljs-string">.......</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/gnu/stubs-64.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/c</span>++<span class="hljs-string">/7/bits/cpu_defines.h</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/assert.h</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cctype</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/ctype.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/types.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/wordsize.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/typesizes.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/endian.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/endian.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/byteswap.h</span><br><span class="hljs-string">......</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/wordsize.h</span><br><span class="hljs-string">......</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/byteswap-16.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/uintn-identity.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/types/locale_t.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cerrno</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/errno.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/errno.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/linux/errno.h</span><br><span class="hljs-string">......</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/asm/errno.h</span><br><span class="hljs-string">.......</span> <span class="hljs-string">/usr/include/asm-generic/errno.h</span><br><span class="hljs-string">........</span> <span class="hljs-string">/usr/include/asm-generic/errno-base.h</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cfloat</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/lib/gcc/x86_64-linux-gnu/7/include/float.h</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/ciso646</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/climits</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/limits.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/syslimits.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/lib/gcc/x86_64-linux-gnu/7/include-fixed/limits.h</span><br><span class="hljs-string">......</span> <span class="hljs-string">/usr/include/limits.h</span><br><span class="hljs-string">.......</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/libc-header-start.h</span><br><span class="hljs-string">.......</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/posix1_lim.h</span><br><span class="hljs-string">........</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/local_lim.h</span><br><span class="hljs-string">.........</span> <span class="hljs-string">/usr/include/linux/limits.h</span><br><span class="hljs-string">.......</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/posix2_lim.h</span><br><span class="hljs-string">.......</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/xopen_lim.h</span><br><span class="hljs-string">........</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/uio_lim.h</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/clocale</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/locale.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/locale.h</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cmath</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/cpp_type_traits.h</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/ext/type_traits.h</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/math.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/libc-header-start.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/math-vector.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/libm-simd-decl-stubs.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/floatn.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/floatn-common.h</span><br><span class="hljs-string">......</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/long-double.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/flt-eval-method.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/fp-logb.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/fp-fast.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/mathcalls.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/mathcalls.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/mathcalls.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/mathcalls.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/mathcalls.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/mathcalls.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/mathcalls.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/mathcalls.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/iscanonical.h</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/std_abs.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/stdlib.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/libc-header-start.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/waitflags.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/waitstatus.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/sys/types.h</span><br><span class="hljs-string">......</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/types/clock_t.h</span><br><span class="hljs-string">......</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h</span><br><span class="hljs-string">......</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/types/time_t.h</span><br><span class="hljs-string">......</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/types/timer_t.h</span><br><span class="hljs-string">......</span> <span class="hljs-string">/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h</span><br><span class="hljs-string">......</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/stdint-intn.h</span><br><span class="hljs-string">......</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/sys/select.h</span><br><span class="hljs-string">.......</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/select.h</span><br><span class="hljs-string">........</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/wordsize.h</span><br><span class="hljs-string">.......</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h</span><br><span class="hljs-string">........</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h</span><br><span class="hljs-string">.......</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h</span><br><span class="hljs-string">.......</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h</span><br><span class="hljs-string">......</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/sys/sysmacros.h</span><br><span class="hljs-string">.......</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/sysmacros.h</span><br><span class="hljs-string">......</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h</span><br><span class="hljs-string">.......</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h</span><br><span class="hljs-string">........</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h</span><br><span class="hljs-string">.........</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/wordsize.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/alloca.h</span><br><span class="hljs-string">......</span> <span class="hljs-string">/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/stdlib-float.h</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/csetjmp</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/setjmp.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/setjmp.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/wordsize.h</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/csignal</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/signal.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/signum.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/signum-generic.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/types/sig_atomic_t.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/wordsize.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/siginfo-arch.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/siginfo-consts-arch.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/types/sigval_t.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/wordsize.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/sigaction.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/sigcontext.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/types/stack_t.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/sys/ucontext.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/sigstack.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/ss_flags.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/types/struct_sigstack.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/sigthread.h</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cstdarg</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/lib/gcc/x86_64-linux-gnu/7/include/stdarg.h</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cstddef</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cstdio</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/stdio.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/libc-header-start.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/types/__FILE.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/types/FILE.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/libio.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/_G_config.h</span><br><span class="hljs-string">......</span> <span class="hljs-string">/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h</span><br><span class="hljs-string">......</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/stdio_lim.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/sys_errlist.h</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cstdlib</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cstring</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/string.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/libc-header-start.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/strings.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/ctime</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/time.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/time.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/timex.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/ccomplex</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/complex</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cmath</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/sstream</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/istream</span><br><span class="hljs-string">......</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/ios</span><br><span class="hljs-string">.......</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/iosfwd</span><br><span class="hljs-string">........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/stringfwd.h</span><br><span class="hljs-string">.........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/memoryfwd.h</span><br><span class="hljs-string">........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/postypes.h</span><br><span class="hljs-string">.........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cwchar</span><br><span class="hljs-string">..........</span> <span class="hljs-string">/usr/include/wchar.h</span><br><span class="hljs-string">...........</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/libc-header-start.h</span><br><span class="hljs-string">...........</span> <span class="hljs-string">/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h</span><br><span class="hljs-string">...........</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/wchar.h</span><br><span class="hljs-string">...........</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/types/wint_t.h</span><br><span class="hljs-string">...........</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/types/mbstate_t.h</span><br><span class="hljs-string">.......</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/exception</span><br><span class="hljs-string">........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/exception.h</span><br><span class="hljs-string">........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/exception_ptr.h</span><br><span class="hljs-string">.........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/exception_defines.h</span><br><span class="hljs-string">.........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/cxxabi_init_exception.h</span><br><span class="hljs-string">..........</span> <span class="hljs-string">/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h</span><br><span class="hljs-string">.........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/typeinfo</span><br><span class="hljs-string">..........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/hash_bytes.h</span><br><span class="hljs-string">.........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/new</span><br><span class="hljs-string">..........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/exception</span><br><span class="hljs-string">........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/nested_exception.h</span><br><span class="hljs-string">.........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/move.h</span><br><span class="hljs-string">..........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/concept_check.h</span><br><span class="hljs-string">..........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/type_traits</span><br><span class="hljs-string">.......</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/char_traits.h</span><br><span class="hljs-string">........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/stl_algobase.h</span><br><span class="hljs-string">.........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/functexcept.h</span><br><span class="hljs-string">.........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/ext/numeric_traits.h</span><br><span class="hljs-string">.........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/stl_pair.h</span><br><span class="hljs-string">.........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/stl_iterator_base_types.h</span><br><span class="hljs-string">.........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/stl_iterator_base_funcs.h</span><br><span class="hljs-string">..........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/debug/assertions.h</span><br><span class="hljs-string">.........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/stl_iterator.h</span><br><span class="hljs-string">..........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/ptr_traits.h</span><br><span class="hljs-string">.........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/debug/debug.h</span><br><span class="hljs-string">.........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/predefined_ops.h</span><br><span class="hljs-string">........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cwchar</span><br><span class="hljs-string">........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cstdint</span><br><span class="hljs-string">.........</span> <span class="hljs-string">/usr/lib/gcc/x86_64-linux-gnu/7/include/stdint.h</span><br><span class="hljs-string">..........</span> <span class="hljs-string">/usr/include/stdint.h</span><br><span class="hljs-string">...........</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/libc-header-start.h</span><br><span class="hljs-string">...........</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/wordsize.h</span><br><span class="hljs-string">...........</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h</span><br><span class="hljs-string">.......</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/localefwd.h</span><br><span class="hljs-string">........</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/c</span>++<span class="hljs-string">/7/bits/c</span>++locale.h<br><span class="hljs-string">.........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/clocale</span><br><span class="hljs-string">........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cctype</span><br><span class="hljs-string">.......</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/ios_base.h</span><br><span class="hljs-string">........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/ext/atomicity.h</span><br><span class="hljs-string">.........</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/c</span>++<span class="hljs-string">/7/bits/gthr.h</span><br><span class="hljs-string">..........</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/c</span>++<span class="hljs-string">/7/bits/gthr-default.h</span><br><span class="hljs-string">...........</span> <span class="hljs-string">/usr/include/pthread.h</span><br><span class="hljs-string">............</span> <span class="hljs-string">/usr/include/sched.h</span><br><span class="hljs-string">.............</span> <span class="hljs-string">/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h</span><br><span class="hljs-string">.............</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/sched.h</span><br><span class="hljs-string">.............</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/cpu-set.h</span><br><span class="hljs-string">............</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/wordsize.h</span><br><span class="hljs-string">.........</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/c</span>++<span class="hljs-string">/7/bits/atomic_word.h</span><br><span class="hljs-string">........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/locale_classes.h</span><br><span class="hljs-string">.........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/string</span><br><span class="hljs-string">..........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/allocator.h</span><br><span class="hljs-string">...........</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/c</span>++<span class="hljs-string">/7/bits/c</span>++allocator.h<br><span class="hljs-string">............</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/ext/new_allocator.h</span><br><span class="hljs-string">..........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/ostream_insert.h</span><br><span class="hljs-string">...........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/cxxabi_forced.h</span><br><span class="hljs-string">..........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/stl_function.h</span><br><span class="hljs-string">...........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/backward/binders.h</span><br><span class="hljs-string">..........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/range_access.h</span><br><span class="hljs-string">...........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/initializer_list</span><br><span class="hljs-string">..........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/basic_string.h</span><br><span class="hljs-string">...........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/ext/alloc_traits.h</span><br><span class="hljs-string">............</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/alloc_traits.h</span><br><span class="hljs-string">...........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/ext/string_conversions.h</span><br><span class="hljs-string">............</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cstdlib</span><br><span class="hljs-string">............</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cwchar</span><br><span class="hljs-string">............</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cstdio</span><br><span class="hljs-string">............</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cerrno</span><br><span class="hljs-string">...........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/functional_hash.h</span><br><span class="hljs-string">..........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/basic_string.tcc</span><br><span class="hljs-string">.........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/locale_classes.tcc</span><br><span class="hljs-string">........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/system_error</span><br><span class="hljs-string">.........</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/c</span>++<span class="hljs-string">/7/bits/error_constants.h</span><br><span class="hljs-string">..........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cerrno</span><br><span class="hljs-string">.........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/stdexcept</span><br><span class="hljs-string">.......</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/streambuf</span><br><span class="hljs-string">........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/streambuf.tcc</span><br><span class="hljs-string">.......</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/basic_ios.h</span><br><span class="hljs-string">........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/locale_facets.h</span><br><span class="hljs-string">.........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cwctype</span><br><span class="hljs-string">..........</span> <span class="hljs-string">/usr/include/wctype.h</span><br><span class="hljs-string">...........</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/wctype-wchar.h</span><br><span class="hljs-string">.........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cctype</span><br><span class="hljs-string">.........</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/c</span>++<span class="hljs-string">/7/bits/ctype_base.h</span><br><span class="hljs-string">.........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/streambuf_iterator.h</span><br><span class="hljs-string">.........</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/c</span>++<span class="hljs-string">/7/bits/ctype_inline.h</span><br><span class="hljs-string">.........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/locale_facets.tcc</span><br><span class="hljs-string">........</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/basic_ios.tcc</span><br><span class="hljs-string">......</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/ostream</span><br><span class="hljs-string">.......</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/ostream.tcc</span><br><span class="hljs-string">......</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/istream.tcc</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/sstream.tcc</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cfenv</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/fenv.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/fenv.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/libc-header-start.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/bits/fenv.h</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cinttypes</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/inttypes.h</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cstdalign</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/lib/gcc/x86_64-linux-gnu/7/include/stdalign.h</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cstdbool</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/lib/gcc/x86_64-linux-gnu/7/include/stdbool.h</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/ctgmath</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cmath</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cuchar</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cwchar</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/uchar.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/lib/gcc/x86_64-linux-gnu/7/include/stddef.h</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cwchar</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cwctype</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/algorithm</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/utility</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/stl_relops.h</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/stl_algo.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cstdlib</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/algorithmfwd.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/stl_heap.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/stl_tempbuf.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/stl_construct.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/uniform_int_dist.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/limits</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bitset</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/deque</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/stl_uninitialized.h</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/stl_deque.h</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/deque.tcc</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/fstream</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/codecvt.h</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cstdio</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/c</span>++<span class="hljs-string">/7/bits/basic_file.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/c</span>++<span class="hljs-string">/7/bits/c</span>++io.h<br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cstdio</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/fstream.tcc</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/functional</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/tuple</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/array</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/uses_allocator.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/invoke.h</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/std_function.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/refwrap.h</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/iomanip</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/locale</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/locale_facets_nonio.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/ctime</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/c</span>++<span class="hljs-string">/7/bits/time_members.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/c</span>++<span class="hljs-string">/7/bits/messages_members.h</span><br><span class="hljs-string">......</span> <span class="hljs-string">/usr/include/libintl.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/locale_facets_nonio.tcc</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/locale_conv.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/stringfwd.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/allocator.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/codecvt.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/unique_ptr.h</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/quoted_string.h</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/iostream</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/iterator</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/stream_iterator.h</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/list</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/stl_list.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/allocated_ptr.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/ext/aligned_buffer.h</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/list.tcc</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/map</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/stl_tree.h</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/stl_map.h</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/stl_multimap.h</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/memory</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/stl_raw_storage_iter.h</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/ext/concurrence.h</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/unique_ptr.h</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/shared_ptr.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/shared_ptr_base.h</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/shared_ptr_atomic.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/atomic_base.h</span><br><span class="hljs-string">.....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/atomic_lockfree_defines.h</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/backward/auto_ptr.h</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/numeric</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/stl_numeric.h</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/queue</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/vector</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/stl_vector.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/stl_bvector.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/vector.tcc</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/stl_queue.h</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/set</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/stl_set.h</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/stl_multiset.h</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/stack</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/stl_stack.h</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/valarray</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cmath</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/valarray_array.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cstdlib</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/valarray_array.tcc</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/valarray_before.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/slice_array.h</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/valarray_after.h</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/gslice.h</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/gslice_array.h</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/mask_array.h</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/indirect_array.h</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/atomic</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/chrono</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/ratio</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/ctime</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/parse_numbers.h</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/codecvt</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/condition_variable</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/std_mutex.h</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/forward_list</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/forward_list.h</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/forward_list.tcc</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/future</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/mutex</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/thread</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cerrno</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/atomic_futex.h</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/random</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cmath</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cstdlib</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/random.h</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/x86_64-linux-gnu/c</span>++<span class="hljs-string">/7/bits/opt_random.h</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/random.tcc</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/regex</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/cstring</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/regex_constants.h</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/regex_error.h</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/regex_automaton.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/regex_automaton.tcc</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/regex_scanner.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/regex_scanner.tcc</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/regex_compiler.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/regex_compiler.tcc</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/regex.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/regex.tcc</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/regex_executor.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/regex_executor.tcc</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/scoped_allocator</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/typeindex</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/unordered_map</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/hashtable.h</span><br><span class="hljs-string">....</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/hashtable_policy.h</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/unordered_map.h</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/unordered_set</span><br><span class="hljs-string">...</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/bits/unordered_set.h</span><br><span class="hljs-string">..</span> <span class="hljs-string">/usr/include/c</span>++<span class="hljs-string">/7/shared_mutex</span><br></code></pre></td></tr></table></figure><p>大概就这些。。。</p><h1 id="预编译头文件"><a href="#预编译头文件" class="headerlink" title="预编译头文件"></a>预编译头文件</h1><p>查阅后发现其实 GCC/G++ 可以预编译头文件的，简单来说就是直接编译头文件成 gch 文件即可，即</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/include/x86_64-linux-gnu/c++/9/bits<br>sudo g++ -std=c++17 stdc++.h<br></code></pre></td></tr></table></figure><p>而后正常使用编译命令即可，GCC/G++ 会<strong>自动</strong>使用预编译的内容</p><h1 id="耗时对比"><a href="#耗时对比" class="headerlink" title="耗时对比"></a>耗时对比</h1><p>同样的命令，同样的代码，仅使用了 <code>bits/stdc++.h</code> 的情况下，两者的耗时情况</p><p>先是不使用预编译的</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">real</span><span class="hljs-number">0</span>m2.<span class="hljs-number">476</span>s<br><span class="hljs-attribute">user</span><span class="hljs-number">0</span>m1.<span class="hljs-number">279</span>s<br><span class="hljs-attribute">sys</span><span class="hljs-number">0</span>m0.<span class="hljs-number">154</span>s<br></code></pre></td></tr></table></figure><p>差不多 4s 的耗时</p><p>然后是使用来预编译的</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">real</span><span class="hljs-number">0</span>m0.<span class="hljs-number">668</span>s<br><span class="hljs-attribute">user</span><span class="hljs-number">0</span>m0.<span class="hljs-number">258</span>s<br><span class="hljs-attribute">sys</span><span class="hljs-number">0</span>m0.<span class="hljs-number">065</span>s<br></code></pre></td></tr></table></figure><p>差不多 1s 的耗时</p><p>天差地别</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GCC/G++</tag>
      
      <tag>性能优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Junit5 和 Mockito 实现 SpringBoot 的单元测试最优美的解决方案</title>
    <link href="/2022/04/22/java/junit5-mockito/"/>
    <url>/2022/04/22/java/junit5-mockito/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是单元测试"><a href="#什么是单元测试" class="headerlink" title="什么是单元测试"></a>什么是单元测试</h1><p>单元测试就是一部分代码，但是它</p><ul><li>不会在正常的业务流程中被执行</li><li>不被打包进入最终的编译程序</li><li>不会被任何其他业务代码以任何方式导入</li><li>不会影响正常的代码</li></ul><p>当然，它通常还要满足下面这些条件</p><ul><li>自动化的，不需要人工输入任何数据即可完成</li><li>独立的，任何两个单元测试之间都不应该发生调用关系</li><li>可重复的，单元测试可以无限重复执行且结果应该一致</li></ul><p>传统的单元测试，即是测试一个函数是否正确运行。单元测试可以<strong>为这个函数预先伪造一个测试环境</strong>，例如用户登录了，且已经有超管权限了，那么运行这个函数是否能够得到我们期望得到的结果</p><p>注意上面这段文字中的提到的「为这个函数预先伪造一个测试环境」，这似乎不是很难理解，让我来举个例子：</p><blockquote><ul><li>例如我们现在希望测试登录能力，这是多数的服务中通常都有的能力，按照一般的编码规范，我们将会在 service 层进行逻辑判断。例如取出匹配此账号的数据库的值，并校验密码。</li><li><p>这是非常传统的做法，也同样足够的有效。接下来，让我们来为这个测试伪造一个环境</p><blockquote><ul><li>首先，我们在数据库中插入一个数据，当然，此时我们并不需要考虑到底插入了什么，因为我现在想要模拟假如没有此账号的似乎，登录的结果</li><li>然后，我们请求对应的接口，使用新的随机数据，当然，这时候我们期望得到的是失败的登录请求，因为我们输入的数据就是不存在的。</li></ul></blockquote></li><li><p>让我们来重新回顾整个过程，这个过程我们做了什么？我们访问了数据库！还修改了里面的数据！这太可怕了！</p></li><li>假如这件事放在业务上，我们需要在发布环境通过单元测试来校验代码是否合理的时候，我们还需要插入一条数据！这仅仅只是一个登录失败的测试，这太可怕了！</li><li>那有没有什么可能的方案来解决这个问题？</li><li>接下来就轮到 Mock 来伪造这个过程了</li><li>还是以登录失败为例，我们现在假定 service 是直接调用了 dao 层接口<blockquote><ul><li>首先，我们 mock 了用户的 dao 层接口，并指定「获取用户」的接口若传入 “ABC” 这个字符串，则返回不存在这个用户</li><li>然后我们调用用户的登录接口，并传入 “ABC” 作为账号</li><li>当用户的 service 遇到需要调用用户的 dao 接口时，会被上面设定的规则将会导致不再请求数据库，而是直接返回不存在</li><li>service 收到不存在后，包装好返回值，并返回</li></ul></blockquote></li><li>虽然看起来与刚才的，最终的结果是一样的，我们测试的代码几乎是相同的，但是我们却解决了最重要的问题——访问数据库</li></ul></blockquote><p>事实上，很多时候 mock 并不是解决这个问题的。我们希望单元测试能够单独测试一个函数是否逻辑正确，那么我们仅需要测试这个函数即可，当这个函数需要调用其他函数的时候，我们会对函数进行 mock 使得得到我们期望的值。这样就可以实现仅仅校验此函数的逻辑是否正确了</p><h1 id="单元测试的意义"><a href="#单元测试的意义" class="headerlink" title="单元测试的意义"></a>单元测试的意义</h1><ul><li>在不需要启动服务的情况下，检查代码逻辑是否有问题</li><li>保证代码在后续的迭代过程中，被其他人更新后导致原来可以正常运行的结果变得不正确了</li></ul><p>因为单元测试是负责完成代码测试的，所以当完整的单元测试写完之后，我们就可以通过单元测试来校验代码逻辑是否有问题</p><p>同时单元测试将会一直存在与源代码中，后续每一次需要进行校验发布时，都可以通过运行一次单元测试来检查是否因为本次修改，导致之前的逻辑出现错误</p><h1 id="单元测试的标准"><a href="#单元测试的标准" class="headerlink" title="单元测试的标准"></a>单元测试的标准</h1><ul><li>单元测试应该是全自动执行的，并且非交互式的。测试用例通常是被定期执行的，执行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。单元 测试中不准使用 System.out 来进行人肉验证，必须使用 assert 来验证。</li><li>保持单元测试的独立性。为了保证单元测试稳定可靠且便于维护，单元测试用例之间决不能互相调用，也不能依赖执行的先后次序。</li><li>单元测试是可以重复执行的，不能受到外界环境的影响。</li><li>对于单元测试，要保证测试粒度足够小，有助于精确定位问题。单测粒度至多是类级别，一般是方法级别。</li><li>单元测试代码必须写在如下工程目录:src/test/java，不允许写在业务代码目录下。</li><li>单元测试应当包含「边界值测试」、「正确的输入」、「强制错误信息输入」的测试，而不是仅仅以满足覆盖率为标准</li></ul><h1 id="你需要会哪些代码知识"><a href="#你需要会哪些代码知识" class="headerlink" title="你需要会哪些代码知识"></a>你需要会哪些代码知识</h1><p>本博客的知识范围是 SpringBoot 框架，所以你必须要掌握下面的技能</p><ul><li>能够熟练使用 Java 语言编写代码</li><li>了解 SpringBoot 的 AOP 的设计思想，会使用依赖注入</li><li>能够看懂上面的基本概念，了解单元测试的重要性</li><li>会使用 maven，并知道如何使用 maven</li><li>能够阅读中文，并能看懂本博客</li></ul><h1 id="开始写单元测试"><a href="#开始写单元测试" class="headerlink" title="开始写单元测试"></a>开始写单元测试</h1><p>单元测试的代码应该位于你的项目目录 <code>src/test/java</code> 下，接下来所有的内容目录都指此目录</p><h2 id="导入-maven-依赖"><a href="#导入-maven-依赖" class="headerlink" title="导入 maven 依赖"></a>导入 maven 依赖</h2><p>我们需要了解下面几个重要的依赖，但是并非都是需要添加的，请继续阅读</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Junit 5 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- Mockito 核心 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mockito<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mockito-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- Mockito 对 static 支持 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mockito<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mockito-inline<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- Spring 对单元测试支持 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以上这些依赖的相互依赖关系如下</p><pre><code class=" mermaid">graph LRc([mockito-inline]) ----&gt; b([mockito-core])d([spring-boot-starter-test]) ----&gt; b([mockito-core])d([spring-boot-starter-test]) ----&gt; a([junit-jupiter])</code></pre><p>所以，实际上你只需要最后两个依赖即可完成本片博客的所有内容，但是还是有必要详细解释一下这些依赖在本博客中起到的作用</p><ul><li>junit5：必须的组件，提供了最重要的注解和单元测试能力</li><li>mockito-core：必须的组件，提供了最重要的 Mock 的能力</li><li>mockito-inline：非必须组件，提供了对静态方法的 Mock 能力，如果不需要对静态方法进行 Mock 则可以不需要</li><li>spring-boot-starter-test：非必须组件，提供了对类的 private 变量的赋值能力，实际上反射也可以做到，但是通常为了方便期间，可以直接使用已经有的轮子</li></ul><p>当你确定好需要的依赖之后，将其最新版本添加到你的 maven 里吧</p><h2 id="创建测试类"><a href="#创建测试类" class="headerlink" title="创建测试类"></a>创建测试类</h2><p>首先，需要进行逻辑测试的永远是某个实现类，而不是接口，因为接口并不是需要测试的，我们需要测试的是实现的过程是否有问题</p><p>创建类用来编写你的单元测试。通常我们会根据需要测试的类进行单独建测试类，即每一个类对应一个测试类，每一个测试类，仅测试对应类的方法。例如，我们有 <code>src/main/java/com/example/service/impl/UserServiceImpl.java</code> 类，那么我们创建 <code>src/test/java/com/example/service/impl/UserServiceImplTest.java</code> 用于测试 <code>UserServiceImpl</code> 类。</p><p>例如，我们创建了 <code>src/test/java/com/example/service/impl/UserServiceImplTest.java</code> 类用于测试对应的类。接下来我们需要介绍一些注解和类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ExtendWith()</span> <span class="hljs-comment">// 来自 junit 5 的注解，用于测试类上，表示此测试需要额外使用什么扩展工具</span><br>MockitoExtension <span class="hljs-comment">// 来自 Mockito-core 的类，是 Mockito 的扩展工具，用于 junit 5 使用，junit 4 并不是这个</span><br><span class="hljs-meta">@BeforeAll</span> <span class="hljs-comment">// 来自 junit5 的注解，用于 static 方法上，表示在进行此类的所有测试方法前，执行一次此函数，仅一次</span><br><span class="hljs-meta">@AfterAll</span> <span class="hljs-comment">// 来自 junit 5 的注解，与 @BeforeAll 类似，但是表示所有测试方法结束后执行一次，仅一次</span><br><span class="hljs-meta">@BeforeEach</span> <span class="hljs-comment">// 来自 junit 5 的注解，用于非 static 方法上，表示在此类的所有测试方法将被执行前，每个都执行一次</span><br><span class="hljs-meta">@AfterEach</span> <span class="hljs-comment">// 来自 junit 5 的注解，与 @BeforeEach 类似，但是是在每个测试方法结束后，都执行一次</span><br><span class="hljs-meta">@Test</span> <span class="hljs-comment">// 来自 junit 5 的注解，用于非 static 方法上，表示此方法是一个测试</span><br></code></pre></td></tr></table></figure><h2 id="添加注解"><a href="#添加注解" class="headerlink" title="添加注解"></a>添加注解</h2><p>接下来，按照上面的描述，为你的每个测试类都添加这些需要的注解，我们可以得到类似下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ExtendWith(MockitoExtension.class)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImplTest</span> &#123;<br><br>    <span class="hljs-meta">@BeforeEach</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 这里的代码将会在每个测试前运行</span><br>    &#125;<br><br>    <span class="hljs-meta">@AfterEach</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">tearDown</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 这里的代码将会在每个测试结束后运行</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试登录，用户不存在的情况</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testLoginWithNoSuchUser</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 这里编写你的测试代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们已经完成了最基本的类的创建，虽然我们还没有开始调用登录的函数，但是我们已经完成类绝大部分的任务。</p><h2 id="注入类"><a href="#注入类" class="headerlink" title="注入类"></a>注入类</h2><p>接下来，让我们将需要测试的类注入进来</p><p>在类中最开头添加类似下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@InjectMocks</span><br><span class="hljs-keyword">private</span> UserServiceImpl userService; <span class="hljs-comment">// 需要测试的类，需要用 @InjectMocks 注解</span><br><br><span class="hljs-meta">@Mock</span><br><span class="hljs-keyword">private</span> UserDaoImpl userDao; <span class="hljs-comment">// 需要 mock 的类，需要用 @Mock 注解</span><br><br></code></pre></td></tr></table></figure><p>然后，开始测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testLoginWithNoSuchUser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> userService.login(<span class="hljs-string">&quot;handle&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>);<br>    Assertions.assertFalse(isSuccess); <span class="hljs-comment">// 校验返回值是否正确</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>但是这样肯定是不行的，因为你会发现，这样运行的结果会使得 <code>isSuccess</code> 为 <code>null</code>，而不是我们期望的结果。当然，我们也还没有配置 mock 的内容。</p><h2 id="mock-it！"><a href="#mock-it！" class="headerlink" title="mock it！"></a>mock it！</h2><p>接下来让我们开始 mock 吧，尝试类似下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testLoginWithNoSuchUser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 表示「当调用 userDao#selectUserByHandle 且参数为 &quot;handle&quot; 时，则返回 null」</span><br>    Mockito.when(userDao.selectUserByHandle(<span class="hljs-string">&quot;handle&quot;</span>)).thenReturn(<span class="hljs-literal">null</span>);<br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> userService.login(<span class="hljs-string">&quot;handle&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>);<br>    Assertions.assertFalse(isSuccess); <span class="hljs-comment">// 校验返回值是否正确</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>再运行一次看看？是不是完美了？</p><p>回头看看我们做的过程，是否让单元测试变得更加简单了，编写单元测试仅需要三步</p><ul><li>编写 Mockito 内容</li><li>调用函数</li><li>校验返回值或者参数</li></ul><p>下面将会介绍几种常见的情况</p><h1 id="应对各种情况"><a href="#应对各种情况" class="headerlink" title="应对各种情况"></a>应对各种情况</h1><h2 id="通用匹配类型"><a href="#通用匹配类型" class="headerlink" title="通用匹配类型"></a>通用匹配类型</h2><p>有时候我们并不喜欢指明参数必须要是什么，例如无论什么调用时，都返回 <code>null</code>，此时，参数可以使用 <code>Mockito.any()</code> 来表示任意参数，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Mockito.when(userDao.selectUserByHandle(Mockito.any())).thenReturn(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><h2 id="指定调用的目标函数的返回值"><a href="#指定调用的目标函数的返回值" class="headerlink" title="指定调用的目标函数的返回值"></a>指定调用的目标函数的返回值</h2><p>这已经在上面提及到了，也就是最常见的问题</p><h2 id="让调用的目标函数抛出错误"><a href="#让调用的目标函数抛出错误" class="headerlink" title="让调用的目标函数抛出错误"></a>让调用的目标函数抛出错误</h2><p>将 <code>thenReturn</code> 改为 <code>thenThrow</code> 即可</p><h2 id="让调用的目标函数做一些指定的事情"><a href="#让调用的目标函数做一些指定的事情" class="headerlink" title="让调用的目标函数做一些指定的事情"></a>让调用的目标函数做一些指定的事情</h2><p>如果希望更加自定义函数的内容，譬如做点什么，则可以使用 <code>thenAnswer</code> 来解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Mockito.when(userDao.selectUserByHandle(Mockito.any())).thenAnswer(invocationOnMock -&gt; &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">handle</span> <span class="hljs-operator">=</span> invocationOnMock.getArgument(<span class="hljs-number">0</span>); <span class="hljs-comment">// 获取第 0 个参数</span><br>    <span class="hljs-keyword">if</span> (handle == <span class="hljs-string">&quot;handle&quot;</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="如何应对没有返回值的函数"><a href="#如何应对没有返回值的函数" class="headerlink" title="如何应对没有返回值的函数"></a>如何应对没有返回值的函数</h2><p>把 then 的部分向前提就行，并改为 do 系列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Mockito.doAnswer(invocationOnMock -&gt; &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">argument</span> <span class="hljs-operator">=</span> invocationOnMock.getArgument(<span class="hljs-number">0</span>);<br>    argument.setId(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 必须要返回些什么</span><br>&#125;).when(userDao).insertAccount(Mockito.any());<br></code></pre></td></tr></table></figure><h2 id="如何控制那些静态的函数"><a href="#如何控制那些静态的函数" class="headerlink" title="如何控制那些静态的函数"></a>如何控制那些静态的函数</h2><p>假如我们有一个校验密码的静态方法 <code>BCryptEncoder#encode</code>，那么下面就是一个很好的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">MockedStatic&lt;BCryptEncoder&gt; bCryptEncoderMockedStatic;<br>bCryptEncoderMockedStatic = Mockito.mockStatic(BCryptEncoder.class);<br>bCryptEncoderMockedStatic.when(() -&gt; BCryptEncoder.encoder(<span class="hljs-string">&quot;abc&quot;</span>)).thenReturn(<span class="hljs-string">&quot;123&quot;</span>);<br><br><span class="hljs-comment">// do something</span><br><br>bCryptEncoderMockedStatic.close();<br></code></pre></td></tr></table></figure><h2 id="如何测试-private-的方法"><a href="#如何测试-private-的方法" class="headerlink" title="如何测试 private 的方法"></a>如何测试 private 的方法</h2><p>private 方法不应该被测试，因为其他类不会调用这方法。应该通过 public 间接测试 private 方法</p><h2 id="如何校验函数的参数"><a href="#如何校验函数的参数" class="headerlink" title="如何校验函数的参数"></a>如何校验函数的参数</h2><p>我们以注册用户的时候使用的插入用户至数据库为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ArgumentCaptor&lt;User&gt; userArgumentCaptor = ArgumentCaptor.forClass(User.class); <span class="hljs-comment">// 创建一个捕获类</span><br>Mockito.verify(userManager, Mockito.times(<span class="hljs-number">1</span>)).insertAccount(userArgumentCaptor.capture()); <span class="hljs-comment">// 第一次插入的时候，捕获参数</span><br><span class="hljs-type">User</span> <span class="hljs-variable">userCP</span> <span class="hljs-operator">=</span> userArgumentCaptor.getValue(); 获取被捕获的参数的值，后面就可以直接校验 userCP 了<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>单元测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>centOS 防火墙 docker-compse 的问题</title>
    <link href="/2022/04/21/develop-note/centos-ufw-docker-ip/"/>
    <url>/2022/04/21/develop-note/centos-ufw-docker-ip/</url>
    
    <content type="html"><![CDATA[<p>当 centOS 关闭掉防火墙后，请务必重启 docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl restart docker<br></code></pre></td></tr></table></figure><p>否则会导致 docker-compose 出错</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">ERROR: </span>Failed to Setup IP tables: Unable to enable SKIP DNAT rule:  (iptables failed: iptables --wait -t nat -I DOCKER -i br<span class="hljs-string">-7506353</span>a9954 -j RETURN: iptables: No chain/target/match by that name.<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>centOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gitbook 安装出错</title>
    <link href="/2022/03/24/develop-note/gitbook-install-error/"/>
    <url>/2022/03/24/develop-note/gitbook-install-error/</url>
    
    <content type="html"><![CDATA[<p>执行 <code>npm i gitbook-cli -g</code> 时出现</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">    <span class="hljs-keyword">if</span> (cb) cb.apply(this, arguments)<br>           ^<br>TypeError: cb.apply is not a <span class="hljs-keyword">function</span><br>    at <span class="hljs-regexp">/home/</span>travis<span class="hljs-regexp">/.nvm/</span>versions<span class="hljs-regexp">/node/</span>v12.<span class="hljs-number">18.3</span><span class="hljs-regexp">/lib/</span>node_modules<span class="hljs-regexp">/gitbook-cli/</span>node_modules<span class="hljs-regexp">/npm/</span>node_modules<span class="hljs-regexp">/graceful-fs/</span>polyfills.js:<span class="hljs-number">287</span>:<span class="hljs-number">18</span><br>    at FSReqCallback.oncomplete (fs.js:<span class="hljs-number">169</span>:<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><p>的情况，可以执行下面的命令解决</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cd</span> `npm root -g`/gitbook-cli/node_modules/npm/node_modules/<br><span class="hljs-attribute">npm</span> install graceful-fs@<span class="hljs-number">4</span>.<span class="hljs-number">2</span>.<span class="hljs-number">4</span> --save<br><span class="hljs-attribute">gitbook</span> install<br></code></pre></td></tr></table></figure><p>即可</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Gitbook</tag>
      
      <tag>nodejs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>macOS 更新后导致 sdk 丢失问题</title>
    <link href="/2022/03/22/mac/clion-mac-CMAKE_OSX_SYSROOT/"/>
    <url>/2022/03/22/mac/clion-mac-CMAKE_OSX_SYSROOT/</url>
    
    <content type="html"><![CDATA[<p>在 macOS 更新后，CLion 可能会出现如下错误</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">CMake</span> <span class="hljs-type">Warning</span> at <span class="hljs-regexp">/Applications/</span><span class="hljs-type">CLion</span>.app<span class="hljs-regexp">/Contents/</span>bin<span class="hljs-regexp">/cmake/</span>mac<span class="hljs-regexp">/share/</span>cmake<span class="hljs-operator">-</span><span class="hljs-number">3.15</span><span class="hljs-regexp">/Modules/</span><span class="hljs-type">Platform</span><span class="hljs-operator">/</span><span class="hljs-type">Darwin</span><span class="hljs-operator">-</span><span class="hljs-type">Initialize</span>.cmake:<span class="hljs-number">131</span> (message):<br>  <span class="hljs-type">Ignoring</span> <span class="hljs-type">CMAKE_OSX_SYSROOT</span> value:<br><br>   <span class="hljs-regexp">/Applications/</span><span class="hljs-type">Xcode</span>.app<span class="hljs-regexp">/Contents/</span><span class="hljs-type">Developer</span><span class="hljs-regexp">/Platforms/</span><span class="hljs-type">MacOSX</span>.platform<span class="hljs-regexp">/Developer/</span><span class="hljs-type">SDKs</span><span class="hljs-operator">/</span><span class="hljs-type">MacOSX12</span>.<span class="hljs-number">1</span>.sdk<br><br>  because the directory does not exist.<br></code></pre></td></tr></table></figure><p>这时候，只需要删除 <code>cmake-build-debug</code> 或者对应的目录，然后 reload cmake 就行了</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>macOS</tag>
      
      <tag>CLion</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 生成验证码 Captcha</title>
    <link href="/2022/03/19/develop-note/java-create-captcha/"/>
    <url>/2022/03/19/develop-note/java-create-captcha/</url>
    
    <content type="html"><![CDATA[<p>方法效率较低，推荐使用缓存，重复使用验证码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 验证码宽度</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">CAPTCHA_WIDTH</span> <span class="hljs-operator">=</span> <span class="hljs-number">150</span>;<br><span class="hljs-comment">// 验证码高度</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">CAPTCHA_HEIGHT</span> <span class="hljs-operator">=</span> <span class="hljs-number">40</span>;<br><span class="hljs-comment">// 验证码最大旋转角度（不推荐修改）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">CAPTCHA_CHAR_ROTATE</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><span class="hljs-comment">// 干扰线数量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">CAPTCHA_LINE_NUM</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><span class="hljs-comment">// 验证码数量</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">CAPTCHA_CHAR_NUM</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br><span class="hljs-comment">// 验证码的保存格式</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CAPTCHA_CONTENT_TYPE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;PNG&quot;</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">createCaptcha</span><span class="hljs-params">(OutputStream outputStream)</span> <span class="hljs-keyword">throws</span> PortableException &#123;<br>    <span class="hljs-type">BufferedImage</span> <span class="hljs-variable">image</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedImage</span>(CAPTCHA_WIDTH, CAPTCHA_HEIGHT, BufferedImage.TYPE_INT_BGR);<br>    <span class="hljs-type">Graphics2D</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> (Graphics2D) image.getGraphics();<br>    g.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, CAPTCHA_WIDTH, CAPTCHA_HEIGHT);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; CAPTCHA_LINE_NUM; i++) &#123;<br>        drawRandomLine(g);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; CAPTCHA_LINE_NUM; i++) &#123;<br>        drawLeftToRightLine(g);<br>    &#125;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; CAPTCHA_CHAR_NUM; i++) &#123;<br>        ans.append(drawString(g, i + <span class="hljs-number">1</span>));<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        ImageIO.write(image, CAPTCHA_CONTENT_TYPE, outputStream);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-keyword">throw</span> PortableException.of(<span class="hljs-string">&quot;B-01-002&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans.toString();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawRandomLine</span><span class="hljs-params">(Graphics2D g)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">xs</span> <span class="hljs-operator">=</span> RANDOM.nextInt(CAPTCHA_WIDTH);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">xe</span> <span class="hljs-operator">=</span> RANDOM.nextInt(CAPTCHA_WIDTH);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ys</span> <span class="hljs-operator">=</span> RANDOM.nextInt(CAPTCHA_HEIGHT);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ye</span> <span class="hljs-operator">=</span> RANDOM.nextInt(CAPTCHA_HEIGHT);<br>    g.setFont(ARIAL_FONT);<br>    g.setColor(getRandomColor());<br>    g.drawLine(xs, ys, xe, ye);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawLeftToRightLine</span><span class="hljs-params">(Graphics2D g)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">xs</span> <span class="hljs-operator">=</span> RANDOM.nextInt(CAPTCHA_WIDTH / <span class="hljs-number">2</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">xe</span> <span class="hljs-operator">=</span> CAPTCHA_WIDTH / <span class="hljs-number">2</span> + RANDOM.nextInt(CAPTCHA_WIDTH / <span class="hljs-number">2</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ys</span> <span class="hljs-operator">=</span> RANDOM.nextInt(CAPTCHA_HEIGHT / <span class="hljs-number">2</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ye</span> <span class="hljs-operator">=</span> CAPTCHA_HEIGHT / <span class="hljs-number">2</span> + RANDOM.nextInt(CAPTCHA_HEIGHT / <span class="hljs-number">2</span>);<br>    g.setFont(ARIAL_FONT);<br>    g.setColor(getRandomColor());<br>    g.drawLine(xs, ys, xe, ye);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">drawString</span><span class="hljs-params">(Graphics2D g, Integer num)</span> &#123;<br>    <span class="hljs-comment">// 保证左侧和右侧不要贴边，总共留出一个字符的空间</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">baseX</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (CAPTCHA_WIDTH * <span class="hljs-number">1.0</span> / (ImageUtils.CAPTCHA_CHAR_NUM + <span class="hljs-number">1</span>) * num);<br>    <span class="hljs-type">AffineTransform</span> <span class="hljs-variable">old</span> <span class="hljs-operator">=</span> g.getTransform();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getRandomChar();<br><br>    g.setFont(ARIAL_FONT);<br>    g.setColor(getRandomColor());<br>    g.rotate(Math.toRadians(RANDOM.nextInt(CAPTCHA_CHAR_ROTATE * <span class="hljs-number">2</span>) - CAPTCHA_CHAR_ROTATE));<br>    g.drawString(c, baseX, CAPTCHA_HEIGHT / <span class="hljs-number">3</span> * <span class="hljs-number">2</span>);<br>    g.setTransform(old);<br><br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Color <span class="hljs-title function_">getRandomColor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">upper</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">lower</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> lower + RANDOM.nextInt(upper);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> lower + RANDOM.nextInt(upper);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> lower + RANDOM.nextInt(upper);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>(r, g, b);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getRandomChar</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> String.valueOf(CAPTCHA_CHAR.charAt(RANDOM.nextInt(CAPTCHA_CHAR.length())));<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习&amp;开发&amp;实现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>验证码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 模版可变参数列表传递给 C 的 va_list 可变参数列表</title>
    <link href="/2022/01/12/cpp/cpp-template-variable-parameter-to-c/"/>
    <url>/2022/01/12/cpp/cpp-template-variable-parameter-to-c/</url>
    
    <content type="html"><![CDATA[<h1 id="C-可变参数"><a href="#C-可变参数" class="headerlink" title="C 可变参数"></a>C 可变参数</h1><p>以 <code>printf</code> 为例，常见如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">printf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* format, ...)</span>;<br></code></pre></td></tr></table></figure></p><h1 id="CPP-可变参数"><a href="#CPP-可变参数" class="headerlink" title="CPP 可变参数"></a>CPP 可变参数</h1><p>常见如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;format, <span class="hljs-type">const</span> Args &amp;... args)</span></span>;<br></code></pre></td></tr></table></figure><p>若此时需要为 C 的 <code>printf</code> 进行包装，使其可以接受 <code>string</code> 类型的 format，则可以用如下方式实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span>... Args&gt;</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">printf</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;format, <span class="hljs-type">const</span> Args &amp;... args)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">printf</span>(format.<span class="hljs-built_in">c_str</span>(), args...);<br>&#125;<br></code></pre></td></tr></table></figure><p>通常会提示警告，因为 <code>c_str()</code> 得到的字符串不能保证是一个可格式化的字符串，而 <code>printf</code> 的函数原型是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">__attribute__((__format__ (__printf__, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)))<br><span class="hljs-type">int</span> <span class="hljs-title function_">printf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* format, ...)</span>;<br></code></pre></td></tr></table></figure><p>这使得 <code>printf</code> 会被检查第一个参数是否满足 <code>printf</code>, <code>scanf</code>, <code>strftime</code>, 或者 <code>strfmon</code> 风格</p><p>但是通过此方法可以将部分 C 语言中的方法扩展到 CPP 的模版化</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>C</tag>
      
      <tag>可变参数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitHub 下载的 zip 代码如何与原仓库再次建立连接</title>
    <link href="/2021/11/25/develop-note/git-remote-reconnect/"/>
    <url>/2021/11/25/develop-note/git-remote-reconnect/</url>
    
    <content type="html"><![CDATA[<p>执行如下命令即可（注意替换关键词）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">unzip &lt;repo&gt;.zip<br>cd &lt;repo&gt;<br>git init<br>git add .<br>git remote add origin https://github.com/&lt;user&gt;/&lt;repo&gt;.git<br>git remote update<br>git checkout master<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>GitHub</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021年浙江工商大学新生赛题解</title>
    <link href="/2021/11/21/acm/other-note/2021-ZJGSU-ACM-freshman-competition/"/>
    <url>/2021/11/21/acm/other-note/2021-ZJGSU-ACM-freshman-competition/</url>
    
    <content type="html"><![CDATA[<div style="color: red;">  <ul>    <li>        本篇中的题目顺序为预期难度顺序，并非比赛题目顺序    </li>    <li>        本篇中所有的“更好的优化”均为标准答案之外的思考，不使用此内容也可以通过题目    </li>  </ul></div><h1 id="比赛预期情况"><a href="#比赛预期情况" class="headerlink" title="比赛预期情况"></a>比赛预期情况</h1><p>总共比赛人数：175 (至少通过一道题的人数，没有通过题的不计入总人数)</p><div class="table-container"><table><thead><tr><th style="text-align:center">题目名</th><th style="text-align:center">实际通过次数</th><th style="text-align:center">实际通过比例</th><th style="text-align:center">预期通过比例</th></tr></thead><tbody><tr><td style="text-align:center">chiking 的偶像</td><td style="text-align:center">172</td><td style="text-align:center">98.3%</td><td style="text-align:center">100%</td></tr><tr><td style="text-align:center">chiking 和珂朵莉</td><td style="text-align:center">141</td><td style="text-align:center">80.6%</td><td style="text-align:center">80%</td></tr><tr><td style="text-align:center">chiking 的序列 II</td><td style="text-align:center">58</td><td style="text-align:center">51.3%</td><td style="text-align:center">60%</td></tr><tr><td style="text-align:center">chiking 的序列 I</td><td style="text-align:center">113</td><td style="text-align:center">64.6%</td><td style="text-align:center">50%</td></tr><tr><td style="text-align:center">chiking 的棋盘</td><td style="text-align:center">2</td><td style="text-align:center">1.1%</td><td style="text-align:center">30%</td></tr><tr><td style="text-align:center">乐于助人的 chiking</td><td style="text-align:center">24</td><td style="text-align:center">13.7%</td><td style="text-align:center">20%</td></tr><tr><td style="text-align:center">chiking 的俄罗斯方块</td><td style="text-align:center">0</td><td style="text-align:center">0%</td><td style="text-align:center">1%</td></tr><tr><td style="text-align:center">chiking 和大家一起来做签到题</td><td style="text-align:center">0</td><td style="text-align:center">0%</td><td style="text-align:center">1%</td></tr><tr><td style="text-align:center">chiking 是一个机器人</td><td style="text-align:center">0</td><td style="text-align:center">0%</td><td style="text-align:center">1%</td></tr></tbody></table></div><p>综上来看，整个新生赛除了一道题没有达到预期的成绩，其他题目均与预期相差不大</p><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><h2 id="chiking-的偶像"><a href="#chiking-的偶像" class="headerlink" title="chiking 的偶像"></a>chiking 的偶像</h2><h3 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h3><p>循环输出 <code>\soup_god/</code>，且总共输出的字符串长度为 $n$</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>简单的签到题，只需要还记得有 mod 这个运算就能写出来</p><h3 id="AC-Code"><a href="#AC-Code" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *data = <span class="hljs-string">&quot;\\soup_god/&quot;</span>;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cout &lt;&lt; data[i % <span class="hljs-number">10</span>];<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h3><p>我以为大家被卡在不会 <code>mod</code>，结果大家都卡在 <code>\\</code>，这就挺尴尬的</p><h2 id="chiking-和珂朵莉"><a href="#chiking-和珂朵莉" class="headerlink" title="chiking 和珂朵莉"></a>chiking 和珂朵莉</h2><h3 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h3><p>$n$ 个物品，每个物品都有价值和所属类别，让你选择 $n - k$ 种类别的物品，使得所选出来的这些类别的物品的总价值最大</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>也是签到题之一</p><p>在读入数据的时候统计每个类别的物品价值只和，之后排序一下，取出后 $n - k$ 个类别的价值即可</p><h3 id="AC-Code-1"><a href="#AC-Code-1" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> w[<span class="hljs-number">11</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> m, n, k;<br>    cin &gt;&gt; m &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        <span class="hljs-type">int</span> d, s;<br>        cin &gt;&gt; d &gt;&gt; s;<br>        w[s] += d;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(w + <span class="hljs-number">1</span>, w + n + <span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k + <span class="hljs-number">1</span>; i &lt;= n; ++i) ans += w[i];<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="吐槽-1"><a href="#吐槽-1" class="headerlink" title="吐槽"></a>吐槽</h3><p>这道题原来有一个小坑点，即物品的价值可以为负数，所以需要额外增加一个判断，但是想了想还是当签到题，不要故意恶心了，于是就删掉了。所以顺便好奇的问一下，有多少人看到题面之后去想过价值是不是可能为负数呢</p><h2 id="chiking-的序列-II"><a href="#chiking-的序列-II" class="headerlink" title="chiking 的序列 II"></a>chiking 的序列 II</h2><h3 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h3><p>有一个<strong>非递减</strong>的数组，允许你进行任意次数操作，每次操作可以使得其中一个值增加 $1$，问至少需要多少次操作才能使得数组内没有相同的值</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>因为只能进行加法运算，所以数字只会增加，由于已经排序好了数组，所以最简单的方案就是让每一个值都比前一个值要大即可</p><h3 id="AC-Code-2"><a href="#AC-Code-2" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cin &gt;&gt; data[i];<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-type">int</span> tmp = <span class="hljs-built_in">max</span>(data[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, data[i]);<br>        sum += tmp - data[i];<br>        data[i] = tmp;<br>    &#125;<br>    cout &lt;&lt; sum &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="chiking-的序列-I"><a href="#chiking-的序列-I" class="headerlink" title="chiking 的序列 I"></a>chiking 的序列 I</h2><h3 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h3><p>有一个数组，允许你进行任意次操作，每次执行操作可以将任意一个数字插入到数组到任意位置，问至少需要多少次操作才能使得数组内到每一个值满足 $a_i \leq i$，其中 $i$ 表示下标</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>首先要让每一位的的数字小于等于其下标，那么插入的数字也不能例外。由于插入的数字可以是任意值，所以理所应当的，选择 $1$ 进行插入是最好的选择，因为无论插入何处均可以使得新插入的数字不再需要考虑</p><p>接下来是考虑插入位置的问题，在等式中 $a_i$ 是不可更新的值，所以只能想办法使得 $i$ 增大，那么最容易得到的解决方案就是将数字插入数组开头，这会使得所有原来在数组内的值的下标都增大，最大程度的满足条件</p><p>接下来考虑插入数量的问题，由于都是插入数组最前面，所以可以将等式改写为 $a_i &lt;= i + x$，其中的 $x$ 即为需要求解的值。那么对于每一个 $i$ 都要满足这个等式，所以遍历一次数组，找出最大的需要的 $x$ 即可</p><h3 id="AC-Code-3"><a href="#AC-Code-3" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            ans = <span class="hljs-built_in">max</span>(ans, tmp - i - <span class="hljs-number">1</span>);<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="chiking-的棋盘"><a href="#chiking-的棋盘" class="headerlink" title="chiking 的棋盘"></a>chiking 的棋盘</h2><h3 id="大致题意-4"><a href="#大致题意-4" class="headerlink" title="大致题意"></a>大致题意</h3><p>用 $k$ 个 <code>L</code> 形状的方块能否平铺一个矩形方格</p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>我们可以用 <code>L</code> 形状的方块拼出如下两种最简平铺方案</p><p><img src="/image/acm/2021-ZJGSU-ACM-freshman-competition/2*4.png" alt="2-4"></p><p><img src="/image/acm/2021-ZJGSU-ACM-freshman-competition/3*8.png" alt="3-8"></p><p>这两个方案都是 $8$ 个方格的倍数，所以起码，方格总数应该是 $8$ 的倍数，即 $n \times m = 8k$</p><ol><li>假设两边都是偶数，那么必然其中一边为 $2$ 的倍数，另外一边为 $4$ 的倍数，所以必然可以被仅靠第一种平铺方案平铺</li><li>假设一边为奇数一边是偶数，那么必然其中一边为 $8$ 的倍数，而第一种方案也可以改写为 $2 * 8$ 的方格，即只需要另外一边可以分解为 $2x + 3y$ 的形式即可，易得只要 $ \geq 2$ 的值均可</li></ol><p>所以结论：只要满足方格数为 $8$ 的倍数，且两边都 $\geq 2$，则必定可以平铺</p><p>接下来只需要计算数量对不对就行</p><h3 id="AC-Code-4"><a href="#AC-Code-4" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, m, k;<br>        cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>        <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span> &amp;&amp; m &gt; <span class="hljs-number">1</span> &amp;&amp; (n * m) % <span class="hljs-number">8</span> == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span> cnt = (n * m / <span class="hljs-number">4</span>);<br>            <span class="hljs-keyword">if</span> (cnt == k) cout &lt;&lt; <span class="hljs-string">&quot;Perfect!\n&quot;</span>;<br>            <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;Single forever!\n&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;Single forever!\n&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="乐于助人的-chiking"><a href="#乐于助人的-chiking" class="headerlink" title="乐于助人的 chiking"></a>乐于助人的 chiking</h2><h3 id="大致题意-5"><a href="#大致题意-5" class="headerlink" title="大致题意"></a>大致题意</h3><p>允许将字符串中 <code>oo</code> 和 <code>u</code> 互转，也允许将字符串的 <code>kh</code> 和 <code>h</code> 互转的前提下，计算给出的字符串数组中有几个不同的字符串</p><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>由于存在转换，所以最好的办法就是统一转为一种类型，再进行比较</p><p><code>oo</code> 和 <code>u</code> 这对规则，若我们将所有的 <code>oo</code> 转为 <code>u</code>，那么当遇到 <code>ou</code> 和 <code>uo</code> 时，会发现在此条规则下应该是相等的字符串没有相等。所以应该将所有的 <code>u</code> 字符转为 <code>oo</code></p><p><code>kh</code> 和 <code>h</code> 这对规则，若我们将所有的 <code>h</code> 转为 <code>kh</code>，那么就会出现 <code>kh</code> 还可以继续转为 <code>kkh</code>、<code>kkkh</code>、<code>kkkkh</code> 等，所以只能选择将 <code>kh</code> 转为 <code>h</code>。但是请注意 <code>kkkh</code> 这类连续的 <code>k</code> 的情况，可以连续多次转换</p><p>处理完成后，统计不同的字符串的数量即可</p><p>处理字符串复杂度 $O(nm) = 1e5$<br>统计不同字符串数量 $O(n^2m) = 1e7$</p><p>满足要求</p><h3 id="AC-Code-5"><a href="#AC-Code-5" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">char</span> a[<span class="hljs-number">1010</span>], b[<span class="hljs-number">2010</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    vector&lt;string&gt; data;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cin &gt;&gt; a;<br>        <span class="hljs-type">int</span> len = (<span class="hljs-type">int</span>) <span class="hljs-built_in">strlen</span>(a);<br>        <span class="hljs-type">int</span> pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (a[j] == <span class="hljs-string">&#x27;u&#x27;</span>) &#123;<br>                b[pos++] = <span class="hljs-string">&#x27;o&#x27;</span>;<br>                b[pos++] = <span class="hljs-string">&#x27;o&#x27;</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[j] == <span class="hljs-string">&#x27;h&#x27;</span>) &#123;<br>                <span class="hljs-keyword">while</span> (pos &gt; <span class="hljs-number">0</span> &amp;&amp; b[pos - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;k&#x27;</span>) pos--;<br>                b[pos++] = <span class="hljs-string">&#x27;h&#x27;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                b[pos++] = a[j];<br>            &#125;<br>            b[pos] = <span class="hljs-number">0</span>;<br>        &#125;<br>        data.<span class="hljs-built_in">emplace_back</span>(b);<br>    &#125;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (data[i] == data[j]) &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (flag) cnt++;<br>    &#125;<br>    cout &lt;&lt; cnt + <span class="hljs-number">1</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="更好的优化"><a href="#更好的优化" class="headerlink" title="更好的优化"></a>更好的优化</h3><p>实际上，这里需要比较的是字符串是否相同，所以可以使用字符串 hash 来解决，这样，复杂度将会降低至 $O(nm)$。当然，字符串 hash 存在一定的可能错误的隐患，但是可以通过增加多组 hash 来解决</p><h3 id="Better-Code"><a href="#Better-Code" class="headerlink" title="Better Code"></a>Better Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">char</span> a[<span class="hljs-number">1010</span>], b[<span class="hljs-number">2010</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    set&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; hashCode;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cin &gt;&gt; a;<br>        <span class="hljs-type">int</span> len = (<span class="hljs-type">int</span>) <span class="hljs-built_in">strlen</span>(a);<br>        <span class="hljs-type">int</span> pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; len; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (a[j] == <span class="hljs-string">&#x27;u&#x27;</span>) &#123;<br>                b[pos++] = <span class="hljs-string">&#x27;o&#x27;</span>;<br>                b[pos++] = <span class="hljs-string">&#x27;o&#x27;</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[j] == <span class="hljs-string">&#x27;h&#x27;</span>) &#123;<br>                <span class="hljs-keyword">while</span> (pos &gt; <span class="hljs-number">0</span> &amp;&amp; b[pos - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;k&#x27;</span>) pos--;<br>                b[pos++] = <span class="hljs-string">&#x27;h&#x27;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                b[pos++] = a[j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> code = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> p = <span class="hljs-number">131</span>, m = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; pos; ++j) &#123;<br>            code *= p;<br>            code %= m;<br>            code += b[j];<br>            code %= m;<br>        &#125;<br>        hashCode.<span class="hljs-built_in">insert</span>(code);<br>    &#125;<br>    cout &lt;&lt; hashCode.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="chiking-的俄罗斯方块"><a href="#chiking-的俄罗斯方块" class="headerlink" title="chiking 的俄罗斯方块"></a>chiking 的俄罗斯方块</h2><h3 id="大致题意-6"><a href="#大致题意-6" class="headerlink" title="大致题意"></a>大致题意</h3><p>宽度为 4 的俄罗斯方块游戏，仅有两种方块：$2 \times 2$ 的方块和 $1 \times 4$ 的长条，在已知所有的下落顺序的情况下，求出最优的分数</p><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>需要思考的东西比较多，我们先来证明一些东西，方面后面使用</p><h4 id="实际上仅会出现-10-分和-3-分两种消方块"><a href="#实际上仅会出现-10-分和-3-分两种消方块" class="headerlink" title="实际上仅会出现 10 分和 3 分两种消方块"></a>实际上仅会出现 10 分和 3 分两种消方块</h4><p>这个结论应该是比较简单就可以得出的，因为垂直方向上只有长度为 2 和 4 的方块，所以当我们能遇到创造出 10 分的情况，尽快消除绝对不会亏</p><h4 id="长条方块必定可以合并视为-2-times-4"><a href="#长条方块必定可以合并视为-2-times-4" class="headerlink" title="长条方块必定可以合并视为 $2 \times 4$"></a>长条方块必定可以合并视为 $2 \times 4$</h4><p>这个结论指的是如下的情况是不可能发生的(带箭头的蓝色方块是最后落下的)</p><p><img src="/image/acm/2021-ZJGSU-ACM-freshman-competition/Tetris-cannot-be-inserted.png" alt="Tetris-cannot be inserted"></p><p>因为这个情况下，才会出现 $1 \times 4$ 无法插入到原来的 $1 \times 4$ 中使得变成 $2 \times 4$</p><p>而这个情况恰好满足一个 10 分的消除情况，即下图</p><p><img src="/image/acm/2021-ZJGSU-ACM-freshman-competition/10-1.png" alt="10-1"></p><p>既然能创造 10 分，那么就没必要纠结是不是能够合并了，先变成 10 分重要，所以不存在单独一根的长条方块的情况</p><h4 id="将-2-2-放中间一定不是好的选择"><a href="#将-2-2-放中间一定不是好的选择" class="headerlink" title="将 2*2 放中间一定不是好的选择"></a>将 2*2 放中间一定不是好的选择</h4><p>这个结论应该显而易见吧，因为放左/右边既可以与 $1 \times 4$ 消分，还可以与 $2 \times 2$ 消分，比放中间肯定更优</p><h4 id="原来的结构不影响当前期望的分数"><a href="#原来的结构不影响当前期望的分数" class="headerlink" title="原来的结构不影响当前期望的分数"></a>原来的结构不影响当前期望的分数</h4><p>这句话扩展起来就是</p><blockquote><p>不管之前的方块带来什么影响，若接下来 n 个方块能够创造 10 分的价值，则一定可以创造 10 分的价值，若接下来 n 个方块能创建 3 分的价值，则一定可以创造 3 分的价值</p></blockquote><p>这一条暂且先不证明</p><h4 id="所有组合如下"><a href="#所有组合如下" class="headerlink" title="所有组合如下"></a>所有组合如下</h4><p>所有能够拿分的组合只有下面这些，其中只有前两个是 10 分，其他的均为 3 分</p><p><img src="/image/acm/2021-ZJGSU-ACM-freshman-competition/10-1.png" alt="10-1"></p><p><img src="/image/acm/2021-ZJGSU-ACM-freshman-competition/10-2.png" alt="10-2"></p><p><img src="/image/acm/2021-ZJGSU-ACM-freshman-competition/3-1.png" alt="3-1"></p><p><img src="/image/acm/2021-ZJGSU-ACM-freshman-competition/3-2.png" alt="3-2"></p><p>接下来我们可以证明上面那条的结论</p><p>之前方块带来的影响主要是由于其必须要先落下导致占用了一定的位置，使得原来可以消掉的方块没有办法继续消除</p><p>最常见的一个影响就是 $2 \times 2$ 影响，简单来说就是原来已经有一块 $2 \times 2$ 方格，此时就不一定能够做到满足上述的消分情况，如下图</p><p><img src="/image/acm/2021-ZJGSU-ACM-freshman-competition/2-2-block.png" alt="2-2-block.jpeg"></p><p>例如此时，其实无法完美的满足第二种 10 分的消分情况，因为你不可能将四个 $1 \times 4$ 放在同一行中，即同时下落四个 $1 \times 4$ 的方块时，你不能仅通过这四个方块得到 10 分</p><p>但是又如何呢？</p><p>实际上我们仍然可以拿到 10 分，而且最后剩下的结果仍然是 $2 \times 2$方块，如下图所示</p><p><img src="/image/acm/2021-ZJGSU-ACM-freshman-competition/2-2-block-solve.png" alt="2-2-block-solve"></p><p>这里就不再详细介绍每种情况了，供各位思考在 $2 \times 2$ 的影响下，四种得分方案是否都可以得到原来的分数且不带来新的影响</p><p>还有一种影响是 $2 \times 4$ 的，比较类似，不再详细说明了</p><p>特别的，无论在 $2 \times 2$ 还是 $2 \times 4$ 的影响下，第三种得分方案都有可能会从 3 分变成 10 分，而这虽然增加了分数，但是同时也增加了难于预料的问题，必须予以解决。有趣的是，这种新的得分方案，其实正是第一种方案，所以如果我们能够优先将所有可能的第一种方案计算完，那么此情况其实不再可能出现，那么也就可以忽略了</p><p>除了 $2 \times 2$ 还是 $2 \times 4$，还有更多的可能，例如更高的 $2 \times 8$ 等等，但实际上是类似的，也就不再需要证明</p><p>当然还有更加离谱的影响，例如 $1 \times 4$ 影响，明显，这个影响确实真的影响到得分了，因为第四种得分方案压根不可能得分了，如下图</p><p><img src="/image/acm/2021-ZJGSU-ACM-freshman-competition/1-4-block-solve.png" alt="1-4-block-solve"></p><p>但是，注意题目中说的 $1 \times 4$ 一定是偶数个，所以之后必定有一个 $1 \times 4$，那么就回到了开头的那个结论的情况，这里又可以拿到 10 分了</p><h4 id="穿插组合并无影响"><a href="#穿插组合并无影响" class="headerlink" title="穿插组合并无影响"></a>穿插组合并无影响</h4><p>简单来说就是两个结构需要的方块穿插起来，并不会影响最终的得分，这里就不再详细介绍</p><p>当你证明完成后接下来就是模拟讨论所有情况即可</p><p>注意第一种 10 分，其要求最后一个落下的必须是 $1 \times 4$ 的长条即可，剩下的，统计数量就行</p><h3 id="AC-Code-6"><a href="#AC-Code-6" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-type">int</span> tot0 = <span class="hljs-number">0</span>, cnt0 = <span class="hljs-number">0</span>, cnt1 = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-type">int</span> tmp;<br>        cin &gt;&gt; tmp;<br>        <span class="hljs-keyword">if</span> (tmp == <span class="hljs-number">1</span>) &#123;<br>            cnt1++;<br>            <span class="hljs-keyword">if</span> (cnt1 &gt;= <span class="hljs-number">2</span> &amp;&amp; cnt0 &gt;= <span class="hljs-number">2</span>) &#123;<br>                cnt1 -= <span class="hljs-number">2</span>;<br>                cnt0 -= <span class="hljs-number">2</span>;<br>                ans += <span class="hljs-number">10</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tot0++;<br>            cnt0++;<br>        &#125;<br>    &#125;<br>    ans += (cnt1 / <span class="hljs-number">4</span>) * <span class="hljs-number">10</span>;<br>    cnt1 &amp;= <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (tot0 &gt;= <span class="hljs-number">2</span>) &#123;<br>        ans += (cnt0 + cnt1) / <span class="hljs-number">2</span> * <span class="hljs-number">3</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cnt0 &amp;&amp; cnt1) &#123;<br>        ans += <span class="hljs-number">3</span>;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="chiking-和大家一起来做签到题"><a href="#chiking-和大家一起来做签到题" class="headerlink" title="chiking 和大家一起来做签到题"></a>chiking 和大家一起来做签到题</h2><h3 id="大致题意-7"><a href="#大致题意-7" class="headerlink" title="大致题意"></a>大致题意</h3><p>给定一个 n，允许使用加减乘除和任意括号，找出有多少种不同的四个数字，使得这四个数字能够运算出 n，且运算过程中一定出现了小数，罗列所有的可能的四个数字的组合</p><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>其实就是一道暴力题</p><p>算一下复杂度，$13^4/2 \times 4! \times 2 \times 3^6 = 499,703,256$</p><p>解释一下，罗列每个位置的每个可能，为 $\rightarrow 13^4 / 2$ （避免重复，遍历过程保证前一个值不大于当前值）</p><p>排列数组 $\rightarrow 4!$</p><p>总共有两种括号方式 $((A @ B) @ C) @ D$ 和 $(A @ B) @ (C @ D)$（$ABCD$ 为数字，$@$ 为运算符号），所以 $\rightarrow 2$</p><p>枚举所有的运算符号 $\rightarrow 3^6$（6 种运算分别为 $A + B, A - B, B - A, A \times B, A \div B, B \div A$）</p><p>做一下剪枝，很容易提前放弃掉部分方案，复杂度还可以降低</p><p>所以直接暴力就行</p><p>但是，如何优雅的暴力呢？</p><h3 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-type">int</span> m;<br>    set&lt;<span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-type">int</span> curValue[<span class="hljs-number">4</span>];<br>    cin &gt;&gt; m;<br><br>    <span class="hljs-keyword">auto</span> isM = [&amp;](<span class="hljs-type">double</span> cur) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(cur - m) &lt; eps; &#125;;<br>    <span class="hljs-keyword">auto</span> isDouble = [&amp;](<span class="hljs-type">double</span> cur) &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">abs</span>(cur - <span class="hljs-built_in">int</span>(cur + eps)) &gt; eps; &#125;;<br><br>    <span class="hljs-keyword">auto</span> add = [](<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b) &#123; <span class="hljs-keyword">return</span> a + b; &#125;;<br>    <span class="hljs-keyword">auto</span> sub1 = [](<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b) &#123; <span class="hljs-keyword">return</span> a - b; &#125;;<br>    <span class="hljs-keyword">auto</span> sub2 = [](<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b) &#123; <span class="hljs-keyword">return</span> b - a; &#125;;<br>    <span class="hljs-keyword">auto</span> times = [](<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b) &#123; <span class="hljs-keyword">return</span> a * b; &#125;;<br>    <span class="hljs-keyword">auto</span> div1 = [](<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b) &#123; <span class="hljs-keyword">return</span> a / b; &#125;;<br>    <span class="hljs-keyword">auto</span> div2 = [](<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b) &#123; <span class="hljs-keyword">return</span> b / a; &#125;;<br><br>    function&lt;<span class="hljs-type">double</span>(<span class="hljs-type">double</span>, <span class="hljs-type">double</span>)&gt; arr[<span class="hljs-number">6</span>] = &#123;add, sub1, sub2, times, div1, div2&#125;;<br><br>    <span class="hljs-keyword">auto</span> cal = [&amp;]() &#123;<br>        <span class="hljs-type">bool</span> reach = <span class="hljs-literal">false</span>, hasNoDouble = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br><br>            function&lt;<span class="hljs-type">bool</span>(<span class="hljs-type">double</span>, <span class="hljs-type">int</span>, <span class="hljs-type">bool</span>)&gt; dfs1 = [&amp;](<span class="hljs-type">double</span> cur, <span class="hljs-type">int</span> deep, <span class="hljs-type">bool</span> hasDouble) &#123;<br>                <span class="hljs-keyword">if</span> (deep == <span class="hljs-number">4</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isM</span>(cur)) &#123;<br>                        reach = <span class="hljs-literal">true</span>;<br>                        <span class="hljs-keyword">if</span> (!hasDouble) &#123;<br>                            hasNoDouble = <span class="hljs-literal">true</span>;<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">all_of</span>(arr, arr + <span class="hljs-number">6</span>, [&amp;](function&lt;<span class="hljs-built_in">double</span>(<span class="hljs-type">double</span>, <span class="hljs-type">double</span>)&gt; &amp;func) &#123;<br>                    <span class="hljs-type">double</span> nxt = <span class="hljs-built_in">func</span>(cur, curValue[deep]);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs1</span>(nxt, deep + <span class="hljs-number">1</span>, hasDouble || <span class="hljs-built_in">isDouble</span>(nxt));<br>                &#125;);<br>            &#125;;<br>            function&lt;<span class="hljs-type">bool</span>()&gt; dfs2 = [&amp;]() &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;i: arr) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;j: arr) &#123;<br>                        <span class="hljs-type">double</span> l = <span class="hljs-built_in">i</span>(curValue[<span class="hljs-number">0</span>], curValue[<span class="hljs-number">1</span>]);<br>                        <span class="hljs-type">double</span> r = <span class="hljs-built_in">j</span>(curValue[<span class="hljs-number">2</span>], curValue[<span class="hljs-number">3</span>]);<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;k: arr) &#123;<br>                            <span class="hljs-type">double</span> t = <span class="hljs-built_in">k</span>(l, r);<br>                            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isM</span>(t)) &#123;<br>                                reach = <span class="hljs-literal">true</span>;<br>                                <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isDouble</span>(l) &amp;&amp; !<span class="hljs-built_in">isDouble</span>(r)) &#123;<br>                                    hasNoDouble = <span class="hljs-literal">true</span>;<br>                                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                                &#125;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;;<br><br>            <span class="hljs-built_in">dfs1</span>(curValue[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);<br>            <span class="hljs-built_in">dfs2</span>();<br><br>        &#125; <span class="hljs-keyword">while</span> (<span class="hljs-built_in">next_permutation</span>(curValue, curValue + <span class="hljs-number">4</span>));<br><br>        <span class="hljs-keyword">if</span> (reach &amp;&amp; !hasNoDouble) &#123;<br>            <span class="hljs-comment">// 四个小于 16 的 int 数字，可以按位压缩到一个 int 中</span><br>            <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: curValue) &#123;<br>                t &lt;&lt;= <span class="hljs-number">4</span>;<br>                t += item;<br>            &#125;<br>            ans.<span class="hljs-built_in">insert</span>(t);<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">// 暴力枚举没有必要一定要用 dfs，实际上 for 也可以，甚至更快，因为减少了出入栈的耗时</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">13</span>; ++i) &#123;<br>        curValue[<span class="hljs-number">0</span>] = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; <span class="hljs-number">13</span>; ++j) &#123;<br>            curValue[<span class="hljs-number">1</span>] = j + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = j; k &lt; <span class="hljs-number">13</span>; ++k) &#123;<br>                curValue[<span class="hljs-number">2</span>] = k + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = k; l &lt; <span class="hljs-number">13</span>; ++l) &#123;<br>                    curValue[<span class="hljs-number">3</span>] = l + <span class="hljs-number">1</span>;<br>                    <span class="hljs-built_in">cal</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    cout &lt;&lt; ans.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: ans) &#123;<br>        <span class="hljs-type">int</span> cur = item;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            curValue[i] = cur % <span class="hljs-number">16</span>;<br>            cur &gt;&gt;= <span class="hljs-number">4</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i)<br>            cout &lt;&lt; curValue[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == <span class="hljs-number">3</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="chiking-是一个机器人"><a href="#chiking-是一个机器人" class="headerlink" title="chiking 是一个机器人"></a>chiking 是一个机器人</h2><h3 id="大致题意-8"><a href="#大致题意-8" class="headerlink" title="大致题意"></a>大致题意</h3><p>有一个地图，有障碍物，三种不同的机器，一个只能下，一个只能右，最后那个可以下右移动，询问 q 次某种机器能否从起始点到终点</p><h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p>考虑前两种机器，其实很好解决，以第一种机器举例，我将整个地图的第一行加到第二行，此时的第二行加到第三行，如此操作后，每个点上保存的是此点的正上方有多少个墙，称其为“前缀墙”。若起点和终点的点的“前缀墙”数量相同，则就可以到达，否则中间必定存在墙</p><p>第二种机器就不再过多介绍了</p><p>第三种机器则比较难做，考虑一种 dp 的可能：若这个点不是墙，则可以到达这个点的所有点，是能够到达这个点上方点的所有点和能够到达这个点左边的所有点的并集。用公式描述一下就是</p><script type="math/tex; mode=display">\begin{equation}    dp[i][j] =    \begin{cases}        dp[i][j - 1] \cup dp[i - 1][j] \cup \{(i, j)\}, & \text{如果当前节点可达 } \\        空集合, & \text{如果当前节点不可达 }    \end{cases}\end{equation}</script>{% raw %}<p>如此计算我们可以得到第一份代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> x1, y1, x2, y2, i;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Node &amp;rhs) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> x2 &lt; rhs.x2;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">510</span>;<br><br>    <span class="hljs-comment">// 读取地图</span><br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;bitset&lt;M&gt;&gt; <span class="hljs-built_in">graph</span>(n);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>            <span class="hljs-type">char</span> c;<br>            cin &gt;&gt; c;<br>            graph[i][j] = c == <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 前缀和解决 1 和 2 型号的</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; modelList[<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;model: modelList) &#123;<br>        model.<span class="hljs-built_in">resize</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: model)<br>            item.<span class="hljs-built_in">resize</span>(m, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>            modelList[<span class="hljs-number">0</span>][i][j] = (i != <span class="hljs-number">0</span> ? modelList[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>][j] : <span class="hljs-number">0</span>) + !graph[i][j];<br>            modelList[<span class="hljs-number">1</span>][i][j] = (j != <span class="hljs-number">0</span> ? modelList[<span class="hljs-number">1</span>][i][j - <span class="hljs-number">1</span>] : <span class="hljs-number">0</span>) + !graph[i][j];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> q;<br>    cin &gt;&gt; q;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(q)</span></span>;    <span class="hljs-comment">// 离线计算答案</span><br>    vector&lt;Node&gt; query;<br>    query.<span class="hljs-built_in">reserve</span>(q);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; ++i) &#123;<br>        <span class="hljs-type">int</span> t, x1, y1, x2, y2;<br>        cin &gt;&gt; t &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;<br>        <span class="hljs-comment">// 下标从 0 开始</span><br>        x1 -= <span class="hljs-number">1</span>;<br>        y1 -= <span class="hljs-number">1</span>;<br>        x2 -= <span class="hljs-number">1</span>;<br>        y2 -= <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-number">1</span>) ans[i] = (y1 == y2) <span class="hljs-built_in">and</span> (x1 &lt;= x2) <span class="hljs-built_in">and</span> (modelList[<span class="hljs-number">0</span>][x1][y1] == modelList[<span class="hljs-number">0</span>][x2][y2]);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t == <span class="hljs-number">2</span>) ans[i] = (x1 == x2) <span class="hljs-built_in">and</span> (y1 &lt;= y2) <span class="hljs-keyword">and</span> modelList[<span class="hljs-number">1</span>][x1][y1] == modelList[<span class="hljs-number">1</span>][x2][y2];<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (x1 &gt; x2 || y1 &gt; y2) ans[i] = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">else</span> query.<span class="hljs-built_in">push_back</span>((Node) &#123;x1, y1, x2, y2, i&#125;);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">sort</span>(query.<span class="hljs-built_in">begin</span>(), query.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-keyword">auto</span> hashNode = [&amp;](<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;y) &#123;<br>        <span class="hljs-keyword">return</span> x * n + y;<br>    &#125;;<br><br>    vector&lt;bitset&lt;N * M&gt;&gt; <span class="hljs-built_in">dp</span>(m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        dp[i].<span class="hljs-built_in">reset</span>();<br>        dp[i][<span class="hljs-built_in">hashNode</span>(<span class="hljs-number">0</span>, i)] = graph[<span class="hljs-number">0</span>][i];<br>    &#125;<br><br>    <span class="hljs-type">int</span> curQuery = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-comment">// 离线计算每个位置哪些可以到达</span><br>        <span class="hljs-keyword">if</span> (!graph[i][<span class="hljs-number">0</span>]) dp[<span class="hljs-number">0</span>].<span class="hljs-built_in">reset</span>();<br>        <span class="hljs-keyword">else</span> dp[<span class="hljs-number">0</span>][<span class="hljs-built_in">hashNode</span>(i, <span class="hljs-number">0</span>)] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; m; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (!graph[i][j]) dp[j].<span class="hljs-built_in">reset</span>();<br>            <span class="hljs-keyword">else</span> &#123;<br>                dp[j][<span class="hljs-built_in">hashNode</span>(i, j)] = <span class="hljs-literal">true</span>;<br>                dp[j] |= dp[j - <span class="hljs-number">1</span>];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (curQuery &lt; query.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (query[curQuery].x2 == i) &#123;<br>                ans[query[curQuery].i] = dp[query[curQuery].y2][<span class="hljs-built_in">hashNode</span>(query[curQuery].x1, query[curQuery].y1)];<br>                curQuery++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; ++i)<br>        cout &lt;&lt; (ans[i] ? <span class="hljs-string">&quot;yes&quot;</span> : <span class="hljs-string">&quot;no&quot;</span>) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>让我们计算一下复杂度: $O(n^4) = 500^4 = 62,500,000,000$，这肯定不行，就算压位也不能通过</p><p>所以需要优化</p><p>问题出在需要计算所有的点可达问题，这就导致了计算一个节点就需要 $O(n^2)$ 的时间，非常不合理</p><p>如果试图减少一个 $n$，那么我们只能计算能否到达某一行或者某一列的值，而不能计算全部</p><p>但是考虑双向，如果我们知道出发点能够到达某个节点。而目标点可以来自同一个点，那么也同样可以说明可以到达</p><p>所以这个特殊的一行或者一列将地图分为两半，同时若询问是跨立在这一行或者这一列，则可以回答，但是对于没有跨立的如何解决？</p><p style="font-weight: 900;text-align: center;color: red;font-size: 50px;">分治</p><p>以横向为例，不断取横向中间轴作为特定行，不断计算跨此轴的询问的解，复杂度为 $O(n^3logn) = 500^3 * log(500) = 337,371,250$，似乎可行</p><p>可以得到第二份代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> QUERY_LEN = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> NUM = <span class="hljs-number">505</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> DIV = <span class="hljs-number">505</span>;<br><br><span class="hljs-type">char</span> mp[NUM][NUM];<br><span class="hljs-type">int</span> n, m, ans[QUERY_LEN];<br><span class="hljs-type">int</span> L[NUM][NUM], U[NUM][NUM];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> id, x1, y1, x2, y2;<br>&#125;;<br>vector&lt;node&gt; queryList;<br><span class="hljs-type">unsigned</span> vis1[NUM][NUM][DIV], vis2[NUM][NUM][DIV];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> *v)</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(v, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">unsigned</span>) * DIV);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cpFlag</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> *dist, <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> *from)</span> </span>&#123;<br>    <span class="hljs-built_in">memcpy</span>(dist, from, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">unsigned</span>) * DIV);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">orFlag</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> *dist, <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> *from)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; DIV; ++i) dist[i] |= from[i];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setFlagTrue</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> *v, <span class="hljs-type">int</span> id)</span> </span>&#123;<br>    v[id] = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">andFlagAny</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> *a, <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> *b)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; DIV; ++i) <span class="hljs-keyword">if</span> (a[i] &amp; b[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, vector&lt;node&gt; &amp;q)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt; r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = mid; i &gt;= l; i--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m; j &gt;= <span class="hljs-number">1</span>; j--) &#123;<br>            <span class="hljs-built_in">reset</span>(vis1[i][j]);<br>            <span class="hljs-keyword">if</span> (mp[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (i == mid) <span class="hljs-built_in">setFlagTrue</span>(vis1[i][j], j);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">cpFlag</span>(vis1[i][j], vis1[i + <span class="hljs-number">1</span>][j]);<br>            <span class="hljs-built_in">orFlag</span>(vis1[i][j], vis1[i][j + <span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = mid; i &lt;= r; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            <span class="hljs-built_in">reset</span>(vis2[i][j]);<br>            <span class="hljs-keyword">if</span> (mp[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (i == mid) <span class="hljs-built_in">setFlagTrue</span>(vis2[i][j], j);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">cpFlag</span>(vis2[i][j], vis2[i - <span class="hljs-number">1</span>][j]);<br>            <span class="hljs-built_in">orFlag</span>(vis2[i][j], vis2[i][j - <span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>    vector&lt;node&gt; vl, vr;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it: q) &#123;<br>        <span class="hljs-keyword">if</span> (it.x2 &lt; mid) vl.<span class="hljs-built_in">push_back</span>(it);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (it.x1 &gt; mid) vr.<span class="hljs-built_in">push_back</span>(it);<br>        <span class="hljs-keyword">else</span> ans[it.id] = <span class="hljs-built_in">andFlagAny</span>(vis1[it.x1][it.y1], vis2[it.x2][it.y2]);<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(l, mid - <span class="hljs-number">1</span>, vl);<br>    <span class="hljs-built_in">dfs</span>(mid + <span class="hljs-number">1</span>, r, vr);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            cin &gt;&gt; mp[i][j];<br>            <span class="hljs-keyword">if</span> (mp[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>) L[i][j] = L[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (mp[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>) U[i][j] = U[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> q;<br>    cin &gt;&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; i++) &#123;<br>        <span class="hljs-type">int</span> op, x1, x2, y1, y2;<br>        cin &gt;&gt; op &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;<br>        <span class="hljs-keyword">if</span> (x1 &gt; x2 || y1 &gt; y2) &#123;<br>            ans[i] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (y1 != y2 || U[x2][y2] &lt; x2 - x1) ans[i] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> ans[i] = <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">if</span> (x1 != x2 || L[x2][y2] &lt; y2 - y1) ans[i] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> ans[i] = <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            queryList.<span class="hljs-built_in">push_back</span>(&#123;i, x1, y1, x2, y2&#125;);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, n, queryList);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; i++) cout &lt;&lt; (ans[i] ? <span class="hljs-string">&quot;yes\n&quot;</span> : <span class="hljs-string">&quot;no\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，还是不对，实际上是空间超限了</p><p>仔细思考，实际上我们使用了 <code>int</code> 来模拟一个布尔值组，非常浪费空间，可以进行压位，得到最终的代码，此时的复杂度为 $O(n^3logn / 64) = 500^3 * log(500) / 64 = 5,271,425$，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> QUERY_LEN = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> NUM = <span class="hljs-number">505</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> DIV = <span class="hljs-number">8</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> LEN = <span class="hljs-number">64</span>;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> bits;<br><br><span class="hljs-type">char</span> mp[NUM][NUM];<br><span class="hljs-type">int</span> n, m, ans[QUERY_LEN];<br><span class="hljs-type">int</span> L[NUM][NUM], U[NUM][NUM];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> id, x1, y1, x2, y2;<br>&#125;;<br>vector&lt;node&gt; queryList;<br>bits vis1[NUM][NUM][DIV], vis2[NUM][NUM][DIV];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(bits *v)</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(v, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(bits) * DIV);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cpFlag</span><span class="hljs-params">(bits *dist, <span class="hljs-type">const</span> bits *from)</span> </span>&#123;<br>    <span class="hljs-built_in">memcpy</span>(dist, from, <span class="hljs-built_in">sizeof</span>(bits) * DIV);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">orFlag</span><span class="hljs-params">(bits *dist, <span class="hljs-type">const</span> bits *from)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; DIV; ++i) dist[i] |= from[i];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setFlagTrue</span><span class="hljs-params">(bits *v, <span class="hljs-type">int</span> id)</span> </span>&#123;<br>    v[id / LEN] |= ((bits) <span class="hljs-number">1u</span>) &lt;&lt; (id % LEN);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">andFlagAny</span><span class="hljs-params">(<span class="hljs-type">const</span> bits *a, <span class="hljs-type">const</span> bits *b)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; DIV; ++i) <span class="hljs-keyword">if</span> (a[i] &amp; b[i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, vector&lt;node&gt; &amp;q)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt; r) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = mid; i &gt;= l; i--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m; j &gt;= <span class="hljs-number">1</span>; j--) &#123;<br>            <span class="hljs-built_in">reset</span>(vis1[i][j]);<br>            <span class="hljs-keyword">if</span> (mp[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (i == mid) <span class="hljs-built_in">setFlagTrue</span>(vis1[i][j], j);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">cpFlag</span>(vis1[i][j], vis1[i + <span class="hljs-number">1</span>][j]);<br>            <span class="hljs-built_in">orFlag</span>(vis1[i][j], vis1[i][j + <span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = mid; i &lt;= r; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            <span class="hljs-built_in">reset</span>(vis2[i][j]);<br>            <span class="hljs-keyword">if</span> (mp[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (i == mid) <span class="hljs-built_in">setFlagTrue</span>(vis2[i][j], j);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">cpFlag</span>(vis2[i][j], vis2[i - <span class="hljs-number">1</span>][j]);<br>            <span class="hljs-built_in">orFlag</span>(vis2[i][j], vis2[i][j - <span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>    vector&lt;node&gt; vl, vr;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it: q) &#123;<br>        <span class="hljs-keyword">if</span> (it.x2 &lt; mid) vl.<span class="hljs-built_in">push_back</span>(it);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (it.x1 &gt; mid) vr.<span class="hljs-built_in">push_back</span>(it);<br>        <span class="hljs-keyword">else</span> ans[it.id] = <span class="hljs-built_in">andFlagAny</span>(vis1[it.x1][it.y1], vis2[it.x2][it.y2]);<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(l, mid - <span class="hljs-number">1</span>, vl);<br>    <span class="hljs-built_in">dfs</span>(mid + <span class="hljs-number">1</span>, r, vr);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>            cin &gt;&gt; mp[i][j];<br>            <span class="hljs-keyword">if</span> (mp[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>) L[i][j] = L[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (mp[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>) U[i][j] = U[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> q;<br>    cin &gt;&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; i++) &#123;<br>        <span class="hljs-type">int</span> op, x1, x2, y1, y2;<br>        cin &gt;&gt; op &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;<br>        <span class="hljs-keyword">if</span> (x1 &gt; x2 || y1 &gt; y2) &#123;<br>            ans[i] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (y1 != y2 || U[x2][y2] &lt; x2 - x1) ans[i] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> ans[i] = <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">if</span> (x1 != x2 || L[x2][y2] &lt; y2 - y1) ans[i] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">else</span> ans[i] = <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            queryList.<span class="hljs-built_in">push_back</span>(&#123;i, x1, y1, x2, y2&#125;);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, n, queryList);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; i++) cout &lt;&lt; (ans[i] ? <span class="hljs-string">&quot;yes\n&quot;</span> : <span class="hljs-string">&quot;no\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，如果你了解 <code>bitset</code> 的话，那么就更好办了</p>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dockerfile 中下载 JDK8</title>
    <link href="/2021/11/18/develop-note/dockerfile-run-apt-install-jdk-8/"/>
    <url>/2021/11/18/develop-note/dockerfile-run-apt-install-jdk-8/</url>
    
    <content type="html"><![CDATA[<h1 id="openjdk-8-jdk-headless"><a href="#openjdk-8-jdk-headless" class="headerlink" title="openjdk-8-jdk-headless"></a>openjdk-8-jdk-headless</h1><p>在 Linux 中常用 <code>apt install openjdk-8-headless</code> 来安装 JDK，但是 dockerfile 中无法正常安装</p><h1 id="adoptopenjdk-8-hotspot"><a href="#adoptopenjdk-8-hotspot" class="headerlink" title="adoptopenjdk-8-hotspot"></a>adoptopenjdk-8-hotspot</h1><p>通常在 docker 中使用 adoptopenjdk-8-hotspot 来代替 openjdk</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">RUN</span> [<span class="hljs-string">&quot;/bin/bash&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;wget -qO - https://adoptopenjdk.jfrog.io/adoptopenjdk/api/gpg/key/public | apt-key add -&quot;</span>]<br><span class="hljs-built_in">RUN</span> [<span class="hljs-string">&quot;/bin/bash&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;echo &#x27;deb https://adoptopenjdk.jfrog.io/adoptopenjdk/deb buster main&#x27; &gt; /etc/apt/sources.list.d/AdoptOpenJDK.list&quot;</span>]<br>apt install adoptopenjdk-8-hotspot<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>短笔记</tag>
      
      <tag>JDK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac 使用带 python 的 vim</title>
    <link href="/2021/11/15/mac/macvim/"/>
    <url>/2021/11/15/mac/macvim/</url>
    
    <content type="html"><![CDATA[<p>mac 自带的 vim 并不支持 python<br>采用 brew 的 macvim 代替即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">brew install macvim<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>macOS</tag>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac 截图唤起速度慢</title>
    <link href="/2021/10/24/mac/screen-cut/"/>
    <url>/2021/10/24/mac/screen-cut/</url>
    
    <content type="html"><![CDATA[<ul><li>打开截屏软件</li><li>选中任意一个录制的按钮</li><li>点击选项</li><li>取消 mac 麦克风按钮</li></ul>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>macOS</tag>
      
      <tag>截图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Strassen算法代码</title>
    <link href="/2021/10/13/cpp/Strassen/"/>
    <url>/2021/10/13/cpp/Strassen/</url>
    
    <content type="html"><![CDATA[<p><strong>本文仅代码，无理论解释</strong></p><p>实话实说，我觉得这个算法在C系列的语言下，简直垃圾到爆炸……毕竟是一群完全不懂程序数学家对着纸弄出来的，看起来好像非常的有用，实际上耗时是非常爆炸的。</p><p>但是《算法导论》里有啊……然后上课又要求手写一个</p><p>于是我就手写了一个……我尽可能的减少使用的空间同时加快速度了，而且是通过递归实现 Strassen 算法</p><p>其中，in.txt 已经预先准备了 3000000 个范围在 0-100 随机数，避免程序在运算过程中爆 int（虽然完全可以取1000）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by Mauve on 3/29/2020.</span><br><span class="hljs-comment"> * Copyright © 2020 Mauve, All Rights Reserved</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 矩阵相乘</span><br><span class="hljs-comment"> * 最终结果耗时结果保存至</span><br><span class="hljs-comment"> * https://www.desmos.com/calculator/gl4tm5i1zu</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">mat</span> &#123;<br>    <span class="hljs-type">unsigned</span> row, col;<br><br>    <span class="hljs-built_in">mat</span>(<span class="hljs-type">unsigned</span> r, <span class="hljs-type">unsigned</span> c) : <span class="hljs-built_in">row</span>(r), <span class="hljs-built_in">col</span>(c) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> &amp;<span class="hljs-title">pos_ref</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> i, <span class="hljs-type">unsigned</span> j)</span> </span>= <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">pos</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> i, <span class="hljs-type">unsigned</span> j)</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">base_mat</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sub_mat</span>;<br><br>stack&lt;sub_mat *&gt; sub_data;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">base_mat</span> : mat &#123;<br>    <span class="hljs-type">int</span> *data;<br><br>    <span class="hljs-built_in">base_mat</span>(<span class="hljs-type">unsigned</span> r, <span class="hljs-type">unsigned</span> c) : <span class="hljs-built_in">mat</span>(r, c), <span class="hljs-built_in">data</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[row * col]) &#123;&#125;<br><br>    ~<span class="hljs-built_in">base_mat</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] data;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> &amp;<span class="hljs-title">pos_ref</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> i, <span class="hljs-type">unsigned</span> j)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> *(data + i * col + j);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">pos</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> i, <span class="hljs-type">unsigned</span> j)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> *(data + i * col + j);<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">unsigned</span> min_mul;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sub_mat</span> : mat &#123;<br>    mat *a, *b;<br>    <span class="hljs-type">bool</span> is_add;<br>    <span class="hljs-type">unsigned</span> offset_ai, offset_aj, offset_bi, offset_bj;<br><br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">sub_mat</span><span class="hljs-params">(mat *data)</span> : mat(data-&gt;row, data-&gt;col), a(data), b(nullptr),</span><br><span class="hljs-function">                                  is_add(false), offset_ai(<span class="hljs-number">0</span>), offset_aj(<span class="hljs-number">0</span>),</span><br><span class="hljs-function">                                  offset_bi(<span class="hljs-number">0</span>), offset_bj(<span class="hljs-number">0</span>) &#123;</span> sub_data.<span class="hljs-built_in">push</span>(<span class="hljs-keyword">this</span>); &#125;<br><br>    <span class="hljs-built_in">sub_mat</span>(mat *data, <span class="hljs-type">bool</span> of_i, <span class="hljs-type">bool</span> of_j) : <span class="hljs-built_in">mat</span>(data-&gt;row &gt;&gt; <span class="hljs-number">1u</span>, data-&gt;col &gt;&gt; <span class="hljs-number">1u</span>), <span class="hljs-built_in">a</span>(data), <span class="hljs-built_in">b</span>(<span class="hljs-literal">nullptr</span>),<br>                                               <span class="hljs-built_in">is_add</span>(<span class="hljs-literal">false</span>), <span class="hljs-built_in">offset_ai</span>(of_i ? data-&gt;row &gt;&gt; <span class="hljs-number">1u</span> : <span class="hljs-number">0</span>),<br>                                               <span class="hljs-built_in">offset_aj</span>(of_j ? data-&gt;col &gt;&gt; <span class="hljs-number">1u</span> : <span class="hljs-number">0</span>),<br>                                               <span class="hljs-built_in">offset_bi</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">offset_bj</span>(<span class="hljs-number">0</span>) &#123; sub_data.<span class="hljs-built_in">push</span>(<span class="hljs-keyword">this</span>); &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> &amp;<span class="hljs-title">pos_ref</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> i, <span class="hljs-type">unsigned</span> j)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-built_in">assert</span>(b == <span class="hljs-literal">nullptr</span>);<br>        <span class="hljs-keyword">return</span> a-&gt;<span class="hljs-built_in">pos_ref</span>(i + offset_ai, j + offset_aj);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">pos</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> i, <span class="hljs-type">unsigned</span> j)</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> a-&gt;<span class="hljs-built_in">pos</span>(i + offset_ai, j + offset_aj);<br>        <span class="hljs-keyword">return</span> a-&gt;<span class="hljs-built_in">pos</span>(i + offset_ai, j + offset_aj) + (is_add ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>) * b-&gt;<span class="hljs-built_in">pos</span>(i + offset_bi, j + offset_bj);<br>    &#125;<br><br>    <span class="hljs-keyword">inline</span> sub_mat *<span class="hljs-keyword">operator</span>+(sub_mat &amp;other) &#123;<br>        <span class="hljs-keyword">auto</span> res = <span class="hljs-keyword">new</span> <span class="hljs-built_in">sub_mat</span>(<span class="hljs-keyword">this</span>);<br>        res-&gt;b = &amp;other;<br>        res-&gt;is_add = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-keyword">inline</span> sub_mat *<span class="hljs-keyword">operator</span>-(sub_mat &amp;other) &#123;<br>        <span class="hljs-keyword">auto</span> res = <span class="hljs-keyword">new</span> <span class="hljs-built_in">sub_mat</span>(<span class="hljs-keyword">this</span>);<br>        res-&gt;b = &amp;other;<br>        res-&gt;is_add = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    mat *<span class="hljs-keyword">operator</span>*(sub_mat &amp;other) &#123;<br>        <span class="hljs-built_in">assert</span>(col == other.row);<br>        <span class="hljs-keyword">auto</span> res = <span class="hljs-keyword">new</span> <span class="hljs-built_in">base_mat</span>(row, other.col);<br>        <span class="hljs-keyword">if</span> (col &amp; <span class="hljs-number">1u</span> || row &amp; <span class="hljs-number">1u</span> || other.col &amp; <span class="hljs-number">1u</span> || col &lt;= min_mul || row &lt;= min_mul || other.col &lt;= min_mul) &#123;<br>            <span class="hljs-built_in">memset</span>(res-&gt;data, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * res-&gt;row * res-&gt;col);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; col; k++)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; row; ++i)<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; other.col; ++j)<br>                        res-&gt;<span class="hljs-built_in">pos_ref</span>(i, j) += <span class="hljs-built_in">pos</span>(i, k) * other.<span class="hljs-built_in">pos</span>(k, j);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">size_t</span> sub_data_size = sub_data.<span class="hljs-built_in">size</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> a(i, j) (*new sub_mat(this, i == 2 , j == 2))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> b(i, j) (*new sub_mat(&amp;other, i == 2 , j == 2))</span><br>            <span class="hljs-keyword">auto</span> m1 = *(<span class="hljs-built_in">a</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) + <span class="hljs-built_in">a</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)) * *(<span class="hljs-built_in">b</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) + <span class="hljs-built_in">b</span> (<span class="hljs-number">2</span>, <span class="hljs-number">2</span>));<br>            <span class="hljs-keyword">auto</span> m2 = *(<span class="hljs-built_in">a</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>) + <span class="hljs-built_in">a</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)) * <span class="hljs-built_in">b</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">auto</span> m3 = <span class="hljs-built_in">a</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) * *(<span class="hljs-built_in">b</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) - <span class="hljs-built_in">b</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>));<br>            <span class="hljs-keyword">auto</span> m4 = <span class="hljs-built_in">a</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>) * *(<span class="hljs-built_in">b</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>) - <span class="hljs-built_in">b</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>));<br>            <span class="hljs-keyword">auto</span> m5 = *(<span class="hljs-built_in">a</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) + <span class="hljs-built_in">a</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)) * <span class="hljs-built_in">b</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>            <span class="hljs-keyword">auto</span> m6 = *(<span class="hljs-built_in">a</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>) - <span class="hljs-built_in">a</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)) * *(<span class="hljs-built_in">b</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) + <span class="hljs-built_in">b</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br>            <span class="hljs-keyword">auto</span> m7 = *(<span class="hljs-built_in">a</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) - <span class="hljs-built_in">a</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)) * *(<span class="hljs-built_in">b</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>) + <span class="hljs-built_in">b</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>));<br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> a</span><br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> b</span><br>            <span class="hljs-type">unsigned</span> half_row = row &gt;&gt; <span class="hljs-number">1u</span>, half_col = col &gt;&gt; <span class="hljs-number">1u</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> m(t) (m##t-&gt;pos(i, j))</span><br>            <span class="hljs-comment">// C11</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> i = <span class="hljs-number">0</span>; i &lt; half_row; ++i)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> j = <span class="hljs-number">0</span>; j &lt; half_col; ++j)<br>                    res-&gt;<span class="hljs-built_in">pos_ref</span>(i, j) = <span class="hljs-built_in">m</span>(<span class="hljs-number">1</span>) + <span class="hljs-built_in">m</span>(<span class="hljs-number">4</span>) - <span class="hljs-built_in">m</span>(<span class="hljs-number">5</span>) + <span class="hljs-built_in">m</span>(<span class="hljs-number">7</span>);<br>            <span class="hljs-comment">// C12</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> i = <span class="hljs-number">0</span>; i &lt; half_row; ++i)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> j = <span class="hljs-number">0</span>; j &lt; half_col; ++j)<br>                    res-&gt;<span class="hljs-built_in">pos_ref</span>(i, j + half_col) = <span class="hljs-built_in">m</span>(<span class="hljs-number">3</span>) + <span class="hljs-built_in">m</span>(<span class="hljs-number">5</span>);<br>            <span class="hljs-comment">// C21</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> i = <span class="hljs-number">0</span>; i &lt; half_row; ++i)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> j = <span class="hljs-number">0</span>; j &lt; half_col; ++j)<br>                    res-&gt;<span class="hljs-built_in">pos_ref</span>(i + half_row, j) = <span class="hljs-built_in">m</span>(<span class="hljs-number">2</span>) + <span class="hljs-built_in">m</span>(<span class="hljs-number">4</span>);<br>            <span class="hljs-comment">// C22</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> i = <span class="hljs-number">0</span>; i &lt; half_row; ++i)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> j = <span class="hljs-number">0</span>; j &lt; half_col; ++j)<br>                    res-&gt;<span class="hljs-built_in">pos_ref</span>(i + half_row, j + half_col) = <span class="hljs-built_in">m</span>(<span class="hljs-number">1</span>) - <span class="hljs-built_in">m</span>(<span class="hljs-number">2</span>) + <span class="hljs-built_in">m</span>(<span class="hljs-number">3</span>) + <span class="hljs-built_in">m</span>(<span class="hljs-number">6</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">undef</span> m</span><br>            <span class="hljs-keyword">delete</span> <span class="hljs-built_in">dynamic_cast</span>&lt;base_mat *&gt;(m1);<br>            <span class="hljs-keyword">delete</span> <span class="hljs-built_in">dynamic_cast</span>&lt;base_mat *&gt;(m2);<br>            <span class="hljs-keyword">delete</span> <span class="hljs-built_in">dynamic_cast</span>&lt;base_mat *&gt;(m3);<br>            <span class="hljs-keyword">delete</span> <span class="hljs-built_in">dynamic_cast</span>&lt;base_mat *&gt;(m4);<br>            <span class="hljs-keyword">delete</span> <span class="hljs-built_in">dynamic_cast</span>&lt;base_mat *&gt;(m5);<br>            <span class="hljs-keyword">delete</span> <span class="hljs-built_in">dynamic_cast</span>&lt;base_mat *&gt;(m6);<br>            <span class="hljs-keyword">delete</span> <span class="hljs-built_in">dynamic_cast</span>&lt;base_mat *&gt;(m7);<br>            <span class="hljs-keyword">while</span> (sub_data.<span class="hljs-built_in">size</span>() &gt; sub_data_size) &#123;<br>                <span class="hljs-keyword">delete</span> sub_data.<span class="hljs-built_in">top</span>();<br>                sub_data.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">unsigned</span> N = <span class="hljs-number">2</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cerr &lt;&lt; <span class="hljs-string">&quot;N = &quot;</span> &lt;&lt; N &lt;&lt; endl;<br>    <span class="hljs-function">base_mat <span class="hljs-title">a</span><span class="hljs-params">(N, N)</span>, <span class="hljs-title">b</span><span class="hljs-params">(N, N)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; N; ++j)<br>            cin &gt;&gt; a.<span class="hljs-built_in">pos_ref</span>(i, j);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; N; ++j)<br>            cin &gt;&gt; b.<span class="hljs-built_in">pos_ref</span>(i, j);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t = <span class="hljs-number">1</span>; t &lt; <span class="hljs-built_in">min</span>(<span class="hljs-number">10u</span>, N); t += <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-keyword">auto</span> x = <span class="hljs-keyword">new</span> <span class="hljs-built_in">sub_mat</span>(&amp;a), y = <span class="hljs-keyword">new</span> <span class="hljs-built_in">sub_mat</span>(&amp;b);<br>        min_mul = t;<br><br>        <span class="hljs-keyword">auto</span> time_1 = <span class="hljs-built_in">clock</span>();<br>        <span class="hljs-keyword">auto</span> z = *x * *y;<br>        <span class="hljs-keyword">auto</span> time_2 = <span class="hljs-built_in">clock</span>();<br><br>        cerr &lt;&lt; <span class="hljs-string">&quot;t = &quot;</span> &lt;&lt; t &lt;&lt; <span class="hljs-string">&quot; time: &quot;</span> &lt;&lt; <span class="hljs-built_in">double</span>(time_2 - time_1) / CLOCKS_PER_SEC &lt;&lt; endl;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-built_in">dynamic_cast</span>&lt;base_mat *&gt;(z);<br>        <span class="hljs-keyword">while</span> (!sub_data.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">delete</span> sub_data.<span class="hljs-built_in">top</span>();<br>            sub_data.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">auto</span> x = <span class="hljs-keyword">new</span> <span class="hljs-built_in">sub_mat</span>(&amp;a), y = <span class="hljs-keyword">new</span> <span class="hljs-built_in">sub_mat</span>(&amp;b);<br>    min_mul = <span class="hljs-number">10000</span>;<br><br>    <span class="hljs-keyword">auto</span> time_1 = <span class="hljs-built_in">clock</span>();<br>    <span class="hljs-keyword">auto</span> z = *x * *y;<br>    <span class="hljs-keyword">auto</span> time_2 = <span class="hljs-built_in">clock</span>();<br><br>    cerr &lt;&lt; <span class="hljs-string">&quot;tradition: &quot;</span> &lt;&lt; <span class="hljs-built_in">double</span>(time_2 - time_1) / CLOCKS_PER_SEC &lt;&lt; endl;<br>    <span class="hljs-keyword">delete</span> <span class="hljs-built_in">dynamic_cast</span>&lt;base_mat *&gt;(z);<br>    <span class="hljs-keyword">while</span> (!sub_data.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">delete</span> sub_data.<span class="hljs-built_in">top</span>();<br>        sub_data.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    N *= <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (N &gt;= <span class="hljs-number">1000</span>) <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios_base::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ACM_LOCAL</span><br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;in.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;out.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> test_index_for_debug = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span> acm_local_for_debug;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; acm_local_for_debug &amp;&amp; acm_local_for_debug != <span class="hljs-string">&#x27;~&#x27;</span>) &#123;<br>        cin.<span class="hljs-built_in">putback</span>(acm_local_for_debug);<br>        <span class="hljs-keyword">if</span> (test_index_for_debug &gt; <span class="hljs-number">20</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Check the stdin!!!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">auto</span> start_clock_for_debug = <span class="hljs-built_in">clock</span>();<br>        <span class="hljs-built_in">solve</span>();<br>        <span class="hljs-keyword">auto</span> end_clock_for_debug = <span class="hljs-built_in">clock</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="hljs-string">&quot; successful&quot;</span> &lt;&lt; endl;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="hljs-string">&quot; Run Time: &quot;</span><br>             &lt;&lt; <span class="hljs-built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="hljs-string">&quot;s&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-built_in">solve</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习&amp;开发&amp;实现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 语言实现动态变化的线程池</title>
    <link href="/2021/10/13/cpp/thread-pool/"/>
    <url>/2021/10/13/cpp/thread-pool/</url>
    
    <content type="html"><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h2><p>Job 作为任务的类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Job</span> &#123;<br>    <span class="hljs-type">void</span> *data;<br>    function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">void</span> *data)&gt; func;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Job</span>(<span class="hljs-type">void</span> *data, function&lt;<span class="hljs-built_in">void</span>(<span class="hljs-type">void</span> *data)&gt; func);<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">exec</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>其中定义两个变量，<code>data</code>，和 <code>func</code>。</p><p><code>func</code> 用来保存需要调用的方法，当执行任务时，调用此函数即可。考虑到需要传递参数的可能，所以定义参数为一个指针，而另一个变量 data 则为需要传递给 func 的参数指针</p><p>函数的实现为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Job::<span class="hljs-built_in">Job</span>(<span class="hljs-type">void</span> *data, function&lt;<span class="hljs-built_in">void</span>(<span class="hljs-type">void</span> *)&gt; func) &#123;<br>    <span class="hljs-keyword">this</span>-&gt;data = data;<br>    <span class="hljs-keyword">this</span>-&gt;func = <span class="hljs-built_in">move</span>(func);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Job::exec</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">func</span>(data);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线程池核心代码"><a href="#线程池核心代码" class="headerlink" title="线程池核心代码"></a>线程池核心代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    Mutex&lt;map&lt;<span class="hljs-type">pthread_t</span>, thread *&gt;&gt; threadPool;             <span class="hljs-comment">// 线程池</span><br>    Mutex&lt;queue&lt;Job *&gt;&gt; enqueue;                            <span class="hljs-comment">// 任务队列</span><br>    Mutex&lt;vector&lt;thread *&gt;&gt; deathThread;                    <span class="hljs-comment">// 已经死亡的线程</span><br>    Mutex&lt;<span class="hljs-type">int</span>&gt; needKill;                                    <span class="hljs-comment">// 需要杀死的线程数量</span><br>    condition_variable noTaskCv;                            <span class="hljs-comment">// 无任务时的条件信号量</span><br>    mutex noTaskCvMutex;                                    <span class="hljs-comment">// 无任务的条件信号量的锁</span><br>    <span class="hljs-type">int</span> maxCore;                                            <span class="hljs-comment">// 核心线程数</span><br>    <span class="hljs-type">bool</span> killed;                                            <span class="hljs-comment">// 已经终止了</span><br><br>    <span class="hljs-function">Job *<span class="hljs-title">takeJob</span><span class="hljs-params">()</span></span>;                                         <span class="hljs-comment">// 获取一个任务</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">addThread</span><span class="hljs-params">()</span></span>;                               <span class="hljs-comment">// 添加一个线程</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">clean</span><span class="hljs-params">()</span></span>;                                           <span class="hljs-comment">// 清理所有死亡的线程</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">ThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> core)</span></span>;                          <span class="hljs-comment">// 构造函数</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">submit</span><span class="hljs-params">(Job *job)</span></span>;                                  <span class="hljs-comment">// 提交任务，需要提交一个指针类型，且不需要主动 delete，当任务完成后，会被线程池 delete 掉</span><br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getAccumulation</span><span class="hljs-params">()</span></span>;                                  <span class="hljs-comment">// 获取当前堆积任务数量</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">updateCore</span><span class="hljs-params">(<span class="hljs-type">int</span> newCount)</span></span>;                          <span class="hljs-comment">// 更新核心线程数，若增加则会新增线程，若减少则会在空闲时间关闭部分线程</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wait</span><span class="hljs-params">()</span></span>;                                            <span class="hljs-comment">// 设定线程池为终止，不再可以提交任务，并等待所有任务完成</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>;                                           <span class="hljs-comment">// 强制关闭线程池，不等待任务完成</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>首先通过 init 函数初始化核心线程数</li><li>通过 submit 的函数提交任务，必须是一个 job 指针，且必须是单独 new 出来的，线程池会自动清理已经完成的任务</li><li>可以随时通过 getAccumulation 来获取到当前堆积的任务，使得可以手动调整线程池数量</li><li>使用 upateCore 来调整核心线程数量</li><li><p>建议通过 wait 来实现终止线程池</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> ThreadPool::<span class="hljs-built_in">ThreadPool</span>(<span class="hljs-type">int</span> core) : <span class="hljs-built_in">maxCore</span>(core), <span class="hljs-built_in">killed</span>(<span class="hljs-literal">false</span>), <span class="hljs-built_in">needKill</span>(<span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; core; ++i) <span class="hljs-built_in">addThread</span>();<br>&#125;<br><br><span class="hljs-function">Job *<span class="hljs-title">ThreadPool::takeJob</span><span class="hljs-params">()</span> </span>&#123;<br>    Job *cur = <span class="hljs-literal">nullptr</span>;<br>    enqueue.<span class="hljs-built_in">run</span>([&amp;](queue&lt;Job *&gt; &amp;q) &#123;<br>        <span class="hljs-keyword">if</span> (q.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span>;<br>        cur = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>    &#125;);<br>    <span class="hljs-keyword">return</span> cur;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ThreadPool::addThread</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> work = [&amp;]() &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            Job *cur = <span class="hljs-built_in">takeJob</span>();<br>            <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">nullptr</span>) &#123;<br>                cur-&gt;<span class="hljs-built_in">exec</span>();<br>                <span class="hljs-keyword">delete</span> cur;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">bool</span> dead = <span class="hljs-literal">false</span>;<br>                needKill.<span class="hljs-built_in">run</span>([&amp;](<span class="hljs-type">int</span> &amp;count) &#123;<br>                    <span class="hljs-keyword">if</span> (count &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>                    dead = <span class="hljs-literal">true</span>;<br>                    count--;<br>                &#125;);<br>                <span class="hljs-keyword">if</span> (dead) <span class="hljs-keyword">break</span>;<br><br>                <span class="hljs-built_in">clean</span>();<br>                <span class="hljs-function">unique_lock&lt;mutex&gt; <span class="hljs-title">lk</span><span class="hljs-params">(noTaskCvMutex)</span></span>;<br>                noTaskCv.<span class="hljs-built_in">wait</span>(lk);<br>            &#125;<br>        &#125;<br>        threadPool.<span class="hljs-built_in">run</span>([&amp;](map&lt;<span class="hljs-type">pthread_t</span>, thread *&gt; &amp;data) &#123;<br>            <span class="hljs-keyword">auto</span> iter = data.<span class="hljs-built_in">find</span>(<span class="hljs-built_in">pthread_self</span>());<br>            deathThread.<span class="hljs-built_in">run</span>([&amp;](vector&lt;thread *&gt; &amp;data) &#123;<br>                data.<span class="hljs-built_in">push_back</span>(iter-&gt;second);<br>            &#125;);<br>            data.<span class="hljs-built_in">erase</span>(iter);<br>        &#125;);<br>    &#125;;<br><br>    <span class="hljs-keyword">auto</span> *newThread = <span class="hljs-keyword">new</span> <span class="hljs-built_in">thread</span>(work);<br>    threadPool.<span class="hljs-built_in">run</span>([&amp;](map&lt;<span class="hljs-type">pthread_t</span>, thread *&gt; &amp;data) &#123;<br>        data.<span class="hljs-built_in">insert</span>(&#123;newThread-&gt;<span class="hljs-built_in">native_handle</span>(), newThread&#125;);<br>    &#125;);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ThreadPool::clean</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (deathThread.<span class="hljs-built_in">get</span>().<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span>;<br>    deathThread.<span class="hljs-built_in">run</span>([&amp;](vector&lt;thread *&gt; &amp;data) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: data) <span class="hljs-keyword">delete</span> item;<br>    &#125;);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ThreadPool::submit</span><span class="hljs-params">(Job *job)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (killed) <span class="hljs-keyword">return</span>;<br>    enqueue.<span class="hljs-built_in">run</span>([&amp;](queue&lt;Job *&gt; &amp;q) &#123;<br>        q.<span class="hljs-built_in">push</span>(job);<br>        noTaskCv.<span class="hljs-built_in">notify_one</span>();<br>    &#125;);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ThreadPool::getAccumulation</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) enqueue.<span class="hljs-built_in">get</span>().<span class="hljs-built_in">size</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ThreadPool::updateCore</span><span class="hljs-params">(<span class="hljs-type">int</span> newCount)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (killed) <span class="hljs-keyword">return</span>;<br>    needKill.<span class="hljs-built_in">run</span>([&amp;](<span class="hljs-type">int</span> &amp;cleaned) &#123;<br>        <span class="hljs-keyword">if</span> (newCount &gt; <span class="hljs-keyword">this</span>-&gt;maxCore)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-keyword">this</span>-&gt;maxCore; i &lt; newCount; ++i)<br>                <span class="hljs-built_in">addThread</span>();<br>        <span class="hljs-keyword">else</span> &#123;<br>            cleaned += <span class="hljs-keyword">this</span>-&gt;maxCore - newCount;<br>            noTaskCv.<span class="hljs-built_in">notify_all</span>();<br>        &#125;<br>    &#125;);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ThreadPool::wait</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">updateCore</span>(<span class="hljs-number">0</span>);<br>    killed = <span class="hljs-literal">true</span>;<br>    map&lt;<span class="hljs-type">pthread_t</span>, thread *&gt; tmp = threadPool.<span class="hljs-built_in">get</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: tmp)<br>        item.second-&gt;<span class="hljs-built_in">join</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ThreadPool::close</span><span class="hljs-params">()</span> </span>&#123;<br>    killed = <span class="hljs-literal">true</span>;<br>    map&lt;<span class="hljs-type">pthread_t</span>, thread *&gt; tmp = threadPool.<span class="hljs-built_in">get</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: tmp) &#123;<br>        <span class="hljs-built_in">pthread_kill</span>(item.first, SIGKILL);<br>        <span class="hljs-keyword">delete</span> item.second;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="线程任务流程"><a href="#线程任务流程" class="headerlink" title="线程任务流程"></a>线程任务流程</h2><ul><li>尝试获取一个任务</li><li>若有任务<ul><li>执行任务</li><li>删除任务</li></ul></li><li>若无任务<ul><li>检查是否有需要杀死的线程</li><li>若有需要杀死的线程<ul><li>将当前线程添加进入已经结束线程组</li><li>将当前线程从线程池中移除</li></ul></li><li>若无需要杀死的线程<ul><li>清理需要删除的任务</li><li>进入等待状态</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习&amp;开发&amp;实现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round#744 (Div. 3)</title>
    <link href="/2021/09/29/acm/codeforces/CodeforcesRound744/"/>
    <url>/2021/09/29/acm/codeforces/CodeforcesRound744/</url>
    
    <content type="html"><![CDATA[<p><em>自从退役之后，打了三个月的工，然后再来打这一场 Div3，庆幸自己还能打打，在最后还剩 4 分钟的时候 A 掉了 G 题，终于在比赛期间 AK</em></p><h1 id="A-Casimir’s-String-Solitaire"><a href="#A-Casimir’s-String-Solitaire" class="headerlink" title="A. Casimir’s String Solitaire"></a>A. Casimir’s String Solitaire</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给你一个字符串，仅还有 <code>&#39;A&#39;, &#39;B&#39;, &#39;C&#39;</code> 三个字符，每次可以同时删除任意两个 <code>&#39;A&#39;, &#39;B&#39;</code>，也可以同时删除两个 <code>&#39;B&#39;, &#39;C&#39;</code>。判断一个字符串能过上述操作变为空字符串</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>统计了一下所有字符串中每个字符串的数量，然后若 <code>&#39;B&#39;</code> 的数量和 <code>&#39;A&#39;</code> 和 <code>&#39;C&#39;</code> 的数量之和相同，则 OK</p><h2 id="AC-Code"><a href="#AC-Code" class="headerlink" title="AC Code"></a>AC Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        string str;<br>        cin &gt;&gt; str;<br>        <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">0</span>, c = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item : str) &#123;<br>            <span class="hljs-keyword">switch</span> (item) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;A&#x27;</span>:<br>                    a++;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;B&#x27;</span>:<br>                    b++;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;C&#x27;</span>:<br>                    c++;<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; (a + c == b ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-Shifting-Sort"><a href="#B-Shifting-Sort" class="headerlink" title="B. Shifting Sort"></a>B. Shifting Sort</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>一个字符串，每次允许选择其中一个区间，对这个区间进行移位运算，使得这个数组最终有序，使用此操作不能超过整个数组长度次数</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>这已经把插入排序写在脸上了</p><h2 id="AC-Code-1"><a href="#AC-Code-1" class="headerlink" title="AC Code"></a>AC Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cin &gt;&gt; data[i];<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; ans;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> l = i + <span class="hljs-number">1</span>, r = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; --j) &#123;<br>                <span class="hljs-keyword">if</span> (data[j] &gt; data[j + <span class="hljs-number">1</span>]) &#123;<br>                    l--;<br>                    <span class="hljs-built_in">swap</span>(data[j], data[j + <span class="hljs-number">1</span>]);<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (l != r) ans.<span class="hljs-built_in">emplace_back</span>(l, r);<br>        &#125;<br>        cout &lt;&lt; ans.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: ans) &#123;<br>            cout &lt;&lt; item.first &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; item.second &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; item.second - item.first &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Ticks"><a href="#C-Ticks" class="headerlink" title="C. Ticks"></a>C. Ticks</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>一个矩形网格，在上面画 <code>&#39;V&#39;</code> 字形，问，当前对矩形网格上，是否是可以通过画若干个至少为 <code>&#39;k&#39;</code> 大的 <code>&#39;V&#39;</code> 来满足</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先所有 <code>&#39;V&#39;</code> 的特点是最下面的点，每个 <code>&#39;V&#39;</code> 都可以用最下面的点来标记 <code>&#39;V&#39;</code>，而其两臂则可以有多长就多长即可。所以可以很轻松得出，应该从下往上遍历来解决问题</p><p>如果从下向上遍历，那么若遇到一个 <code>&#39;*&#39;</code> 点，有可能是之前 <code>&#39;V&#39;</code> 的臂，也有可能是新的 <code>&#39;V&#39;</code>，同时也可以是两者的结合。所以需要一个标记数组，表示每个点是否已经被下面的 <code>&#39;V&#39;</code> 给画过了，若没有，则这里必定是 <code>&#39;V&#39;</code> 的起点。<br>但是若为画过，则需要同时考虑两种情况</p><h2 id="AC-Code-2"><a href="#AC-Code-2" class="headerlink" title="AC Code"></a>AC Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, m, k;<br>        cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">vis</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            cin &gt;&gt; data[i];<br>            vis[i].<span class="hljs-built_in">resize</span>(m, <span class="hljs-literal">false</span>);<br>        &#125;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">auto</span> findCell = [&amp;](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;<br>            <span class="hljs-type">int</span> cur = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                <span class="hljs-type">bool</span> left = x &gt;= i &amp;&amp; y &gt;= i &amp;&amp; data[y - i][x - i] == <span class="hljs-string">&#x27;*&#x27;</span>;<br>                <span class="hljs-type">bool</span> right = x + i &lt; m &amp;&amp; y &gt;= i &amp;&amp; data[y - i][x + i] == <span class="hljs-string">&#x27;*&#x27;</span>;<br>                <span class="hljs-keyword">if</span> (left &amp;&amp; right) &#123;<br>                    cur++;<br>                    vis[y - i][x - i] = <span class="hljs-literal">true</span>;<br>                    vis[y - i][x + i] = <span class="hljs-literal">true</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cur &lt; k) flag = <span class="hljs-literal">false</span>;<br>        &#125;;<br><br>        <span class="hljs-keyword">auto</span> tryCell = [&amp;](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123;<br>            <span class="hljs-type">int</span> cur = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>                <span class="hljs-type">bool</span> left = x &gt;= i &amp;&amp; y &gt;= i &amp;&amp; data[y - i][x - i] == <span class="hljs-string">&#x27;*&#x27;</span>;<br>                <span class="hljs-type">bool</span> right = x + i &lt; m &amp;&amp; y &gt;= i &amp;&amp; data[y - i][x + i] == <span class="hljs-string">&#x27;*&#x27;</span>;<br>                <span class="hljs-keyword">if</span> (left &amp;&amp; right) &#123;<br>                    cur++;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cur &gt;= k) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cur + <span class="hljs-number">1</span>; ++i) &#123;<br>                    vis[y - i][x - i] = <span class="hljs-literal">true</span>;<br>                    vis[y - i][x + i] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j)<br>                <span class="hljs-keyword">if</span> (data[i][j] == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (!vis[i][j]) <span class="hljs-built_in">findCell</span>(j, i);<br>                    <span class="hljs-keyword">else</span> <span class="hljs-built_in">tryCell</span>(j, i);<br>                &#125;<br>        cout &lt;&lt; (flag ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Productive-Meeting"><a href="#D-Productive-Meeting" class="headerlink" title="D. Productive Meeting"></a>D. Productive Meeting</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>有 $n$ 堆石头，每堆石头有若干数量，每次从两堆不同堆石头中取出各一个，如何取使得最后所有堆的石头和最少</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>第一反应过来以为是背包问题，就是普通的分为两组然后尽可能均分。但是很快意识到不对，因为可以一个人在两堆中变换。然后就简单了，简单的不断取出最大的两堆，各取一个，直到不能取出两个即可</p><h2 id="AC-Code-3"><a href="#AC-Code-3" class="headerlink" title="AC Code"></a>AC Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        priority_queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; prq;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            <span class="hljs-keyword">if</span> (tmp == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            prq.<span class="hljs-built_in">push</span>(&#123;tmp, i&#125;);<br>        &#125;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; ans;<br>        <span class="hljs-keyword">while</span> (prq.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">auto</span> a = prq.<span class="hljs-built_in">top</span>();<br>            prq.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">auto</span> b = prq.<span class="hljs-built_in">top</span>();<br>            prq.<span class="hljs-built_in">pop</span>();<br>            ans.<span class="hljs-built_in">emplace_back</span>(a.second, b.second);<br>            <span class="hljs-keyword">if</span> (a.first &gt; <span class="hljs-number">1</span>) prq.<span class="hljs-built_in">push</span>(&#123;a.first - <span class="hljs-number">1</span>, a.second&#125;);<br>            <span class="hljs-keyword">if</span> (b.first &gt; <span class="hljs-number">1</span>) prq.<span class="hljs-built_in">push</span>(&#123;b.first - <span class="hljs-number">1</span>, b.second&#125;);<br>        &#125;<br>        cout &lt;&lt; ans.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item : ans) cout &lt;&lt; item.first + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; item.second + <span class="hljs-number">1</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="E1-Permutation-Minimization-by-Deque"><a href="#E1-Permutation-Minimization-by-Deque" class="headerlink" title="E1. Permutation Minimization by Deque"></a>E1. Permutation Minimization by Deque</h1><h2 id="大致题意-4"><a href="#大致题意-4" class="headerlink" title="大致题意"></a>大致题意</h2><p>一个双向队列，按照一定顺序往其中插入一组值，在已知接下来要插入的值的顺序后，如何确定每一次插入队列前面还是后面，使得整个序列的字典序最小</p><h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><p>设计的逻辑很简单，其实每次插入时，若比第一个值大，那么插入到后面，否则一定会使整体值增加，反正则插入到前面即可</p><h2 id="AC-Code-4"><a href="#AC-Code-4" class="headerlink" title="AC Code"></a>AC Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cin &gt;&gt; data[i];<br>        list&lt;<span class="hljs-type">int</span>&gt; res;<br>        res.<span class="hljs-built_in">push_back</span>(data[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (res.<span class="hljs-built_in">front</span>() &gt; data[i]) res.<span class="hljs-built_in">push_front</span>(data[i]);<br>            <span class="hljs-keyword">else</span> res.<span class="hljs-built_in">push_back</span>(data[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item : res) &#123;<br>            cout &lt;&lt; item &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="E2-Array-Optimization-by-Deque"><a href="#E2-Array-Optimization-by-Deque" class="headerlink" title="E2. Array Optimization by Deque"></a>E2. Array Optimization by Deque</h1><h2 id="大致题意-5"><a href="#大致题意-5" class="headerlink" title="大致题意"></a>大致题意</h2><p>和上一题差不多的同时，这次需要的是使得逆序对尽可能少</p><h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><p>贪心解决了，每次插入的时候，若插入到最前面产生的逆序对数量少于最后面，则插入到前面，否则后面。而计算数量，应该是很久没训练了，一下子只能想到线段树，所以就直接上一个动态开点的线段树解决了</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">3e6</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> L = <span class="hljs-number">-1e9</span> - <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> R = <span class="hljs-number">1e9</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegTree</span> &#123;<br>    <span class="hljs-type">int</span> s[N], l[N], r[N];<br>    <span class="hljs-type">int</span> tot;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        tot = <span class="hljs-number">1</span>;<br>        s[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        l[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>        r[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">newNode</span><span class="hljs-params">()</span> </span>&#123;<br>        s[tot] = <span class="hljs-number">0</span>;<br>        l[tot] = <span class="hljs-number">-1</span>;<br>        r[tot] = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> tot++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lc</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l[x] == <span class="hljs-number">-1</span>)<br>            l[x] = <span class="hljs-built_in">newNode</span>();<br>        <span class="hljs-keyword">return</span> l[x];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rc</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (r[x] == <span class="hljs-number">-1</span>)<br>            r[x] = <span class="hljs-built_in">newNode</span>();<br>        <span class="hljs-keyword">return</span> r[x];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        s[x] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (l[x] != <span class="hljs-number">-1</span>) s[x] += s[l[x]];<br>        <span class="hljs-keyword">if</span> (r[x] != <span class="hljs-number">-1</span>) s[x] += s[r[x]];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> cur, <span class="hljs-type">int</span> ll, <span class="hljs-type">int</span> rr)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (ll == rr) &#123;<br>            s[cur]++;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> mid = (ll + rr) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (x &lt;= mid) <span class="hljs-built_in">add</span>(x, <span class="hljs-built_in">lc</span>(cur), ll, mid);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">add</span>(x, <span class="hljs-built_in">rc</span>(cur), mid + <span class="hljs-number">1</span>, rr);<br>        <span class="hljs-built_in">up</span>(cur);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> cur, <span class="hljs-type">int</span> ll, <span class="hljs-type">int</span> rr)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (ll == x &amp;&amp; rr == y) &#123;<br>            <span class="hljs-keyword">return</span> s[cur];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s[cur] == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> mid = (ll + rr) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (y &lt;= mid) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(x, y, <span class="hljs-built_in">lc</span>(cur), ll, mid);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt; mid) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(x, y, <span class="hljs-built_in">rc</span>(cur), mid + <span class="hljs-number">1</span>, rr);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(x, mid, <span class="hljs-built_in">lc</span>(cur), ll, mid) + <span class="hljs-built_in">query</span>(mid + <span class="hljs-number">1</span>, y, <span class="hljs-built_in">rc</span>(cur), mid + <span class="hljs-number">1</span>, rr);<br>        &#125;<br>    &#125;<br>&#125; segTree;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cin &gt;&gt; data[i];<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>        segTree.<span class="hljs-built_in">init</span>();<br>        segTree.<span class="hljs-built_in">add</span>(data[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, L, R);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> left = segTree.<span class="hljs-built_in">query</span>(data[i] + <span class="hljs-number">1</span>, R, <span class="hljs-number">0</span>, L, R);<br>            <span class="hljs-type">int</span> right = segTree.<span class="hljs-built_in">query</span>(L, data[i] - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, L, R);<br>            ans += <span class="hljs-built_in">min</span>(left, right);<br>            segTree.<span class="hljs-built_in">add</span>(data[i], <span class="hljs-number">0</span>, L, R);<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="F-Array-Stabilization-AND-version"><a href="#F-Array-Stabilization-AND-version" class="headerlink" title="F. Array Stabilization (AND version)"></a>F. Array Stabilization (AND version)</h1><h2 id="大致题意-6"><a href="#大致题意-6" class="headerlink" title="大致题意"></a>大致题意</h2><p>给你一个 <code>01</code> 字符串，每次进行对此字符串的某个移位运算后的值进行 <code>AND</code> 运算的，直到此字符串不再改变，需要多少次才能使得整个字符串变为纯 <code>0</code> 的字符串</p><h2 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h2><p>根据移位操作，建图，然后在拓扑，找出最长链就行了，若不能完整拓扑，则不能</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, d;<br>        cin &gt;&gt; n &gt;&gt; d;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cin &gt;&gt; data[i];<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (data[i] == <span class="hljs-number">1</span>) &#123;<br>                flag = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!flag) &#123;<br>            cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">to</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">deg</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> nxt = (i + n - d) % n;<br>            <span class="hljs-keyword">if</span> (data[i] == <span class="hljs-number">1</span> &amp;&amp; data[nxt] == <span class="hljs-number">1</span>) &#123;<br>                to[i] = nxt;<br>                deg[nxt] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br>        queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (!deg[i]) q.<span class="hljs-built_in">push</span>(&#123;i, <span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> vis = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> cur = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            vis++;<br>            ans = <span class="hljs-built_in">max</span>(ans, cur.second + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (to[cur.first] == <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<br>            deg[to[cur.first]] = <span class="hljs-literal">false</span>;<br>            q.<span class="hljs-built_in">push</span>(&#123;to[cur.first], cur.second + <span class="hljs-number">1</span>&#125;);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (vis == n)<br>            cout &lt;&lt; ans &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="G-Minimal-Coverage"><a href="#G-Minimal-Coverage" class="headerlink" title="G. Minimal Coverage"></a>G. Minimal Coverage</h1><h2 id="大致题意-7"><a href="#大致题意-7" class="headerlink" title="大致题意"></a>大致题意</h2><p>有 $n$ 段线段，首尾相连，连接处可以折叠，求出折叠后，这些线段占用的最小总长度</p><h2 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h2><p>借用一下数据量并不大的特点，可以直接暴力找所有可能的情况。创建一个布尔数组，若此处为 true 则表示可以从这里开始，否则不能。通过滚动的方式进行 dp 最后找到任意一处为 true 则为成功。</p><p>当然此方法仅适合用于 check，所以加一个二分就能解决了</p><h2 id="AC-Code-5"><a href="#AC-Code-5" class="headerlink" title="AC Code"></a>AC Code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bits/stdc++.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">bool</span> vis[<span class="hljs-number">2</span>][<span class="hljs-number">3100</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cin &gt;&gt; data[i];<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = <span class="hljs-number">2000</span>;<br><br>        <span class="hljs-keyword">auto</span> cal = [&amp;](<span class="hljs-type">int</span> len) &#123;<br>            <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>, nxt = <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">memset</span>(vis[nxt], <span class="hljs-literal">true</span>, <span class="hljs-built_in">sizeof</span>(vis[nxt]));<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item: data) &#123;<br>                <span class="hljs-built_in">memset</span>(vis[cur], <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(vis[cur]));<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) &#123;<br>                    <span class="hljs-keyword">if</span> (vis[nxt][i]) &#123;<br>                        <span class="hljs-keyword">if</span> (i - item &gt;= <span class="hljs-number">0</span>) vis[cur][i - item] = <span class="hljs-literal">true</span>;<br>                        <span class="hljs-keyword">if</span> (i + item &lt; len) vis[cur][i + item] = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-built_in">swap</span>(cur, nxt);<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; ++i) <span class="hljs-keyword">if</span> (vis[nxt][i]) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;;<br><br>        <span class="hljs-keyword">while</span> (l + <span class="hljs-number">3</span> &lt; r) &#123;<br>            <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cal</span>(mid + <span class="hljs-number">1</span>)) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l + <span class="hljs-number">5</span>; i &gt;= l - <span class="hljs-number">5</span>; --i) &#123;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">cal</span>(i + <span class="hljs-number">1</span>)) &#123;<br>                cout &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; endl;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学</title>
    <link href="/2021/06/10/notebook/Computer-Graphics/"/>
    <url>/2021/06/10/notebook/Computer-Graphics/</url>
    
    <content type="html"><![CDATA[<h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><h2 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h2><ul><li>屏幕分辨率：用水平和垂直方向所能显示光点数总和的乘积表示</li><li>显示分辨率：用水平和垂直方向所能显示像素点总和的乘积表示</li><li>存储分辨率：指帧缓存区域的大小</li></ul><h3 id="帧缓存计算"><a href="#帧缓存计算" class="headerlink" title="帧缓存计算"></a>帧缓存计算</h3><p>$水平分辨率 <em> 垂直分辨率 </em> 每个像素所占用的字节$</p><h1 id="图的表示和数据结构"><a href="#图的表示和数据结构" class="headerlink" title="图的表示和数据结构"></a>图的表示和数据结构</h1><ul><li>复杂的图形通常被看作是由一些基本图形元素（图元）构成的。基本二维图元包括点、直线、圆弧、多边形、字体符号和位图等</li><li>图元通常是指不可再分的独立的图形实体。一个图元中的所有像素点、直线、顶点等是作为一个整体存在的，不再细分为独立的图元。</li></ul><h1 id="基本图形生成算法"><a href="#基本图形生成算法" class="headerlink" title="基本图形生成算法"></a>基本图形生成算法</h1><h2 id="直线生成算法"><a href="#直线生成算法" class="headerlink" title="直线生成算法"></a>直线生成算法</h2><h3 id="数值微分法"><a href="#数值微分法" class="headerlink" title="数值微分法"></a>数值微分法</h3><p>定义</p>$$\epsilon = \frac{1}{max(|\Delta x|, |\Delta y|)}$$<p>则递推公式为</p>$$\left\{\begin{aligned}x' = Math.round(x + \epsilon \cdot \Delta x) \\y' = Math.round(y + \epsilon \cdot \Delta y)\end{aligned}\right.$$<h3 id="逐点比较法"><a href="#逐点比较法" class="headerlink" title="逐点比较法"></a>逐点比较法</h3><p>略</p><h3 id="Bresenham-直线算法"><a href="#Bresenham-直线算法" class="headerlink" title="Bresenham 直线算法"></a>Bresenham 直线算法</h3><p>假定 $\Delta x &gt; \Delta y$</p><ol><li>计算得到 $\Delta x = (x_1 - x_0), \Delta y = (y_1 - y_0)$</li><li>定义 $x = x_0, d = - \Delta x, y = y_0$</li><li>绘制点 $(x_0, y_0)$</li><li>将 $x = x + 1$</li><li>将 $d = d + 2 \cdot \Delta y$</li><li>若 $d &gt; 0$ 则 $d = d - 2 \cdot \Delta x, y = y + 1$</li><li>绘制点 $(x, y)$</li><li>若 $x \neq x_1$ 则跳到第三步</li></ol><h2 id="二次曲线生成算法"><a href="#二次曲线生成算法" class="headerlink" title="二次曲线生成算法"></a>二次曲线生成算法</h2><h3 id="Bresenham-整圆"><a href="#Bresenham-整圆" class="headerlink" title="Bresenham 整圆"></a>Bresenham 整圆</h3><p>按照八分法画圆，先绘制 $\frac{\pi}{2} 至 \frac{\pi}{4}$ 的圆，即下图的 $1b$ 区域</p><p><img src="/image/notebook/Computer-Graphics/draw-a-circle.png" alt="draw-a-circle"></p><p>定义圆的半径 $R$，则</p><ol><li>定义 $d = 1 - R, x = 0, y = R$</li><li>绘制点 $(x, y), (x, -y), (-x, y), (-x, -y), (y, x), (y, -x), (-y, x), (-y, -x)$</li><li>$x = x + 1$</li><li>若 $d &lt; 0$ 则 $d = d + 2x + 3$ 反之 $d = d + 2(x - y) + 5, y = y - 1$</li><li>若 $x &lt; y$ 则返回步骤 2，否则结束</li></ol><h2 id="区域填充算法"><a href="#区域填充算法" class="headerlink" title="区域填充算法"></a>区域填充算法</h2><h3 id="种子填充算法"><a href="#种子填充算法" class="headerlink" title="种子填充算法"></a>种子填充算法</h3><p>在区域内部找到一个像素，通过在这个像素的基础上，对邻接的像素进行搜索，并将邻接的像素作为下一个种子</p><h3 id="扫描线种子填充算法"><a href="#扫描线种子填充算法" class="headerlink" title="扫描线种子填充算法"></a>扫描线种子填充算法</h3><p>给定的种子点开始，填充当前扫描线上种子点所在的区间，然后确定与这一区间相邻上下两条扫描线上需要填充的区间，在这些区间上取最左侧或最右侧的一个点作为新的种子点。不断重复以上过程，直至所有区间都被处理完</p><ol><li>初始化一个栈用来存放种子点</li><li>将初始的种子放入栈中</li><li>若栈为空，则结束算法</li><li>取出栈上的第一个点，作为当前种子</li><li>从当前种子出发，向左右两边延伸，直到遇到边界</li><li>从左往右扫描这条扫描线相邻的 $y - 1$ 和 $y + 1$ 的像素，若不是边界，则将其中所有相邻线段的最右边的像素放入栈中</li><li>回到第三步</li></ol><h3 id="射线法"><a href="#射线法" class="headerlink" title="射线法"></a>射线法</h3><p>从外部点出发，沿任意方向发射射线，若射线与多边形的交点个数为奇数，则为内部，否则为外部</p><h3 id="弧长法"><a href="#弧长法" class="headerlink" title="弧长法"></a>弧长法</h3><p>略</p><h3 id="有效边表算法"><a href="#有效边表算法" class="headerlink" title="有效边表算法"></a>有效边表算法</h3><p>考虑对于每一条直线 $y = kx + b$，当 $y’ = y + 1$ 时， $x’ = x + \frac{1}{k}$。所以求交点时，若已知一个交点 $(x, y)$，则可以通过上述公式推导出下一个交点为 $(x + \frac{1}{k}, y + 1)$</p><p>所以依照上述结论，得出如下的操作（以下图为例）<br><img src="/image/notebook/Computer-Graphics/active-edge-list-algorithm-example.png" alt="active-edge-list-algorithm-example"></p><ol><li>构建一个长度等于几何图形的最大高度的表格</li><li>将几何图形的每一条边的最低点的 $x, y_{max}, \frac{1}{k}$ 保存进入对应的 $y_{min}$ 表格中，（这三个值的顺序可以任意交换，例如下面的所有图中的数据顺序为 $y_{max}, x, \frac{1}{k}$ ），对于每一个单元，按照 $x$ 进行从小到大排序，若 $x$ 相同，则按照 $\frac{1}{k}$ 从小到大排序。所以可以得到下面的表格<br><img src="/image/notebook/Computer-Graphics/active-edge-list-algorithm-1.png" alt="active-edge-list-algorithm-1"></li><li>从最小的 $y$ 开始，不断增大 $y$，根据上一次的 $y$，计算 $y’ = y + 1$ 时，每一个元素对应的 $x’ = x + \frac{1}{k}$ ，对于当前的 $y$ 从第一个节点遍历到最后一个节点，若经过的节点数为奇数，则将这块区域内都进行染色，然后移除所有 $y = y_{max}$ 的数据，可以得到下图<br><img src="/image/notebook/Computer-Graphics/active-edge-list-algorithm-2.png" alt="active-edge-list-algorithm-2"></li></ol><h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><p>略</p><h2 id="反走样技术"><a href="#反走样技术" class="headerlink" title="反走样技术"></a>反走样技术</h2><h3 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h3><ul><li>倾斜的直线和区域的边界呈阶梯状、锯齿状</li><li>图像细节失真，由于离散像素的四舍五入导致了本应均匀的纹理图案变得不均匀显示</li><li>很细小的线和点由于分辨率低而不能被显示出来</li></ul><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ul><li>超采样：以高于物理设备的分辨率完成光栅化，然后再回归到物理设备的分辨率</li><li>计算线段跨越的面积，确定颜色值</li></ul><h1 id="二维观察"><a href="#二维观察" class="headerlink" title="二维观察"></a>二维观察</h1><p>使用齐次坐标表示一个点的坐标</p>$$\left(\begin{matrix}x & y\end{matrix}\right)\rightarrow\left(\begin{matrix}x & y & 1\end{matrix}\right)$$<p>为什么使用齐次坐标系：使图形变换转化为表示图形的点集矩阵与某一变换矩阵相乘，可以借助计算机的高速运算</p><h2 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h2><h3 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h3>$$\left[\begin{matrix}x' & y' & 1\end{matrix}\right]=\left[\begin{matrix}x & y & 1\end{matrix}\right]\left[\begin{matrix}1 & 0 & 0 \\0 & 1 & 0 \\T_x & T_y & 1\end{matrix}\right]=\left[\begin{matrix}x + T_x & y + T_y & 1\end{matrix}\right]$$<h3 id="比例缩放"><a href="#比例缩放" class="headerlink" title="比例缩放"></a>比例缩放</h3>$$\left[\begin{matrix}x' & y' & 1\end{matrix}\right]=\left[\begin{matrix}x & y & 1\end{matrix}\right]\left[\begin{matrix}S_x & 0 & 0 \\0 & S_y & 0 \\0 & 0 & 1\end{matrix}\right]=\left[\begin{matrix}xS_x & yS_y & 1\end{matrix}\right]$$<p>或</p>$$\left[\begin{matrix}x' & y' & 1\end{matrix}\right]=\left[\begin{matrix}x & y & 1\end{matrix}\right]\left[\begin{matrix}1 & 0 & 0 \\0 & 1 & 0 \\0 & 0 & S\end{matrix}\right]=\left[\begin{matrix}\frac{x}{S} & \frac{y}{S} & 1\end{matrix}\right]$$<h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>关于原点进行<font color=red>逆</font>时针旋转</p>$$\left[\begin{matrix}x' & y' & 1\end{matrix}\right]=\left[\begin{matrix}x & y & 1\end{matrix}\right]\left[\begin{matrix}cos(\theta) & sin(\theta) & 0 \\-sin(\theta) & cos(\theta) & 0 \\0 & 0 & 1\end{matrix}\right]=\left[\begin{matrix}xcos(\theta) - ysin(\theta) & xsin(\theta) + ycos(\theta) & 1\end{matrix}\right]$$<p>关于原点进行<font color=red>顺</font>时针旋转</p>$$\left[\begin{matrix}x' & y' & 1\end{matrix}\right]=\left[\begin{matrix}x & y & 1\end{matrix}\right]\left[\begin{matrix}cos(\theta) & -sin(\theta) & 0 \\sin(\theta) & cos(\theta) & 0 \\0 & 0 & 1\end{matrix}\right]=\left[\begin{matrix}xcos(\theta) + ysin(\theta) & -xsin(\theta) + ycos(\theta) & 1\end{matrix}\right]$$<h3 id="对称变换"><a href="#对称变换" class="headerlink" title="对称变换"></a>对称变换</h3><p>关于<font color=red> x </font>轴对称</p>$$\left[\begin{matrix}x' & y' & 1\end{matrix}\right]=\left[\begin{matrix}x & y & 1\end{matrix}\right]\left[\begin{matrix}1 & 0 & 0 \\0 & -1 & 0 \\0 & 0 & 1\end{matrix}\right]=\left[\begin{matrix}x & -y & 1\end{matrix}\right]$$<p>关于<font color=red> y </font>轴对称</p>$$\left[\begin{matrix}x' & y' & 1\end{matrix}\right]=\left[\begin{matrix}x & y & 1\end{matrix}\right]\left[\begin{matrix}-1 & 0 & 0 \\0 & 1 & 0 \\0 & 0 & 1\end{matrix}\right]=\left[\begin{matrix}-x & y & 1\end{matrix}\right]$$<p>关于<font color=red> 原点 </font>轴对称</p>$$\left[\begin{matrix}x' & y' & 1\end{matrix}\right]=\left[\begin{matrix}x & y & 1\end{matrix}\right]\left[\begin{matrix}-1 & 0 & 0 \\0 & -1 & 0 \\0 & 0 & 1\end{matrix}\right]=\left[\begin{matrix}-x & -y & 1\end{matrix}\right]$$<p>关于<font color=red> $y = x$ </font>轴对称</p>$$\left[\begin{matrix}x' & y' & 1\end{matrix}\right]=\left[\begin{matrix}x & y & 1\end{matrix}\right]\left[\begin{matrix}0 & 1 & 0 \\1 & 0 & 0 \\0 & 0 & 1\end{matrix}\right]=\left[\begin{matrix}y & x & 1\end{matrix}\right]$$<p>关于<font color=red> $y = -x$ </font>轴对称</p>$$\left[\begin{matrix}x' & y' & 1\end{matrix}\right]=\left[\begin{matrix}x & y & 1\end{matrix}\right]\left[\begin{matrix}0 & -1 & 0 \\-1 & 0 & 0 \\0 & 0 & 1\end{matrix}\right]=\left[\begin{matrix}-y & -x & 1\end{matrix}\right]$$<h3 id="错切变换"><a href="#错切变换" class="headerlink" title="错切变换"></a>错切变换</h3><p>略</p><h3 id="二维图形几何变换"><a href="#二维图形几何变换" class="headerlink" title="二维图形几何变换"></a>二维图形几何变换</h3><p>定义</p>$$\mathbf P  = \left[\begin{matrix}x_1 & y_1 & 1 \\x_2 & y_2 & 1 \\x_3 & y_3 & 1 \\\dots \\x_n & y_n & 1\end{matrix}\right]$$<p>为这个二维多边形的所有顶点的坐标矩阵，此时再乘上变换矩阵，得到最终结果</p><h2 id="复合变换"><a href="#复合变换" class="headerlink" title="复合变换"></a>复合变换</h2><h3 id="相对任意参考点的二维变换"><a href="#相对任意参考点的二维变换" class="headerlink" title="相对任意参考点的二维变换"></a>相对任意参考点的二维变换</h3><p>先通过<a href="#平移">平移变换</a>将参考点移动至原点，然后进行变换，然后再重做<a href="#平移">平移变换</a>进行撤销一开始的变换</p><h3 id="相对任意方向的二维变换"><a href="#相对任意方向的二维变换" class="headerlink" title="相对任意方向的二维变换"></a>相对任意方向的二维变换</h3><p>先通过<a href="#旋转">旋转变换</a>将参考点移动至原点，然后进行变换，然后再重做<a href="#旋转">旋转变换</a>进行撤销一开始的变换</p><h2 id="二维观察-1"><a href="#二维观察-1" class="headerlink" title="二维观察"></a>二维观察</h2><p>略</p><h2 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h2><h3 id="点的裁剪"><a href="#点的裁剪" class="headerlink" title="点的裁剪"></a>点的裁剪</h3><p>对于点 $P(x, y)$，若满足 $x_{wl} \leq x \leq x_{wr}$ 且 $y_{wb} \leq y \leq y_{wt}$ 则在窗口内，否则在窗口外</p><h3 id="直线的裁剪"><a href="#直线的裁剪" class="headerlink" title="直线的裁剪"></a>直线的裁剪</h3><h4 id="Cohen-Sutherland-算法"><a href="#Cohen-Sutherland-算法" class="headerlink" title="Cohen-Sutherland 算法"></a>Cohen-Sutherland 算法</h4><p>对一条直线的两个顶点进行编码</p><p><img src="/image/notebook/Computer-Graphics/Cohen-Sutherland-1.png" alt="Cohen-Sutherland-1"></p><p>如图，若 $x &lt; x_l$ 则 $D_0 = 1$。若 $x &gt; x_r$ 则 $D_1 = 1$。若 $y &lt; y_b$ 则 $D_2 = 1$。若 $y &gt; y_t$ 则 $D_3 = 1$<br>若两个点 $p_1, p_2$ 的编码 $code_1, code_2$ 满足 $code_1 | code_2 = 0$ 则这条直线就在窗口内，若 $code_1 \&amp; code_2 \neq 0$ 则这条直线可以直接抛弃掉。其他情况只需要求出这条直线和四条边的交点即可<br>所以可以得到如下的流程</p><ol><li>输入点 $p_1, p_2$</li><li>对这两个点进行编码，结果为 $code_1, code_2$</li><li>若 $code_1 = 0$ 且 $code_2 = 0$ 则绘制直线 $p_1, p_2$，然后退出</li><li>若 $code_1 \&amp; code_2 \neq 0$ 则直接退出</li><li>若 $code_1 = 0$ 则交换 $p_1, p_2$，同时交换 $code_1, code_2$</li><li>若 $code_1 的 D_0 \neq 0$ 则计算直线和 $x = x_l$ 的交点，并将其赋值给 $p_1$，返回第二步</li><li>若 $code_1 的 D_1 \neq 0$ 则计算直线和 $x = x_r$ 的交点，并将其赋值给 $p_1$，返回第二步</li><li>若 $code_1 的 D_2 \neq 0$ 则计算直线和 $y = y_b$ 的交点，并将其赋值给 $p_1$，返回第二步</li><li>若 $code_1 的 D_3 \neq 0$ 则计算直线和 $y = y_t$ 的交点，并将其赋值给 $p_1$，返回第二步</li></ol><p>计算交点时，可以借用比例的方式计算，例如计算与 $x = x_l$ 的交点时，可以得到</p>$$\left\{\begin{aligned}x' & = & x_l \\y' & = & y_1 + (y_2 - y_1) \times (x_l - x_1) / (x_2 - x_1)\end{aligned}\right.$$<h4 id="中点分割算法"><a href="#中点分割算法" class="headerlink" title="中点分割算法"></a>中点分割算法</h4><p>使用了和 <a href="#Cohen-Sutherland-算法">Cohen-Sutherland</a> 完全相同的编码方式，但在求解交点时略有不同。此方法包含一个“求出距离一个点最远的，且在窗口内的点”。所以分别对 $p_1, p_2$ 进行一次求解，并代替掉对方（即对于 $p_1$ 求解的答案，代替掉 $p_2$）即可，以下方法的是对 $p_1$ 进行求解的操作，对 $p_2$ 求解时，交换两个值即可</p><ol><li>若 $code_2 = 0$ 则返回 $p_2$</li><li>求出 $p_1$ 和 $p_2$ 的中点 $p_3$</li><li>若 $code_3 = 0$ 则用 $p_3$ 代替 $p_1$（仅算法内代替）</li><li>若 $code_3 \neq 0$ 则若 $code_1 \&amp; code_3$ 则用 $p_3$ 代替 $p_1$，反之，则用 $p_3$ 代替 $p_2$，回到第二步</li></ol><h4 id="Liang-Barsky-算法"><a href="#Liang-Barsky-算法" class="headerlink" title="Liang-Barsky 算法"></a>Liang-Barsky 算法</h4><ol><li>计算$$\left\{\begin{aligned}p_1 & = & -(x_2 - x_1) \\p_2 & = & x_2 - x_1 \\p_3 & = & -(y_2 - y_1) \\p_4 & = & y_2 - y_1 \\q_1 & = & x_1 - x_l \\q_2 & = & x_r - x_1 \\q_3 & = & y_1 - y_b \\q_4 & = & y_t - y_1\end{aligned}\right.$$</li><li>若满足 $p1 = 0 \ AND \  (q1 &lt; 0 \ OR \ q2 &lt; 0)$ 则直线不在窗口内</li><li>若满足 $p3 = 0 \ AND \  (q3 &lt; 0 \ OR \ q4 &lt; 0)$ 则直线不在窗口内</li><li>准备两个数组 $pos, neg$，将 $1$ 加入到数组 $pos$ 中，将 $0$ 加入到数组 $neg$ 中</li><li>若 $p1 = 0$ 则跳到第七步</li><li>若 $p1 &lt; 0$ 则将 $r1$ 放入 $neg$，把 $r2$ 放入 $pos$。反之，则将 $r1$ 放入 $pos$，把 $r2$ 放入 $neg$（$r1 = q1 / p1$，$r2 = q2 / p2$，下同）</li><li>若 $p3 = 0$ 则跳到第九步</li><li>若 $p3 &lt; 0$ 则将 $r3$ 放入 $neg$，把 $r4$ 放入 $pos$。反之，则将 $r3$ 放入 $pos$，把 $r4$ 放入 $neg$</li><li>定义 $rn1$ 为 $neg$ 中的最大值，$rn2$ 为 $pos$ 中的最小值</li><li>若 $rn1 &gt; rn2$ 则直线不在窗口内</li><li>得到交点为 $(x1 + p2 \times rn1, y1 + p4 \times rn1), (x1 + p2 \times rn2, y1 + p4 \times rn2)$</li></ol><h3 id="多边形的裁剪"><a href="#多边形的裁剪" class="headerlink" title="多边形的裁剪"></a>多边形的裁剪</h3><h4 id="Sutherland-Hodgeman-算法"><a href="#Sutherland-Hodgeman-算法" class="headerlink" title="Sutherland-Hodgeman 算法"></a>Sutherland-Hodgeman 算法</h4><p>适合凸多边形，对于凹多边形则需要先分解为多个凸多边形</p><p>对于窗口的所有边界，进行一轮裁剪，裁剪对象是多边形的所有的边。</p><p>对于一个多边形，可以认为是一系列的顶点集合，顶点之间的连线即为一个多边形。沿着顶点的连线，进行如下的裁剪操作</p><ul><li>若从窗口内到窗口外，则输出交点 $I$</li><li>若从窗口外到窗口内，则输出交点 $I$ 和到达点 $P$</li><li>若从窗口内到窗口内，则输出到达点 $P$</li><li>若从窗口外到窗口外，则不输出</li></ul><p><img src="/image/notebook/Computer-Graphics/Sutherland-Hodgeman-1.png" alt="Sutherland-Hodgeman-1"></p><p>将所有输出的点连接，得到新的多边形</p><p>对于窗口的所有边界都进行一次如上的操作，即可得到最终的图像，例如下图，为左边界对此多边形进行裁剪的结果</p><p><img src="/image/notebook/Computer-Graphics/Sutherland-Hodgeman-2.png" alt="Sutherland-Hodgeman-2"></p><h4 id="Weiler-Atherton-算法"><a href="#Weiler-Atherton-算法" class="headerlink" title="Weiler-Atherton 算法"></a>Weiler-Atherton 算法</h4><p>从多边形 $P_s$ 的任意一点出发，顺时针遍历所有点</p><ul><li>若出现从窗口外进入窗口内，则输出在窗口内的直线</li><li>若一直在窗口内，则输出直线</li><li>若出现从窗口内进入窗口外，则输出在窗口内的直线，并从此交点 $p_1$ 出发，顺时针的遍历窗口边界的所有点，直到找到第一个与窗口边界相交的多边形的点 $p_2$，则输出 $p_1, p_2$ 的这条路线</li></ul><h1 id="三维观察"><a href="#三维观察" class="headerlink" title="三维观察"></a>三维观察</h1><h2 id="三维变换"><a href="#三维变换" class="headerlink" title="三维变换"></a>三维变换</h2><h3 id="平移-1"><a href="#平移-1" class="headerlink" title="平移"></a>平移</h3>$$\left[\begin{matrix}x' & y' & z' & 1\end{matrix}\right]=\left[\begin{matrix}x & y & z & 1\end{matrix}\right]\left[\begin{matrix}1 & 0 & 0 & 0 \\0 & 1 & 0 & 0 \\0 & 0 & 1 & 0 \\T_x & T_y & T_z & 1\end{matrix}\right]=\left[\begin{matrix}x + T_x & y + T_y & z + T_z & 1\end{matrix}\right]$$<h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><script type="math/tex; mode=display">\left[\begin{matrix}x' & y' & z' & 1\end{matrix}\right]=\left[\begin{matrix}x & y & z & 1\end{matrix}\right]\left[\begin{matrix}a & 0 & 0 & 0 \\0 & e & 0 & 0 \\0 & 0 & i & 0 \\0 & 0 & 0 & 1\end{matrix}\right]=\left[\begin{matrix}ax & ey & iz & 1\end{matrix}\right]</script><h3 id="旋转-1"><a href="#旋转-1" class="headerlink" title="旋转"></a>旋转</h3><p>将右手大拇指指向旋转轴的正方向，然后四个手指的弯曲方向即为正旋转方向</p><p>绕<font color=red>z</font>轴旋转</p><script type="math/tex; mode=display">\left[\begin{matrix}x' & y' & z' & 1\end{matrix}\right]=\left[\begin{matrix}x & y & z & 1\end{matrix}\right]\left[\begin{matrix}cos \theta & sin \theta & 0 & 0 \\-sin \theta & cos \theta & 0 & 0 \\0 & 0 & 1 & 0 \\0 & 0 & 0 & 1\end{matrix}\right]=\left[\begin{matrix}xcos \theta - y sin \theta & xsin \theta + ycos \theta & z & 1\end{matrix}\right]</script><p>绕<font color=red>x</font>轴旋转</p><script type="math/tex; mode=display">\left[\begin{matrix}x' & y' & z' & 1\end{matrix}\right]=\left[\begin{matrix}x & y & z & 1\end{matrix}\right]\left[\begin{matrix}1 & 0 & 0 & 0 \\0 &cos \theta & sin \theta & 0 \\0 &-sin \theta & cos \theta & 0 \\0 & 0 & 0 & 1\end{matrix}\right]=\left[\begin{matrix}x & ycos \theta - zsin \theta & zsin \theta + zcos \theta & 1\end{matrix}\right]</script><p>绕<font color=red>y</font>轴旋转</p><script type="math/tex; mode=display">\left[\begin{matrix}x' & y' & z' & 1\end{matrix}\right]=\left[\begin{matrix}x & y & z & 1\end{matrix}\right]\left[\begin{matrix}cos \theta & 0 & -sin \theta & 0 \\0 & 1 & 0 & 0 \\sin \theta & 0 & cos \theta & 0 \\0 & 0 & 0 & 1\end{matrix}\right]=\left[\begin{matrix}zsin \theta + xcos \theta & y & zcos \theta - xsin \theta & 1\end{matrix}\right]</script><h2 id="三维投影"><a href="#三维投影" class="headerlink" title="三维投影"></a>三维投影</h2><h3 id="投影类型"><a href="#投影类型" class="headerlink" title="投影类型"></a>投影类型</h3><ul><li>透视投影<ul><li>一点透视</li><li>两点透视</li><li>三点透视</li></ul></li><li>正投影</li><li>斜投影</li></ul><h3 id="三维投影变换"><a href="#三维投影变换" class="headerlink" title="三维投影变换"></a>三维投影变换</h3><p>略</p><h1 id="曲线与曲面"><a href="#曲线与曲面" class="headerlink" title="曲线与曲面"></a>曲线与曲面</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>拟合：对已经存在的离散点列构造出尽可能光滑的曲线或曲面，用以直观（而忠实）地反映出实验特性、变化规律和趋势等。</li><li>插值：通过所有的特征点</li><li>逼近：不通过或部分通过特征点，并在整体上接近这些特征点</li></ul><h2 id="连续性条件"><a href="#连续性条件" class="headerlink" title="连续性条件"></a>连续性条件</h2><h3 id="参数连续"><a href="#参数连续" class="headerlink" title="参数连续"></a>参数连续</h3><ul><li>C0 连续：交点处的两条曲线段相交</li><li>C1 连续：交点处的两条曲线段相交，且此点的一阶导函数值相同</li><li>C2 连续：交点处的两条曲线段相交，且此点的一阶和二阶导函数都相同</li></ul><h3 id="几何连续"><a href="#几何连续" class="headerlink" title="几何连续"></a>几何连续</h3><ul><li>G0 连续：交点处的两条曲线段相交</li><li>G1 连续：交点处的两条曲线段相交，且此点的一阶导函数值成比例</li><li>G2 连续：交点处的两条曲线段相交，且此点的一阶和二阶导函数都成比例</li></ul><h2 id="三次样条（二维）"><a href="#三次样条（二维）" class="headerlink" title="三次样条（二维）"></a>三次样条（二维）</h2><p>对于 $n$ 个点，用 $n - 1$ 条曲线连接，对于每一条直线看，可以用一个三阶函数表示，所以得到</p><script type="math/tex; mode=display">\left\{\begin{aligned}f_1(x) & = a_1 + b_1x + c_1x^2 + d_1x^3 & x \in [x_0, x_1] \\f_2(x) & = a_2 + b_2x + c_2x^2 + d_2x^3 & x \in [x_1, x_2] \\f_3(x) & = a_3 + b_3x + c_3x^2 + d_3x^3 & x \in [x_2, x_3] \\\dots \\f_n(x) & = a_n + b_nx + c_nx^2 + d_nx^3 & x \in [x_{n - 1}, x_n]\end{aligned}\right.</script><p>则对于所有的曲线，由于所有曲线必须保证 G0 连续，所以可以得到如下等式</p><script type="math/tex; mode=display">\left\{\begin{aligned}f_0(x_0) & = & & & y_0 \\f_1(x_1) & = & f_0(x_1) & = & y_1 \\f_2(x_2) & = & f_1(x_2) & = & y_2 \\\dots \\f_n(x_n) & = & f_{n - 1}(x_n) & = & y_n \\\end{aligned}\right.</script><p>又为了保证 G1 连续，则可以得到他们的导数相同</p><script type="math/tex; mode=display">\left\{\begin{aligned}f_1'(x_1) & = & f_0'(x_1) \\f_2'(x_2) & = & f_1'(x_2) \\f_3'(x_3) & = & f_2'(x_3) \\\dots \\f_n'(x_n) & = & f_{n - 1}'(x_n) \\\end{aligned}\right.</script><p>为了保证 G2 连续，则他们的导数的导数相同，所以还可以得到</p><script type="math/tex; mode=display">\left\{\begin{aligned}f_1''(x_1) & = & f_0''(x_1) \\f_2''(x_2) & = & f_1''(x_2) \\f_3''(x_3) & = & f_2''(x_3) \\\dots \\f_n''(x_n) & = & f_{n - 1}''(x_n) \\\end{aligned}\right.</script><p>由此，可以计算出所有的参数</p><h2 id="Bezier-曲线"><a href="#Bezier-曲线" class="headerlink" title="Bézier 曲线"></a>Bézier 曲线</h2><script type="math/tex; mode=display">P(t) = \sum^n_{k=0}P_kBEN_{k, n}, t \in [0, 1]</script><script type="math/tex; mode=display">BEN_{k, n}(t) = \frac{n!}{k!(n - k)!}t^k(1 - t)^{n - k} = C^k_nt^k(1 - t) ^ {n - k}</script><h3 id="一阶导数"><a href="#一阶导数" class="headerlink" title="一阶导数"></a>一阶导数</h3><script type="math/tex; mode=display">P'(0) = n(P_1 - P_0)</script><script type="math/tex; mode=display">P'(1) = n(P_n - P_{n - 1})</script><h3 id="二阶导数"><a href="#二阶导数" class="headerlink" title="二阶导数"></a>二阶导数</h3><script type="math/tex; mode=display">P''(0) = n(n - 1)((P_2 - P_1) - (P_1 - P_0))</script><script type="math/tex; mode=display">P''(1) = n(n - 1)((P_{n - 2} - P_{n - 1}) - (P_{n - 1} - P_n))</script><h3 id="对称性"><a href="#对称性" class="headerlink" title="对称性"></a>对称性</h3><p>颠倒控制顶点，Bézier 曲线仍然保持，走向相反</p><h3 id="凸包性"><a href="#凸包性" class="headerlink" title="凸包性"></a>凸包性</h3><p>略</p><h3 id="几何不变性"><a href="#几何不变性" class="headerlink" title="几何不变性"></a>几何不变性</h3><p>Bézier 曲线与坐标轴无关</p><h3 id="G1-连续"><a href="#G1-连续" class="headerlink" title="G1 连续"></a>G1 连续</h3><p>由于一阶导数可知，若需要满足 G1 连续，则必须要满足第一条曲线的最后两个控制点和第二条曲线的开始两个控制点在同一条直线上，且保证不在同一侧，即</p><p><img src="/image/notebook/Computer-Graphics/Bezier-G1.png" alt="Bezier-G1"></p><script type="math/tex; mode=display">(P_n - P_{n - 1}) = \alpha (Q_1 - Q_0')</script><h3 id="G2-连续"><a href="#G2-连续" class="headerlink" title="G2 连续"></a>G2 连续</h3><script type="math/tex; mode=display">((P_{n - 2} - P_{n - 1}) - (P_{n - 1} - P_n)) = \beta ((Q_2 - Q_1) - (Q_1 - Q_0))</script><h1 id="消隐"><a href="#消隐" class="headerlink" title="消隐"></a>消隐</h1><h2 id="z-buffer"><a href="#z-buffer" class="headerlink" title="z-buffer"></a>z-buffer</h2><p>向 z 轴的负方向作为观察方向，以其 z 轴的大小作为深度值，保存每一个像素的颜色值和深度值，当此像素被再次覆盖时，若新的深度比之前保存的大，则用新的深度和颜色覆盖之前的值，否则不更换</p><h2 id="画家算法"><a href="#画家算法" class="headerlink" title="画家算法"></a>画家算法</h2><p>将物品从远到近排列，先绘制远处的图形，再由近处的图形进行覆盖</p><h2 id="光线投射算法"><a href="#光线投射算法" class="headerlink" title="光线投射算法"></a>光线投射算法</h2><p>对于屏幕上的每一个像素点，构造一条模拟视线的射线，由射线的交点来确定深度最大的点</p><h1 id="光照"><a href="#光照" class="headerlink" title="光照"></a>光照</h1><h2 id="光照模型"><a href="#光照模型" class="headerlink" title="光照模型"></a>光照模型</h2><p>用于物体表面采样点处光强度的计算</p><h2 id="明暗处理"><a href="#明暗处理" class="headerlink" title="明暗处理"></a>明暗处理</h2><h3 id="恒定光强的多边形绘制"><a href="#恒定光强的多边形绘制" class="headerlink" title="恒定光强的多边形绘制"></a>恒定光强的多边形绘制</h3><p>取一个平面内的任意一个点的光强来表示整个平面的光强</p><p>计算量非常小，粗糙，亮度变化大，出现马赫带效应</p><h3 id="Gouraud"><a href="#Gouraud" class="headerlink" title="Gouraud"></a>Gouraud</h3><p>根据多边形在顶点处的光强，线性插值求出平面内其他点的光强</p><p>计算量小，算法简单，出现马赫带效应，对镜面反射效果不佳</p><h3 id="Phong"><a href="#Phong" class="headerlink" title="Phong"></a>Phong</h3><p>根据多边形在顶点处的法向量，线性插值求出平面内其他点的法向量</p><p>计算量大，效果好，精度高</p><h2 id="光线跟踪算法"><a href="#光线跟踪算法" class="headerlink" title="光线跟踪算法"></a>光线跟踪算法</h2><p>基于几何光学原理，模拟光的传播路径来确定反射、折射和阴影。通过“过采样”的方式，实现反走样</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机图形学</tag>
      
      <tag>学习</tag>
      
      <tag>课程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows 通过网络访问 WSL2</title>
    <link href="/2021/06/07/develop-note/wsl-localhost/"/>
    <url>/2021/06/07/develop-note/wsl-localhost/</url>
    
    <content type="html"><![CDATA[<h1 id="localhost"><a href="#localhost" class="headerlink" title="localhost"></a>localhost</h1><p>当使用 localhost 时，Windows 直接访问到 WSL 内的进程，即看起来似乎是一台电脑，</p><h1 id="127-0-0-1"><a href="#127-0-0-1" class="headerlink" title="127.0.0.1"></a>127.0.0.1</h1><p>当使用本地 IP 时，即使用 <code>127.0.0.1</code> 时，Windows 将会无法访问到 WSL，Windows 认为这是强调它自己。</p><h1 id="JVM-SpringBoot"><a href="#JVM-SpringBoot" class="headerlink" title="JVM(SpringBoot)"></a>JVM(SpringBoot)</h1><p>由于此问题是在使用 SpringBoot 时遇到的问题，并不确定是不是 JVM 的问题还是 SpringBoot 的问题</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当使用 WSL2 中的 docker 来启动一个 mongo 镜像，使用的命令是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -itd --name mongo -p 27017:27017 mongo --auth<br>docker exec -it mongo mongo admin<br>db.createUser(&#123; user:&#x27;root&#x27;,pwd:&#x27;123456&#x27;,roles:[ &#123; role:&#x27;userAdminAnyDatabase&#x27;, db: &#x27;admin&#x27;&#125;,&quot;readWriteAnyDatabase&quot;]&#125;);<br></code></pre></td></tr></table></figure><p>然后在 Navicat 中，可以直接使用 <code>localhost</code> 对此 mongo 进行连接，但是在 SpringBoot 中，无法连接到此 mongo 数据库，配置如下</p><p><img src="/image/develop-note/wsl-localhost/SpringBoot-Before.png" alt="SpringBoot-Before"></p><p>报错信息：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">com<span class="hljs-selector-class">.mongodb</span><span class="hljs-selector-class">.MongoSocketOpenException</span>: Exception opening socket<br></code></pre></td></tr></table></figure><p>后测试发现，Navicat 也无法使用 <code>127.0.0.1</code> 来访问 WSL，由此推测，JVM 或者 SpringBoot 是否是将 <code>localhost</code> 直接解析为 <code>127.0.0.1</code> 了</p><h2 id="解决策略"><a href="#解决策略" class="headerlink" title="解决策略"></a>解决策略</h2><p>直接使用 WSL 的 IP 来代替 <code>localhost</code></p><p>在 WSL 中使用 <code>ifconfig</code> 来获取 VM 的 IP，例如下图中，应该选择 <code>eth0</code> 的 IP <code>172.31.18.91</code> 来代替 <code>localhost</code></p><p><img src="/image/develop-note/wsl-localhost/WSL-ifconfig.jpg" alt="WSL-ifconfig"></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在 Navicat 和 SpringBoot 中，均连接数据库成功</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>短笔记</tag>
      
      <tag>WSL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原生 JavaScript 实现图片裁剪</title>
    <link href="/2021/05/17/front-end/Front-end-image-cropping-effect/"/>
    <url>/2021/05/17/front-end/Front-end-image-cropping-effect/</url>
    
    <content type="html"><![CDATA[<h1 id="原生-JavaScript-实现图片裁剪"><a href="#原生-JavaScript-实现图片裁剪" class="headerlink" title="原生 JavaScript 实现图片裁剪"></a>原生 JavaScript 实现图片裁剪</h1><p>由于最近做的一个项目里，需要把用户头像上传。但是要求用户头像必须是正方形，所以需要将矩形图片裁剪为正方形</p><p>在花了接近 5 个小时之后，总算是将功能上线了，在此记录下整个思路经过</p><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>首先，单纯靠前端，是不可能实现将图片截取其中的部分，然后将部分上传到后端。<br>所以，需要靠伪装裁剪效果的方式来实现裁剪</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先把裁剪图片的页面进行分层</p><h3 id="思路1——clip"><a href="#思路1——clip" class="headerlink" title="思路1——clip"></a>思路1——clip</h3><div class="table-container"><table><thead><tr><th style="text-align:center">层级</th><th style="text-align:center">内容</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">一个灰白色的背景的 div</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">半透明的原图</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">不透明的原图的裁剪部分</td></tr></tbody></table></div><p>层级 3 的效果，打算靠 css 的 <code>clip-path</code> 来实现，</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>反手打开 Google，打开 Google 的头像上传页面，然后检查元素</p><p><img src="/image/front-end/Front-end-image-cropping-effect/googleAvatarUpload.png" alt="googleAvatarUpload"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ee-dm-Ch&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://lh3.googleusercontent.com/-ij1qBucmZrI/YJ5t2R6hBPI/AAAAAAAAAJY/DyrS8qSCb4keWB2-fIvIv42m9oW8B9ZnQCLcBGAsYHQ/s180/79468803_p0_master1200.jpg&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;transform: rotate(0deg); width: 127px; height: 180px; opacity: 1; left: 279px; top: 0px; position: absolute;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 127px; height: 180px; left: 279px; top: 0px; position: absolute;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ee-im&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;top: 42px; left: 16px; width: 95px; height: 95px;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ee-fm&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;cursor: ne-resize; left: 96px; top: 27px;&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ee-gm&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ee-fm&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;cursor: sw-resize; left: 1px; top: 122px;&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ee-gm&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ee-fm&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;cursor: se-resize; left: 96px; top: 122px;&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ee-gm&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ee-fm&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;cursor: nw-resize; left: 1px; top: 27px;&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ee-gm&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ee-km&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 127px; top: 0px; left: 0px; height: 42px;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ee-km&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;top: 42px; left: 111px; width: 16px; height: 95px;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ee-km&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;left: 0px; width: 127px; top: 137px; height: 43px;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ee-km&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;left: 0px; top: 42px; width: 16px; height: 95px;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ee-em&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;top: 41px; left: 15px; width: 95px; height: 95px;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>首先是一个 <code>img</code> 作为底图，而且其宽和高同时被限制在 180px 中（上传了一张高大于宽的图片），这可以用 <code>max-height</code> 和 <code>max-width</code> 实现</li><li>其次是一个 <code>div</code> ，而且恰好与上面的 <code>img</code> 重合，这应该是作为覆盖在图片上，然后其中有一堆的 <code>div</code><ul><li>第一个 <code>div</code> 应该是作为上传图片时，覆盖在最中央的透明方块，用来接受鼠标的拖拽和缩放事件</li><li>第二个至第五个，是中间选择框的四个角落，用来拖拽缩放图片</li><li>第六个又是一个 <code>div</code>，内部有四个 <code>div</code>，观察后发现，这四个 <code>div</code> 分别是“左上+正上+右上”，“正右”，“右下+正下+左下”，“正左”，而且这四个 <code>div</code> 都是带有半透明属性，且背景为纯白色</li></ul></li><li>最后一个 <code>div</code> 其恰好比图片大一个像素，恰好可以作为黑色的外框</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>虽然看起来，第一个的思路更加的简单容易，但是第二个思路更合理，毕竟对于低版本的浏览器，更适合此方案</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>首先需要一个能够选择文件的 UI，由于 <code>&lt;input type=&quot;file&quot;&gt;</code> 的页面实在过于丑陋，于是我先对其进行美化</p><h3 id="美化-input"><a href="#美化-input" class="headerlink" title="美化 input"></a>美化 <code>input</code></h3><p>首先准备一个 <code>relative</code> 的 <code>div</code> 用于容纳新的 UI，同时将 <code>&lt;input type=&quot;file&quot;&gt;</code> 设置为 <code>absolute</code>，并使其覆盖整个 <code>div</code>，然后将不透明度调整为 <code>0</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;upload&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fileInput&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.upload</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.fileInput</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">overflow</span>: hidden;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后找来了一个上传图片的 svg，直接丢进去</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;upload&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">t</span>=<span class="hljs-string">&quot;1620918057417&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;icon&quot;</span> <span class="hljs-attr">viewBox</span>=<span class="hljs-string">&quot;0 0 1024 1024&quot;</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;1.1&quot;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.w3.org/2000/svg&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;100&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M1035.3664 1035.82151111h-86.47111111v-27.30666666h59.16444444v-59.16444445h27.30666667zM881.69813333 1035.82151111H747.30382222v-27.30666666h134.39431111v27.30666666z m-201.59146666 0H545.71235555v-27.30666666h134.39431112v27.30666666z m-201.59146667 0H344.12088889v-27.30666666h134.39431111v27.30666666z m-201.59146667 0H142.52942222v-27.30666666h134.39431111v27.30666666zM75.33226667 1035.82151111h-86.47111112v-86.47111111h27.30666667v59.16444445h59.16444445zM16.16782222 882.15324445h-27.30666667V747.75893333h27.30666667v134.39431112z m0-201.59146667h-27.30666667V546.16746667h27.30666667v134.39431111z m0-201.59146667h-27.30666667V344.576h27.30666667v134.39431111z m0-201.59146666h-27.30666667V142.98453333h27.30666667v134.39431112zM16.16782222 75.78737778h-27.30666667v-86.47111111h86.47111112v27.30666666h-59.16444445zM881.69813333 16.62293333H747.30382222v-27.30666666h134.39431111v27.30666666z m-201.59146666 0H545.71235555v-27.30666666h134.39431112v27.30666666z m-201.59146667 0H344.12088889v-27.30666666h134.39431111v27.30666666z m-201.59146667 0H142.52942222v-27.30666666h134.39431111v27.30666666zM1035.3664 75.78737778h-27.30666667v-59.16444445h-59.16444444v-27.30666666h86.47111111zM1035.3664 882.15324445h-27.30666667V747.75893333h27.30666667v134.39431112z m0-201.59146667h-27.30666667V546.16746667h27.30666667v134.39431111z m0-201.59146667h-27.30666667V344.576h27.30666667v134.39431111z m0-201.59146666h-27.30666667V142.98453333h27.30666667v134.39431112z&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#bfbfbf&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M599.74674456 523.1642475H424.34544577c-6.10760857 0-11.06283816-4.95062007-11.06283815-11.06283815 0-6.10760857 4.95522958-11.06283816 11.06283814-11.06283815h175.4012988c6.10760857 0 11.06283816 4.95522958 11.06283816 11.06283815 0 6.11221808-4.95062007 11.06283816-11.06283816 11.06283815z&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#bfbfbf&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">path</span> <span class="hljs-attr">d</span>=<span class="hljs-string">&quot;M512.04609516 610.86489689c-6.10760857 0-11.06283816-4.95522958-11.06283816-11.06283815V424.40075995c0-6.10760857 4.95522958-11.06283816 11.06283816-11.06283814s11.06283816 4.95522958 11.06283814 11.06283814v175.40129879c0 6.11221808-4.95522958 11.06283816-11.06283814 11.06283815z&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">fill</span>=<span class="hljs-string">&quot;#bfbfbf&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fileInput&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="准备覆盖物"><a href="#准备覆盖物" class="headerlink" title="准备覆盖物"></a>准备覆盖物</h3><p>直接创建了一堆的 <code>div</code>，为了简化，我把 Google 的拖动缩放的方块改为了滚轮缩放</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;clip&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;overlay&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display: none&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;overlayInline&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;img&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;image&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;base&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;imageOverlayBase&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;imageOverlay&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;top&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;imageOverlay&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;bottom&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;imageOverlay&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;imageOverlay&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;imageOverlayCenter&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.overlay</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>);<br>    <span class="hljs-attribute">position</span>: fixed;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">z-index</span>: <span class="hljs-number">2021</span><br>&#125;<br><br><span class="hljs-selector-class">.overlayInline</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">background</span>: white;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);<br>&#125;<br><br><span class="hljs-selector-class">.image</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">max-width</span>: <span class="hljs-number">250px</span>;<br>    <span class="hljs-attribute">max-height</span>: <span class="hljs-number">250px</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);<br>&#125;<br><br><span class="hljs-selector-class">.imageOverlayBase</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><br><span class="hljs-selector-class">.imageOverlay</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;<br>    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.5</span>;<br>    <span class="hljs-attribute">position</span>: absolute;<br>&#125;<br><br><span class="hljs-selector-class">.imageOverlayCenter</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.6</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我准备了一个 <code>overlay</code> 用于让整个屏幕的剩下部分变成灰色，这样可以避免在拖动的时候点击到其他元素</p><p>然后就是无尽的 JavaScript 时间</p><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> width = <span class="hljs-number">300</span>                     <span class="hljs-comment">// 最大图片宽度</span><br><span class="hljs-keyword">let</span> height = <span class="hljs-number">300</span>                    <span class="hljs-comment">// 最大图片高度</span><br><span class="hljs-keyword">let</span> scroll = <span class="hljs-number">0.1</span>                    <span class="hljs-comment">// 单次滚轮缩放的最大比例</span><br><span class="hljs-keyword">let</span> imageWidth, imageHeight         <span class="hljs-comment">// 当前图片的大小</span><br><span class="hljs-keyword">let</span> clipLeft, clipTop, clipWidth, clipHeight<br><span class="hljs-keyword">let</span> topOverlay, bottomOverlay, leftOverlay, rightOverlay, centerOverlay<br><span class="hljs-keyword">let</span> lastX, lastY                    <span class="hljs-comment">// 记录鼠标上次位置</span><br></code></pre></td></tr></table></figure><p>其中 <code>clipLeft, clipTop, clipWidth, clipHeight</code> 分别是“裁剪图片距离左边界的百分比”，“裁剪图片距离上边界的百分比”，“裁剪图片宽度百分比”，“裁剪图片高度百分比”</p><p>而 <code>topOverlay, bottomOverlay, leftOverlay, rightOverlay, centerOverlay</code> 则是一些保存所有的元素的变量</p><p>然后是当渲染完成时<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> input = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;file&quot;</span>)<br>    input.<span class="hljs-property">onchange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>        <span class="hljs-keyword">let</span> reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>()<br>        reader.<span class="hljs-title function_">readAsDataURL</span>(input.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>])<br>        reader.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-keyword">let</span> img = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;img&quot;</span>)<br>            img.<span class="hljs-property">src</span> = reader.<span class="hljs-property">result</span>;<br>            img.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>                <span class="hljs-title function_">prepareClip</span>()       <span class="hljs-comment">// 准备裁剪</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>获取 <code>input</code> 中的图片，并将其读出，然后让 <code>img</code> 显示出来</p><p>然后是一些渲染的准备工作<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">prepareClip</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 获取图片的尺寸</span><br>    <span class="hljs-keyword">let</span> clip = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;clip&quot;</span>)<br>    clip.<span class="hljs-property">style</span>.<span class="hljs-property">display</span> = <span class="hljs-string">&quot;block&quot;</span><br>    <span class="hljs-keyword">let</span> base = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;base&quot;</span>)<br>    <span class="hljs-keyword">let</span> img = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;img&quot;</span>)<br>    imageWidth = img.<span class="hljs-property">width</span><br>    imageHeight = img.<span class="hljs-property">height</span><br>    <span class="hljs-comment">// 将一个 div 移动至恰好覆盖整个图片，方便后续的相对位移的计算</span><br>    base.<span class="hljs-property">style</span>.<span class="hljs-property">width</span> = imageWidth<br>    base.<span class="hljs-property">style</span>.<span class="hljs-property">height</span> = imageHeight<br>    base.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = ((width - imageWidth) / <span class="hljs-number">2</span>).<span class="hljs-title function_">toString</span>()<br>    base.<span class="hljs-property">style</span>.<span class="hljs-property">top</span> = ((height - imageHeight) / <span class="hljs-number">2</span>).<span class="hljs-title function_">toString</span>()<br>    <span class="hljs-comment">// 保存下所有的遮罩 div</span><br>    topOverlay = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;top&quot;</span>)<br>    bottomOverlay = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;bottom&quot;</span>)<br>    leftOverlay = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;left&quot;</span>)<br>    rightOverlay = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;right&quot;</span>)<br>    centerOverlay = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;center&quot;</span>)<br>    <span class="hljs-comment">// 为部分的 div 设置不会改变的固定值</span><br>    topOverlay.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = <span class="hljs-string">&quot;0&quot;</span><br>    topOverlay.<span class="hljs-property">style</span>.<span class="hljs-property">top</span> = <span class="hljs-string">&quot;0&quot;</span><br>    topOverlay.<span class="hljs-property">style</span>.<span class="hljs-property">right</span> = <span class="hljs-string">&quot;0&quot;</span><br><br>    bottomOverlay.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = <span class="hljs-string">&quot;0&quot;</span><br>    bottomOverlay.<span class="hljs-property">style</span>.<span class="hljs-property">bottom</span> = <span class="hljs-string">&quot;0&quot;</span><br>    bottomOverlay.<span class="hljs-property">style</span>.<span class="hljs-property">right</span> = <span class="hljs-string">&quot;0&quot;</span><br><br>    leftOverlay.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = <span class="hljs-string">&quot;0&quot;</span><br><br>    rightOverlay.<span class="hljs-property">style</span>.<span class="hljs-property">right</span> = <span class="hljs-string">&quot;0&quot;</span><br>    <span class="hljs-comment">// 由于项目要求，所以图片将会是正方形，在最开始的时候，裁剪图片的尺寸为最短边的 80%</span><br>    <span class="hljs-keyword">let</span> tmp = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(imageWidth * <span class="hljs-number">0.8</span>, imageHeight * <span class="hljs-number">0.8</span>)<br>    clipWidth = tmp / imageWidth<br>    clipHeight = tmp / imageHeight<br><br>    clipLeft = (<span class="hljs-number">1</span> - clipWidth) / <span class="hljs-number">2</span><br>    clipTop = (<span class="hljs-number">1</span> - clipHeight) / <span class="hljs-number">2</span><br><br>    <span class="hljs-comment">// 添加事件</span><br>    centerOverlay.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;mousedown&quot;</span>, mouseDown)<br>    centerOverlay.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;mousewheel&quot;</span>, mouseWheel)<br>    <span class="hljs-title function_">resetOverlay</span>()<br>&#125;<br></code></pre></td></tr></table></figure></p><p>然后为每一块 <code>div</code> 计算出他们的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">resetOverlay</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> position = &#123;<br>        <span class="hljs-attr">left</span>: clipLeft * imageWidth,<br>        <span class="hljs-attr">right</span>: (<span class="hljs-number">1</span> - clipLeft - clipWidth) * imageWidth,<br>        <span class="hljs-attr">top</span>: clipTop * imageHeight,<br>        <span class="hljs-attr">bottom</span>: (<span class="hljs-number">1</span> - clipTop - clipHeight) * imageHeight<br>    &#125;<br>    topOverlay.<span class="hljs-property">style</span>.<span class="hljs-property">bottom</span> = (imageHeight - position.<span class="hljs-property">top</span>).<span class="hljs-title function_">toString</span>()<br><br>    bottomOverlay.<span class="hljs-property">style</span>.<span class="hljs-property">top</span> = (imageHeight - position.<span class="hljs-property">bottom</span>).<span class="hljs-title function_">toString</span>()<br><br>    leftOverlay.<span class="hljs-property">style</span>.<span class="hljs-property">top</span> = position.<span class="hljs-property">top</span>.<span class="hljs-title function_">toString</span>()<br>    leftOverlay.<span class="hljs-property">style</span>.<span class="hljs-property">bottom</span> = position.<span class="hljs-property">bottom</span>.<span class="hljs-title function_">toString</span>()<br>    leftOverlay.<span class="hljs-property">style</span>.<span class="hljs-property">right</span> = (imageWidth - position.<span class="hljs-property">left</span>).<span class="hljs-title function_">toString</span>()<br><br>    rightOverlay.<span class="hljs-property">style</span>.<span class="hljs-property">top</span> = position.<span class="hljs-property">top</span>.<span class="hljs-title function_">toString</span>()<br>    rightOverlay.<span class="hljs-property">style</span>.<span class="hljs-property">bottom</span> = position.<span class="hljs-property">bottom</span>.<span class="hljs-title function_">toString</span>()<br>    rightOverlay.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = (imageWidth - position.<span class="hljs-property">right</span>).<span class="hljs-title function_">toString</span>()<br><br>    centerOverlay.<span class="hljs-property">style</span>.<span class="hljs-property">left</span> = position.<span class="hljs-property">left</span>.<span class="hljs-title function_">toString</span>()<br>    centerOverlay.<span class="hljs-property">style</span>.<span class="hljs-property">right</span> = position.<span class="hljs-property">right</span>.<span class="hljs-title function_">toString</span>()<br>    centerOverlay.<span class="hljs-property">style</span>.<span class="hljs-property">top</span> = position.<span class="hljs-property">top</span>.<span class="hljs-title function_">toString</span>()<br>    centerOverlay.<span class="hljs-property">style</span>.<span class="hljs-property">bottom</span> = position.<span class="hljs-property">bottom</span>.<span class="hljs-title function_">toString</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是三个事件的处理过程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">clamp</span>(<span class="hljs-params">l, r, v</span>) &#123;<br>    <span class="hljs-keyword">if</span> (v &lt; l) <span class="hljs-keyword">return</span> l<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v &gt; r) <span class="hljs-keyword">return</span> r<br>    <span class="hljs-keyword">return</span> v<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mouseMove</span>(<span class="hljs-params">event</span>) &#123;<br>    clipLeft += (event.<span class="hljs-property">pageX</span> - lastX) / imageWidth<br>    clipLeft = <span class="hljs-title function_">clamp</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span> - clipWidth, clipLeft)<br>    clipTop += (event.<span class="hljs-property">pageY</span> - lastY) / imageHeight<br>    clipTop = <span class="hljs-title function_">clamp</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span> - clipHeight, clipTop)<br>    lastX = event.<span class="hljs-property">pageX</span><br>    lastY = event.<span class="hljs-property">pageY</span><br>    <span class="hljs-title function_">resetOverlay</span>()<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mouseUp</span>(<span class="hljs-params">event</span>) &#123;<br>    centerOverlay.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">&#x27;mousemove&#x27;</span>, mouseMove);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mouseDown</span>(<span class="hljs-params">event</span>) &#123;<br>    lastX = event.<span class="hljs-property">pageX</span><br>    lastY = event.<span class="hljs-property">pageY</span><br>    centerOverlay.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;mousemove&quot;</span>, mouseMove)<br>    centerOverlay.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&quot;mouseup&quot;</span>, mouseUp)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mouseWheel</span>(<span class="hljs-params">event</span>) &#123;<br>    <span class="hljs-keyword">let</span> op = event.<span class="hljs-property">wheelDelta</span> / <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(event.<span class="hljs-property">wheelDelta</span>)<br>    <span class="hljs-keyword">let</span> maxDelta = op &gt; <span class="hljs-number">0</span> ?<br>        <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(imageWidth * (<span class="hljs-number">1</span> - clipWidth), imageHeight * (<span class="hljs-number">1</span> - clipHeight), scroll * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(imageWidth, imageHeight)) :<br>        <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(imageWidth * (clipWidth - <span class="hljs-number">0.1</span>), imageHeight * (clipHeight - <span class="hljs-number">0.1</span>), scroll * <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(imageWidth, imageHeight))<br>    clipWidth += maxDelta / imageWidth * op<br>    clipHeight += maxDelta / imageHeight * op<br>    clipLeft -= maxDelta / imageWidth / <span class="hljs-number">2</span> * op<br>    clipLeft = <span class="hljs-title function_">clamp</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span> - clipWidth, clipLeft)<br>    clipTop -= maxDelta / imageHeight / <span class="hljs-number">2</span> * op<br>    clipTop = <span class="hljs-title function_">clamp</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span> - clipHeight, clipTop)<br>    <span class="hljs-title function_">resetOverlay</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是效果图</p><p><img src="/image/front-end/Front-end-image-cropping-effect/myAvatarUpload.png" alt="myAvatarUpload"></p>]]></content>
    
    
    <categories>
      
      <category>学习&amp;开发&amp;实现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>HTML</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试复习（计算机图形学）</title>
    <link href="/2021/03/27/interview/computer-graphics/"/>
    <url>/2021/03/27/interview/computer-graphics/</url>
    
    <content type="html"><![CDATA[<h1 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h1><ul><li>渲染流程<ul><li>应用程序阶段<ul><li>加载数据到显存</li><li>设置渲染模式</li><li>调用 DrawCall</li></ul></li><li>几何阶段<ul><li>顶点着色器：将三维的顶点坐标信息映射到 $[-1, 1]$ 的平面上</li><li>裁剪：裁剪出摄像机视野内的顶点</li><li>屏幕映射：将 $[-1, 1]$ 内的图片映射到屏幕上</li></ul></li><li>光栅化阶段<ul><li>三角形设置与三角形遍历：找出片元</li><li>片元着色器：对每一个片元进行着色，计算其颜色值</li><li>逐片元操作：模板测试，深度测试，混合</li></ul></li></ul></li></ul><h1 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h1><ul><li>高斯模糊方式<ul><li>按照与当前像素的距离值，计算出高斯函数的值作为权值，进行颜色混合</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试准备</tag>
      
      <tag>计算机图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试复习（算法）</title>
    <link href="/2021/03/27/interview/algorithm/"/>
    <url>/2021/03/27/interview/algorithm/</url>
    
    <content type="html"><![CDATA[<h1 id="链表有环问题"><a href="#链表有环问题" class="headerlink" title="链表有环问题"></a>链表有环问题</h1><ul><li>判断单向链表是否有环<ul><li>定义两个指针，从链表的开始，同时沿着链表指针移动，速度分别为一个单位和两个单位。当某个时刻，两个指针指向同一个节点的时候则此链表有环</li><li>理论上，速度可以是任意的两个不同的值，因为只要速度差和环的长度有最小公倍数，则必定存在相交的时间点</li></ul></li><li>找出链表的环的交点位置<ul><li>通过上述步骤（速度取一步两步），当两个指针第一次相遇的时候，将速度为二步的指针移动至开头，并将速度调整为一步，然后两个指针继续前进，直到第一次相遇，此相遇点即为链表的环的交点</li><li>原理：把整个链表认为长度就是两步的那个指针所走过的路程，把重复的那部分复制一份，将链表展开为无环。此时可以认为整个链表长度为 $2n$，且一步的那个指针恰好位于整个链表最中间的地方，即 $n$，同时，在展开之前，这两个节点是“相同的节点”，此时如果再有一个指针以一步的速度从开头开始走，那么当这两个指针分别走到链表的正中间和最后的时候，此时这两个指针实际上相同了，而这两个指针速度相同，所以在之前应该也有一段时间已经相同了。反过来，当他们第一次重合的时候，即为环的入口</li></ul></li><li>判断两个链表是否最终交在同一个节点<ul><li>利用上述的规则，将其中一个链表的头尾相连，然后从另一个链表开头进行一步两步的判断</li></ul></li></ul><h1 id="洗牌问题"><a href="#洗牌问题" class="headerlink" title="洗牌问题"></a>洗牌问题</h1><ul><li>问题样式<ul><li>在 $n$ 个不相同的数中随机取出 $m$ 个数，使得这 $m$ 个数字不同</li><li>一个长度为 $n$ 的数组，将其打散</li></ul></li><li>解题方法<ul><li>Fisher-Yates Shuffle算法<ul><li>优点：逻辑简单</li><li>缺点：时间复杂度高($O(n^2)$)，空间复杂度也较高($O(n)$)，而且需要提前知道数组长度</li><li><ol><li>设定 $x = n$</li></ol></li><li><ol><li>获得一个在 $[1, x]$ 之间的随机数 $t$</li></ol></li><li><ol><li>将原数组中第 $t$ 个没有被取出的数据拿出</li></ol></li><li><ol><li>使得 $x = x - 1$</li></ol></li><li><ol><li>重复 2-4 步直到取出 $m$ 个整数</li></ol></li></ul></li><li>Knuth-Durstenfeld Shuffle算法<ul><li>优点：时间复杂度($O(n)$)和空间复杂度($O(1)$)都低</li><li>缺点：会修改原数组，而且需要提前知道数组长度</li><li><ol><li>设定 $x = 1$</li></ol></li><li><ol><li>获得一个在 $[x, n]$ 之间的随机数 $t$</li></ol></li><li><ol><li>交换数组中的第 $x$ 个和第 $t$ 个值</li></ol></li><li><ol><li>使得 $x = x + 1$</li></ol></li><li><ol><li>重复 2-4 步直到 $x = m + 1$</li></ol></li></ul></li><li>Inside-Out Algorithm算法<ul><li>优点：时间复杂度($O(n)$)低，不需要提前知道数组长度</li><li>缺点：空间复杂度高($O(n)$)</li><li><ol><li>将整个数据拷贝至一个新的数组 $a$</li></ol></li><li><ol><li>设定 $x = 1$</li></ol></li><li><ol><li>获取一个在 $[1, x]$ 之间的随机数 $t$</li></ol></li><li><ol><li>交换 $a_x$ 和 $a_t$</li></ol></li><li><ol><li>使得 $x = x + 1$</li></ol></li><li><ol><li>重复 3-5 步直到 $x = m + 1$</li></ol></li></ul></li></ul></li></ul><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><ul><li>快速排序的实现</li><li>快速排序的优缺点<ul><li>优点：平均时间复杂度 $O(Nlog_2N)$，空间复杂度 $O(1)$</li><li>缺点：不稳定，初始序列有序或基本有序时，时间复杂度降为 $O(n^2)$</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试准备</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round#706(Div. 2)-Let&#39;s Go Hiking</title>
    <link href="/2021/03/11/acm/codeforces/CodeforcesRound706-D%20Let&#39;s%20Go%20Hiking/"/>
    <url>/2021/03/11/acm/codeforces/CodeforcesRound706-D%20Let&#39;s%20Go%20Hiking/</url>
    
    <content type="html"><![CDATA[<h1 id="Let’s-Go-Hiking"><a href="#Let’s-Go-Hiking" class="headerlink" title="Let’s Go Hiking"></a>Let’s Go Hiking</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个数组，两个人，第一步，两个人先后选择数组中的两个下标，要求两个人选择的下标不可以相同。随后按照选择顺序以此进行选择，要求选择一个新的下标，使得新的下标是原来下标的左边或者右边，且不超出数组边界，其中第一个选择的人需要保证新的下标对应的值严格小于原来的下标对应的值，而第二个选择的人则相反，需要选择严格大于的，且保证两人在任意时刻选择的下标不相同，第一个不能选择的人为失败，问第一个人第一次选择哪些下标能够使得他必赢，仅需要输出下标个数</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>按照题目要求，肯定是尽量让第一个人去选择最长的严格单调的子串的最大端，这样第一个人的可选个数最多。而若仅仅如此选择，那么作为第二手，他必定可以选择与这个下标相邻的且比第一个人选的值小的，则可以堵死第一个人的下一步选择</p><blockquote><p>例如<br>1, 2, 3, 4, 5, 6, 7<br>对于第一个人而言，他肯定是选择 7 比较好，因为他接下来可以走 6、5、4、3、2、1，拥有最多的步数<br>但是第二个人完全可以直接选择 6，使得第一个人无法走，因为不能选择相同下标</p></blockquote><p>既然单调的子串会因为第二个人的直接掐断而注定失败，那必定需要为第一个人做第二手的准备，也就是必须要构造一个峰，使得左右两侧都可以下坡，避免出现上述的情况</p><p>由于上面得到的结论，假定这个峰左侧的坡较长，而右侧较短。此时第二个人必然选择左侧的峰底，或者峰底以上的一个值。这样无论第一个人往左走还是往右走，都可以保证第一个人会率先遇到无法选择的问题</p><blockquote><p>例如<br>1, 2, 3, 4, 5, 4, 3, 2<br>作为第一个人，必定应该选 5<br>那么第二个人可以直接选 2 （左坡峰底以上的一个值）<br>若选择往左坡走，那么恰好第一个人遇到无法选择<br>若往右坡走，那么第一个人必定会把 5 腾出来，使得第二个人拥有和第一个人一样的路程，第一个人仍然输</p></blockquote><p>那么可以很简单的想到，这个峰必须是左右坡长度相同的，但似乎不一定，例如下面这个例子</p><blockquote><p>例如<br>1, 2, 3, 4, 3, 2, 1<br>作为第一个人，则必定是选 4<br>第二个人也没太多选择的余地，肯定是选 1<br>这时会发现仍然第一个人输了</p></blockquote><p>而如果是下面这个例子</p><blockquote><p>例如<br>1, 2, 3, 4, 5, 4, 3, 2, 1<br>可以容易得出，第一个人能够赢的结论</p></blockquote><p>所以答案就是找出存在的一个峰，使得它的左坡和右坡的长度恰好相等且为奇数，则为答案</p><p>但是似乎并不是很完整，如果出现下面这样的情况</p><blockquote><p>例如<br>1, 2, 3, 4, 3, 2, 1, 2, 3, 4, 5<br>按照上面的规律，第一个人只能选择 4<br>而实际上有更长的坡可以使用，所以第二个人会选择更长的坡，所以第一个人仍然输</p></blockquote><p>同时，还需要保证这个峰是独一无二的，没有其他的坡比他的要大，或者相等</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span>, <span class="hljs-title">l</span><span class="hljs-params">(n)</span>, <span class="hljs-title">r</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cin &gt;&gt; data[i];<br><br>    <span class="hljs-type">int</span> cur = <span class="hljs-number">1</span>;<br>    l[<span class="hljs-number">0</span>] = l[n - <span class="hljs-number">1</span>] = r[<span class="hljs-number">0</span>] = r[n - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (data[i] &gt; data[i - <span class="hljs-number">1</span>]) cur++;<br>        <span class="hljs-keyword">else</span> cur = <span class="hljs-number">1</span>;<br>        l[i] = cur;<br>    &#125;<br>    cur = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-keyword">if</span> (data[i] &gt; data[i + <span class="hljs-number">1</span>]) cur++;<br>        <span class="hljs-keyword">else</span> cur = <span class="hljs-number">1</span>;<br>        r[i] = cur;<br>    &#125;<br><br>    <span class="hljs-type">int</span> maxLen = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (l[i] == r[i] &amp;&amp; l[i] &amp; <span class="hljs-number">1</span>) maxLen = <span class="hljs-built_in">max</span>(maxLen, l[i]);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) count += (l[i] == maxLen) + (r[i] == maxLen);<br>    cout &lt;&lt; (count == <span class="hljs-number">2</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>) &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios_base::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ACM_LOCAL</span><br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;in.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;out.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br>    <span class="hljs-type">signed</span> localTestCount = <span class="hljs-number">1</span>, localReadPos = cin.<span class="hljs-built_in">tellg</span>();<br>    <span class="hljs-type">char</span> localTryReadChar;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-keyword">if</span> (localTestCount &gt; <span class="hljs-number">20</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Check the stdin!!!&quot;</span>);<br>        <span class="hljs-keyword">auto</span> startClockForDebug = <span class="hljs-built_in">clock</span>();<br>        <span class="hljs-built_in">solve</span>();<br>        <span class="hljs-keyword">auto</span> endClockForDebug = <span class="hljs-built_in">clock</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;Test &quot;</span> &lt;&lt; localTestCount &lt;&lt; <span class="hljs-string">&quot; successful&quot;</span> &lt;&lt; endl;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;Test &quot;</span> &lt;&lt; localTestCount++ &lt;&lt; <span class="hljs-string">&quot; Run Time: &quot;</span><br>             &lt;&lt; <span class="hljs-built_in">double</span>(endClockForDebug - startClockForDebug) / CLOCKS_PER_SEC &lt;&lt; <span class="hljs-string">&quot;s&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">while</span> (localReadPos != cin.<span class="hljs-built_in">tellg</span>() &amp;&amp; cin &gt;&gt; localTryReadChar &amp;&amp; localTryReadChar != <span class="hljs-string">&#x27;$&#x27;</span> &amp;&amp;<br>             cin.<span class="hljs-built_in">putback</span>(localTryReadChar));<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-built_in">solve</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试复习（Java）</title>
    <link href="/2021/02/25/interview/java/"/>
    <url>/2021/02/25/interview/java/</url>
    
    <content type="html"><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><ul><li>线程池的原因<ul><li>不断的创建和删除线程，会带来较大的系统资源负载</li><li>线程缺乏统一的管理，可能会出现无限制的创建线程</li><li>线程之间抢占资源</li></ul></li><li>线程池的属性<ul><li>核心线程数：保持存在的线程数量，这些线程会一直存在，不会被删除</li><li>任务缓冲队列：当所有的核心线程都在运行时，新的任务会被加入到缓冲队列中</li><li>非核心线程数：当任务缓冲队列满后，将会创建新的线程来执行队列中的任务，且额外创建的线程数不会超过非核心线程数</li><li>空闲线程的存活时间：当非核心线程空闲时，且持续了一段时间后，此线程将会被删除</li><li>拒绝策略：当非核心线程和任务缓存队列满后，对待新的任务的策略</li></ul></li><li>Java 默认的线程池类型</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">核心线程数</th><th style="text-align:center">线程池大小</th><th style="text-align:center">非核心线程存活时间</th><th>等待队列大小</th></tr></thead><tbody><tr><td style="text-align:center">CachedThreadPool</td><td style="text-align:center">0</td><td style="text-align:center">$\infty$</td><td style="text-align:center">60s</td><td>0</td></tr><tr><td style="text-align:center">SingleThreadExecutor</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td>$\infty$</td></tr><tr><td style="text-align:center">FixedThreadPool</td><td style="text-align:center">$n$</td><td style="text-align:center">$n$</td><td style="text-align:center">0</td><td>$\infty$</td></tr><tr><td style="text-align:center">ScheduledThreadPoolExecutor</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td></td></tr></tbody></table></div><ul><li>Java 默认的线程池有什么问题，为什么会引起 OOM 异常（OutOfMemoryError）<ul><li>CachedThreadPool 允许创建无线的线程，从而引起 OOM 异常</li><li>SingleThreadExecutor 和 FixedThreadPool 请求队列为无限长，可能会堆积大量的消息，从而引发 OOM 异常</li></ul></li></ul><h1 id="Java-内存"><a href="#Java-内存" class="headerlink" title="Java 内存"></a>Java 内存</h1><ul><li>内存模型<ul><li>主内存：线程之间共享的变量储存在主内存中</li><li>本地内存：每个线程独立拥有的内存</li><li>本地内存保存的是主内存的共享变量的副本</li></ul></li><li>垃圾回收<ul><li>根搜索算法（可达性分析算法）从 GC ROOT 节点沿着引用链搜索，无法到达的节点即为不可到达的对象</li></ul></li><li>垃圾回收器<ul><li>G1 收集器<ul><li>独特的分代垃圾回收器，分代GC：分代收集器，同时兼顾年轻代和老年代</li><li>使用分区算法，不要求eden，年轻代或老年代的空间都连续</li><li>并行性：回收期间，可由多个线程同时工作，有效利用多核cpu资源</li><li>空间整理：回收过程中，会进行适当对象移动，减少空间碎片</li><li>可预见性：G1可选取部分区域进行回收，可以缩小回收范围，减少全局停顿</li></ul></li><li>G1 收集器的过程<ul><li>初始标记（它标记了从GC Root开始直接可达的对象）Stop-The-World</li><li>并发标记（从GC Roots开始对堆中对象进行可达性分析，找出存活对象）</li><li>最终标记（标记那些在并发标记阶段发生变化的对象，将被回收）Stop-The-World</li><li>筛选回收（首先对各个Regin的回收价值和成本进行排序，根据用户所期待的GC停顿时间指定回收计划，回收一部分Region）Stop-The-World</li></ul></li></ul></li></ul><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><ul><li>hashMap 的结构<ul><li>采用链地址法，当发生哈希冲突时使用链表解决</li><li>当链表过长时，在 JDK 1.8 下采用红黑树代替链表，当数据量较少时，转回链表</li><li>当存储的数据量超过一个阈值后，hashMap 的哈希表长度将会扩容到原来的两倍，然后将所有的数据重新分配到新的内存中</li></ul></li><li>hashMap 的这样扩容的理由<ul><li>通过恰好两倍扩容，可以让原来在第 $i$ 个链表的值被恰好分配到第 $i$ 和第 $2i$ 个链表的位置</li><li>每一个值，只需要判断其哈希值在某个二进制位上的值即可直接完成分配</li></ul></li><li>treeMap 的结构<ul><li>treeMap 是一棵红黑树</li></ul></li></ul><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><ul><li>设计原则<ul><li>开闭原则：对扩展开放，对修改关闭</li><li>里氏替换原则：子类必须拥有所有的父类功能，子类可以开发自己的新功能</li><li>依赖倒置原则：高层实现不能依赖于低层实现，而是依赖于低层的抽象类</li><li>单一职责原则：一个类应当只负责一个职责</li><li>接口隔离原则：接口应该更小更具体，而不是去实现很庞大的接口来适应所有的需求</li><li>迪米特法则：避免与无关实体进行通信</li><li>合成复用原则：尽量先使用组合或者聚合等关联，其次考虑继承</li></ul></li><li>设计模式<ul><li>创建型模式<ul><li>单例模式：限制一个类只能有一个实例</li><li>原型模式：以一个此类型的实例为模板，通过拷贝内存中的二进制值来直接创建一个对象</li><li>工厂模式：将创建对象的过程由另一个类进行封装</li><li>建造者模式：将一个复杂的对象分为多个简单的对象的组合，并实现将多个小对象进行拼装的过程</li></ul></li><li>结构型模式<ul><li>代理模式：使得两个对象之间不能直接引用访问，只能通过第三方，可以保护目标对象，扩展目标对象的功能</li><li>适配器模式：将一个类的接口转换为另外一个类的接口，通常是为了适配两个接口的对接问题</li><li>桥接模式：将抽象与实现分离，使得他们可以独立变化，用组合关系来代替继承关系</li><li>装饰器模式：为类增加新的功能的同时，避免了继承</li><li>外观模式：隐藏系统的复杂性</li><li>享元模式：重复使用已经创建的同类对象</li><li>组合模式</li></ul></li><li>行为型模式<ul><li>模板方法模式：仅实现一个操作中的骨干步骤，具体步骤由其子类实现</li><li>策略模式</li><li>命令模式</li><li>责任链模式</li><li>状态模式</li><li>观察者模式</li><li>中介者模式</li><li>迭代器模式</li><li>访问者模式</li><li>备忘录模式</li><li>解释器模式</li></ul></li></ul></li></ul><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><ul><li>String 类型<ul><li>String 类型是不可变的，对 String 类型进行操作的时，会重新生成新的 String 对象</li></ul></li><li>StringBuilder 和 StringBuffer<ul><li>StringBuilder 和 StringBuffer 都是可变的</li><li>StringBuilder 没有线程同步，存在线程安全问题，但是其效率略高于 StringBuffer</li><li>StringBuffer 能够保证线程安全，但效率较低</li></ul></li></ul><h1 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h1><ul><li>接口和抽象类的区别<ul><li>抽象类可以写非抽象方法，而接口类只能有抽象方法</li><li>一个类只能继承自一个抽象类，而一个类能实现多个接口</li><li>继承是一个“是不是”的关系，而 接口 实现则是“有没有”的关系</li></ul></li></ul><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><ul><li>子类实例化总是默认调用父类的无参构造方法<ul><li>为了让父类初始化属性和方法</li></ul></li></ul><h1 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h1><ul><li><code>equals</code> 和 <code>==</code> 的区别<ul><li><code>==</code> 对于基本类型时，比较的是两个对象的值是否相同，而对于对象时，则比较的是这两个引用是否指向了同一个对象</li><li><code>equals</code> 则可以由类进行重写，使得其满足正常的比较关系。若不进行重写，则与 <code>==</code> 等价</li></ul></li><li><code>equals</code> 和 <code>hashCode</code> 为什么需要同时进行重写<ul><li><code>hashCode</code> 在 <code>Object</code> 类下的默认行为是将此值的地址取出作为 <code>hashCode</code>，但这与 <code>hashCode</code> 本意不同，<code>hashCode</code> 的值应当满足对于 $\forall x$ 若 <code>x.equals(y) = true</code>，则 <code>x.hashCode() = y.hashCode()</code>。所以当重写 <code>equals</code> 时，通常意味着这个值的相等概念与 <code>==</code> 不同，所以必然需要重写 <code>hashCode</code> 避免在 <code>hashMap</code> 中出现意料之外的情况</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试准备</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试复习（Git）</title>
    <link href="/2021/02/24/interview/git/"/>
    <url>/2021/02/24/interview/git/</url>
    
    <content type="html"><![CDATA[<h1 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h1><ul><li>revert<ul><li>重做某个版本，在当前版本后，重新将某个版本的操作重做一次，得到一个新的版本，将会保留所有其他版本的操作</li></ul></li><li>reset<ul><li>返回到某个版本，所有在这个版本之后的版本都会被撤销</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试准备</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试复习（Linux）</title>
    <link href="/2021/02/23/interview/linux/"/>
    <url>/2021/02/23/interview/linux/</url>
    
    <content type="html"><![CDATA[<h1 id="查看进程占用系统资源情况"><a href="#查看进程占用系统资源情况" class="headerlink" title="查看进程占用系统资源情况"></a>查看进程占用系统资源情况</h1><ul><li>top</li><li>ps</li></ul><h1 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h1><ul><li>session<ul><li>一个终端窗口对应一个会话(session)</li><li>一个会话包含多个进程组</li><li>一个会话只有一个前台进程组，可以有多个后台进程组</li><li>所有在终端内的输入都会发送给前台进程组</li><li>当会话关闭时，所有会话内的进程将会被终止</li></ul></li></ul><h1 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h1><ul><li>进程的 fork 过程<ul><li>给新进程分配一个标识符</li><li>在内核中分配一个PCB</li><li>复制它的父进程的环境（PCB中大部分的内容）</li><li>为其分配资源（程序、数据、栈等）</li><li>复制父进程地址空间里的内容（代码共享，数据写时拷贝）</li><li>将进程置成就绪状态，并将其放入就绪队列，等待CPU调度</li></ul></li></ul><h1 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h1><ul><li>什么是守护进程<ul><li>在后台运行的一种特殊的进程</li><li>一般在系统启动时开始运行，系统关机后结束运行</li><li>常常以 root 权限启动</li><li>不需要输入，独立与终端</li><li>名称常常以 <code>d</code> 结尾</li></ul></li><li>创建守护进程的过程<ul><li>在父进程中执行 <code>fork</code> 并 <code>exit</code> 退出</li><li>在子进程中调用 <code>setsid</code> 函数创建新的会话</li><li>在子进程中调用 <code>chdir</code> 函数，让根目录 <code>/</code> 成为子进程的工作目录</li><li>在子进程中调用 <code>umask</code> 函数，设置进程的 <code>umask</code> 为 0</li><li>在子进程中关闭任何不需要的文件描述符</li></ul></li></ul><h1 id="IO模式"><a href="#IO模式" class="headerlink" title="IO模式"></a>IO模式</h1><ul><li>IO 模式有哪些<ul><li>阻塞 IO：当进行 IO 时，线程阻塞，不再占用 CPU，直到 IO 完成</li><li>非阻塞 IO：当进行 IO 时，线程不阻塞，而是进行循环判断是否 IO 完成，一直占用 CPU</li><li>IO 多路复用：允许同时进行多个 IO，线程仍然阻塞</li><li>异步 IO：在 IO 时不会阻塞，也不会关心 IO 状态，而是继续执行代码，直到 IO 完成再回来执行 IO 完成的代码</li></ul></li><li>IO 多路复用的机制<ul><li>select：当有任意一个 IO 完成时，通知程序。缺点在于单个进程只能打开有限的文件，同时其采用轮番查询，效率较低，而且仅通知程序有 IO 完成，并不知道到底哪个文件的 IO 完成了</li><li>poll：与 select 相同，但其提供了无限制的文件打开数量</li><li>epoll：可以自定义打开的文件数量，同时当 IO 完成时会已消息的形式通知程序，包括了到底是哪个 IO 完成了</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试准备</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试复习（数据库）</title>
    <link href="/2021/02/23/interview/database/"/>
    <url>/2021/02/23/interview/database/</url>
    
    <content type="html"><![CDATA[<h1 id="B-树和-B-树"><a href="#B-树和-B-树" class="headerlink" title="B 树和 B+ 树"></a>B 树和 B+ 树</h1><ul><li>B 树的特点<ul><li>一个节点上包含至多 $m - 1$ 个值</li><li>根节点至少有两个孩子</li><li>非叶子节点如果包含了 $k$ 个值，则其包含了 $k + 1$ 个孩子节点</li><li>所有叶子节点都位于同一层</li></ul></li><li>B+ 树的特点<ul><li>所有的非叶子节点不再保存值，而是只保存了中间值</li><li>所有值保存在叶子节点上</li><li>所有的叶子节点通过链表按照顺序进行连接</li></ul></li><li>为什么数据库会采用 B+ 树而不是 B 树或者 AVL 树<ul><li>AVL 的节点访问次数更多，而对于数据库而言，每个节点通常被存储在一个文件中，所以需要读取的文件数量更多，导致效率低</li><li>在数据库中有时需要进行范围的搜索，此时 B+ 树的链表结构可以快速的找到某个节点的下一个节点位置</li></ul></li></ul><h1 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h1><ul><li>什么是联合索引<ul><li>多个列同时组成索引</li></ul></li></ul><h1 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h1><ul><li>聚簇索引<ul><li>叶子节点上直接保存值</li></ul></li><li>非聚簇索引<ul><li>叶子节点上保存的是值所在的地址</li></ul></li><li>聚簇索引的优点<ul><li>理论上速度更快，因为聚簇索引少一次文件的读取过程</li></ul></li><li>非聚簇索引的优点<ul><li>更新主键的代价低</li><li>主键插入的顺序可以混乱</li></ul></li></ul><h1 id="MySQL-锁"><a href="#MySQL-锁" class="headerlink" title="MySQL 锁"></a>MySQL 锁</h1><ul><li>类型<ul><li>全局锁</li><li>表级锁</li><li>行级锁</li></ul></li><li>读写锁<ul><li>读锁：可以与其他的读锁共存，但是不可以与写锁共存</li><li>写锁：不可以与其他任何锁共存</li></ul></li><li>悲观锁<ul><li>普通的锁，锁定此行/表/数据库以防止其他操作进行修改，会导致其他事务被阻塞</li></ul></li><li>乐观锁<ul><li>通过比较版本号的区别的方法，来确定此数据是否经过修改，如果修改则需要读取最新的值</li></ul></li></ul><h1 id="MyISAM和InnoDB"><a href="#MyISAM和InnoDB" class="headerlink" title="MyISAM和InnoDB"></a>MyISAM和InnoDB</h1><ul><li>区别<ul><li>MyISAM 是 MySQL 之前默认数据库，不支持事务、行级锁和外键，崩溃后无法安全恢复，支持全文索引，强调性能</li><li>InnoDB 是 MySQL 目前的默认数据库，支持了ACID兼容的事务，支持行级锁，不支持全文索引</li></ul></li><li>适合范围<ul><li>MyISAM 适合读密集场所</li><li>InnoDB 适合写密集场所</li></ul></li></ul><h1 id="数据库联合查询和连接查询"><a href="#数据库联合查询和连接查询" class="headerlink" title="数据库联合查询和连接查询"></a>数据库联合查询和连接查询</h1><ul><li>联合查询(JOIN)<ul><li>将两张表按照一定规律进行拼接组成结果并返回</li><li><code>SELECT table1.*, table2.* FROM table1 JOIN table2 ON table1.id=table2.id</code></li><li><code>INNER JOIN</code> 仅当左右两个表同时存在对应的数据时才返回</li><li><code>LEFT JOIN</code> 当左边的表存在则返回</li><li><code>RIGHT JOIN</code> 当右边的表存在则返回</li></ul></li><li>连接查询(UNION)<ul><li>将两个或更多查询的结果集组合为单个结果集，查询来自同一个表的相同列</li><li><code>UNION ALL</code> 不做重复性检查</li></ul></li></ul><h1 id="数据库的索引类型"><a href="#数据库的索引类型" class="headerlink" title="数据库的索引类型"></a>数据库的索引类型</h1><ul><li>普通索引<ul><li>没有限制，普通的索引</li></ul></li><li>唯一索引<ul><li>索引列的值必须唯一，但允许有空值</li></ul></li><li>主键索引<ul><li>特殊的唯一索引，不允许有空值</li></ul></li><li>全文索引<ul><li>对全文的索引，耗时耗空间</li></ul></li></ul><h1 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h1><div class="table-container"><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读（Dirty Read）</th><th style="text-align:center">不可重复读（NonRepeatable Read）</th><th style="text-align:center">幻读（Phantom Read）</th></tr></thead><tbody><tr><td style="text-align:center">未提交读（Read uncommitted）</td><td style="text-align:center">可能</td><td style="text-align:center">可能</td><td style="text-align:center">可能</td></tr><tr><td style="text-align:center">已提交读（Read committed）</td><td style="text-align:center">不可能</td><td style="text-align:center">可能</td><td style="text-align:center">可能</td></tr><tr><td style="text-align:center">可重复读（Repeatable read）</td><td style="text-align:center">不可能</td><td style="text-align:center">不可能</td><td style="text-align:center">可能</td></tr><tr><td style="text-align:center">可串行化（Serializable）</td><td style="text-align:center">不可能</td><td style="text-align:center">不可能</td><td style="text-align:center">不可能</td></tr></tbody></table></div><ul><li>隔离级别<ul><li>未提交读：最朴素的数据库形式</li><li>已提交读：在事务完成之后再更新数据库的值</li><li>可重复读：每个事务开始前锁定所更新的行</li><li>可串行化：单一线程，所有事务必须按照顺序进行</li></ul></li><li>三种错误<ul><li>脏读：读取到其他事务正在修改过程中的值</li><li>不可重复读：一个事务中，同一条语句得到的对应行的内容不同</li><li>幻读：一个事务中，同一条语句得到的数据数量不同</li></ul></li></ul><h1 id="MySQL-的存储引擎"><a href="#MySQL-的存储引擎" class="headerlink" title="MySQL 的存储引擎"></a>MySQL 的存储引擎</h1><ul><li>MySQL 的存储引擎类型<ul><li>InnoDB（默认）：支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）</li><li>MyISAM（旧版本的 MySQL 默认）：插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比较低，也可以使用</li><li>Memory：所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择 Memory。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表</li></ul></li></ul><h1 id="MySQL-主从复制"><a href="#MySQL-主从复制" class="headerlink" title="MySQL 主从复制"></a>MySQL 主从复制</h1><ul><li>MySQL 主从复制作用<ul><li>实现数据的多处自动备份</li><li>实现读写分离还能进一步提升数据库的负载性能</li></ul></li><li>MySQL 主从复制的原理<ul><li>从服务器将日志与主服务器同步，同时重放日志的内容实现数据同步</li></ul></li></ul><h1 id="回表查询"><a href="#回表查询" class="headerlink" title="回表查询"></a>回表查询</h1><ul><li>MySQL 的索引逻辑<ul><li>MySQL 会为主键保存一棵聚集索引数树（叶子节点上保存了此节点的所有属性值），而其他的索引则为普通的索引树，普通的索引树进仅保存了主键值而没有保存属性值</li><li>当需要进行查询且 WHERE 条件不是主键时，需要先通过查询对应的索引，然后通过索引得到主键值，然后再去聚集索引树上搜索对应的主键值，所以需要查询两次索引，效率低</li></ul></li><li>覆盖索引<ul><li>如果使用 <code>SELECT</code> 的时候，恰好只需要主键和此搜索值，则可以不搜索聚集索引树，因为仅靠普通索引树即可得到答案</li><li>为了避免回表，可以通过建议一些可能的联合索引，使得进行 <code>SELECT</code> 的时候不会进行回表操作</li></ul></li></ul><h1 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h1><ul><li>为什么使用连接池<ul><li>与 Java 的线程池相同，为了节约系统资源</li></ul></li><li>常用的连接池<ul><li>DBCP：使用量最大的连接池</li><li>C3P0</li></ul></li></ul><h1 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h1><ul><li>水平分表<ul><li>将一个表的记录分割到数个表中，可以减少索引的大小，加快索引</li></ul></li><li>垂直分表<ul><li>将部分字段划分至其他的表，部分字段数据量大，进行索引时会带来大量的 IO 负担，进行分表有利于查询效率</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试准备</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试复习（计算机网络）</title>
    <link href="/2021/02/23/interview/computer-network/"/>
    <url>/2021/02/23/interview/computer-network/</url>
    
    <content type="html"><![CDATA[<h1 id="OSI-模型"><a href="#OSI-模型" class="headerlink" title="OSI 模型"></a>OSI 模型</h1><ul><li>哪七层<ul><li>应用层：协议与端口</li><li>表示层</li><li>会话层</li><li>传输层：TCP、UDP</li><li>网络层：IP、ARP</li><li>数据链路层：mac地址</li><li>物理层：物理字节流传输</li></ul></li></ul><h1 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h1><ul><li>ARP 协议的作用<ul><li>将 IP 地址转为下一跳的 mac 地址</li></ul></li></ul><h1 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h1><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">数据发送内容</th><th style="text-align:center">发送方向</th><th style="text-align:center">客户端状态</th><th style="text-align:center">服务器状态</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">CLOSED</td><td style="text-align:center">LISTEN</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">SYN=1 seq=x</td><td style="text-align:center">客户端 -&gt; 服务器</td><td style="text-align:center">发送后转为 SYN_SENT</td><td style="text-align:center">接收后转为 SYN_RCVD</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">SYN=1 ACK=1 ack=x+1 seq=y</td><td style="text-align:center">服务器 -&gt; 客户端</td><td style="text-align:center">接收后转为 ESTABLISHED</td><td style="text-align:center">SYN_RCVD</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">ACK=1 ack=y+1</td><td style="text-align:center">客户端 -&gt; 服务器</td><td style="text-align:center">ESTABLISHED</td><td style="text-align:center">接收后转为 ESTABLISHED</td></tr></tbody></table></div><ul><li><p>为什么需要最后一次握手</p><ul><li>在最后一次握手前，不能确定服务器本身不能确定自己发送的数据能否被客户端所接收到</li></ul></li><li><p>如果最后一次的 ACK 包服务器没有接收到，即客户端已经进入了 ESTABLISHED 而服务器仍然没有进入到 ESTABLISHED，此时会发生什么</p><ul><li>服务器：由于仍然处于 SYN_RCVD 状态下，当超过一定时间后，服务器会重新发送 SYN+ACK 包，直到达到次数上限后，直接关闭本次连接</li><li>客户端：因为已经进入了 ESTABLISHED，所以实际上已经可以发送数据了，当发送数据给服务器时，服务器会发现此连接并未建立，此时服务器将会按照 TCP 规则，发送 RST 包给客户端，当客户端接收到此 RST 包后，关闭连接</li></ul></li></ul><h1 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h1><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">数据发送内容</th><th style="text-align:center">发送方向</th><th style="text-align:center">客户端状态</th><th style="text-align:center">服务器状态</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">ESTABLISHED</td><td style="text-align:center">ESTABLISHED</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">FIN=1 seq=x</td><td style="text-align:center">客户端 -&gt; 服务器</td><td style="text-align:center">发送后转为 FIN_WAIT_1</td><td style="text-align:center">接收后转为 CLOSE_WAIT</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">ACK=1 ack=x+1</td><td style="text-align:center">服务器 -&gt; 客户端</td><td style="text-align:center">接收后转为 FIN_WAIT_2</td><td style="text-align:center">CLOSE_WAIT</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">FIN=1 seq=y</td><td style="text-align:center">服务器 -&gt; 客户端</td><td style="text-align:center">接收后转为 TIME_WAIT</td><td style="text-align:center">发送后转为 LAST_ACK</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">ACK=1 ack=y+1</td><td style="text-align:center">客户端 -&gt; 服务器</td><td style="text-align:center">发送后等待 2MSL 后转为 CLOSED</td><td style="text-align:center">接收后转为 CLOSED</td></tr></tbody></table></div><ul><li>四次挥手的理解<ul><li>四次挥手可以认为是两次+两次，一次是由客户端发起的，客户端表示自己的数据已经发送完毕了，通过 FIN 包通知服务器，而服务器接收到后通过 ACK 包向客户端回复表示收到。另一次是由服务器发起的，因为客户端发送完成数据并不代表服务器发送完成数据了，所以还有服务器单独发起的 FIN 包，此时客户端发送 ACK 包表示确定</li></ul></li></ul><h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><ul><li>特点<ul><li>基于 TCP/IP （从 HTTP 3.0 开始，改为采用 UDP 协议）</li><li>由客户端发起请求，服务器进行响应</li><li>通过 URL 来区分服务</li><li>无状态</li><li>无连接</li><li>提供了八种方法，其中最常见的两种为 <code>GET</code> 和 <code>POST</code></li></ul></li><li>端口<ul><li>HTTP 协议默认为 80 端口，HTTPS 协议为 443 端口</li></ul></li><li>状态码</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">状态码</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">1XX</td><td style="text-align:center">信息状态码</td></tr><tr><td style="text-align:center">2XX</td><td style="text-align:center">成功状态码</td></tr><tr><td style="text-align:center">3XX</td><td style="text-align:center">重定向状态码</td></tr><tr><td style="text-align:center">4XX</td><td style="text-align:center">客户端错误码</td></tr><tr><td style="text-align:center">5XX</td><td style="text-align:center">服务器错误码</td></tr></tbody></table></div><ul><li>常见的状态码</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">状态码</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">200</td><td style="text-align:center">成功</td></tr><tr><td style="text-align:center">302</td><td style="text-align:center">重定向</td></tr><tr><td style="text-align:center">404</td><td style="text-align:center">客户端的 URL 不存在</td></tr><tr><td style="text-align:center">500</td><td style="text-align:center">服务器错误</td></tr></tbody></table></div><ul><li>HTTP 和 HTTPS 的区别<ul><li>HTTP 采用明文传输的方式，而 HTTPS 采用的是加密的方式传输</li><li>HTTPS 通常需要申请证书</li></ul></li><li>GET 和 POST 的区别<ul><li>GET 通常用于获取数据，GET 的请求参数会附在 URL 后，用 <code>?</code> 分割 URL 和参数，用 <code>&amp;</code> 分割多个参数，特殊字符进行 base64 转码，以明文的方式显示</li><li>POST 通常用于更新数据，POST 的请求参数会放在数据包的 Body 部分，相对更加安全，浏览器不会进行保存</li></ul></li><li>HTTP 1.0 和 1.1 的区别<ul><li>持久连接</li><li>管道机制：同一个连接中，客户端可以发送多个请求</li><li>分块传输：服务器每产生一个数据，就发送一个数据</li><li>新增了部分请求方式</li></ul></li><li>HTTP 1.1 和 2.0 的区别<ul><li>完全采用二进制进行传输</li><li>完全多路复用</li><li>报头压缩</li></ul></li></ul><h1 id="TCP-的可靠传输"><a href="#TCP-的可靠传输" class="headerlink" title="TCP 的可靠传输"></a>TCP 的可靠传输</h1><ul><li>TCP 的可靠传输的实现<ul><li>数据校验</li><li>数据的合理分片和排序</li><li>滑动窗口机制<ul><li>发送方保留了已经发送的数据的副本，用于重传</li><li>发送方接收到 ACK 确认包后才会丢弃副本</li><li>发送方维护一个重传时间，当没有接收到 ACK 确认包时将会进行重传</li><li>通过拥塞控制来管理滑动窗口的大小</li><li>发送方和接收方商讨发送速度，通过控制发送速度保证接收方有足够的内存空间来接受数据</li></ul></li></ul></li><li>TCP “粘包” 现象<ul><li>原因：TCP 是面向字节流的，而且在遇到多个连续的数据包时，会合并至一个数据包内发送，此时接收方将难以识别并读取内部的数据</li><li>解决办法：在每个数据包前加上数据包的长度，使得每次读取数据时可以获取到数据包的长度而读出足够长的数据再进行解析</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试准备</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试复习（操作系统）</title>
    <link href="/2021/02/22/interview/operating-system/"/>
    <url>/2021/02/22/interview/operating-system/</url>
    
    <content type="html"><![CDATA[<h1 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h1><ul><li>什么时候从用户态转为内核态<ul><li>程序在用户态执行时，当需要进行系统调用的时候，或者遇到异常，或者外围设备引发的中断，如文件读取与写入，程序报错，键盘输入，网络操作等行为时，程序会从用户态转为内核态，直到执行此行为结束时，再返回用户态</li></ul></li><li>为什么要转至内核态<ul><li>通过限制用户态的权利，使得有限的系统资源能够受到系统的控制与管理，由系统进行资源的分配</li></ul></li><li>用户态和内核态的切换原理<ul><li>实质上就是中断，保存当前用户态的所有寄存器信息等，然后将代码指针指向中断处理程序</li></ul></li></ul><h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><ul><li>区别<ul><li>进程是相对于操作系统的最小单位，每个进程都有唯一一个 PID 与之对应，每个进程都有独立的内存空间，代码段，数据段。进程之间相互独立且不会相互影响，一个进程可以包含多个线程。CPU在多个进程之间切换时会带来较大的开销。进程可以由CPU单独启动</li><li>线程是相对于处理器的最小单位，单个CPU只能同时处理一个线程，相同进程的线程之间共用内存空间，共用代码段和数据段，线程不可以单独执行，线程没有 PID 用于区别，线程出现错误或者异常时会影响此进程内的所有线程，CPU在同一个进程的线程内切换所带来的开销相对较小</li></ul></li><li>进程之间的通信<ul><li>管道（无名和有名管道）</li><li>消息队列</li><li>共享内存<ul><li>不同的进程可以同时将同一个内存页面映射到自己的地址空间中</li></ul></li><li>信号</li><li>套接口（网络）</li></ul></li><li>线程之间的通信<ul><li>锁机制（互斥锁、读写锁）</li><li>wait 和 notify</li><li>violate</li></ul></li><li>进程切换代价<ul><li>切换页目录</li><li>切换内核栈</li><li>切换上下文</li></ul></li><li>线程切换代价<ul><li>切换内核栈</li><li>切换上下文</li></ul></li></ul><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><ul><li>内存寻址是如何实现的<ul><li>段页式，程序进行分段，包括代码段，数据段等等，每一段再分页，并由 MMU 保存页表</li><li>MMU 通过页表将逻辑地址转为物理地址</li></ul></li></ul><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><ul><li>缓存列<ul><li>每次计算机读取数据放入缓存的单位长度</li></ul></li></ul><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><ul><li>iNode 结构<ul><li>文件树结构保存了一个目录的子文件/目录的名称以及对应的 iNode 号码</li><li>需要访问文件内容时，需要通过 iNode 号码来获取文件的详细信息</li><li>iNode 不包含文件名信息，指包含文件的 “元信息”</li></ul></li></ul><h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试准备</tag>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试复习（C++）</title>
    <link href="/2021/02/22/interview/cpp/"/>
    <url>/2021/02/22/interview/cpp/</url>
    
    <content type="html"><![CDATA[<h1 id="C-的特性与轨迹"><a href="#C-的特性与轨迹" class="headerlink" title="C++的特性与轨迹"></a>C++的特性与轨迹</h1><ul><li>C++ 的特性（C++11及以上）<ul><li>需要在不同的平台上进行编译</li><li>编译后的程序可以在操作系统上直接运行</li><li>可以面对过程和面对对象两种设计方式</li><li>可以直接操作本地的系统库</li><li>可以直接使用操作系统提供的接口</li><li>编译后仅对变量的类型进行了存储，不可以进行类似反射的操作</li><li>支持无符号整型</li><li>变量类型的字节长度受操作系统影响</li><li>支持指针、引用、值传递</li><li>没有默认提供的 GC 系统</li><li>由程序员负责管理变量所储存的位置</li><li>严格的 RAII</li><li>支持重写、重载，包括运算符的重载</li><li>多重继承</li><li>支持预编译，编译宏定义</li><li>支持函数指针，函数对象，lambda 表达式</li></ul></li><li>C++ 11 新增的特性<ul><li><code>foreach</code></li><li><code>auto</code> 自动类型推断</li><li><code>lambda</code> 匿名函数</li><li>后置返回类型</li><li><code>override</code> 关键字</li><li><code>nullptr</code> 代替原来的 NULL<ul><li>当存在 <code>void a(int x);</code> 和 <code>void a(char *x)</code> 时，若使用 <code>a(NULL)</code> 则会调用前者，这与通常的理解不同，而使用 <code>a(nullptr)</code> 则会明确的调用后者</li></ul></li><li>元组 tuple，可以使用 <code>get&lt;&gt;()</code> 取出其中的一个值，或者使用 <code>tie()</code> 装包或解包</li></ul></li></ul><h1 id="struct-和-class"><a href="#struct-和-class" class="headerlink" title="struct 和 class"></a>struct 和 class</h1><ul><li>区别<ul><li>struct 默认使用 public 而 class 默认使用 private</li><li>struct 可以直接使用 <code>&#123;&#125;</code> 进行初始化，而 class 则需要所有成员变量都是 public 的时候才可以使用</li></ul></li></ul><h1 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h1><ul><li>操作系统角度<ul><li>堆是操作系统为进程所分配的空间，在 C、C++ 语言中用来存放全局变量。由程序员管理，主动申请以及释放的空间，可能会出现内存泄漏。在进程结束后，由操作系统回收</li><li>栈是由编译器进行管理，由编译器进行申请，释放的空间，通常比堆要小很多，在 C、C++ 语言中，当调用一个函数时会创建一个栈，当函数结束时则会回收栈的空间</li></ul></li><li>数据结构的角度<ul><li>堆是一棵完全二叉树，常见的有最大堆和最小堆，以最大堆为例，其满足二叉树中的任意一个节点的孩子节点都比此节点小。通常用来实现优先队列的效果，插入和删除的复杂度均为 O(logN)</li><li>栈是一种线性数据结构，满足先进后出的特点，即最先进入的数据最后离开，常见于 DFS 中。也可以通过单调栈的方式求解一些问题。插入和删除的复杂度均为 O(1)</li></ul></li></ul><h1 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h1><ul><li>虚函数<ul><li>虚函数由 virtual 标记</li><li>普通的虚函数仍然需要进行实现，所有继承此类的派生类可以重新实现此函数也可以不实现</li></ul></li><li>纯虚函数<ul><li>纯虚函数在普通的虚函数后，加上 <code>=0</code></li><li>当一个类拥有纯虚函数后，则此类变成抽象类，不可以进行实例化</li><li>纯虚函数不需要实现，且所有继承自此类的派生类必须实现此函数，否则派生类也是抽象类，不可以实例化</li></ul></li><li>虚函数的实现原理<ul><li>在类中保存一张虚函数表，表内保存了函数所在的代码段</li><li>当其他类继承自此类时，复制一份此虚函数表。当其中的虚函数进行实现后，将虚函数表中此函数的指针指向新的函数的地址</li><li>定义类的实例的时候，在类的开头保存了一个指向此虚函数表的指针，当需要调用此函数的时候，通过此指针找到对应的函数地址</li></ul></li></ul><h1 id="静态函数和虚函数"><a href="#静态函数和虚函数" class="headerlink" title="静态函数和虚函数"></a>静态函数和虚函数</h1><ul><li>静态函数和虚函数的区别<ul><li>静态函数在编译时就确定了运行的时机，而虚函数则是在运行的过程中动态的得知虚函数地址</li></ul></li></ul><h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><ul><li>扩容规则<ul><li>当空间不足的时候，vector 会扩容至当前空间的 2(GCC下)/1.5(MSVC)</li></ul></li><li>为什么这样扩容<ul><li>以两倍空间为例，当扩容次数为 30 次左右时，vector 的空间达到 1e9 （十亿）而通常每次扩容，都会需要在堆上重新分配空间，需要重新移动整个数组到新的空间。由此，可以得出重新分配空间的次数越少越好，同时也要节约内存的占用，因为按照此增长，其内存的重复的分配次数始终在常数范围内，所以采用了上述的扩容方式。</li></ul></li><li>MSVC下的 1.5 倍的空间相对于 GCC 下的 2 倍有什么好处和坏处<ul><li>好处：因为 2 倍空间下，任意一个空间都大于之前所有分配过的空间之和，这就意味着每次进行扩容的时候都需要分配一个新的空间。而在 1.5 倍下，可以重复使用之前的空间，1.5 倍相对会节约内存</li><li>坏处： 1.5 倍下的重新分配次数更多，也就意味着需要更多的重新分配空间和重新移动的次数，更加浪费时间</li></ul></li><li>clear 的复杂度<ul><li>复杂度与已有的元素数量成线性，因为每个元素都需要析构</li><li>clear 后，并不会改变 vector 的容量上限，只会更新 vector 内的 size 大小</li></ul></li></ul><h1 id="队列和堆栈的模拟"><a href="#队列和堆栈的模拟" class="headerlink" title="队列和堆栈的模拟"></a>队列和堆栈的模拟</h1><ul><li>用两个堆栈模拟队列<ul><li>将两个堆栈命名为 A、B</li><li>若 B 堆栈为空，则将 A 堆栈的所有值都推入 B 中</li><li>若需要推入，则推入到 A 中</li><li>若需要推出，则从 B 中推出</li></ul></li><li>用两个队列模拟堆栈<ul><li>将两个队列命名为 A、B</li><li>若需要推入，则推入到 A 中</li><li>若需要弹出，则将 A 中的值除了最后一个，其他都推入到 B 中，且仅留下一个值，然后弹出这个值，并将 A、B 队列命名为 B、A 队列</li></ul></li></ul><h1 id="四个类型转换"><a href="#四个类型转换" class="headerlink" title="四个类型转换"></a>四个类型转换</h1><div class="table-container"><table><thead><tr><th style="text-align:center">转换</th><th style="text-align:center">特点</th></tr></thead><tbody><tr><td style="text-align:center">static_cast</td><td style="text-align:center">普通的转换，与普通的 C 语言的强制类型转换相同，在编译期间进行转换，所以会检查转换是否合法</td></tr><tr><td style="text-align:center">const_cast</td><td style="text-align:center">去除 const 属性，但是不能去除其本身的 const 属性</td></tr><tr><td style="text-align:center">reinterpret_cast</td><td style="text-align:center">无条件强制转换</td></tr><tr><td style="text-align:center">dynamic_cast</td><td style="text-align:center">将基类转换为派生类</td></tr></tbody></table></div><h1 id="三个访问限制"><a href="#三个访问限制" class="headerlink" title="三个访问限制"></a>三个访问限制</h1><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">private</td><td style="text-align:center">私有的，仅此类可以访问此属性</td></tr><tr><td style="text-align:center">protect</td><td style="text-align:center">保护的，仅此类已经此类的派生类可以访问此属性</td></tr><tr><td style="text-align:center">public</td><td style="text-align:center">公有的，任意对象和方法可以访问此属性</td></tr></tbody></table></div><h1 id="下面这段代码最终结果是"><a href="#下面这段代码最终结果是" class="headerlink" title="下面这段代码最终结果是"></a>下面这段代码最终结果是</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">main</span> () &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;xxx&quot;</span>);<br>    fork();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>为 <code>xxxxxx</code></li><li>由于有输出缓存，实际上在 fork 的时候，并没有输出至屏幕，而是保存在缓存中，当程序结束时，将缓存中的值输出至终端，所以得到 <code>xxxxxx</code></li></ul><h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><ul><li>static 变量的特点<ul><li>该变量在全局数据区分配内存</li><li>未经初始化的静态全局变量会被程序自动初始化为0（自动变量的值是随机的，除非它被显式初始化）</li><li>静态全局变量在声明它的整个文件都是可见的，而在文件之外是不可见的</li></ul></li></ul><h1 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h1><ul><li>指针和引用的区别<ul><li>指针有自己的内存空间，是一个变量类型，而引用没有占用内存空间，只是一个别名</li><li>使用 <code>sizeof</code> 可以求得在 32 位操作系统下，指针的大小为 $4$ 个字节，而引用则为原对象的大小</li><li>指针可以初始化为任意正整数值，而引用必须初始化为一个已经存在的变量</li><li>参数传递时，指针需要先进行指针转为引用然后再使用，而引用可以直接操作原对象</li><li>指针可以有 const 属性，而引用没有 const 属性</li><li>指针可以重新赋值，而引用不可以更改</li><li>指针可以进行多级指针，而引用只有一级</li><li>指针可以引用进行 ++（自增）操作的逻辑和结果都不同</li><li>当需要返回动态内存分配的对象时，需要使用指针而不是引用，因为引用可能会产生内存泄漏</li></ul></li></ul><h1 id="平面几何问题"><a href="#平面几何问题" class="headerlink" title="平面几何问题"></a>平面几何问题</h1><ul><li>判断一个点是否在一个三角形内<ul><li>定义三角形为 $ \vartriangle ABC$，点为 $P$，计算 $ S<em>{\vartriangle ABC} = S</em>{\vartriangle ABP} + S<em>{\vartriangle ACP} + S</em>{\vartriangle BCP}$ 是否成立。而三角形面积可以通过割补法或者叉积求</li></ul></li></ul><h1 id="c-智能指针"><a href="#c-智能指针" class="headerlink" title="c++智能指针"></a>c++智能指针</h1><ul><li><code>auto_ptr</code>（已弃用）<ul><li>采用所有权模式，任何一个 <code>new</code> 的对象只能由一个 <code>auto_ptr</code> 来指向，进行赋值操作会使得原来的指针丢失指向的对象</li></ul></li><li><code>unique_ptr</code><ul><li>与 <code>auto_ptr</code> 相同，但是进行赋值操作时，会直接报错，而 <code>auto_ptr</code> 不会</li></ul></li><li><code>shared_ptr</code><ul><li>共享指针，允许多个指针指向此对象，同时当所有指向此对象的指针都被析构后，此对象将会被删除</li></ul></li><li><code>weak_ptr</code><ul><li>弱共享指针，允许指向其他的 <code>shared_ptr</code> 对象，此指针不会影响 <code>shared_ptr</code> 的析构行为，通常用来避免相互指向问题</li></ul></li></ul><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><ul><li>构造函数有哪些特征<ul><li>名字和类名相同</li><li>没有返回值</li><li>生成类的自动执行，不需要调用</li></ul></li><li>为什么构造函数不可以是虚函数<ul><li>因为虚函数表指针是在构造函数期间创建的，没有虚函数表就没有办法调用虚函数</li></ul></li></ul><h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><ul><li>析构函数的作用<ul><li>如果一个类中有指针，且这个指针指向了一段由此类的实例请求分配的空间，那么需要由析构函数来实现对这块区域的释放，否则会造成内存泄漏</li></ul></li><li>C++ 为什么习惯把析构函数定义为虚函数<ul><li>当这个类需要作为父类派生的时候，如果程序得到的是此父类的指针，那么此时就无法析构子类，出现内存泄漏</li></ul></li><li>C++ 为什么默认的析构函数不是虚函数<ul><li>虚函数需要额外的虚函数表和虚函数表指针，对于不会派生的类而言，浪费空间</li></ul></li></ul><h1 id="重载和覆盖"><a href="#重载和覆盖" class="headerlink" title="重载和覆盖"></a>重载和覆盖</h1><ul><li>重载和覆盖的区别<ul><li>重载：两个相同的函数名，但是参数列表不同</li><li>覆盖：父类创建的虚函数，派生类重新定义</li></ul></li></ul><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><ul><li>C++ 中的锁类型<ul><li>互斥锁：对于同一个变量只允许一个线程进行读写，若不满足时则会进入阻塞，并且 CPU 不会进入忙等</li><li>条件锁：当满足某个条件时，再唤醒此线程，否则一直处于阻塞状态</li><li>自旋锁：不断的检查锁是否满足条件，不释放 CPU，比较耗费 CPU</li><li>读写锁：允许有读锁的时候再加读锁，但是有写锁时不再能加任何锁</li><li>递归锁：允许同一个线程对同一个锁进行多次加锁</li></ul></li></ul><h1 id="new和malloc"><a href="#new和malloc" class="headerlink" title="new和malloc"></a>new和malloc</h1><ul><li>new 和 malloc 的区别<ul><li>new 是一个 c++ 关键字，不需要头文件支持，而 malloc 是一个函数，需要头文件支持</li><li>malloc 需要给出需要的空间大小，而 new 不需要</li><li>new 返回的是对象的指针，而 malloc 返回的是 void* 类型的指针</li><li>new 分配失败时会抛出错误，而 malloc 失败时返回空指针</li><li>new 会调用被构造的类型的构造函数，而 malloc 只是分配内存空间</li><li>可以重载 new 操作，但是不能重载 malloc 操作</li></ul></li><li>delete 和 free 的区别<ul><li>delete 会调用析构函数，而 free 直接回收空间</li></ul></li></ul><h1 id="C-编译"><a href="#C-编译" class="headerlink" title="C++ 编译"></a>C++ 编译</h1><ul><li>从源文件到可执行文件的过程<ul><li>预处理，宏定义替换</li><li>编译，生成汇编代码</li><li>汇编，将汇编代码转为机器代码，生成目标文件</li><li>链接，将多个目标文件连接成最终可执行文件</li></ul></li></ul><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><ul><li>C++ 的内存分布<ul><li>代码段：存储机器代码和字符串常量</li><li>数据段：存储程序中已初始化的全局变量和静态变量</li><li>BSS段：存储未初始化的全局变量和静态变量，以及所有被初始化为 0 的全局变量和静态变量</li><li>堆区：调用 <code>new/malloc</code> 函数时动态管理分配的内存，同时需要用 <code>delete/free</code> 来手动释放</li><li>栈区：使用栈空间存储的函数的变量和返回值等</li><li>映射区：存储动态链接库以及调用 <code>mmap</code> 函数进行的文件映射</li></ul></li><li>C++ 内存泄漏检查<ul><li>通过 valgrind 检查一个调试程序</li><li>valgrind 可以检查出内存泄漏、越界访问、未初始化内存</li></ul></li></ul><h1 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h1><ul><li>静态方法和实例方法有何不同<ul><li>调用时，静态方法既可以用 <code>类名.方法名</code> 和 <code>对象名.方法名</code>，而实例方法只能用后者</li><li>静态方法只能访问静态变量，而实例方法可以访问静态变量和成员变量</li></ul></li></ul><h1 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h1><ul><li>如何确定一个值是左值还是右值<ul><li>提供了地址的为左值，左值可以没有值，但是一定有地址</li><li>提供了值的为右值，右值可以没有地址，但是一定有值</li></ul></li><li>右值引用的功能<ul><li>移动语句</li><li>完美转发</li></ul></li><li>更详细的内容见<a href="/2023/09/03/cpp/lvalue-xvalue-prvalue/">此处</a></li></ul><h1 id="C-hash"><a href="#C-hash" class="headerlink" title="C++ hash"></a>C++ hash</h1><ul><li>C++ 的内置 <code>hash</code> 函数的实现<ul><li>对于基础变量，<code>hash</code> 函数返回值为此变量的值，不做修改</li><li>对于 <code>string</code>，<code>hash</code> 函数对每四个字节(64位操作系统下)进行位运算最终得到结果，实际的内部过程使用了两个特殊的固定值，下面是 C++ 的字符串 <code>hash</code> 函数的实际内部实现（C++11）<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> std::<span class="hljs-type">size_t</span> <span class="hljs-title">unaligned_load</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *p)</span> </span>&#123;<br>    std::<span class="hljs-type">size_t</span> result;<br>    __builtin_memcpy(&amp;result, p, <span class="hljs-built_in">sizeof</span>(result));<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-type">size_t</span> _Hash_bytes(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *ptr, <span class="hljs-type">size_t</span> len, <span class="hljs-type">size_t</span> seed = <span class="hljs-number">0xc70f6907</span>UL) &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> m = <span class="hljs-number">0x5bd1e995</span>;<br>    <span class="hljs-type">size_t</span> hash = seed ^len;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *buf = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span> *&gt;(ptr);<br><br>    <span class="hljs-comment">// Mix 4 bytes at a time into the hash.</span><br>    <span class="hljs-keyword">while</span> (len &gt;= <span class="hljs-number">4</span>) &#123;<br>        <span class="hljs-type">size_t</span> k = <span class="hljs-built_in">unaligned_load</span>(buf);<br>        k *= m;<br>        k ^= k &gt;&gt; <span class="hljs-number">24</span>;<br>        k *= m;<br>        hash *= m;<br>        hash ^= k;<br>        buf += <span class="hljs-number">4</span>;<br>        len -= <span class="hljs-number">4</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Handle the last few bytes of the input array.</span><br>    <span class="hljs-keyword">switch</span> (len) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>            hash ^= <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;(buf[<span class="hljs-number">2</span>]) &lt;&lt; <span class="hljs-number">16</span>;<br>            [[gnu::fallthrough]];<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            hash ^= <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;(buf[<span class="hljs-number">1</span>]) &lt;&lt; <span class="hljs-number">8</span>;<br>            [[gnu::fallthrough]];<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            hash ^= <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>&gt;(buf[<span class="hljs-number">0</span>]);<br>            hash *= m;<br>    &#125;;<br><br>    <span class="hljs-comment">// Do a few final mixes of the hash.</span><br>    hash ^= hash &gt;&gt; <span class="hljs-number">13</span>;<br>    hash *= m;<br>    hash ^= hash &gt;&gt; <span class="hljs-number">15</span>;<br>    <span class="hljs-keyword">return</span> hash;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试准备</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round#699 (Div. 2)</title>
    <link href="/2021/02/06/acm/codeforces/CodeforcesRound699/"/>
    <url>/2021/02/06/acm/codeforces/CodeforcesRound699/</url>
    
    <content type="html"><![CDATA[<p><em>暂时还没有 AK，留坑</em></p><h1 id="A-Space-Navigation"><a href="#A-Space-Navigation" class="headerlink" title="A. Space Navigation"></a>A. Space Navigation</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给你一段在棋盘上的移动指令，问能否通过在不改变原指令顺序，仅删除部分或者全部或者不删除的情况下，到达某个指定地点</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>可以通过指令直接得出可以到达的范围，比如删除所有的“向左”指令后，能够到达的最右，同理可以得到四个方向的极值，最后判断目标地点是否在极值范围内即可</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> x, y;<br>        string str;<br>        cin &gt;&gt; x &gt;&gt; y &gt;&gt; str;<br>        <span class="hljs-type">int</span> cnt[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item : str) &#123;<br>            <span class="hljs-keyword">switch</span> (item) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;R&#x27;</span>:<br>                    cnt[<span class="hljs-number">0</span>]++;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;L&#x27;</span>:<br>                    cnt[<span class="hljs-number">1</span>]++;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;U&#x27;</span>:<br>                    cnt[<span class="hljs-number">2</span>]++;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;D&#x27;</span>:<br>                    cnt[<span class="hljs-number">3</span>]++;<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (-cnt[<span class="hljs-number">1</span>] &lt;= x &amp;&amp; x &lt;= cnt[<span class="hljs-number">0</span>] &amp;&amp; -cnt[<span class="hljs-number">3</span>] &lt;= y &amp;&amp; y &lt;= cnt[<span class="hljs-number">2</span>]) cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-New-Colony"><a href="#B-New-Colony" class="headerlink" title="B. New Colony"></a>B. New Colony</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>给你一段台阶，然后你从第一阶开始往下面滚砖块，砖块遇到下坡就走到下一阶，遇到上坡就停止，并增加这一阶的高度。给你 $n$ 个砖块，请问最后一块砖块停止在哪里</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>首先这道题如果不能使用暴力的话，是很麻烦的一道题。但是注意观察这道题的数据范围</p>$$1 \leq n \leq 100, 1 \leq k \leq 10^9, 1 \leq h_i \leq 100, \sum n \leq 100$$<p>假如阶梯是一直下坡或者平坡，那么砖块就会直接掉出阶梯。而如果砖块没有掉出阶梯，那么它一定会不会处于整个阶梯的最高处。所以考虑一个可能，即不断的滚落的方块将整个阶梯都填满成平地，则最多需要 $n \times h_i = 10000$ 个砖块</p><p>也就是说，当 $k &gt; 10000$ 时，则最后一块砖块必然掉出阶梯。那么当 $k \leq 10000$ 时，暴力求解即可</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cin &gt;&gt; data[i];<br>        <span class="hljs-keyword">if</span> (k &gt; <span class="hljs-number">10000</span>) cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> last = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>                <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> (cur &lt; n - <span class="hljs-number">1</span> &amp;&amp; data[cur + <span class="hljs-number">1</span>] &lt;= data[cur]) cur++;<br>                <span class="hljs-keyword">if</span> (cur == n - <span class="hljs-number">1</span>) last = <span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    data[cur]++;<br>                    last = cur + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>            cout &lt;&lt; last &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Fence-Painting"><a href="#C-Fence-Painting" class="headerlink" title="C. Fence Painting"></a>C. Fence Painting</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>一个篱笆有 $n$ 个木条组成，每个木条有一个初始的颜色。每一个木条都有一个指定的目标颜色。有 $m$ 个油漆工，每个油漆工都只携带一种颜料，按照顺序来给这个篱笆上色，他们每次必须选择一块且恰好一块木板，把它的颜色变成油漆工所携带的颜色。问每个油漆工应该选择哪一块，使得最后的木条都变成指定的颜色</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>首先，肯定找出目前没有达到目标的木条，然后找到合适的油漆工给它上色。如果找不到合适的油漆工，那么肯定没戏</p><p>接下来是剩下的多出来的没有使用的油漆工，也需要为他们找一块木板去上色。</p><p>注意到，由于后来的可以覆盖前面的颜色，所以可以直接考虑最后那个油漆匠。</p><p>如果根据上面的操作，这个油漆匠已经有了一块木板去上色的话，那么剩下多出来的油漆工可以都给这块木板上色，这样的话，无论最后上色是什么，最后一个油漆匠一定能把这块木板染回指定的颜色。</p><p>而如果最后一个油漆工也在那些没有使用的油漆工内，那么他只需要找到一块最终颜色和自己所携带的颜色相同的，然后指定他去给这块木板上色。剩下的那些没有使用的油漆工也去给这块木板上色即可。</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, m;<br>        cin &gt;&gt; n &gt;&gt; m;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span>, <span class="hljs-title">b</span><span class="hljs-params">(n)</span>, <span class="hljs-title">c</span><span class="hljs-params">(m)</span>, <span class="hljs-title">res</span><span class="hljs-params">(m, <span class="hljs-number">0</span>)</span></span>;<br>        map&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;&gt; data;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cin &gt;&gt; a[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            cin &gt;&gt; b[i];<br>            <span class="hljs-keyword">if</span> (a[i] != b[i]) data[b[i]].<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) cin &gt;&gt; c[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-keyword">auto</span> iter = data.<span class="hljs-built_in">find</span>(c[i]);<br>            <span class="hljs-keyword">if</span> (iter == data.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">continue</span>;<br>            res[i] = iter-&gt;second.<span class="hljs-built_in">back</span>();<br>            iter-&gt;second.<span class="hljs-built_in">pop_back</span>();<br>            <span class="hljs-keyword">if</span> (iter-&gt;second.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) data.<span class="hljs-built_in">erase</span>(iter);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (res.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">if</span> (c.<span class="hljs-built_in">back</span>() == b[i]) res.<span class="hljs-built_in">back</span>() = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item : res) <span class="hljs-keyword">if</span> (item == <span class="hljs-number">0</span>) item = res.<span class="hljs-built_in">back</span>();<br>        <span class="hljs-keyword">if</span> (res.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span> || !data.<span class="hljs-built_in">empty</span>()) cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; res.<span class="hljs-built_in">size</span>(); ++i) cout &lt;&lt; res[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == res.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-AB-Graph"><a href="#D-AB-Graph" class="headerlink" title="D. AB Graph"></a>D. AB Graph</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>给你一个完全有向图，每条边都有一个字母标记，标记的字母只有可能是 “a” 或者 “b”。你需要找出一条可以包含重复点重复边的路径，满足这条路径的长度等于给定的要求，并且这条路径组成的字符串为回文串</p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>首先，由于可以有重复点和重复边，那么考虑下面的情况</p><h3 id="如果这个图只有两个点。"><a href="#如果这个图只有两个点。" class="headerlink" title="如果这个图只有两个点。"></a>如果这个图只有两个点。</h3><p>此时只有两条边。如果这两条边恰好字母还相同(例如下面的 mermaid 图)，那么任意长度的路径都可以画出来，只需要在这两个点之间来回走即可</p><pre><code class=" mermaid">graph LRA -- a --&gt; BB -- a --&gt; A</code></pre><p>如果这两条边的字母还不相同(例如下面的 mermaid 图)，那么来回的路径为奇数的时候，可以画出来，只需要在这两个点之间来回走即可</p><pre><code class=" mermaid">graph LRA -- a --&gt; BB -- b --&gt; A</code></pre><h3 id="如果这个图至少有三个点"><a href="#如果这个图至少有三个点" class="headerlink" title="如果这个图至少有三个点"></a>如果这个图至少有三个点</h3><p>取出整个图中任意三个点，假定这三个点为 $a, b, c$，这里定义 $g(a, b)$ 为从点 $a$ 到点 $b$ 的路径的标记字母。那么我们可以知道，一定满足 $g(a, b) = g(b, c)$ 或 $g(b, c) = g(c, a)$ 或 $g(c, a) = g(a, b)$ 其中至少一个</p><blockquote><p>证明<br>反证法，假设上述不成立，则<br>由上述得 $g(a, b) \not = g(b, c)$，那么 $g(a, b)$ 与 $g(b, c)$ 相异。<br>由上述得 $g(b, c) \not = g(c, a)$，那么 $g(b, c)$ 与 $g(c, a)$ 相异。由于 $g(a, b)$ 与 $g(b, c)$ 相异，而所有边只有两种可能，所以 $g(c, a)$ 与 $g(b, c)$ 必定相同<br>由上述得 $g(c, a) \not = g(a, b)$，那么 $g(c, a)$ 与 $g(a, b)$ 相异，这与上面的结论相反，所以假设不成立，即，上述结论成立</p></blockquote><p>这时，通过交换 $a, b, c$ 三个点，使得 $g(a, b) = g(b, c)$ 得到满足，则可以得到下图</p><pre><code class=" mermaid">graph LRa -- x --&gt; bb -- x --&gt; cc -- y --&gt; a</code></pre><p>这里，我们不需要关心 $y$ 的情况，无论它是否与 $x$ 相同</p><p>这里，只需要进行 $a \rightarrow b \rightarrow c \rightarrow a$ 这样的循环，即可实现一个回文串。只需要确定是从哪一个节点开始循环即可</p><ul><li>若从 $a$ 开始循环，则得到的串为 $xxyxxyxxyxx \dots$ 当长度为 $3t + 2$　时为回文串</li><li>若从 $b$ 开始循环，则得到的串为 $xyxxyxxyxxyx \dots$ 当长度为 $3t$ 时为回文串</li><li>若从 $c$ 开始循环，则得到的串为 $yxxyxxyxxyxxy \dots$ 当长度为 $3t + 1$ 时为回文串</li></ul><p>所以只需要判断所需要的字符串长度与 $3$ 取模即可</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, m;<br>        cin &gt;&gt; n &gt;&gt; m;<br>        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">g</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item : g) item.<span class="hljs-built_in">reserve</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cin &gt;&gt; g[i];<br><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">if</span> (g[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] == g[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] || m % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m + <span class="hljs-number">1</span>; ++i) cout &lt;&lt; (i % <span class="hljs-number">2</span>) + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == m];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">tmp</span>(<span class="hljs-number">3</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) tmp[i] = i;<br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">if</span> (g[tmp[<span class="hljs-number">0</span>]][tmp[<span class="hljs-number">1</span>]] == g[tmp[<span class="hljs-number">1</span>]][tmp[<span class="hljs-number">2</span>]]) <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">while</span> (<span class="hljs-built_in">next_permutation</span>(tmp.<span class="hljs-built_in">begin</span>(), tmp.<span class="hljs-built_in">end</span>()));<br><br>            <span class="hljs-built_in">assert</span>(g[tmp[<span class="hljs-number">0</span>]][tmp[<span class="hljs-number">1</span>]] == g[tmp[<span class="hljs-number">1</span>]][tmp[<span class="hljs-number">2</span>]]);<br>            <span class="hljs-type">int</span> cur = (m + <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>;<br><br>            cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m + <span class="hljs-number">1</span>; ++i) cout &lt;&lt; tmp[(i + cur) % <span class="hljs-number">3</span>] + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == m];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="E-Sorting-Books"><a href="#E-Sorting-Books" class="headerlink" title="E. Sorting Books"></a>E. Sorting Books</h1><h2 id="大致题意-4"><a href="#大致题意-4" class="headerlink" title="大致题意"></a>大致题意</h2><p>给你一段数列，进行如下的操作使得整个序列中相同的数字处于连续的子段中</p><p>操作：将这个数字放到整个字符串的最后</p><p>问，最少需要进行多少次操作</p><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>首先，如果进行 $n$ 次操作，那么必然可以使得整个序列满足上述的要求。因为只需要按照排序后的顺序来移动所有的数字，则必定可以满足条件</p><p>那么接下来就是想办法减少次数。</p><p>如果我选出一个值，当数字与这个值相同的时候，不对其进行操作。由于其他值被移动到了最后。所以与这个值相同的值都自然而然的被移动到了最前面，例如下面这个序列</p>$$1, 3, 2, 2, 1, 3$$<p>如果我选择 $3$ 作为固定值，那么当 $1, 2$ 都进行过移动后，$3$ 自然而然的也就满足了条件</p><p>再进一步，如果稍微修改一下这个序列，将其改为</p>$$1, 3, 1, 2, 3, 2$$<p>这时，发现当我仅对 $3$ 进行移动之后，$1, 2$ 自然而然的也满足条件了。由此，可以得到一个这样的推广结论：</p><p>在某一个子区间内，如果这个子区间内存在某一个数值 $x$，满足整个区间的所有 $x$ 都在这个子区间内，那么，这个 $x$ 可以固定不动，且这个子区间内的其他所有值都需要进行操作。</p><p>所以此时可以进行 dp 求解，方法如下：</p><ul><li>找出所有值所对应的最小子区间</li><li>假如这个子区间内选择这个值作为固定值，那么它所带来的代价就是这个子区间的长度减去这个值的个数</li><li>由于需要进行减法比较麻烦，可以改变思路用加法，即求出有多少个值是可以固定不操作的</li><li>则对于每一个区间的固定值，那么其带来的固定值数量就是这个区间内的值的个数</li><li>对每一位进行 dp 求解即可</li></ul><h2 id="AC-code-4"><a href="#AC-code-4" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(n)</span>, <span class="hljs-title">l</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, n)</span>, <span class="hljs-title">r</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">dp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">cnt</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cin &gt;&gt; data[i];<br>        l[data[i]] = <span class="hljs-built_in">min</span>(l[data[i]], i);<br>        r[data[i]] = <span class="hljs-built_in">max</span>(r[data[i]], i);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        cnt[data[i]]++;<br>        dp[i] = <span class="hljs-built_in">max</span>(dp[i + <span class="hljs-number">1</span>], cnt[data[i]]);<br>        <span class="hljs-keyword">if</span> (l[data[i]] == i) dp[i] = <span class="hljs-built_in">max</span>(dp[i], cnt[data[i]] + dp[r[data[i]] + <span class="hljs-number">1</span>]);<br>    &#125;<br>    cout &lt;&lt; n - dp[<span class="hljs-number">0</span>] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>清理 WSL2 的磁盘占用</title>
    <link href="/2021/01/27/develop-note/wsl-clean/"/>
    <url>/2021/01/27/develop-note/wsl-clean/</url>
    
    <content type="html"><![CDATA[<p>方法来源：<a href="https://github.com/microsoft/WSL/issues/4699#issuecomment-627133168">https://github.com/microsoft/WSL/issues/4699#issuecomment-627133168</a></p><p>由于 vhdx 格式的磁盘镜像文件只支持自动扩容但不支持自动缩容，所以需要手动来实现缩容，即利用 Windows 自带的 diskpart 来实现</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>短笔记</tag>
      
      <tag>WSL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round#697 (Div. 3)</title>
    <link href="/2021/01/25/acm/codeforces/CodeforcesRound697/"/>
    <url>/2021/01/25/acm/codeforces/CodeforcesRound697/</url>
    
    <content type="html"><![CDATA[<p><em>自南京区域赛结束之后就一直在准备期末考试，直到最近结束考试之后开始了复建的生活，这场 Div3 除了 D 题因为爆了 int 然后卡了，G题真的没在比赛期间想出来，其他题目都是非常顺利的解决掉了，且只用了一个小时</em></p><h1 id="A-Odd-Divisor"><a href="#A-Odd-Divisor" class="headerlink" title="A. Odd Divisor"></a>A. Odd Divisor</h1><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个整数，请问它是否存在一个不为 1 的奇因子</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>因为除 1 以外的所有奇因子都可以分解出至少一个奇质因子，那么只需要找到那些不包含奇质因子的数进行排查就行。而不包含奇质因子的数字很明显就是所有的 2 的幂次，所以打表就可以了。注意别忘记范围超过了 int</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    set&lt;<span class="hljs-type">int</span>&gt; err;<br>    <span class="hljs-type">int</span> cur = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">62</span>; ++i) &#123;<br>        err.<span class="hljs-built_in">insert</span>(cur);<br>        cur &lt;&lt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> tmp;<br>        cin &gt;&gt; tmp;<br>        cout &lt;&lt; (err.<span class="hljs-built_in">count</span>(tmp) ? <span class="hljs-string">&quot;NO&quot;</span> : <span class="hljs-string">&quot;YES&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B-New-Year’s-Number"><a href="#B-New-Year’s-Number" class="headerlink" title="B. New Year’s Number"></a>B. New Year’s Number</h1><h2 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h2><p>给你一个数，请问它是不是 n 个 2020 和 m 个 2021 相加得到的</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>把 2021 看成 2020 + 1，那么就变成了 (n + m) 个 2020 和 m 个 1 相加得到，由于 n 肯定是自然数，则只要满足这个数除以 2020 的商(也就是 n + m 部分)大于等于余数(也就是 m)即可</p><h2 id="AC-code-1"><a href="#AC-code-1" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> tmp;<br>        cin &gt;&gt; tmp;<br>        cout &lt;&lt; (tmp / <span class="hljs-number">2020</span> &gt;= tmp % <span class="hljs-number">2020</span> ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C-Ball-in-Berland"><a href="#C-Ball-in-Berland" class="headerlink" title="C. Ball in Berland"></a>C. Ball in Berland</h1><h2 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h2><p>有两组人，分别为 a 和 b ，有 k 对组合，每对组合都是从 a 中选出一个，从 b 中选出一个。你现在需要选出两对组合，使得这两对组合不会发生冲突，即不会出现 a 中的人同时参与了这两个组合或者 b 中的人同时参与了这两个组合或者两者都同时参与</p><h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>可以用类似容斥的办法解决。因为保证了每一对组合都不同，所以当我选出一对的时候，那么还有 <code>k - cnt[a] - cnt[b] + 1</code> 对我可以选，其中的 <code>cnt</code> 为这个人参与的组合数量。只需要遍历所有的组合，然后对于每对组合进行求解即可</p><h2 id="AC-code-2"><a href="#AC-code-2" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> a, b, k;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; k;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ca</span><span class="hljs-params">(a + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">cb</span><span class="hljs-params">(b + <span class="hljs-number">1</span>)</span></span>;<br>        vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">p</span>(k);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            <span class="hljs-type">int</span> u;<br>            cin &gt;&gt; u;<br>            p[i].first = u;<br>            ca[u]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            <span class="hljs-type">int</span> u;<br>            cin &gt;&gt; u;<br>            p[i].second = u;<br>            cb[u]++;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) ans += k - ca[p[i].first] - cb[p[i].second] + <span class="hljs-number">1</span>;<br>        cout &lt;&lt; ans / <span class="hljs-number">2</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D-Cleaning-the-Phone"><a href="#D-Cleaning-the-Phone" class="headerlink" title="D. Cleaning the Phone"></a>D. Cleaning the Phone</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一组物品，他们有各自的代价和价值，其中代价只有 1 或者 2 两种，请问如何选择物品，使得代价尽可能小的情况下满足所需要的价值</p><h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><p>直接考虑枚举，比如枚举选择了 x 件代价为 1 的物品，求出这时候至少需要多少件代价为 2 的物品，然后枚举所有情况，输出最小的情况即可。</p><h2 id="AC-code-3"><a href="#AC-code-3" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, m;<br>        cin &gt;&gt; n &gt;&gt; m;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mem</span><span class="hljs-params">(n)</span></span>;<br>        vector&lt;<span class="hljs-type">int</span>&gt; data[<span class="hljs-number">2</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cin &gt;&gt; mem[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> op;<br>            cin &gt;&gt; op;<br>            data[op - <span class="hljs-number">1</span>].<span class="hljs-built_in">push_back</span>(mem[i]);<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(data[<span class="hljs-number">0</span>].<span class="hljs-built_in">begin</span>(), data[<span class="hljs-number">0</span>].<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br>        <span class="hljs-built_in">sort</span>(data[<span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>(), data[<span class="hljs-number">1</span>].<span class="hljs-built_in">end</span>(), <span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br>        <span class="hljs-type">int</span> ans = INT_MAX;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; data[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); ++i) data[<span class="hljs-number">0</span>][i] += data[<span class="hljs-number">0</span>][i - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; data[<span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>(); ++i) data[<span class="hljs-number">1</span>][i] += data[<span class="hljs-number">1</span>][i - <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">auto</span> iter = <span class="hljs-built_in">lower_bound</span>(data[<span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>(), data[<span class="hljs-number">1</span>].<span class="hljs-built_in">end</span>(), m);<br>        <span class="hljs-keyword">if</span> (iter != data[<span class="hljs-number">1</span>].<span class="hljs-built_in">end</span>()) ans = <span class="hljs-built_in">min</span>(ans, (<span class="hljs-type">int</span>) (iter - data[<span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>) * <span class="hljs-number">2</span>);<br><br>        iter = <span class="hljs-built_in">lower_bound</span>(data[<span class="hljs-number">0</span>].<span class="hljs-built_in">begin</span>(), data[<span class="hljs-number">0</span>].<span class="hljs-built_in">end</span>(), m);<br>        <span class="hljs-keyword">if</span> (iter != data[<span class="hljs-number">0</span>].<span class="hljs-built_in">end</span>()) ans = <span class="hljs-built_in">min</span>(ans, (<span class="hljs-type">int</span>) ((iter - data[<span class="hljs-number">0</span>].<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>)));<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; data[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            iter = <span class="hljs-built_in">lower_bound</span>(data[<span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>(), data[<span class="hljs-number">1</span>].<span class="hljs-built_in">end</span>(), m - data[<span class="hljs-number">0</span>][i]);<br>            <span class="hljs-keyword">if</span> (iter != data[<span class="hljs-number">1</span>].<span class="hljs-built_in">end</span>()) ans = <span class="hljs-built_in">min</span>(ans, (<span class="hljs-type">int</span>) ((iter - data[<span class="hljs-number">1</span>].<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>) * <span class="hljs-number">2</span> + i + <span class="hljs-number">1</span>));<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; data[<span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>(); ++i) &#123;<br>            iter = <span class="hljs-built_in">lower_bound</span>(data[<span class="hljs-number">0</span>].<span class="hljs-built_in">begin</span>(), data[<span class="hljs-number">0</span>].<span class="hljs-built_in">end</span>(), m - data[<span class="hljs-number">1</span>][i]);<br>            <span class="hljs-keyword">if</span> (iter != data[<span class="hljs-number">0</span>].<span class="hljs-built_in">end</span>()) ans = <span class="hljs-built_in">min</span>(ans, (<span class="hljs-type">int</span>) ((iter - data[<span class="hljs-number">0</span>].<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>) + <span class="hljs-number">2</span> * (i + <span class="hljs-number">1</span>)));<br>        &#125;<br>        cout &lt;&lt; (ans == INT_MAX ? <span class="hljs-number">-1</span> : ans) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="E-Advertising-Agency"><a href="#E-Advertising-Agency" class="headerlink" title="E. Advertising Agency"></a>E. Advertising Agency</h1><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>给你一组数据，要求你从中取出 k 个数据，使得这 k 个数据的之和最大，问有几种取法</p><h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><p>首先取最大必然只能从大到小取，直到取满 k 个。但是在取最后几个相同的值的时候，由于有多个选择，则可以产生多个方案。而这个方案数量很明显即为组合数。</p><h2 id="AC-code-4"><a href="#AC-code-4" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1100</span>;<br><br><span class="hljs-function">ll <span class="hljs-title">qpow</span><span class="hljs-params">(ll a, ll b)</span> </span>&#123;<br>    ll res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (b) &#123;<br>        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res = res * a % mod;<br>        a = a * a % mod;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br>ll fac[N], ifac[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> siz)</span> </span>&#123;<br>    fac[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= siz; i++)<br>        fac[i] = i * fac[i - <span class="hljs-number">1</span>] % mod;<br>    ifac[siz] = <span class="hljs-built_in">qpow</span>(fac[siz], mod - <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = siz; i &gt;= <span class="hljs-number">1</span>; i--) ifac[i - <span class="hljs-number">1</span>] = ifac[i] * i % mod;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">C</span><span class="hljs-params">(ll n, ll m)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span> || n == m) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (m &gt; n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br>    <span class="hljs-keyword">return</span> fac[n] * ifac[m] % mod * ifac[n - m] % mod;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">init</span>(<span class="hljs-number">1050</span>);<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            mp[tmp]++;<br>        &#125;<br><br>        <span class="hljs-keyword">auto</span> iter = mp.<span class="hljs-built_in">rbegin</span>();<br>        <span class="hljs-keyword">while</span> (iter != mp.<span class="hljs-built_in">rend</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (k &gt; iter-&gt;second) &#123;<br>                k -= iter-&gt;second;<br>                iter++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cout &lt;&lt; <span class="hljs-built_in">C</span>(iter-&gt;second, k) &lt;&lt; endl;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="F-Unusual-Matrix"><a href="#F-Unusual-Matrix" class="headerlink" title="F. Unusual Matrix"></a>F. Unusual Matrix</h1><h2 id="大致题意-2"><a href="#大致题意-2" class="headerlink" title="大致题意"></a>大致题意</h2><p>给你两个 01 矩阵，问能否通过下面两个方式将第一个矩阵转为和第二个矩阵一样</p><ul><li>将一行的值翻转</li><li>将一列的值翻转</li></ul><h2 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h2><p>由于是翻转相同，那么首先直接对这两个矩阵做异或，可以得到一个矩阵，接下来只需要把这个矩阵给转为只有 0 或者只有 1 的矩阵即可</p><p>这时候其实可以模拟，假定这行第一个值为 1 则翻转，否者不翻转，然后最后判定是否为纯 0 矩阵</p><p>但是这样太麻烦了，其实可以直接判断相邻两行之间是否相同或者相异，即任意两行或者两列的异或结果全为 0 或者 全为 1 则可以，否则不可以</p><h2 id="AC-code-5"><a href="#AC-code-5" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">data1</span><span class="hljs-params">(n)</span>, <span class="hljs-title">data2</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cin &gt;&gt; data1[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) cin &gt;&gt; data2[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) data1[i][j] = (data1[i][j] - <span class="hljs-string">&#x27;0&#x27;</span>) ^ (data2[i][j] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">char</span> tmp = data1[i][<span class="hljs-number">0</span>] ^ data1[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> ((data1[i][j] ^ data1[i - <span class="hljs-number">1</span>][j]) != tmp) &#123;<br>                    flag = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!flag) <span class="hljs-keyword">break</span>;<br>        &#125;<br>        cout &lt;&lt; (flag ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="G-Strange-Beauty"><a href="#G-Strange-Beauty" class="headerlink" title="G. Strange Beauty"></a>G. Strange Beauty</h1><h2 id="大致题意-3"><a href="#大致题意-3" class="headerlink" title="大致题意"></a>大致题意</h2><p>给你一组数列，请问至少需要删除几个数字，使得整个数列的任意两个值满足大数取模小数为 0</p><h2 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h2><p>利用素数筛的方式来 dp 求算最多能有多少个值能满足此条件，相减就能得到答案</p><h2 id="AC-code-6"><a href="#AC-code-6" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> _;<br>    cin &gt;&gt; _;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; _; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">2e5</span> + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-number">2e5</span> + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            cin &gt;&gt; tmp;<br>            cnt[tmp]++;<br>        &#125;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2e5</span>; ++i) &#123;<br>            dp[i] += cnt[i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + i; j &lt;= <span class="hljs-number">2e5</span>; j += i) dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[i]);<br>            ans = <span class="hljs-built_in">max</span>(ans, dp[i]);<br>        &#125;<br>        cout &lt;&lt; n - ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows 下的 NTFS 驱动器索引 BUG</title>
    <link href="/2021/01/18/develop-note/windows-ntfs/"/>
    <url>/2021/01/18/develop-note/windows-ntfs/</url>
    
    <content type="html"><![CDATA[<h1 id="NTFS-BUG"><a href="#NTFS-BUG" class="headerlink" title="NTFS BUG"></a>NTFS BUG</h1><div class="note note-danger">            <font color=red size=5>警告，请千万不要在 Windows 下的命令行中运行此命令，或者以其他等价的方式访问</font>          </div><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> c:\:<span class="hljs-variable">$i30</span>:<span class="hljs-variable">$bitmap</span><br></code></pre></td></tr></table></figure><div class="note note-danger">            <font color=red size=5>警告，请千万不要在 Windows 下的命令行中运行此命令，或者以其他等价的方式访问</font>          </div><p>当你试图进入、访问此目录时，就有机会导致 NTFS 驱动器索引损坏，此问题的触发方式包括但不限于</p><ul><li>在极低权限的命令行中执行此命令</li><li>在 powershell 中执行此命令</li><li>在浏览器中试图访问此 <code>c:\:$i30:$bitmap</code> 地址</li><li>其他试图访问此地址的程序</li></ul><p>触发后，系统将会提示磁盘错误，需要修复，并提示重启电脑。重启后，电脑将会进入磁盘修复，Windows 将会试图修复此问题</p><p>部分电脑可以修复此问题，并且正常进入系统，而部分电脑将会无法修复此 BUG，且无法进入系统。</p><h1 id="我的经历"><a href="#我的经历" class="headerlink" title="我的经历"></a>我的经历</h1><p>当我第一次得到此命令的时候，我尝试在 Google 中搜索此地址含义，我直接将其输入到 chrome 的地址栏里，然后我直接按下了回车键！！！</p><p>然后悲剧诞生了，我的电脑提示我，磁盘出错需要修复</p><h2 id="尝试修复-1"><a href="#尝试修复-1" class="headerlink" title="尝试修复-1"></a>尝试修复-1</h2><p>使用 Windows 的磁盘修复工具。</p><ul><li>驱动卷-属性-工具-检查驱动器中的文件系统错误</li><li>提示我需要重启电脑，重启</li><li>进入系统前尝试修复错误</li><li>没有找到错误，但是无法进入系统</li></ul><h2 id="尝试修复-2"><a href="#尝试修复-2" class="headerlink" title="尝试修复-2"></a>尝试修复-2</h2><p>直接删除 C 盘，然后通过 DG 等软件重建分区表</p><ul><li>进入 DG，备份分区表</li><li>直接删除 C 盘</li><li>使用 DG 直接找回分区表</li><li>找回了分区表，但是重启之后仍然无法进入系统</li></ul><h2 id="尝试修复-3"><a href="#尝试修复-3" class="headerlink" title="尝试修复-3"></a>尝试修复-3</h2><p>仔细想想，为什么我不能进入 Windows，但是 PE 可以进入 C 盘呢？同样是同一块硬盘，如果真的是 NTFS 的问题，那为什么我的 PE 仍然能够正确的读取出我的硬盘内的文件内容？使用了好几个不同的软件试图扫描 NTFS 的结果均为正常、无错误</p><p>开始怀疑这是不是 Windows 因为遇到了这个问题而产生的 BUG 而并非 NTFS 的问题</p><ul><li>使用 Dism++，进行恢复系统受损</li><li>修复完成重启系统</li><li>手动跳过磁盘检查</li><li><font color=red>成功</font>进入系统</li></ul>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>短笔记</tag>
      
      <tag>Windows</tag>
      
      <tag>NTFS</tag>
      
      <tag>BUG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译原理</title>
    <link href="/2021/01/07/notebook/Compilation-principle/"/>
    <url>/2021/01/07/notebook/Compilation-principle/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><ul><li>编译：将高级语言翻译成汇编语言或机器语言的过程</li></ul><h2 id="编译过程的五个阶段"><a href="#编译过程的五个阶段" class="headerlink" title="编译过程的五个阶段"></a>编译过程的五个阶段</h2><ol><li>词法分析</li><li>语法分析</li><li>词义分析与中间代码生成</li><li>优化</li><li>目标代码生成</li></ol><h2 id="编译过程的八个部分"><a href="#编译过程的八个部分" class="headerlink" title="编译过程的八个部分"></a>编译过程的八个部分</h2><ol><li>词法分析程序</li><li>语法分析程序</li><li>语义分析程序</li><li>中间代码生成</li><li>代码优化程序</li><li>目标代码生成程序</li><li>错误检查和处理程序</li><li>信息表管理程序</li></ol><h1 id="文法和语言"><a href="#文法和语言" class="headerlink" title="文法和语言"></a>文法和语言</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="字母表"><a href="#字母表" class="headerlink" title="字母表"></a>字母表</h3><p>字母表 $\sum$ 是一个<font color=red>有穷的符号集合</font>，符号包括了字母、数字、标点符号……</p><h3 id="字母表上的运算"><a href="#字母表上的运算" class="headerlink" title="字母表上的运算"></a>字母表上的运算</h3><ul><li>乘积：$\sum_1 \sum_2 = {ab | a \in \sum_1 , b \in \sum_2 }$。即从 $\sum_1$ 中选择一个字符串，和 $\sum_2$ 中的一个字符串连接</li><li>幂：即多次进行自我乘积的过程。字母表的 $n$ 次幂指长度为 $n$ 的符号串构成的集合</li><li>正闭包：长度正数的符号串构成的集合（任意一个合理的符号串均属于字母表的正闭包）记作：$\sum^+$</li><li>克林闭包：允许长度为 $0$ 的正闭包，记作：$\sum^*$</li></ul><h3 id="串"><a href="#串" class="headerlink" title="串"></a>串</h3><ul><li>串是字母表的克林闭包的一个元素，是字母表中符号的一个有穷序列</li><li>串的长度通常记作 $|s|$，指的是串 $s$ 中的符号个数</li><li>空串是长度为 $0$ 的串，用 $\varepsilon$ 表示，$|\varepsilon | = 0$</li></ul><h3 id="串上的运算"><a href="#串上的运算" class="headerlink" title="串上的运算"></a>串上的运算</h3><ul><li>连接</li><li>幂</li></ul><h2 id="文法的定义"><a href="#文法的定义" class="headerlink" title="文法的定义"></a>文法的定义</h2><p>对于文法 $G$，可以定义为 $G = (V_T, V_N, P, S)$</p><ul><li>$V_T$：终结符集合，表示的是一系列不可以被符号替换的符号，例如“宾语”不是一个终结符，而“水果”则是一个终结符。非空有穷集</li><li>$V_N$：非终结符集合，表示的是一系列一定可以被符号替换的符号，在等式中至少会出现一次在等号左侧的符号。非空有穷集</li><li>$P$：产生式/规则，表示的是替换过程，可以表示为 $\alpha \rightarrow \beta$，其中 $\alpha \in (V_N \cup V_T)^*$且至少包含一个非终结符。$\beta \in (V_N \cup V_T)^*$。非空有穷集</li><li>$S$：开始符号，表示的是该文法中最大的语法成分，例如 $S = 句子$</li></ul><h3 id="产生式的简写"><a href="#产生式的简写" class="headerlink" title="产生式的简写"></a>产生式的简写</h3><p>对于含有相同左部的产生式，可以通过“或”运算简写<br>例如对于</p><script type="math/tex; mode=display">\alpha \rightarrow \beta_1 , \alpha \rightarrow \beta_2 , \dots , \alpha \rightarrow \beta_n</script><p>可以简写为</p><script type="math/tex; mode=display">\alpha \rightarrow \beta_1 | \beta_2 | \dots | \beta_n</script><h3 id="符号约定"><a href="#符号约定" class="headerlink" title="符号约定"></a>符号约定</h3><ul><li>下列符号是终结符<ul><li>字母表中排在前面的小写字母，如 a、b、c</li><li>运算符，如+、*等</li><li>标点符号，如括号、逗号</li><li>数字，0、1、……、9</li><li>粗体字符串，如<strong>id</strong>、<strong>if</strong></li></ul></li><li>下列符号是非终结符<ul><li>字母表中排在前面的大写字母，如 A、B、C</li><li>字母 S，通常表示开始符号</li><li>小写、斜体的名字，如<em>expr</em>、<em>stmt</em></li><li>代表程序构造的大写字母，如 $E$(表达式)、$T$(项)、$F$(因子)</li></ul></li><li>字母表中排在后面的大写字母表示文法符号(终结符或非终结符)，如 $X、Y、Z$</li><li>字母表中排在后面的小写字母表示终结符号串，如 $u、v、\dots 、z$</li><li>小写希腊字母表示文法符号串 $\alpha 、\beta 、 \gamma$</li><li>除非特别说明，第一个产生式的左部就是开始符号</li></ul><h2 id="语言的定义"><a href="#语言的定义" class="headerlink" title="语言的定义"></a>语言的定义</h2><h3 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h3><p>从语言的规则<font color=red>推导</font>生成语言的过程</p><p>根据规则，可以将符号串推成另一个符号串的过程称为推导。用产生式的右部替换产生式的左部</p><p>如果是经过多次推导得到，则记为 $a_0 \Rightarrow^n a_n$</p><p>$a_0 \Rightarrow^+ a_n$ 表示经过至少一步推导得到<br>$a_0 \Rightarrow^* a_n$ 表示经过任意步数推导得到</p><h3 id="规约"><a href="#规约" class="headerlink" title="规约"></a>规约</h3><p>根据语言的规则<font color=red>识别</font>语言的过程</p><p>根据规则，可以将符号串还原成。将产生式的右部替换为产生式的左部</p><h3 id="句型和句子"><a href="#句型和句子" class="headerlink" title="句型和句子"></a>句型和句子</h3><ul><li>如果 $S \Rightarrow^* \alpha, \alpha \in (V_T \cup V_N)^*$ 则称 $\alpha$ 是语法 $G$ 的一个句型</li><li>一个句型中既可以包含终结符，也可以包含非终结符，也可以是空串</li><li>如果 $S \Rightarrow^* w, w \in V_T^*$ 则称 $w$ 是 $G$ 的一个句子</li><li>句子是不包含任何非终结符的句型</li><li>由文法推导出的所有句子构成的集合称为：文法 $G$ 生成的语言，记为 $L(G)$，即</li></ul><script type="math/tex; mode=display">L(G) = \{w | S \Rightarrow^* w, w \in V_T^* \}</script><h2 id="文法的分类"><a href="#文法的分类" class="headerlink" title="文法的分类"></a>文法的分类</h2><h3 id="0型文法"><a href="#0型文法" class="headerlink" title="0型文法"></a>0型文法</h3><p>对于 $\forall \alpha \rightarrow \beta \in P$，满足 $\alpha$ 中至少包含一个非终结符</p><h3 id="1型文法-上下文有关文法"><a href="#1型文法-上下文有关文法" class="headerlink" title="1型文法(上下文有关文法)"></a>1型文法(上下文有关文法)</h3><p>对于 $\forall \alpha \rightarrow \beta \in P$，满足 $|\alpha| \leq |\beta|$</p><p>也可以理解为对于 $\forall \alpha A \beta \rightarrow \alpha \gamma \beta \in P$，其中 $\alpha$、$\beta$ 可以为 $\varepsilon$，满足 $\gamma \neq \varepsilon$(在 $A = S$ 的情况下，此等式可以成立)</p><h3 id="2型文法-上下文无关文法"><a href="#2型文法-上下文无关文法" class="headerlink" title="2型文法(上下文无关文法)"></a>2型文法(上下文无关文法)</h3><p>对于 $\forall \alpha \rightarrow \beta \in P$，满足 $\alpha$ 是一个非终结符</p><h3 id="3型文法-正规文法"><a href="#3型文法-正规文法" class="headerlink" title="3型文法(正规文法)"></a>3型文法(正规文法)</h3><p>对于 $\forall \alpha \rightarrow \beta \in P$，满足 $\alpha$ 是一个非终结符，而 $\beta$ 只能是空串、一个终结符号或者一个终结符号和一个非终结符号</p><h2 id="CFG-分析树"><a href="#CFG-分析树" class="headerlink" title="CFG 分析树"></a>CFG 分析树</h2><p>分析树是推导的图形化表示</p><p><img src="/image/notebook/Compilation-principle/1.png" alt="CFG"></p><h3 id="二义性文法"><a href="#二义性文法" class="headerlink" title="二义性文法"></a>二义性文法</h3><p>如果一个文法可以为某个句子生成多棵分析树，则称这个文法是二义性的</p><h1 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h1><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式(简称：RE)是一种描述正则语言的表示方法，正则表达式可以由较小的正则表达式按照特定规则递归地构建。每个正则表达式 $r$ 定义(表示)一个语言，记为 $L(r)$。这个语言也是根据 $r$ 的子表达式所表示的语言递归定义的</p><h3 id="正则表达式的定义"><a href="#正则表达式的定义" class="headerlink" title="正则表达式的定义"></a>正则表达式的定义</h3><ul><li>$\varepsilon$ 是一个 RE，<script type="math/tex">L(\varepsilon) = \{ \varepsilon \}</script></li><li>如果 $a \in \sum(字母表)$，则 $a$ 是一个 RE，<script type="math/tex">L(a) = \{a\}</script></li><li><p>加入 $r$ 和 $s$ 都是 RE，表示的语言分别是 $L(r)$ 和 $L(s)$，则</p><ul><li>$r|s$ 是一个 RE，$L(r|s) = L(r) \cup L(s)$</li><li>$rs$ 是一个 RE，$L(rs) = L(r)L(s)$</li><li>$r^*$ 是一个 RE，$L(r^*) = (L(r))^*$</li><li>$(r)$ 是一个 RE，$L((r)) = L(r)$</li></ul></li><li><p>可以用RE定义的语言叫做正则语言(regular language)或正则集合(regular set)</p></li><li>对任何正则文法 $G$，存在定义同一语言的正则表达式 $r$</li><li>对任何正则表达式 $r$，存在生成同一语言的正则文法 $G$</li></ul><h3 id="正则定义"><a href="#正则定义" class="headerlink" title="正则定义"></a>正则定义</h3><p>给一些RE命名，并在之后的RE中像使用字母表中的符号一样使用这些名字</p><h2 id="有穷自动机"><a href="#有穷自动机" class="headerlink" title="有穷自动机"></a>有穷自动机</h2><p>具有一系列离散的输入输出信息和有穷数目的内部状态的系统</p><h3 id="有穷自动机的分类"><a href="#有穷自动机的分类" class="headerlink" title="有穷自动机的分类"></a>有穷自动机的分类</h3><ul><li>确定的有穷自动机</li><li>不确定的有穷自动机</li></ul><h3 id="确定的有穷自动机-DFA"><a href="#确定的有穷自动机-DFA" class="headerlink" title="确定的有穷自动机(DFA)"></a>确定的有穷自动机(DFA)</h3><p>对于任意的一个输入，自动机都唯一地确定了下一个状态</p><p>定义 $M=(S, \sum, \delta, s_0, F)$ 为一个确定的有穷自动机</p><ul><li>$S$：有穷状态集</li><li>$\sum$：输入的字母表，即输入的符号集合($\varepsilon \notin \sum $)</li><li>$\delta$：$\forall s \in S, a \in \sum, \delta(s, a)$ 表示从状态 $s$ 出发，沿着标记为 $a$ 的边所能到达的状态</li><li>$s_0$：开始状态，$s_0 \in S$</li><li>$F$：接收状态(终止状态)的集合，$F \subseteq S$</li></ul><p>确定的有穷自动机可以通过状态图来表示</p><p><img src="/image/notebook/Compilation-principle/2.png" alt="DFA状态图"></p><p>初始结点通常用 $\Rightarrow$ 表示，终态结点通常为双圈表示</p><p>确定的有穷自动机还可以使用表格来表示其状态，例如上述的状态图可以表示为</p><div class="table-container"><table><thead><tr><th style="text-align:center">状态</th><th style="text-align:center">0</th><th style="text-align:center">1</th></tr></thead><tbody><tr><td style="text-align:center">$S_0$</td><td style="text-align:center">$S_1$</td><td style="text-align:center">$S_0$</td><td>0</td></tr><tr><td style="text-align:center">$S_1$</td><td style="text-align:center">$S_1$</td><td style="text-align:center">$S_2$</td><td>0</td></tr><tr><td style="text-align:center">$S_2$</td><td style="text-align:center">$S_1$</td><td style="text-align:center">$S_0$</td><td>1</td></tr></tbody></table></div><p>通常，在表格对应行的右端通过01的标注表示这个状态为终态</p><p>对于 $\sum^*$ 中的任意符号串 $t$，如果在状态图中存在一条从初态到某一终态的路径，且这条路径上所有弧的标记符连接起来等于 $t$，则称 $t$ 可以被此 DFA 接受</p><h3 id="不确定的有穷自动机-NFA"><a href="#不确定的有穷自动机-NFA" class="headerlink" title="不确定的有穷自动机(NFA)"></a>不确定的有穷自动机(NFA)</h3><p>收到一个符号，可能进入不同的状态</p><p>定义 $M=(S, \sum, \delta, s_0, F)$ 为一个确定的有穷自动机</p><ul><li>$S$：是一个有穷集，它的每一个元素称为一个状态</li><li>$\sum$：是一个有穷字母表，它的每一个元素称为一个输入符号</li><li>$\delta$：表示一个转移函数，可以描述为<script type="math/tex">S \times (\sum \cup \{\varepsilon \}) \rightarrow P(S)</script>。$P(S)$ 是 $S$ 的一个子集</li><li>$s_0$：$S_0 \in S$，表示自动机的初始态</li><li>$F$：接收状态(终止状态)的集合，$F \subseteq S$</li></ul><p>NFA 也可以通过状态图来表示和表格进行表示，与 DFA 的状态图类似</p><h3 id="DFA-和-NFA-的等价性"><a href="#DFA-和-NFA-的等价性" class="headerlink" title="DFA 和 NFA 的等价性"></a>DFA 和 NFA 的等价性</h3><ul><li>对任何非确定的有穷自动机 N ，存在定义同一语言的确定的有穷自动机 D</li><li>对任何确定的有穷自动机 D ，存在定义同一语言的非确定的有穷自动机 N</li></ul><h3 id="从正则表达式转为-NFA"><a href="#从正则表达式转为-NFA" class="headerlink" title="从正则表达式转为 NFA"></a>从正则表达式转为 NFA</h3><p>参考下面两张图<br><img src="/image/notebook/Compilation-principle/3.png" alt="RE转NFA-1"></p><p><img src="/image/notebook/Compilation-principle/4.png" alt="RE转NFA-2"></p><h3 id="NFA-转-DFA"><a href="#NFA-转-DFA" class="headerlink" title="NFA 转 DFA"></a>NFA 转 DFA</h3><p>步骤：</p><ol><li>从起始状态开始，通过所有的路径，得到新的状态集的组合</li><li>将所有新的状态集组合重新通过路径，重复操作直到没有新的组合</li><li>将状态集作为 DFA 的结点，建成 DFA 状态机</li><li>如果新的状态包含原来的可接受状态(终止状态)，则认为新的状态也是可接受状态</li></ol><blockquote><p>以下图为例<br><img src="/image/notebook/Compilation-principle/NFA-example-1.png" alt="NFA示例"><br>画出如下的表格</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">状态</th><th style="text-align:center">a</th><th style="text-align:center">b</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0,1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">0,1</td><td style="text-align:center">0,1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr></tbody></table></div><blockquote><p>将序号代替状态，重新绘图<br><img src="/image/notebook/Compilation-principle/NFA2DFA-2.png" alt="NFA转DFA-1"></p></blockquote><h3 id="DFA-最小化"><a href="#DFA-最小化" class="headerlink" title="DFA 最小化"></a>DFA 最小化</h3><ul><li>删除从起始结点开始的不可到达的状态</li><li>合并所有的等价状态<ul><li>两个状态必须同时是可接受状态或不可接受状态</li><li>对于所有输入的符号，两个状态都必须转换到等价的状态里</li></ul></li></ul><blockquote><p>以上方的图为例，易得状态 1 和状态 2 是等价状态，所以合并得到</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">状态</th><th style="text-align:center">a</th><th style="text-align:center">b</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr></tbody></table></div><blockquote><p>最终得到<br><img src="/image/notebook/Compilation-principle/NFA2DFA-1.png" alt="DFA最小化-2"></p></blockquote><h1 id="自顶向下语法分析方法"><a href="#自顶向下语法分析方法" class="headerlink" title="自顶向下语法分析方法"></a>自顶向下语法分析方法</h1><h2 id="自顶向下的分析思想"><a href="#自顶向下的分析思想" class="headerlink" title="自顶向下的分析思想"></a>自顶向下的分析思想</h2><p>从分析树的顶部（根节点）向底部（叶节点）方向构造分析树，可以看成是从文法开始符号S推导出词串w的过程</p><h3 id="最左推导"><a href="#最左推导" class="headerlink" title="最左推导"></a>最左推导</h3><p>在最左推导中，总是选择每个句型的最左非终结符进行替换，即优先满足表达式左侧<br><img src="/image/notebook/Compilation-principle/leftmost-derivation.png" alt="最左推导"></p><h3 id="最右推导"><a href="#最右推导" class="headerlink" title="最右推导"></a>最右推导</h3><p>在最右推导中，总是选择每个句型的最右非终结符进行替换，即优先满足表达式右侧<br><img src="/image/notebook/Compilation-principle/rightmost-derivation.png" alt="最右推导"></p><p>自顶向下的语法分析采用最左推导方式</p><h3 id="预测分析"><a href="#预测分析" class="headerlink" title="预测分析"></a>预测分析</h3><ul><li>预测分析是递归下降分析技术的一个特例，通过在输入中向前看固定个数（通常是一个）符号来选择正确的A-产生式。</li><li>可以对某些文法构造出向前看k个输入符号的预测分析器，该类文法有时也称为LL(k) 文法类</li><li>预测分析不需要回溯，是一种确定的自顶向下分析方法</li></ul><h2 id="文法转换"><a href="#文法转换" class="headerlink" title="文法转换"></a>文法转换</h2><h3 id="消除左递归"><a href="#消除左递归" class="headerlink" title="消除左递归"></a>消除左递归</h3><h4 id="直接左递归"><a href="#直接左递归" class="headerlink" title="直接左递归"></a>直接左递归</h4><p>当出现了类似如下的推导公式时</p><script type="math/tex; mode=display">A \rightarrow A \alpha | \beta</script><p>时，此时可以出现左递归的情况，这会导致无法正确的进行最左推导，因为可以出现下面的情况：</p><script type="math/tex; mode=display">A \Rightarrow A \alpha \Rightarrow A \alpha\alpha \Rightarrow A \alpha\alpha\alpha \Rightarrow A \alpha\alpha\alpha\alpha \dots</script><p>此时可以将上述的推导公式转换为</p><script type="math/tex; mode=display">\begin{cases}A \rightarrow \beta A' \\A' \rightarrow \alpha A' | \varepsilon\end{cases}</script><p>将左递归的公式转换为右递归即可</p><p>这样的操作的代价是</p><ul><li>引入了非终结符</li><li>$\varepsilon$ 产生式</li></ul><h4 id="间接左递归"><a href="#间接左递归" class="headerlink" title="间接左递归"></a>间接左递归</h4><p>例如</p><script type="math/tex; mode=display">\begin{cases}S \rightarrow Aa | b \\A \rightarrow Sd | \varepsilon\end{cases}</script><p>此时可以产生这样的推导</p><script type="math/tex; mode=display">S \rightarrow Aa \rightarrow Sda \rightarrow Aada \rightarrow Sdada \dots</script><p>这时，应该将改为先进行替换得到</p><script type="math/tex; mode=display">A \rightarrow Aad | bd | \varepsilon</script><script type="math/tex; mode=display">\begin{cases}A \rightarrow bdA' | A' \\A' \rightarrow abA' | \varepsilon\end{cases}</script><h3 id="多个候选式"><a href="#多个候选式" class="headerlink" title="多个候选式"></a>多个候选式</h3><p>当出现</p><script type="math/tex; mode=display">S \rightarrow aAd | aBe</script><p>之类的结构，当读入的第一个字符为 $a$ 时，无法确定应该选择哪个产生式的时候，应该进行左公因子提取，即改编为</p><script type="math/tex; mode=display">\begin{cases}S \rightarrow aS' \\S' \rightarrow Ad|Be\end{cases}</script><h2 id="LL-1-文法"><a href="#LL-1-文法" class="headerlink" title="LL(1) 文法"></a>LL(1) 文法</h2><h3 id="FIRST-集"><a href="#FIRST-集" class="headerlink" title="FIRST 集"></a>FIRST 集</h3><p>$FIRST(A)$ 集表示非终结符 $A$ 能够推导出的所有等式的第一个终结符的集合</p><script type="math/tex; mode=display">FIRST(\alpha) = \{ a | \alpha \Rightarrow a \beta, a \in V_T ， \alpha, \beta \in V^* \}</script><p>这条等式可以用下面三个原则来求算</p><p>对于一个产生式 $A \rightarrow B$而言</p><ul><li>若 $B$ 的第一个符号是终结符，则将此终结符加入到 $FIRST(A)$ 中</li><li>若 $B$ 的第一个符号是非终结符，则将此非终结符的 $FIRST$ 中除了 $\varepsilon$ 的加入到 $FIRST(A)$ 中</li><li>若 $B$ 的第一个符号是非终结符，它的 $FIRST$ 集中含有 $\varepsilon$ 则将下一个符号也进行这三条规则的判断，如果没有，下一个字符了，则将 $\varepsilon$ 加入到 $FIRST(A)$ 中</li></ul><h3 id="FOLLOW-集"><a href="#FOLLOW-集" class="headerlink" title="FOLLOW 集"></a>FOLLOW 集</h3><p>$FOLLOW(A)$ 集表示非终结符 $A$ 后可以跟随哪些终结符</p><script type="math/tex; mode=display">FOLLOW(A) = \{ a | S \Rightarrow^* \dots A a \dots，a \in V_T \}</script><script type="math/tex; mode=display">若 A \Rightarrow^* \dots A，则 \# \in FOLLOW(A)</script><p>这两条等式可以用下面三个原则来求算</p><ul><li>对于文法开始符号 $S$，则 <script type="math/tex">\# \in FOLLOW(S)</script></li><li>若存在类似 $B \rightarrow \alpha A \beta$ 的表达式，则 <script type="math/tex">FIRST(\beta) - \{\varepsilon\} \subseteq FOLLOW(A)</script></li><li>若存在类似 $B \rightarrow \alpha A$ 或者 $B \rightarrow \alpha A \beta 且 \beta \Rightarrow^* \varepsilon$，则 <script type="math/tex">FOLLOW(B) \subseteq FOLLOW(A)</script></li></ul><h3 id="SELECT-集"><a href="#SELECT-集" class="headerlink" title="SELECT 集"></a>SELECT 集</h3><p>表示使用某个产生式的选择符号</p><script type="math/tex; mode=display">\begin{cases}SELECT(A \rightarrow \alpha) = (FIRST(\alpha) - \{\varepsilon\}) \cup FOLLOW(A)，\alpha \Rightarrow^* \varepsilon \\SELECT(A \rightarrow \alpha) = FIRST(\alpha)，\alpha \not\Rightarrow^* \varepsilon\end{cases}</script><p>同时满足</p><script type="math/tex; mode=display">SELECT(A \rightarrow \alpha) \cap SELECT(A \rightarrow \beta) = \varnothing</script><h3 id="LL-1"><a href="#LL-1" class="headerlink" title="LL(1)"></a>LL(1)</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>满足 LL(1) 的文法有下面三个条件：</p><p>若文法存在语句</p><script type="math/tex; mode=display">A \rightarrow \alpha | \beta</script><p>则</p><ul><li>不存在终结 $a$ 使得 $\alpha$ 和 $\beta$ 都能推导出以 $a$ 开头的串，即 $FIRST(\alpha) \cap FIRST(\beta) = \varnothing$</li><li>$\alpha$ 和 $\beta$ 至多有一个能推导出 $\varepsilon$</li><li>满足下面的等式</li></ul><script type="math/tex; mode=display">\begin{cases}FIRST(\alpha) \cap FOLLOW(A) = \varnothing, \beta \Rightarrow^* \varepsilon \\FIRST(\beta) \cap FOLLOW(A) = \varnothing, \alpha \Rightarrow^* \varepsilon\end{cases}</script><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><script type="math/tex; mode=display">对于所有的 A \rightarrow \alpha | \beta</script><p>若满足</p><script type="math/tex; mode=display">SELECT(A \rightarrow \alpha) \cap SELECT(A \rightarrow \beta) = \varnothing</script><p>则为 LL(1)</p><h3 id="非递归的预测分析法-表驱动的预测分析"><a href="#非递归的预测分析法-表驱动的预测分析" class="headerlink" title="非递归的预测分析法(表驱动的预测分析)"></a>非递归的预测分析法(表驱动的预测分析)</h3><p>首先需要根据 $SELECT$ 集来构建一个分析表。通过表的信息实现语法分析</p><h3 id="LL-1-文法分析示例"><a href="#LL-1-文法分析示例" class="headerlink" title="LL(1) 文法分析示例"></a>LL(1) 文法分析示例</h3><p>以下面的表达式文法为例</p><script type="math/tex; mode=display">\begin{cases}E \rightarrow E + T | T \\T \rightarrow T * F | F \\F \rightarrow i | (E)\end{cases}</script><h4 id="消除左递归-1"><a href="#消除左递归-1" class="headerlink" title="消除左递归"></a>消除左递归</h4><p>首先，消除左递归，易得，前两个式子均为左递归<br>得到</p><script type="math/tex; mode=display">\begin{cases}E \rightarrow TE' \\E' \rightarrow +TE' | \varepsilon \\T \rightarrow FT' \\T' \rightarrow *FT' | \varepsilon \\F \rightarrow i | (E)\end{cases}</script><h4 id="求出-FIRST"><a href="#求出-FIRST" class="headerlink" title="求出 FIRST"></a>求出 FIRST</h4><p>得到各个符号的 FIRST 集：</p><p>首先根据2、4、5式得到</p><script type="math/tex; mode=display">\begin{cases}FIRST(E') = \{+, \varepsilon\} \\FIRST(T') = \{*, \varepsilon\} \\FIRST(F) = \{i, (\}\end{cases}</script><p>然后根据 FIRST 集的求出剩下的 FIRST 集</p><script type="math/tex; mode=display">\begin{cases}FIRST(E) = \{i, ( \} \\FIRST(T) = \{i, ( \}\end{cases}</script><h4 id="求出-FOLLOW-集"><a href="#求出-FOLLOW-集" class="headerlink" title="求出 FOLLOW 集"></a>求出 FOLLOW 集</h4><p>然后再求出 FOLLOW 集</p><p>首先</p><script type="math/tex; mode=display">\# \in FOLLOW(E)</script><p>然后根据第一个等式得到</p><script type="math/tex; mode=display">FIRST(E') - \varepsilon \subseteq FOLLOW(T) \Rightarrow FOLLOW(T) = \{+\}</script><script type="math/tex; mode=display">FOLLOW(E) \subseteq FOLLOW(E') \Rightarrow FOLLOW(E') = \{\#\}</script><p>然后继续重复做，直到没有 FOLLOW 集发生更新为止，最终得到</p><script type="math/tex; mode=display">\begin{cases}FOLLOW(E) = \{ \#, ) \} \\FOLLOW(E') = \{ \#, ) \} \\FOLLOW(T) = \{ \#, +, )\} \\FOLLOW(T') = \{ \#, +, )\} \\FOLLOW(F) = \{ \#, +, ), *\}\end{cases}</script><h4 id="求出-SELECT-集"><a href="#求出-SELECT-集" class="headerlink" title="求出 SELECT 集"></a>求出 SELECT 集</h4><p>再得到 SELECT 集</p><script type="math/tex; mode=display">\begin{cases}SELECT(E \rightarrow TE') = FIRST(TE') = FIRST(T) = \{i, ( \} \\SELECT(E' \rightarrow +TE') = FIRST(+TE') = FIRST(+) = \{+\} \\SELECT(E' \rightarrow \varepsilon) = (FIRST(\varepsilon) - \{\varepsilon \}) \cup FOLLOW(E') = \{ \#, ) \} \\SELECT(T \rightarrow FT') = FIRST(FT') = FIRST(F) = \{i, (\} \\SELECT(T' \rightarrow * FT') = FIRST(*FT') = FIRST(*) = \{*\} \\SELECT(T' \rightarrow \varepsilon) = (FIRST(\varepsilon) - \{\varepsilon \}) \cup FOLLOW(T') = \{ \#, +, )\} \\SELECT(F \rightarrow i) = FIRST(i) = \{ i \} \\SELECT(F \rightarrow (E)) = FIRST((E)) = FIRST(() = \{ ( \} \\\end{cases}</script><p>此时，判断是否为 LL(1) 文法</p><script type="math/tex; mode=display">\begin{cases}SELECT(E' \rightarrow +TE') \cup SELECT(E' \rightarrow \varepsilon) = \varnothing \\SELECT(T' \rightarrow * FT') \cup SELECT(T' \rightarrow \varepsilon) = \varnothing \\SELECT(F \rightarrow i) \cup SELECT(F \rightarrow (E)) = \varnothing\end{cases}</script><p>所以是 LL(1)文法</p><h4 id="求出分析表"><a href="#求出分析表" class="headerlink" title="求出分析表"></a>求出分析表</h4><p>根据 SELECT 得出下表</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">i</th><th style="text-align:center">+</th><th style="text-align:center">*</th><th style="text-align:center">(</th><th style="text-align:center">)</th><th style="text-align:center">#</th></tr></thead><tbody><tr><td style="text-align:center">E</td><td style="text-align:center">$\rightarrow TE’$</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">$\rightarrow TE’$</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">E’</td><td style="text-align:center"></td><td style="text-align:center">$\rightarrow +TE’$</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">$\rightarrow \varepsilon$</td><td style="text-align:center">$\rightarrow \varepsilon$</td></tr><tr><td style="text-align:center">T</td><td style="text-align:center">$\rightarrow FT’$</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">$\rightarrow FT’$</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">T’</td><td style="text-align:center"></td><td style="text-align:center">$\rightarrow \varepsilon$</td><td style="text-align:center">$\rightarrow *FT’$</td><td style="text-align:center"></td><td style="text-align:center">$\rightarrow \varepsilon$</td><td style="text-align:center">$\rightarrow \varepsilon$</td></tr><tr><td style="text-align:center">F</td><td style="text-align:center">$\rightarrow i$</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">$\rightarrow (E)$</td><td style="text-align:center"></td></tr></tbody></table></div><h4 id="分析输入串"><a href="#分析输入串" class="headerlink" title="分析输入串"></a>分析输入串</h4><p>采用三列分析法来分析，使用 <code>#</code> 表示尾部，假设输入的串为 <code>i+i*i</code></p><div class="table-container"><table><thead><tr><th style="text-align:center">栈</th><th style="text-align:center">剩余输入</th><th style="text-align:center">输出</th></tr></thead><tbody><tr><td style="text-align:center"><code>E#</code></td><td style="text-align:center"><code>i+i*i#</code></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>TE&#39;#</code></td><td style="text-align:center"><code>i+i*i#</code></td><td style="text-align:center">匹配了表中的 $\rightarrow TE’$</td></tr><tr><td style="text-align:center"><code>FT&#39;E&#39;#</code></td><td style="text-align:center"><code>i+i*i#</code></td><td style="text-align:center">$\rightarrow FT’$</td></tr><tr><td style="text-align:center"><code>iT&#39;E&#39;#</code></td><td style="text-align:center"><code>i+i*i#</code></td><td style="text-align:center">$\rightarrow i$</td></tr><tr><td style="text-align:center"><code>T&#39;E&#39;#</code></td><td style="text-align:center"><code>+i*i#</code></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>E&#39;#</code></td><td style="text-align:center"><code>+i*i#</code></td><td style="text-align:center">$\rightarrow \varepsilon$</td></tr><tr><td style="text-align:center"><code>+TE&#39;#</code></td><td style="text-align:center"><code>+i*i#</code></td><td style="text-align:center">$\rightarrow +TE’$</td></tr><tr><td style="text-align:center"><code>TE&#39;#</code></td><td style="text-align:center"><code>i*i#</code></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>FT&#39;E&#39;#</code></td><td style="text-align:center"><code>i*i#</code></td><td style="text-align:center">$\rightarrow FT’$</td></tr><tr><td style="text-align:center"><code>iT&#39;E&#39;#</code></td><td style="text-align:center"><code>i*i#</code></td><td style="text-align:center">$\rightarrow i$</td></tr><tr><td style="text-align:center"><code>T&#39;E&#39; #</code></td><td style="text-align:center"><code>*i#</code></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>*FT&#39;E&#39;#</code></td><td style="text-align:center"><code>*i#</code></td><td style="text-align:center">$\rightarrow *FT’$</td></tr><tr><td style="text-align:center"><code>FT&#39;E&#39;#</code></td><td style="text-align:center"><code>i#</code></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>iT&#39;E&#39;#</code></td><td style="text-align:center"><code>i#</code></td><td style="text-align:center">$\rightarrow i$</td></tr><tr><td style="text-align:center"><code>T&#39;E&#39;#</code></td><td style="text-align:center"><code>#</code></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><code>E&#39;#</code></td><td style="text-align:center"><code>#</code></td><td style="text-align:center">$\rightarrow \varepsilon$</td></tr><tr><td style="text-align:center"><code>#</code></td><td style="text-align:center"><code>#</code></td><td style="text-align:center">$\rightarrow \varepsilon$</td></tr></tbody></table></div><p>匹配成功</p><h2 id="LL-1-分析中的出错处理"><a href="#LL-1-分析中的出错处理" class="headerlink" title="LL(1) 分析中的出错处理"></a>LL(1) 分析中的出错处理</h2><p>略</p><h1 id="自底向上优先分析"><a href="#自底向上优先分析" class="headerlink" title="自底向上优先分析"></a>自底向上优先分析</h1><h2 id="自底向下的分析思想"><a href="#自底向下的分析思想" class="headerlink" title="自底向下的分析思想"></a>自底向下的分析思想</h2><p>从分析树的底部(叶节点)向顶部(根节点)方向构造分析树，可以看成是将输入串w归约为文法开始符号S的过程，自底向上的语法分析采用最左归约方式（反向构造最右推导）</p><h1 id="LR-0-和-SLR-1-分析法"><a href="#LR-0-和-SLR-1-分析法" class="headerlink" title="LR(0) 和 SLR(1) 分析法"></a>LR(0) 和 SLR(1) 分析法</h1><ul><li>L: 对输入进行从左到右的扫描</li><li>R: 反向构造出一个最右推导序列</li></ul><p><strong><font color=red>由于 SLR(1) 的操作和 LR(0) 分析法相似，且兼容，所以这里直接写 SLR(1) 的操作过程，LR(0) 文法也可以直接用此方法，得到的结果完全相同</font></strong></p><p>以此文法为例</p><script type="math/tex; mode=display">\begin{cases}S \rightarrow L*L | L \\L \rightarrow LB | B \\B \rightarrow 0 | 1\end{cases}</script><h2 id="构造分析表"><a href="#构造分析表" class="headerlink" title="构造分析表"></a>构造分析表</h2><h3 id="将所有的或运算式子转换为多个式子"><a href="#将所有的或运算式子转换为多个式子" class="headerlink" title="将所有的或运算式子转换为多个式子"></a>将所有的或运算式子转换为多个式子</h3><p>得到</p><script type="math/tex; mode=display">\begin{cases}S \rightarrow L*L \\S \rightarrow L \\L \rightarrow LB \\L \rightarrow B \\B \rightarrow 0 \\B \rightarrow 1\end{cases}</script><h3 id="合并相同开始符号"><a href="#合并相同开始符号" class="headerlink" title="合并相同开始符号"></a>合并相同开始符号</h3><p>LR分析法不适用于有多个开始符号的产生式，所以应当对上面的产生式进行处理得到</p><script type="math/tex; mode=display">\begin{cases} 0) S' \rightarrow S \\ 1) S \rightarrow L*L \\ 2) S \rightarrow L \\ 3) L \rightarrow LB \\ 4) L \rightarrow B \\ 5) B \rightarrow 0 \\ 6) B \rightarrow 1\end{cases}</script><p><em>每行开头的为编号，后续通过编号来指代产生式</em></p><h3 id="建立状态"><a href="#建立状态" class="headerlink" title="建立状态"></a>建立状态</h3><p>对于一个状态，首先，判断<code>.</code>后面是否为非终结符号。如果是，那我们就得找所有由此非终结符推出的产生式，并将它们添加进入此状态里。循环做即可。</p><p><em>使用 <code>.</code> 表示当前匹配到的位置</em></p><p>首先建立初状态，将第一个表达式加入初状态 State 0</p><h4 id="State-0"><a href="#State-0" class="headerlink" title="State 0"></a>State 0</h4><p>此状态中有 $S’ \rightarrow .S$</p><p>检查 <code>.</code> 后是否为非终结符，得到 $S$，由于 $S$ 是非终结符，所以将 $S$ 的产生式加入此状态得到</p><script type="math/tex; mode=display">\begin{cases}S' \rightarrow .S \\S \rightarrow .L*L \\S \rightarrow .L \\\end{cases}</script><p>再检查新加入的，得到 $L$ 也需要加入此状态</p><script type="math/tex; mode=display">\begin{cases}S' \rightarrow .S \\S \rightarrow .L*L \\S \rightarrow .L \\L \rightarrow .LB \\L \rightarrow .B \\\end{cases}</script><p>最后发现 $B$ 也是需要加入此状态的得到 State 0 的最终结果</p><script type="math/tex; mode=display">\begin{cases}S' \rightarrow .S \\S \rightarrow .L*L \\S \rightarrow .L \\L \rightarrow .LB \\L \rightarrow .B \\B \rightarrow .0 \\B \rightarrow .1\end{cases}</script><p>接下来的每个状态都是从 State 转换过来的，即将小数点向后移动，可以得到不同的状态<br>根据其状态内的产生式，可以得到 State 0 可以有 $S, L, B, 0, 1$ 这五个转移方式</p><h4 id="State-1"><a href="#State-1" class="headerlink" title="State 1"></a>State 1</h4><p>设定 State 1 是从 State 0 通过 $S$ 转移过来的</p><p>所以可以得到，仅</p><script type="math/tex; mode=display">S' \rightarrow S.</script><p>满足，所以 State 1 即只有此产生式，且不可以再转移</p><p>注意，State 1 是第一个产生式的最后的结果，所以此状态作为 <code>Accept</code> 状态，简称 <code>acc</code></p><h4 id="State-2"><a href="#State-2" class="headerlink" title="State 2"></a>State 2</h4><p>设定 State 2 是从 State 0 通过 $L$ 转移过来</p><p>所以可以直接得到的有</p><script type="math/tex; mode=display">\begin{cases}S \rightarrow L.*L \\S \rightarrow L. \\L \rightarrow L.B \\\end{cases}</script><p>对于第三个式子，其满足条件(<code>.</code>后为非终结符)，所以需要把 $B$ 加入此状态</p><p>即得到</p><script type="math/tex; mode=display">\begin{cases}S \rightarrow L.*L \\S \rightarrow L. \\L \rightarrow L.B \\B \rightarrow .0 \\B \rightarrow .1\end{cases}</script><h4 id="其他-State"><a href="#其他-State" class="headerlink" title="其他 State"></a>其他 State</h4><p>不断重复上述步骤，得到下面的图和结果</p><script type="math/tex; mode=display">State 0 =\begin{cases}S' \rightarrow .S \\S \rightarrow .L*L \\S \rightarrow .L \\L \rightarrow .LB \\L \rightarrow .B \\B \rightarrow .0 \\B \rightarrow .1\end{cases}</script><script type="math/tex; mode=display">State 1 =\begin{cases}S' \rightarrow S.\end{cases}</script><script type="math/tex; mode=display">State 2 =\begin{cases}S \rightarrow L.*L \\S \rightarrow L. \\L \rightarrow L.B \\B \rightarrow .0 \\B \rightarrow .1\end{cases}</script><script type="math/tex; mode=display">State 3 =\begin{cases}L \rightarrow B.\end{cases}</script><script type="math/tex; mode=display">State 4 =\begin{cases}B \rightarrow 0.\end{cases}</script><script type="math/tex; mode=display">State 5 =\begin{cases}B \rightarrow 1.\end{cases}</script><script type="math/tex; mode=display">State 6 =\begin{cases}S \rightarrow L*.L \\L \rightarrow .LB \\L \rightarrow .B \\B \rightarrow .0 \\B \rightarrow .1\end{cases}</script><script type="math/tex; mode=display">State 7 =\begin{cases}L \rightarrow LB.\end{cases}</script><script type="math/tex; mode=display">State 8 =\begin{cases}S \rightarrow L*L. \\L \rightarrow L.B \\B \rightarrow .0 \\B \rightarrow .1\end{cases}</script><pre><code class=" mermaid">graph LRA[State 0] -- S --&gt; B[State 1]A[State 0] -- L --&gt; C[State 2]A[State 0] -- B --&gt; D[State 3]A[State 0] -- 0 --&gt; E[State 4]A[State 0] -- 1 --&gt; F[State 5]C[State 2] -- * --&gt; G[State 6]C[State 2] -- B --&gt; H[State 7]C[State 2] -- 0 --&gt; E[State 4]C[State 2] -- 1 --&gt; F[State 5]G[State 6] -- L --&gt; I[State 8]G[State 6] -- B --&gt; D[State 3]G[State 6] -- 0 --&gt; E[State 4]G[State 6] -- 1 --&gt; F[State 5]I[State 8] -- B --&gt; H[State 7]I[State 8] -- 0 --&gt; E[State 4]I[State 8] -- 1 --&gt; F[State 5]B[State 1] --&gt; Accept([Accept])</code></pre><p><em>Accept通常状态不需要画出</em></p><h3 id="创建LR分析表"><a href="#创建LR分析表" class="headerlink" title="创建LR分析表"></a>创建LR分析表</h3><p>由此图和上面的集合可以画出表格</p><table border="0" cellpadding="0" cellspacing="0" width="576" style="border-collapse: collapse;table-layout:fixed;width:432pt">        <tbody>        <tr height="19" style="mso-height-source:userset;height:14.25pt" id="r0">            <td rowspan="2" height="38" class="x21" width="72" style="height:28.5pt;width:54pt;">状态</td>            <td colspan="4" class="x21" width="288">ACTION</td>            <td colspan="3" class="x21" width="216">GOTO</td>        </tr>        <tr height="19" style="mso-height-source:userset;height:14.25pt" id="r1">            <td class="x22">0</td>            <td class="x22">1</td>            <td class="x22">*</td>            <td class="x22">$</td>            <td class="x22">S</td>            <td class="x22">L</td>            <td class="x22">B</td>        </tr>        <tr height="19" style="mso-height-source:userset;height:14.25pt" id="r2">            <td height="19" class="x22" style="height:14.25pt;">0</td>            <td class="x22">s4</td>            <td class="x22">s5</td>            <td class="x22"></td>            <td class="x22"></td>            <td class="x22">1</td>            <td class="x22">2</td>            <td class="x22">3</td>        </tr>        <tr height="19" style="mso-height-source:userset;height:14.25pt" id="r3">            <td height="19" class="x22" style="height:14.25pt;">1</td>            <td class="x22"></td>            <td class="x22"></td>            <td class="x22"></td>            <td class="x22">acc</td>            <td class="x22"></td>            <td class="x22"></td>            <td class="x22"></td>        </tr>        <tr height="19" style="mso-height-source:userset;height:14.25pt" id="r4">            <td height="19" class="x22" style="height:14.25pt;">2</td>            <td class="x22">s4</td>            <td class="x22">s5</td>            <td class="x22">s6</td>            <td class="x22">r2</td>            <td class="x22"></td>            <td class="x22"></td>            <td class="x22">7</td>        </tr>        <tr height="19" style="mso-height-source:userset;height:14.25pt" id="r5">            <td height="19" class="x22" style="height:14.25pt;">3</td>            <td class="x22">r4</td>            <td class="x22">r4</td>            <td class="x22">r4</td>            <td class="x22">r4</td>            <td class="x22"></td>            <td class="x22"></td>            <td class="x22"></td>        </tr>        <tr height="19" style="mso-height-source:userset;height:14.25pt" id="r6">            <td height="19" class="x22" style="height:14.25pt;">4</td>            <td class="x22">r5</td>            <td class="x22">r5</td>            <td class="x22">r5</td>            <td class="x22">r5</td>            <td class="x22"></td>            <td class="x22"></td>            <td class="x22"></td>        </tr>        <tr height="19" style="mso-height-source:userset;height:14.25pt" id="r7">            <td height="19" class="x22" style="height:14.25pt;">5</td>            <td class="x22">r6</td>            <td class="x22">r6</td>            <td class="x22">r6</td>            <td class="x22">r6</td>            <td class="x22"></td>            <td class="x22"></td>            <td class="x22"></td>        </tr>        <tr height="19" style="mso-height-source:userset;height:14.25pt" id="r8">            <td height="19" class="x22" style="height:14.25pt;">6</td>            <td class="x22">s4</td>            <td class="x22">s5</td>            <td class="x22"></td>            <td class="x22"></td>            <td class="x22"></td>            <td class="x22">8</td>            <td class="x22">3</td>        </tr>        <tr height="19" style="mso-height-source:userset;height:14.25pt" id="r9">            <td height="19" class="x22" style="height:14.25pt;">7</td>            <td class="x22">r3</td>            <td class="x22">r3</td>            <td class="x22">r3</td>            <td class="x22">r3</td>            <td class="x22"></td>            <td class="x22"></td>            <td class="x22"></td>        </tr>        <tr height="19" style="mso-height-source:userset;height:14.25pt" id="r10">            <td height="19" class="x22" style="height:14.25pt;">8</td>            <td class="x22">s4</td>            <td class="x22">s5</td>            <td class="x22"></td>            <td class="x22">r1</td>            <td class="x22"></td>            <td class="x22"></td>            <td class="x22">7</td>        </tr>        <!--[if supportMisalignedColumns]-->        <tr height="0" style="display:none">            <td width="72" style="width:54pt"></td>            <td width="72" style="width:54pt"></td>            <td width="72" style="width:54pt"></td>            <td width="72" style="width:54pt"></td>            <td width="72" style="width:54pt"></td>            <td width="72" style="width:54pt"></td>            <td width="72" style="width:54pt"></td>            <td width="72" style="width:54pt"></td>        </tr>        <!--[endif]-->    </tbody></table><p>表的构建原则：</p><ul><li>首先，表头分为两列，ACTION 和 GOTO，在 ACTION 下均为终结符，而在 GOTO 下均为非终结符，其中在 ACTION 下还需要加上 <code>$</code> 状态标识匹配结束符(在LL(1)文法中，使用了 <code>#</code> 作为结束符，实际上两种方法均可作为结束符，只需要在题目中注明即可)</li><li>对于每一个状态，如果它在图中存在任何转移的方向，则将此转移方向填入表格中。如果转移状态为非终结符，则直接填入对应状态的序号，如果为终结符，则格式为 <code>sn</code> 其中 <code>n</code> 为转移的目标状态<ul><li>以图中 State 0 为例，其可以通过 $B$ 转移至 State 3，而 $B$ 是一个非终结符，所以在状态为 0 的那一行的第 $B$ 类填上 <code>3</code> 即可</li><li>以图中 State 0 为例，其可以通过 $0$ 转移至 State 4，所以在状态为 0 的那一行的第 $0$ 列填上 <code>s4</code></li></ul></li><li>若此状态中存在任何一个产生式满足 <code>.</code> 在此产生式的最后<ul><li>假定此状态内的等式有两类，则进行如下操作(此时可以确定，此文法不可能为 LR(0)，但是可以是SLR(1))<blockquote><p>既有满足条件的，又有不满足条件的时候</p><script type="math/tex; mode=display">\begin{cases}A_1 \rightarrow \alpha_1 . a_1 \beta_1 \\A_2 \rightarrow \alpha_2 . a_2 \beta_2 \\\dots \\B_1 \rightarrow \gamma_1 . \\B_2 \rightarrow \gamma_2 . \\\dots\end{cases}</script><p>显然，前面的产生式为不满足条件的产生式，后面的产生式均为满足条件的产生式<br>若均满足下列条件，则认为可以通过 SLR 分析法处理，否则认为不可解</p><script type="math/tex; mode=display">\begin{cases}\forall FOLLOW(B_i) \cap \{a_1, a_2 \dots \}  = \varnothing \\\forall FOLLOW(B_i) \cap \forall FOLLOW(B_j) = \varnothing\end{cases}</script><p>若满足上述条件，则对于 <code>ACTION</code> 列中的每一项 $a$<br>若 $a \in {a_1, a_2 \dots }$，则采用 <code>sn</code> 的标识方式，即<br>若 $a \in FOLLOW(B_i)$，则在所在列标注上 <code>rn</code>，其中 <code>n</code> 指代第几号产生式，这条产生式为 $B_i \rightarrow \gamma_i$</p></blockquote></li><li>若此状态内的等式只有一类，即只有满足条件的，则在其所有的 ACTION 列中用 <code>rn</code> 标注(若只有此条件的状态，则此时可以称文法为 LR(0) 文法)<blockquote><p>以 State 2 为例，有四个式子不满足条件，仅一个式子满足条件。其中 $S \rightarrow L.$ 为满足条件的式子，剩下四个均不满足条件。所以我们先求出 $S$ 的 <script type="math/tex">FOLLOW(S) = \{\$\}</script>，满足等式 <script type="math/tex">FOLLOW(S) \cap \{*, B, 0, 1\} = \varnothing</script><br>接着遍历所有 <code>ACTION</code> 内的符号，对于 $0$ 而言，其属于 <script type="math/tex">\{*, B, 0, 1\}</script> 所以，写入 <code>s4</code><br>对于 $\$$ 而言，其属于 FOLLOW(S)，所以写上 $S \rightarrow L$ 这个产生对应的序号，即 <code>r2</code></p></blockquote></li></ul></li></ul><!-- ## LR(1) 和 LALR(1)提出了后继符号概念定义每一个产生式应当描述为$$A \rightarrow \alpha . \beta, a$$其中，前半部分为普通的产生式，后面紧跟一个<font color=red>展望符</font>。其表示 $A$ 后面必须紧跟的终结符，其通常是 FOLLOW(A) 的真子集。 - LR(1) 中的 1 表示的即为此展望符的长度 - 当 $\beta \neq \varepsilon$ 时，此展望符没有任何作用 - 当 $\beta = \varepsilon$ 时，当且仅当下一个符号属于 $a$ 时，才可以用此产生式进行规约 - 若存在 $B \rightarrow \gamma$ 则其展望符为 $FIRST(\beta a)$，当 $\beta \Rightarrow^* \varepsilon$ 时，此时展望符为 $a$此时，再进行类似 LL(0) 文法的分析操作，以下面的文法为例$$\begin{cases}S \rightarrow L=R | R \\L \rightarrow *R | id \\R \rightarrow L\end{cases}$$此处省略过程，直接得到答案### 处理后的产生式为$$\begin{cases} 0) S' \rightarrow S \\ 1) S \rightarrow L=R \\ 2) S \rightarrow R \\ 3) L \rightarrow *R \\ 4) L \rightarrow id \\ 5) R \rightarrow L\end{cases}$$### 每个状态的产生式为$$State 0\begin{cases}S' \rightarrow .S, \$ \\S \rightarrow .L=R, \$ \\S \rightarrow .R, \$ \\L \rightarrow .*R, =/\$ \\L \rightarrow .id, =/\$ \\R \rightarrow .L, =/\$\end{cases}$$$$State 1\begin{cases}S' \rightarrow S.,\$\end{cases}$$$$State 2\begin{cases}S \rightarrow L.=R,\$ \\R \rightarrow L.,\$\end{cases}$$$$State 3\begin{cases}S \rightarrow R.,\$\end{cases}$$$$State 4\begin{cases}L \rightarrow *.R,=/\$ \\R \rightarrow .L, =/\$ \\L \rightarrow .*R, =/\$ \\L \rightarrow .id, =/\$\end{cases}$$$$State 4\begin{cases}S \rightarrow L=.R,\$ \\R \rightarrow .L, \$ \\L \rightarrow .*R, \$ \\L \rightarrow .id, \$\end{cases}$$ --><h1 id="LR-1-和-LALR-1"><a href="#LR-1-和-LALR-1" class="headerlink" title="LR(1) 和 LALR(1)"></a>LR(1) 和 LALR(1)</h1><p>略</p><h1 id="语法制导翻译"><a href="#语法制导翻译" class="headerlink" title="语法制导翻译"></a>语法制导翻译</h1><p>即将上面的那些产生式带入实际的使用中</p><p>例如可以通过下面的文法来描述 <code>C</code> 语言的定义一个变量的过程</p><div class="table-container"><table><thead><tr><th style="text-align:center">产生式</th><th style="text-align:center">语义规则</th></tr></thead><tbody><tr><td style="text-align:center">$S \rightarrow TL$</td><td style="text-align:center">L的类型为T</td></tr><tr><td style="text-align:center">$T \rightarrow int$</td><td style="text-align:center">T为int</td></tr><tr><td style="text-align:center">$T \rightarrow double$</td><td style="text-align:center">T为double</td></tr><tr><td style="text-align:center">$L \rightarrow L, id$</td><td style="text-align:center">创建一个新的 <script type="math/tex">L_{右}</script>，将其类型设置为 <script type="math/tex">L_{左}</script> 相同的类型。并创建一个变量，其类型为 <script type="math/tex">L_{左}</script> 的类型，名字为 <script type="math/tex">id</script></td></tr><tr><td style="text-align:center">$L \rightarrow id$</td><td style="text-align:center">创建一个变量，其类型为 <script type="math/tex">L_{左}</script> 的类型，名字为 <script type="math/tex">id</script></td></tr></tbody></table></div><p>改为用属性来描述，则可以得到如下表格</p><div class="table-container"><table><thead><tr><th style="text-align:center">产生式</th><th style="text-align:center">语义规则</th></tr></thead><tbody><tr><td style="text-align:center">$S \rightarrow TL$</td><td style="text-align:center"><code>L.type = T.type</code></td></tr><tr><td style="text-align:center">$T \rightarrow int$</td><td style="text-align:center"><code>T.type = int</code></td></tr><tr><td style="text-align:center">$T \rightarrow double$</td><td style="text-align:center"><code>T.type = double</code></td></tr><tr><td style="text-align:center">$L \rightarrow L, id$</td><td style="text-align:center"><code>L(右).type = L.type</code><br><code>CreateVar(type = L.type, name = id.name)</code></td></tr><tr><td style="text-align:center">$L \rightarrow id$</td><td style="text-align:center"><code>CreateVar(type = L.type, name = id.name)</code></td></tr></tbody></table></div><ul><li>语法制导定义(SDD)</li><li>语法制导翻译方案(SDT)</li></ul><h2 id="SDD-语法制导定义"><a href="#SDD-语法制导定义" class="headerlink" title="SDD(语法制导定义)"></a>SDD(语法制导定义)</h2><h3 id="综合属性和继承属性"><a href="#综合属性和继承属性" class="headerlink" title="综合属性和继承属性"></a>综合属性和继承属性</h3><p>对于一个产生式产生的语义规则中，如果产生式左部的属性是仅通过右部的属性得到的，则称此属性为<font color=red>综合属性</font>。而如果产生式右部的属性是通过右部的属性或者左部的属性得到的，则称为<font color=red>继承属性</font></p><p><img src="/image/notebook/Compilation-principle/L-SDD.png" alt="L-SDD"></p><h3 id="S-属性定义-与-L-属性定义"><a href="#S-属性定义-与-L-属性定义" class="headerlink" title="S-属性定义 与 L-属性定义"></a>S-属性定义 与 L-属性定义</h3><h4 id="S-属性文法"><a href="#S-属性文法" class="headerlink" title="S-属性文法"></a>S-属性文法</h4><p>仅仅使用综合属性的SDD称为S属性的SDD，或S-属性定义、S-SDD</p><h4 id="L-属性文法"><a href="#L-属性文法" class="headerlink" title="L-属性文法"></a>L-属性文法</h4><p>一个SDD是L-属性定义(L-SDD)，当且仅当它的每个属性要么是一个综合属性，要么是满足如下条件的继承属性：假如存在一个产生式 $A \rightarrow X_1 X_2 X_3 \dots$，若存在一个 $X_i$，它的一个属性值与下面的有关</p><ul><li>$A$ 的继承属性</li><li>来自 <script type="math/tex">X_1, X_2, X_3, \dots , X_{i-1}</script> 的属性</li><li>$X_i$ 自身的属性，但不能形成死循环</li></ul><p>例如上面的图片即为 L-SDD</p><h2 id="SDT-语法制导翻译方案"><a href="#SDT-语法制导翻译方案" class="headerlink" title="SDT(语法制导翻译方案)"></a>SDT(语法制导翻译方案)</h2><p>语法制导翻译方案(SDT)是在产生式右部中嵌入了程序片段(称为语义动作)的CFG(上下文无关文法)</p><p>例如</p><script type="math/tex; mode=display">\begin{cases}D \rightarrow T \{L.type = T.type \} L \\T \rightarrow int \{T.type = int \} \\T \rightarrow double \{T.type = double \} \\L \rightarrow \{ L_1.type = L.type \} L_1, id\end{cases}</script><p>嵌入规则如下</p><ul><li>将计算某个非终结符号A的继承属性的动作插入到产生式右部中紧靠在A的本次出现之前的位置上</li><li>将计算一个产生式左部符号的综合属性的动作放置在这个产生式右部的最右端</li></ul><p>使用时，当在进行规约操作时，需要同时执行此程序片段</p><h1 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h1><h2 id="中间代码举例"><a href="#中间代码举例" class="headerlink" title="中间代码举例"></a>中间代码举例</h2><ul><li>AST，抽象语法树</li><li>TAC，三地址码，四元式</li><li>P-code，特别用于 Pasal 语言实现</li><li>Bytecode，Java 编译器的输出</li><li>SSA，静态单赋值形式</li></ul><h2 id="典型语句的翻译-四元式"><a href="#典型语句的翻译-四元式" class="headerlink" title="典型语句的翻译(四元式)"></a>典型语句的翻译(四元式)</h2><h3 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">x = b * (c + d) + a<br></code></pre></td></tr></table></figure><ol><li><code>(+, c, d, t1)</code></li><li><code>(*, b, t1, t2)</code></li><li><code>(+, t2, a, t3)</code></li><li><code>(=, t3,  , x)</code></li></ol><h3 id="布尔表达式"><a href="#布尔表达式" class="headerlink" title="布尔表达式"></a>布尔表达式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">(a &gt; b) &amp;&amp; (c &lt; d) || (e &lt; f) &amp;&amp; (!g)<br></code></pre></td></tr></table></figure><ol><li><code>(j&gt;, a, b, 3)</code></li><li><code>(j, , ,5)</code></li><li><code>(j&lt;, c, d, true)</code></li><li><code>(j, , , 5)</code></li><li><code>(j&lt;, e, f, 7)</code></li><li><code>(j, , , false)</code></li><li><code>(jnz, g, , true)</code></li><li><code>(j, , , false)</code></li></ol><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (a &gt; <span class="hljs-number">0</span>) x = x + <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> x = <span class="hljs-number">4</span> * (x - <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><ol><li><code>(j&gt;, a, 0, 3)</code></li><li><code>(j, , , 6)</code></li><li><code>(+, x, 1, t1)</code></li><li><code>(=, t1, , x)</code></li><li><code>(j, , , 9)</code></li><li><code>(-, x, 1, t2)</code></li><li><code>(*, 4, t2, t3)</code></li><li><code>(=, t3, , x)</code><br>9.</li></ol><h1 id="运行存储分配"><a href="#运行存储分配" class="headerlink" title="运行存储分配"></a>运行存储分配</h1><ul><li>对于那些在编译时刻就可以确定大小的数据对象，可以在编译时刻就为它们分配存储空间，这样的分配策略称为<font color=red>静态存储分配</font></li><li>反之，如果不能在编译时完全确定数据对象的大小，就要采用<font color=red>动态存储分配</font>的策略。即在编译时仅产生各种必要的信息，而在运行时刻，再动态地分配数据对象的存储空间</li></ul><p><img src="/image/notebook/Compilation-principle/memory.png" alt="memory"></p><ul><li>使用过程(或函数、方法)作为用户自定义动作的单元的语言，其编译器通常以过程为单位分配存储空间</li><li>过程体的每次执行称为该过程的一个<font color=red>活动</font>(activation)</li><li>过程每执行一次，就为它分配一块连续存储区，用来管理过程一次执行所需的信息，这块连续存储区称为<font color=red>活动记录</font>(activation record)</li></ul><h2 id="静态存储分配"><a href="#静态存储分配" class="headerlink" title="静态存储分配"></a>静态存储分配</h2><ul><li>静态存储分配中，由编译器决定其在程序中的位置，每次运行时，其位置都相同</li><li>限制条件<ul><li>数组上下界均为常数</li><li>不允许过程的递归调用</li><li>不允许动态建立数据实体</li></ul></li></ul><h3 id="顺序分配法"><a href="#顺序分配法" class="headerlink" title="顺序分配法"></a>顺序分配法</h3><p>为每个静态过程都逐段分配存储空间，每个过程的内存空间都相互独立且不相交</p><p>优点：处理上简单<br>缺点：对内存空间的使用不够经济合理</p><h3 id="层次分配法"><a href="#层次分配法" class="headerlink" title="层次分配法"></a>层次分配法</h3><p>通过对过程间的调用关系进行分析，凡属无相互调用关系的并列过程，尽量使其局部数据<font color=red>共享</font>存储空间</p><h2 id="栈式存储分配"><a href="#栈式存储分配" class="headerlink" title="栈式存储分配"></a>栈式存储分配</h2><p>将内存认为是一个栈空间</p><p>当一个过程被调用时，向栈中推入一个活动记录，当此过程结束时，该记录被弹出栈</p><h2 id="活动树"><a href="#活动树" class="headerlink" title="活动树"></a>活动树</h2><p>用来描述程序运行期间控制进入和离开各个活动的情况的树称为活动树。在表示过程 p 的某个活动的结点上，其子结点对应于被 p的这次活动调用的各个过程的活动。按照这些活动被调用的顺序，自左向右地显示它们。一个子结点必须在其右兄弟结点的活动开始之前结束</p><h2 id="调用序列和返回序列"><a href="#调用序列和返回序列" class="headerlink" title="调用序列和返回序列"></a>调用序列和返回序列</h2><p>暂略</p><h2 id="非局部数据的访问"><a href="#非局部数据的访问" class="headerlink" title="非局部数据的访问"></a>非局部数据的访问</h2><p>暂略</p><h2 id="堆式存储分配"><a href="#堆式存储分配" class="headerlink" title="堆式存储分配"></a>堆式存储分配</h2><p>暂略</p><h2 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h2><p>暂略</p><h1 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h1><h2 id="流图"><a href="#流图" class="headerlink" title="流图"></a>流图</h2><h3 id="基本块"><a href="#基本块" class="headerlink" title="基本块"></a>基本块</h3><ul><li>控制流只能从基本块的第一个指令进入该块。也就是说，没有跳转到基本块中间或末尾指令的转移指令</li><li>除了基本块的最后一个指令，控制流在离开基本块之前不会跳转或者停机</li></ul><p>划分方法：</p><ul><li>确定首指令<ul><li>第一个指令是首指令</li><li>任何一个条件或无条件转移的指令的目标指令是一个首指令</li><li>紧跟在一个条件或无条件转移指令之后的指令是一个首指令</li></ul></li><li>任意两个相邻的首指令之间的记为一个基本块</li></ul><p>例如对于代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">i = m - <span class="hljs-number">1</span>;<br>j = n;<br>v = a[n];<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">do</span> i = i + <span class="hljs-number">1</span>; <span class="hljs-keyword">while</span>(a[i] &lt; v);<br>    <span class="hljs-keyword">do</span> j = j - <span class="hljs-number">1</span>; <span class="hljs-keyword">while</span>(a[j] &gt; v);<br>    <span class="hljs-keyword">if</span> (i &gt;= j) <span class="hljs-keyword">break</span>;<br>    x = a[i];<br>    a[i] = a[j];<br>    a[j] = x;<br>&#125;<br>x = a[i];<br>a[i] = a[n];<br>a[n] = x;<br></code></pre></td></tr></table></figure><p>可以划分出 6 个基本块</p><p>B1:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">i = m - <span class="hljs-number">1</span>;<br>j = n;<br>v = a[n];<br></code></pre></td></tr></table></figure><br>B2:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">i = i + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> a[i] &lt; v <span class="hljs-keyword">goto</span> B2<br></code></pre></td></tr></table></figure><br>B3:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">j = j - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> a[j] &gt; v <span class="hljs-keyword">goto</span> B3<br></code></pre></td></tr></table></figure><br>B4:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> i &gt;= j <span class="hljs-keyword">goto</span> B6<br></code></pre></td></tr></table></figure><br>B5:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">x = a[i];<br>a[i] = a[j];<br>a[j] = x;<br><span class="hljs-keyword">goto</span> B2<br></code></pre></td></tr></table></figure><br>B6:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">x = a[i];<br>a[i] = a[n];<br>a[n] = x;<br></code></pre></td></tr></table></figure></p><h3 id="流图-1"><a href="#流图-1" class="headerlink" title="流图"></a>流图</h3><p>根据上面的基本块，再根据其转跳关系，可以绘制流图<br><pre><code class=" mermaid">graph LRB1 --&gt; B2B2 --&gt; B2B2 --&gt; B3B3 --&gt; B3B3 --&gt; B4B4 --&gt; B5B4 --&gt; B6B5 --&gt; B2</code></pre></p><h2 id="常用的代码优化方法"><a href="#常用的代码优化方法" class="headerlink" title="常用的代码优化方法"></a>常用的代码优化方法</h2><p>暂略</p><h2 id="基本块的优化"><a href="#基本块的优化" class="headerlink" title="基本块的优化"></a>基本块的优化</h2><p>将基本块通过 DAG(有向无环图) 表示</p><p>例如对于代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">a = b + c;<br>b = b - d;<br>c = c + d;<br>e = b + c;<br></code></pre></td></tr></table></figure><p>可以绘制出如下的 DAG 图(通常在图上标注运算符号而不是字母，这里为了更容易理解标注了字母)</p><pre><code class=" mermaid">graph LRb0((b)) --&gt; a0((a))c0((c)) --&gt; a0((a))b0((b)) --&gt; b1((b))d0((d)) --&gt; b1((b))c0((c)) --&gt; c1((c))d0((d)) --&gt; c1((c))c1((c)) --&gt; e0((e))b1((b)) --&gt; e0((e))</code></pre><p>若结果 <code>e</code> 是需要返回的值，即其他基本块需要使用的值，则通过 DAG 图可知，变量 <code>a</code> 是无用的，可以删除</p><p>得到新的图为<br><pre><code class=" mermaid">graph LRb0((b)) --&gt; b1((b))d0((d)) --&gt; b1((b))c0((c)) --&gt; c1((c))d0((d)) --&gt; c1((c))c1((c)) --&gt; e0((e))b1((b)) --&gt; e0((e))</code></pre></p><p>所以可以得到优化后的代码为<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">b = b - d;<br>c = c + d;<br>e = b + c;<br></code></pre></td></tr></table></figure></p><h2 id="数据流分析"><a href="#数据流分析" class="headerlink" title="数据流分析"></a>数据流分析</h2><p>略</p><h2 id="到达定值分析"><a href="#到达定值分析" class="headerlink" title="到达定值分析"></a>到达定值分析</h2><p>暂略</p><h2 id="代码优化技术"><a href="#代码优化技术" class="headerlink" title="代码优化技术"></a>代码优化技术</h2><ul><li>依优化范围划分<ul><li>窥孔优化：局部的几条指令范围内的优化</li><li>局部优化：基本块范围内的优化</li><li>全局优化：流图范围内的优化</li><li>过程间优化：整个程序范围内的优化</li></ul></li><li>依优化对象划分<ul><li>目标代码优化：面向代码优化</li><li>中间代码优化：面向程序的中间表示</li><li>源级优化：面向源程序</li></ul></li><li>依优化侧面划分<ul><li>指令调度</li><li>寄存器分配</li><li>存储层次优化</li><li>存储布局优化</li><li>循环优化</li><li>控制流优化</li><li>过程优化</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>课程</tag>
      
      <tag>编译原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络复习</title>
    <link href="/2021/01/07/notebook/Computer-network/"/>
    <url>/2021/01/07/notebook/Computer-network/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><ul><li>21世纪的重要特征是：数字化、网络化、信息化，以网络为核心的信息时代</li><li>三类网络：电信网络、有线电视网络、计算机网络</li><li>互联网的特点：连通性和共享<ul><li>连通性：互联网使得上网用户之间，不管相距多远，都可以非常便捷、非常经济地交换信息</li><li>共享：信息共享、软件共享、硬件共享</li></ul></li></ul><h2 id="互联网"><a href="#互联网" class="headerlink" title="互联网"></a>互联网</h2><ul><li>计算机网络由若干结点(node)和连接这些结点的链路(link)组成</li><li>internet 是一个通用名词，它泛指由多个计算机网络互连而成的计算机网络</li><li>Internet 是一个专有名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定互连网，它采用 TCP/IP 协议族作为通信的规则，且其前身是美国的 ARPANET</li><li>互联网的三个阶段<ul><li>从单个网络 ARPANET 向互连网发展的过程，TCP/IP 协议成为 ARPANET 上的标准协议</li><li>建成了三级结构的互联网，分为主干网、地区网、校园网(企业网)</li><li>形成了多层次 ISP 结构的互联网</li></ul></li><li>ISP：网络服务提供商，例如中国电信<ul><li>ISP分为不同的层次：主干 ISP、地区 ISP、本地 ISP</li><li>主干 ISP 服务面积大，拥有高速主干网</li><li>地区 ISP 通过一个或多个主干 ISP 连接起来，部分大公司直接接入地区 ISP</li><li>本地 ISP 负责给用户提供直接的服务，用户数据经由本地 ISP、地区 ISP、主干 ISP、地区 ISP、本地 ISP 发送至目标用户</li></ul></li><li>IXP：互联网交换点，将两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组。使得互联网上的数据流量分布更加合理，减少了分组转发的迟延时间，降低了分组转发的费用</li></ul><p><img src="/image/notebook/Computer-network/1.png" alt="ISP"></p><ul><li>万维网(WWW)被广泛使用在互联网上，大大方便广大非网络专业人员对网络的使用</li><li>互联网的标准化工作由互联网协会(ISOC)进行管理<ul><li>互联网体系结构委员会(IAB)：负责管理互联网有关协议的开发<ul><li>互联网工程部(IETF)</li><li>互联网研究部(IRTF)</li></ul></li></ul></li></ul><h2 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h2><ul><li>边缘部分：由所有连接在互联网上的主机(端系统 end system)组成。这部分是用户直接使用的，用来进行通信和资源共享</li><li>核心部分：由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的</li></ul><h3 id="边缘部分"><a href="#边缘部分" class="headerlink" title="边缘部分"></a>边缘部分</h3><p>互联网的<font color=red>通信方式</font>：</p><ul><li>客户(Client)-服务器(Server)(C/S方式)：主机A运行客户程序而主机B运行服务器程序，在这种情况下，A是客户而B是服务器。客户A向服务器发出服务请求，而服务器B向客户A提供服务。<font color=red>客户是服务请求方，而服务器是服务提供方</font>。</li><li>对等方式(P2P方式 peer-to-peer)：两台主机都运行了对等连接软件(P2P软件)，他们可以进行平等的、对等连接通信</li></ul><h3 id="互联网的核心部分-通信交换方式"><a href="#互联网的核心部分-通信交换方式" class="headerlink" title="互联网的核心部分(通信交换方式)"></a>互联网的核心部分(通信交换方式)</h3><p>在互联网核心部分起特殊作用的是路由器。路由器是实现分组交换的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能</p><h4 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h4><p>使用电路交换通话之前，必须先拨号请求连接。当被叫用户听到交换机振铃音并摘机后，从主叫端到被叫端就建立了一条连接，也就是一条专用的物理通路。这条连接保证了双方通话时所需的通信资源，而这些资源在双方通信时不会被其他用户占用。<font color=red>在通话的全部时间内，通话的两个用户始终占用端到端的通信资源</font>。以下三个步骤称为电路交换</p><ul><li>建立连接(占用通信资源)</li><li>通话(一直占用通信资源)</li><li>释放资源(归还通信资源)</li></ul><p>如果用户在拨号呼叫时电信网的资源已不足以支持此次呼叫，则主叫用户会听到忙音，表示电信网不接受用户的呼叫(例如对方正在通话中)</p><p>但使用电路交换来传送计算机数据时，其<strong>线路的的传输效率往往很低</strong>。这是因为计算机的数据是突发式地出现在传输线路上的，因此线路上真正用来传送的数据时间往往不到10%，甚至1%。浪费通信线路资源</p><h4 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h4><p>分组交换采用存储转发技术，我们把要发送的整块数据称为一个报文(message)，在发送端，先把较长的报文划分成较短的、固定长度的数据段，每一个数据段前面添加上首部(header)构成分组(packet)。分组又称为包，分组的首部也可以称为包头。以下三个步骤</p><ul><li>路由器/交换机接受数据包(存储)</li><li>路由器/交换机查看数据段的首部，决定数据包接下来应该发送给哪个路由器</li><li>路由器/交换机发送数据包(转发)</li></ul><p>优点：</p><ul><li>高效：在分组传输的过程中动态分配传输带宽，对通信链路是逐段占用</li><li>灵活：为每一个分组独立地选择最合适的转发路由</li><li>迅速：以分组作为传送单位，可以不先建立连接就能向其他主机发送分组</li><li>可靠：保证可靠的网络协议，分布式多路由的分组交换网，使网络有很好的生存性</li></ul><p>缺点：</p><ul><li>分组在各路由器存储转发时需要排队，会造成一定的时延</li><li>分组交换需要携带控制信息</li></ul><p><img src="/image/notebook/Computer-network/2.png" alt="分组交换"></p><p><em>注：图中的报文交换即为将报文不拆分为较短的、固定长度的数据段的报文交换方式</em></p><h2 id="计算机网络类别"><a href="#计算机网络类别" class="headerlink" title="计算机网络类别"></a>计算机网络类别</h2><ul><li>按照作用范围分<ul><li>广域网(WAN)：广域网的作用范围通常为几十到几千公里，是互联网的核心部分，其任务是通过长距离运送主机发送给的数据，速度高、通信量大</li><li>城域网(MAN)：作用范围通常为一个城市，可以跨越几个街区甚至整个城市。目前城域网很多采用以太网技术，因此有时也常常并入局域网的范围</li><li>局域网(LAN)：一般工作范在1km左右</li><li>个人区域网(PAN)：个人网络，通常只有10m左右</li></ul></li><li>按照使用者分<ul><li>公用网(public network)：指电信公司出资建造的大型网络，这种网络通常是提供给所有愿意缴纳费用的人</li><li>专用网(private network)：某个部门为了满足本单位的需要而建造的网络，这种网络不向本单位以外的人提供服务</li></ul></li><li>用来把用户接入到互联网的网络<ul><li>这种网络称为接入网(AN)，即与宽带接入技术有关的网络</li></ul></li></ul><h2 id="网络性能"><a href="#网络性能" class="headerlink" title="网络性能"></a>网络性能</h2><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><p>速率的单位为 <code>bit/s</code>，有时写作<code>bps</code>，含义为：<font color=red>每秒传输的比特位个数</font>。<strong>注意，这与通常提及的网速单位不同，通常网速的单位为 B/s 而不是 b/s</strong></p>$$1Gbps = 1000Mbps = 10^6 Kbps = 10^9 bps$$$$1 B/s = 8 bps$$<h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p>通常带宽指代某个<strong>信号具有的频带宽度</strong>，单位为<code>Hz</code></p><p>在计算机网络中，带宽和速率同义，单位为<code>bit/s</code></p><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>在单位时间内，通过某个网络的实际数据量</p><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p>指数据从网络的一段传送到另一端所需要的时间</p><ul><li>发送时延：主机或路由器发送数据帧需要的时间。从发送数据帧的第一个比特开始到最后一个比特发送完毕所需要的时间 $发送时延 = \frac{数据帧长度(bit)}{速率(bit/s)}$</li><li>传播时延：电磁波在信道中传播一定的距离需要花费的时间 $传播时延 = \frac{链路长度(m)}{数据在链路上的传播速度(m/s)}$</li><li>处理时延：主机或路由器收到分组后需要花费时间进行处理。包括分析数据首部、提取数据部分、差错检验、寻找下一个路由</li><li>排队时延：分组经过网络传输时，在进入路由器后需要在输入队列中等待处理，待路由器确定了转发接口后，还要在输出队列中等待转发</li></ul><script type="math/tex; mode=display">总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延</script><p><strong>提高数据的发送速率只能减小数据的发送时延</strong></p><h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><p>表示通信管道链路中总共可以容纳多少个比特</p><script type="math/tex; mode=display">时延带宽积 = 传播时延 \times 带宽</script><h3 id="往返时间-RTT"><a href="#往返时间-RTT" class="headerlink" title="往返时间 RTT"></a>往返时间 RTT</h3><script type="math/tex; mode=display">有效数据率 = \frac{数据长度}{发送时间 + RTT}</script><h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><p>利用率有信道利用率和网络利用率两种</p><ul><li>信道利用率：某信道有百分之几的时间是被利用的(有数据通过)。信道利用率并非越高越好，信道利用率越大，则该信道的时延就会增加。令 $D_0$ 表示网络空闲时的时延，$D$ 表示网络当前的时延，信道利用率用$U$表示，则<script type="math/tex; mode=display">D = \frac{D_0}{1-U}</script>通常较大的主干网的 ISP 的信道利用率不超过 50%</li><li>网络利用率：全网络的信道利用率的加权平均值</li></ul><h3 id="其他非性能特征"><a href="#其他非性能特征" class="headerlink" title="其他非性能特征"></a>其他非性能特征</h3><ul><li>费用</li><li>质量</li><li>标准化</li><li>可靠性</li><li>可拓展性和可升级性</li><li>易于管理和维护</li></ul><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><p>规定了所交换数据的格式以及有关的同步问题规则称为网络协议，主要由下面三个要素构成</p><ul><li>语法：数据与控制信息的结构或格式</li><li>语义：需要发出何种控制信息，完成何种动作以及做出何种响应</li><li>同步：事件实现顺序的详细说明</li></ul><h3 id="网络层次"><a href="#网络层次" class="headerlink" title="网络层次"></a>网络层次</h3><p>分层的好处：</p><ul><li>各层之间是独立的</li><li>灵活性好</li><li>结构上可分割开</li><li>易于实现和维护</li><li>能促进标准化工作<ul><li>差错控制</li><li>流量控制</li><li>分段和重装</li><li>复用和分用</li><li>连接建立和释放</li></ul></li></ul><h3 id="五层协议结构"><a href="#五层协议结构" class="headerlink" title="五层协议结构"></a>五层协议结构</h3><h4 id="应用层-application-layer"><a href="#应用层-application-layer" class="headerlink" title="应用层(application layer)"></a>应用层(application layer)</h4><p>通过应用进程间的交互来完成特定网络应用。对于不同的网络应用需要有不同的应用层协议。例如 DNS(域名系统)，HTTP(万维网应用)，SMTP(电子邮件协议)</p><h4 id="运输层-transport-layer"><a href="#运输层-transport-layer" class="headerlink" title="运输层(transport layer)"></a>运输层(transport layer)</h4><p>负责向两台主机中进程通信提供通用的数据传输服务。主要有两种协议：</p><ul><li>TCP(传输控制协议)：面向连接的、可靠的数据传输服务。其数据传输的单位是<strong>报文段</strong></li><li>UDP(用户数据报协议)：提供无连接的、尽最大努力的数据传输服务，不保证数据传输的可靠性。其数据传输的单位是用户<strong>数据报</strong></li></ul><h4 id="网络层-network-layer"><a href="#网络层-network-layer" class="headerlink" title="网络层(network layer)"></a>网络层(network layer)</h4><p>负责为<a href="#分组交换">分组交换</a>网上的不同主机提供通信服务，将运输层产生的报文段或用户数据封装成分组或包进行传送。IP 协议</p><h4 id="数据链路层-data-link-layer"><a href="#数据链路层-data-link-layer" class="headerlink" title="数据链路层(data link layer)"></a>数据链路层(data link layer)</h4><p>将IP数据报组装成帧(framing)，添加控制信息(同步信息、地址信息、差错控制)。检查所收到的帧中是否有差错。与 mac 地址有关</p><h4 id="物理层-physical-layer"><a href="#物理层-physical-layer" class="headerlink" title="物理层(physical layer)"></a>物理层(physical layer)</h4><p>传输比特流</p><h3 id="实体、协议、服务-和服务访问点："><a href="#实体、协议、服务-和服务访问点：" class="headerlink" title="实体、协议、服务 和服务访问点："></a>实体、协议、服务 和服务访问点：</h3><ul><li>实体(entity)——表示任何可发送或接收信息的硬件或软件进程。</li><li>协议——控制两个对等实体进行通信的规则的集合。</li><li>在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。</li><li>要实现本层协议，还需要使用下层所提供的服务。</li><li>下面的协议对上面的服务用户是透明的。</li><li>协议是“水平的”，即协议是控制对等实体之间通信的规则。</li><li>服务是“垂直的”，即服务是由下层向上层通 过层间接口提供的。</li><li>同一系统相邻两层的实体进行交互的地方，称为服务访问点 SAP (Service Access Point)</li><li>协议必须把所有不利的条件事先都估计到，而不能假定一切都是正常的和非常理想的，必须非常仔细地检查这个协议能否应付各种异常情况。</li></ul><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p>物理层的主要任务是<font color=red>确定与传输媒体的接口有关的一些特性</font></p><ul><li>机械特性：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等</li><li>电器特性：指明在接口电缆的各条线上出现的电压的范围</li><li>功能特性：指明某条线上出现的某一电平的电压的意义</li><li>过程特性：指明对于不同功能的各种可能事件出现的顺序</li></ul><h2 id="数据通信的基础知识"><a href="#数据通信的基础知识" class="headerlink" title="数据通信的基础知识"></a>数据通信的基础知识</h2><h3 id="数据通信模型"><a href="#数据通信模型" class="headerlink" title="数据通信模型"></a>数据通信模型</h3><p>一个数据通信系统可以划分为三大部分</p><ul><li>源系统<ul><li>源点：源点设备产生要传输的数据</li><li>发送器：调制器(调制解调器)</li></ul></li><li>传输系统</li><li>目标系统<ul><li>接收器：解调器(调制解调器)</li><li>终点</li></ul></li></ul><h3 id="通信系统中的术语"><a href="#通信系统中的术语" class="headerlink" title="通信系统中的术语"></a>通信系统中的术语</h3><ul><li>消息(message)：运送消息的实体</li><li>信号(signal)：数据的电气或电磁的表现<ul><li>模拟信号(连续信号)：消息的参数取值是连续的</li><li>数字信号(离散信号)：消息的参数取值是离散的</li></ul></li><li>单向通信(单工通信)：只能有一个方向的通信而没有反方向的交互</li><li>双向交替通信(半双工通信/单工)：双方都可以发送信息，但是双方不能同时发送信息</li><li>双向同时通信(全双工通信)：双方可以同时发送给和接受信息</li><li>基带信号：由源点产生的信号。通常包含有低频甚至直流成分，需要通过调制器进行调制(modulation)</li><li>调制：对基带信号进行的变换<ul><li>基带调制(编码)：仅仅对基带信号的波形进行变换，使它能够与信道特性相适应，变换后仍然是基带信号<ul><li>不归零制：正电平表示1，负电平表示0</li><li>归零制：正脉冲表示1，负脉冲表示0</li><li>曼切斯特编码：周期中心向上跳为0，周期中心向下跳为1</li><li>差分曼切斯特编码：位开始边界有跳位0，没有跳变为1。每个位中间必须进行一次跳变<br><img src="/image/notebook/Computer-network/3.png" alt="编码"></li></ul></li><li>带通调制：使用载波(carrier)进行调制，将基带的信号频率范围搬移到高频率段，并转换为模拟信号(为了达到更高的信息传输速率，通常采用复杂的多元振幅相位混合调制方法QAM)<ul><li>调幅(AM)：载波的振幅随着基带数字信号变化而变化</li><li>调频(FM)：载波的频率随着基带数字信号变化而变化</li><li>调相(PM)：载波的初始相位随基带数字信号变化而变化</li></ul></li></ul></li></ul><h3 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h3><ul><li>信道能够通过的频率范围：在任何信道中，，码元传输的速率是有上线的，传输速率超过此上线，就会出现严重的码间串扰的问题，使接收端对码元的识别称为不可能</li><li>信噪比：所有电子设备和通信信道中，会随机产生噪音。如果信号相对较强，则噪音的影响就相对较小。<script type="math/tex; mode=display">信噪比(dB) = 10 \times log_{10}(\frac{信号的平均功率(S)}{噪音的平均功率(N)}) (dB)</script></li><li>信道极限信息传输速率$C$为<script type="math/tex; mode=display">C = W \times log_2(1 + \frac{S}{N}) (bit/s)</script>其中，$W$ 为信道的带宽(Hz)，$S$ 为信道内所传信号的平均功率，$N$ 信道内部的(高斯)噪音的功率</li></ul><h2 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h2><ul><li>导引型传输媒体：<ul><li>双绞线：屏蔽双绞线，无屏蔽双绞线</li><li>同轴电缆</li><li>光缆<ul><li>单模光纤：纤芯细，光线不会经过多次反射，成本高，传输距离远</li><li>多模光纤：可以同时传输多个光路，容易失真，只适合近距离传输</li></ul></li></ul></li><li>非导引型传输媒体<ul><li>短波</li><li>微波</li><li>卫星</li></ul></li></ul><h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><ul><li>频分复用：所有用户在同样的时间占用不同的带宽（频率带宽）资源</li><li>时分复用：将时间划分为一段段等长的时分复用帧(TDM 帧)。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。每一个用户所占用的时隙是周期性地出现(其周期就是 TDM 帧的长度)。TDM 信号也称为等时(isochronous)信号。时分复用的所有用户是在不同的时间占用同样的频带宽度。</li><li>统计时分复用(提供时分复用的利用率)</li><li>波分复用：光的频分复用。</li><li>码分复用CDM：常用的名词是码分多址 CDMA。各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。每一个比特时间划分为 m 个短的间隔，称为码片(chip)。当码片序列长度为$m$ bit发送的信息的速率为$b$ bit/s，则实际的发送速率要达到$mb$ bit/s。CDMA 的重要特点：每个站分配的码片序列不仅必须各不相同，并且还必须互相正交(orthogonal)。在实用的系统中是使用伪随机码序列。</li></ul><h2 id="数字传输系统"><a href="#数字传输系统" class="headerlink" title="数字传输系统"></a>数字传输系统</h2><p>略</p><h2 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h2><p>略</p><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><p>链路层使用的信道分为两种类型：</p><ul><li>点对点信道：一对一</li><li>广播信道：一对多</li></ul><h2 id="使用点对点信道的数据链路层"><a href="#使用点对点信道的数据链路层" class="headerlink" title="使用点对点信道的数据链路层"></a>使用点对点信道的数据链路层</h2><h3 id="数据链路和帧"><a href="#数据链路和帧" class="headerlink" title="数据链路和帧"></a>数据链路和帧</h3><ul><li>链路(link)：是一条无源的点到点（一个节点到相邻节点）的物理线路段，中间没有任何其他的交换结点。一条链路只是一条通路的一个组成部分。</li><li>数据链路(data link)：除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。最常用的就是网络适配器（即网卡）。</li><li>帧：数据链路层的协议数据单元。数据链路层把网络层交下来的数据打包成帧发送到链路上，以及把接收到的帧中的数据取出并交给网络层</li></ul><h3 id="数据链路层协议"><a href="#数据链路层协议" class="headerlink" title="数据链路层协议"></a>数据链路层协议</h3><h4 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h4><ul><li>在一段数据的前后分别添加首部和尾部，构成一个帧。</li><li>首部和尾部的一个重要作用就是进行帧定界(确定一个帧的界限)。</li><li>每一种链路层协议都规定了所能传送的帧的数据部分长度的上限——最大传送单元(MTU)</li><li>控制字符SOH(Start Of Header)放在一帧的最前面，EOT(End Of Transmission)放在一帧的结束。如果只有SOH没有EOT则丢弃。(SOH = 0x01，EOT = 0x04)</li></ul><h4 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h4><p>由于数据部分也有可能出现 EOT 的字符导致数据链路层会错误的找到帧的边界。若发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”，则在前面插入一个转义字符“ESC”(其十六进制编码是 0x1B)，如果出现了转义字符“ESC”，则再插入一个“ESC”。这种办法称为<strong>字节填充</strong></p><h4 id="差错检验"><a href="#差错检验" class="headerlink" title="差错检验"></a>差错检验</h4><h5 id="CRC-循环冗余检验"><a href="#CRC-循环冗余检验" class="headerlink" title="CRC(循环冗余检验)"></a><font color=red>CRC(循环冗余检验)</font></h5><p>在发送端，先把数据划分为组，每组 $k$ 个比特，将每组的数据用二进制的模2运算进行$2^n$乘的运算，然后在每组数据后添加 $n$ 位冗余码。</p><blockquote><p>假定本组数据为 $M = 101001$，$n = 3$。假定除数$P = 1101(n + 1位)$<br>首先在 $M$ 后添加 $n$ 位 $0$，得到 $2^nM = 101001000$<br>将新得到的值与 $P$ 进行模2除法(进行异或运算，直到最后一位)<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml">        <span class="hljs-number">110101</span> <span class="hljs-string">(商)</span><br>    <span class="hljs-string">+---------</span><br><span class="hljs-number">1101</span><span class="hljs-string">|101001000</span> <span class="hljs-string">(被除数)</span><br>     <span class="hljs-number">1101</span><br>    <span class="hljs-string">----------</span><br>      <span class="hljs-number">1110</span>     <span class="hljs-string">(每次运算使用的是异或运算，而不是减法)</span><br>      <span class="hljs-number">1101</span><br>    <span class="hljs-string">----------</span><br>       <span class="hljs-number">0111</span>    <span class="hljs-string">(每次运算时，如果首位是0，则商为0，如果首位是1，则商为1)</span><br>       <span class="hljs-number">0000</span><br>    <span class="hljs-string">----------</span><br>        <span class="hljs-number">1110</span><br>        <span class="hljs-number">1101</span><br>    <span class="hljs-string">----------</span><br>         <span class="hljs-number">0110</span><br>         <span class="hljs-number">0000</span><br>    <span class="hljs-string">----------</span><br>          <span class="hljs-number">1100</span><br>          <span class="hljs-number">1101</span><br>    <span class="hljs-string">----------</span><br>           <span class="hljs-number">001</span> <span class="hljs-string">(余数R)</span><br></code></pre></td></tr></table></figure><br>将余数$R = 001$添加至 $M$ 后，得到CPC后的结果为 $101001001$</p></blockquote><p>CPC校验只能判断这个帧是否有差错，不能判断哪一位或者哪几位除了差错</p><p>仅用循环冗余检验 CRC 差错检测技术只能做到无差错接受(accept)。</p><p>“无差错接受”是指:“凡是接受的帧(即不包括丢弃的帧)，我们都能以非常接近于 1 的概率认为这些帧在传输过程中没有产生差错”。也就是说:“凡是接收端数据链路层接受的帧都没有传输差错”(有差错的帧就丢弃而不接受)。要做到“可靠传输”(即发送什么就收到什么)就必须再加上确认和重传机制</p><p>在数据后面添加上的冗余码称为帧检验序列 FCS</p><h2 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h2><ul><li>PPP协议的功能<ul><li>简单：这是首要的要求，互操作性提高了</li><li>封装成帧：必须规定特殊字符作为帧定界符</li><li>透明性</li><li>多种网络层协议：同一条物理链路上同时支持多种网络层协议</li><li>多种类型链路</li><li>差错检测</li><li>检测连接状态</li><li>最大传输单元</li><li>网络层地址协商</li><li>数据压缩协商</li></ul></li><li>PPP协议不需要的功能<ul><li>纠错</li><li>流量控制</li><li>序号</li><li>多点线路</li><li>半双工或单工链路</li></ul></li><li>PPP协议的组成<ul><li>一个将IP数据报封装到串行链路的方法</li><li>链路控制协议 LCP(Link Control Protocol)</li><li>网络控制协议 NCP(Network Control Portocol)</li></ul></li><li>PPP协议的帧格式<ul><li>各字段的含义<ul><li>其中，首部的第一个字段和尾部的最后一个字段 F(flag) 都是 <code>0x7E</code>，表示一个帧的开始或结束。</li><li>首部中的地址字段 A 规定为 <code>0xFF</code>，控制字段 C 规定为 <code>0x03</code> 这两个字段并没有携带 PPP 帧的信息</li><li>首部中第四个字段为协议字段，当协议字段为 0x0021 时，PPP 帧的信息字段就是 IP 数据报。若为 0xC021, 则信息字段是 PPP 链路控制数据。若为 0x8021，则表示这是网络控制数据。</li><li><font color=red>信息字段的长度是可变的，不超过 1500 字节</font></li><li>尾部中的第一个字段是用于CRC的帧校验序列FCS</li></ul></li><li>字节填充<ul><li>将信息字段中出现的每一个 <code>0x7E</code> 字节转变成为 2 字节序列(<code>0x7D</code>, <code>0x5E</code>)。</li><li>若信息字段中出现一个 <code>0x7D</code> 的字节，则将其转变成为 2 字节序列(<code>0x7D</code>, <code>0x5D</code>)。</li><li>若信息字段中出现 ASCII 码的控制字符 (即数值小于 <code>0x20</code> 的字符)，则在该字 符前面要加入一个 <code>0x7D</code> 字节，同时将该字符的编码加以改变。例如出现 <code>0x03</code>，则要改为 <code>0x7D</code>，<code>0x23</code></li></ul></li><li>零比特填充：PPP 协议用在 SONET/SDH 链路时，是使用同步传输，这时 PPP 协议采用零比特填充方法来实现透明传输。信息字段每出现5个连续的1，则添加一个0，这样不会产生控制字符<code>F</code>相同的信息部分。<br><img src="/image/notebook/Computer-network/4.png" alt="PPP帧"></li></ul></li><li>PPP协议的工作状态：略</li></ul><h2 id="使用广播信道的数据链路层"><a href="#使用广播信道的数据链路层" class="headerlink" title="使用广播信道的数据链路层"></a>使用广播信道的数据链路层</h2><h3 id="局域网的数据链路层"><a href="#局域网的数据链路层" class="headerlink" title="局域网的数据链路层"></a>局域网的数据链路层</h3><p>共享信道技术：</p><ul><li>静态划分信道</li><li>动态媒体接入控制<ul><li>随机接入</li><li>受控接入</li></ul></li></ul><h3 id="CSMA-CD-协议-Carrier-Sense-Multiple-Access-with-Collision-Detection-载波侦听多路访问-碰撞检测"><a href="#CSMA-CD-协议-Carrier-Sense-Multiple-Access-with-Collision-Detection-载波侦听多路访问-碰撞检测" class="headerlink" title="CSMA/CD 协议(Carrier Sense Multiple Access with Collision Detection 载波侦听多路访问/碰撞检测)"></a><font color=red>CSMA/CD 协议(Carrier Sense Multiple Access with Collision Detection 载波侦听多路访问/碰撞检测)</font></h3><ul><li>以太网<ul><li>所有计算机连接到一根总线上</li><li>采用无连接的工作方式</li><li>差错帧是否需要重传由高层决定</li><li>使用<a href="#通信系统中的术语">曼切斯特编码</a></li></ul></li><li>CSMA/CD 协议<ul><li>多点接入：许多计算机以多点接入的方式连接在一根总线上</li><li>载波监听：用电子技术监听总线上有没有其他计算机在发送数据</li><li>碰撞检测：边发送边监听</li></ul></li></ul><h4 id="截断二进制指数退避"><a href="#截断二进制指数退避" class="headerlink" title="截断二进制指数退避"></a><font color=red>截断二进制指数退避</font></h4><p>当发送的数据包发生碰撞冲突时，以太网使用截断二进制指数退避法</p><ul><li>确定一个争用期时间：以太网把争用期定为 $51.2 \mu s$。<ul><li>早期的以太网的网速为 $10Mbps$，所以在此时间内，计算机总共能够发送 64 字节的数据(512bit)。所以这个时间通常也被叫做512比特时间</li></ul></li><li>当数据包开始发送的 $51.2 \mu s$ 内，如果接收到了其他计算机发送的数据包，则认为此次数据包发生了碰撞，并立即停止数据包的传输。</li><li>发生冲突的双方从 $[0, (2^k - 1)]$ 范围中随机取出一个整数，记为 $r$<script type="math/tex; mode=display">k = min\{重传次数(第一次为1), 10\}</script></li><li>下一次重传的将在 $r$ 倍的争用期</li><li>当重传达到 $16$ 次仍不能成功时，则放弃，并向高层报告</li></ul><blockquote><p>例如，在第1次重传时，k=1，随机数 $r$ 从整数 <script type="math/tex">\{0,1\}</script> 中选一个数。因此重传推迟的时间是0或争用期，在这两个时间中随机选择一个。整数范围的选择为2的k次方个数<br>若再发生碰撞，则重传时，k=2，随机数 $r$ 就从整数 <script type="math/tex">\{0,1,2,3\}</script> 中选一个数。因此重传推迟的时间是在$0, 1, 2, 3$倍的争用期这4个时间中随机抽取一个<br>同样，若在发生碰撞，则重传时k=3，随机数 $r$ 就从整数 <script type="math/tex">\{0,1,2,3,4,5,6,7\}</script> 中选一个数。以此类推</p></blockquote><p>同时，以太网规定了最短的帧长为 64 字节，如果要发送的数据小于此数值，则必须要填入一些字节使得帧长不小于 64 字节。同样，如果发送方发送的帧数据在争用期(64比特)内没有发送碰撞，则后续发送的数据一定不会发生碰撞</p><p>对于接收方，如果接收到的帧小于 64 字节，则可以认为这是由于冲突而异常中止的无效帧</p><p>同时为了使刚刚收到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备，以太网还规定了帧间最小间隔 $9.6 \mu s$</p><h4 id="CSMA-CD-协议要点归纳"><a href="#CSMA-CD-协议要点归纳" class="headerlink" title="CSMA/CD 协议要点归纳"></a>CSMA/CD 协议要点归纳</h4><ul><li>准备发送</li><li>检测信道</li><li>在发送过程中仍不停检测信道<ul><li>发送成功：在争用期内没有检测到碰撞</li><li>发送失败：在争用期内检测到碰撞，立即停止发送数据</li></ul></li></ul><p>以太网每发送一帧，一定要把已发送是帧保留一下，如果在争用期内检测到了碰撞，则此帧需要重传</p><h3 id="使用集线器的星形拓扑"><a href="#使用集线器的星形拓扑" class="headerlink" title="使用集线器的星形拓扑"></a>使用集线器的星形拓扑</h3><p>略</p><h3 id="以太网的信道利用率"><a href="#以太网的信道利用率" class="headerlink" title="以太网的信道利用率"></a>以太网的信道利用率</h3><script type="math/tex; mode=display">S_{max} = \frac{T_0}{T_0 + \tau} = \frac{1}{1+\frac{\tau}{T_0}}</script><script type="math/tex; mode=display">T_0 = \frac{帧长(bit)}{发送速率(bit/s)}</script><h3 id="mac地址"><a href="#mac地址" class="headerlink" title="mac地址"></a>mac地址</h3><p>mac地址是计算机中固化在适配器ROM中的地址，简单来说mac地址由电脑硬件直接决定，<font color=red>长度为 48 位(6 个字节)</font>。制作适配器的厂商通常需要向 IEEE 的 RA 购买 OUI(组织唯一标识符，也可以理解为是mac地址段)</p><h3 id="适配器过滤"><a href="#适配器过滤" class="headerlink" title="适配器过滤"></a>适配器过滤</h3><p>适配器在接收到 mac 帧后，先用硬件检查 mac 帧中的目的地址，如果是发往本站的帧则收下，否则丢弃掉。<br>这里“发往本机的帧”包括以下三种：</p><ul><li>单播(unicast)：一对一</li><li>广播(broadcast)：一对全体</li><li>多播(multicast)：一对多</li></ul><p>一些适配器可以设置为混杂模式，工作在混杂方式的适配器会将以太网上传输的所有帧都接受下来。这样实际上是窃听其他站点的通信</p><h3 id="mac帧格式"><a href="#mac帧格式" class="headerlink" title="mac帧格式"></a>mac帧格式</h3><p><img src="/image/notebook/Computer-network/5.png" alt="mac帧格式"></p><ul><li>前两个字段为目的地址和源地址</li><li>第三个字段为类型字段，用来标志上一层使用的是说明协议。例如为 <code>0x0800</code> 时为 IP 数据报，为 <code>0x8137</code> 为 Novell IPX</li><li>第四个字段为数据段，长度在 46 到 1500 字节(46 = 最短长度 64 字节 - 第一个字段 6 字节 - 第二个字段 6 字节 - 第三个字段 2 字节 - 第五个字段 4 字节)</li><li>第五个字段是帧校验序列 CRC</li><li>将 mac 帧向物理层传输时，还需要在开头加上 7 个字节的前同步码，同步码是由 <code>10</code> 串组成，使得接收端的适配器能够根据同步码的频率来调制时钟频率。和一个字节的帧开始界定符</li></ul><h3 id="无效的-mac-帧"><a href="#无效的-mac-帧" class="headerlink" title="无效的 mac 帧"></a>无效的 mac 帧</h3><ul><li>帧的长度不是整数个字节</li><li>用收到的帧检验序列 FCS 由差错</li><li>收到的帧的 mac 数据字段的长度不在 46-1500 字节之间</li></ul><h2 id="扩展的以太网"><a href="#扩展的以太网" class="headerlink" title="扩展的以太网"></a>扩展的以太网</h2><p>略</p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h2><ul><li>虚电路服务：通过网络层来实现可靠的传输网络协议，面向连接，类似打电话时的连接建立过程</li><li>数据报服务：不提供服务质量的保证，不需要建立连接</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">方面</th><th style="text-align:center">虚电路服务</th><th style="text-align:center">数据报服务(采用的)</th></tr></thead><tbody><tr><td style="text-align:center">思路</td><td style="text-align:center">可靠的通信应当由网络来保证</td><td style="text-align:center">可靠的通信应当由用户主机来保证</td></tr><tr><td style="text-align:center">连接的建立</td><td style="text-align:center">必须有</td><td style="text-align:center">不需要</td></tr><tr><td style="text-align:center">终点的地址</td><td style="text-align:center">仅在建立连接阶段使用，每个分组使用短的虚电路号</td><td style="text-align:center">每个分组都有终点的完整地址</td></tr><tr><td style="text-align:center">分组转发</td><td style="text-align:center">属于同一条虚电路的分组均按照同一路由进行转发</td><td style="text-align:center">每个分组独立选择路由进行转发</td></tr><tr><td style="text-align:center">当结点出现故障时</td><td style="text-align:center">所有通过出故障的结点的虚电路均不能工作</td><td style="text-align:center">出故障的结点可能会丢失分组，一些路由可能会发生变化</td></tr><tr><td style="text-align:center">分组的顺序</td><td style="text-align:center">总是按照顺序到达终点</td><td style="text-align:center">到达终点的顺序不一定按照发送顺序</td></tr><tr><td style="text-align:center">端到端的差错处理和流量控制</td><td style="text-align:center">可以由网络负责，也可以由用户主机负责</td><td style="text-align:center">由用户主机负责</td></tr></tbody></table></div><h2 id="网络协议-IP"><a href="#网络协议-IP" class="headerlink" title="网络协议 IP"></a>网络协议 IP</h2><p>与 IP 协议配套使用的还有三个协议</p><ul><li>ARP(地址解析协议)</li><li>ICMP(网络控制报文协议)</li><li>IGMP(网际组管理协议)</li></ul><h3 id="虚拟互连网络"><a href="#虚拟互连网络" class="headerlink" title="虚拟互连网络"></a>虚拟互连网络</h3><p>网络上使用的中间设备</p><ul><li>物理层：转发器</li><li>数据链路层：网桥</li><li>网络层：路由器</li><li>网络层以上：网关</li></ul><h3 id="分类的-IP-地址"><a href="#分类的-IP-地址" class="headerlink" title="分类的 IP 地址"></a>分类的 IP 地址</h3><p>IP地址有两个固定长度的字段组成，第一个字段为<strong>网络号</strong>，第二个为<strong>主机号</strong>。一个 IP 地址在整个互联网范围内是唯一的，</p><p><img src="/image/notebook/Computer-network/6.png" alt="IP地址分类"></p><ul><li>A类、B类、C类地址的网络号字段分别为1个、2个和3个字节长，而在网络号字段的最前面有 1-3 位的类别位，其数值分别规定位 <code>0</code>、<code>10</code>、<code>110</code></li><li>A类、B类、C类地址的主机号的主机号字段分别为3个、2个、1个字节长</li><li>A类、B类、C类的地址都是单播<a href="#适配器过滤">见适配器过滤</a>地址</li><li>D类地址(前4位是<code>1110</code>)用于多播</li><li>E类地址(前4位是<code>1111</code>)保留为以后用</li></ul><p>IP 地址的指派范围</p><div class="table-container"><table><thead><tr><th style="text-align:center">网络类别</th><th style="text-align:center">最大可以指派的网络数</th><th style="text-align:center">第一个可以指派的网络号</th><th style="text-align:center">最后可以指派的网络号</th><th style="text-align:center">每个网络中的最大主机数</th></tr></thead><tbody><tr><td style="text-align:center">A</td><td style="text-align:center">126($2^{7} - 2$)</td><td style="text-align:center">1</td><td style="text-align:center">126</td><td style="text-align:center">16777214($2^{24} - 2$)</td></tr><tr><td style="text-align:center">B</td><td style="text-align:center">16383($2^{14} - 1$)</td><td style="text-align:center">128.1</td><td style="text-align:center">191.255</td><td style="text-align:center">65534($2^{14} - 1$)</td></tr><tr><td style="text-align:center">C</td><td style="text-align:center">2097151($2^{21} - 1$)</td><td style="text-align:center">192.0.1</td><td style="text-align:center">223.255.255</td><td style="text-align:center">254</td></tr></tbody></table></div><p>特殊的 IP 地址</p><div class="table-container"><table><thead><tr><th style="text-align:center">网络号</th><th style="text-align:center">主机号</th><th style="text-align:center">源地址使用</th><th style="text-align:center">目的地址使用</th><th style="text-align:center">代表的含义</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">可以</td><td style="text-align:center">不可以</td><td style="text-align:center">本网络上的本主机</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">非全0且非全1</td><td style="text-align:center">可以</td><td style="text-align:center">不可以</td><td style="text-align:center">在本网络上的某台主机</td></tr><tr><td style="text-align:center">全1</td><td style="text-align:center">全1</td><td style="text-align:center">不可以</td><td style="text-align:center">可以</td><td style="text-align:center">在本网络上进行广播</td></tr><tr><td style="text-align:center">非全0且非全1</td><td style="text-align:center">全1</td><td style="text-align:center">不可以</td><td style="text-align:center">可以</td><td style="text-align:center">对某个网络上的所有主机进行广播</td></tr><tr><td style="text-align:center">127</td><td style="text-align:center">非全0且非全1</td><td style="text-align:center">可以</td><td style="text-align:center">可以</td><td style="text-align:center">本机</td></tr></tbody></table></div><p>IP 地址的一些特点</p><ul><li>每一个 IP 地址都由网络号和主机号两部分组成</li><li>实际上 IP 地址标志的是一台主机(或路由器)和一条链路的接口</li><li>一个网络指的是具有相同网络号的主机的集合</li><li>在 IP 地址中，所有分配到网络号的网络都是平等的</li><li>同一个局域网上的主机或者路由器的 IP 地址中的网络号必须是一样的</li><li>用网桥(它工作在链路层)互连的网段仍然是一个局域网，网络号必须相同</li><li>路由器总是拥有两个或更多的 IP 地址，即路由器的每一个接口都有一个不同网络号的 IP 地址</li><li>当两个路由器相连时，在接口两端处，可以分配也可以不分配 IP</li></ul><h3 id="IP-地址与硬件地址-mac地址"><a href="#IP-地址与硬件地址-mac地址" class="headerlink" title="IP 地址与硬件地址(mac地址)"></a>IP 地址与硬件地址(mac地址)</h3><ul><li>物理地址/硬件地址/mac 地址是数据链路层和物理层使用的地址，是固定的</li><li>IP 地址是网络层和以上各层使用的地址，是一种逻辑地址</li><li>在 IP 层抽象的互联网上只能看到 IP 数据报。IP 数据报不论转发多少次，其数据报中的 IP 地址始终是源地址和目的地址。</li><li>虽然 IP 数据报首部有源 IP 地址，但是路由器只根据目的站的 IP 地址进行转发</li><li>在链路层，只能看到 mac 帧，IP。数据报倍封装在 mac 帧中，mac 地址在不同网络中时，mac 帧内的源地址和目标地址会发生变化，具体表现为，对于每一次转发，其 mac 帧内的源地址和目标地址都会发生变化</li><li>考虑网络层时，可以是哟个统一的、抽象的 IP 地址来研究主机和主机或者路由器之间的通信</li></ul><h3 id="ARP-地址解析协议"><a href="#ARP-地址解析协议" class="headerlink" title="ARP(地址解析协议)"></a>ARP(地址解析协议)</h3><p>将网络层得到的 IP 地址转为下一跳的 mac 地址的过程(将 IP 地址映射到 mac 地址)</p><ul><li>当主机 A 需要向 主机 B 发送 IP 数据报时，首先根据主机 B 的 IP 的地址，在本机的 ARP 缓存中寻找是否有主机 B 的 IP 地址，如果有，则可以获取主机 B 的 mac 地址</li><li>如果没有主机 B 的 IP，则向本局域网上广播一个 ARP 请求</li><li>在本局域网上的所有主机运行的 ARP 进程都收到此 ARP 请求</li><li>ARP 进程查询本机的 IP 是否与请求的 IP 相同，如果相同，则向主机 A 发送 ARP 响应</li><li>主机 A 收到主机 B 的 ARP 响应后，将此 mac 地址和 IP 写入 ARP 缓存</li></ul><p>为什么<font color=red><strong>不直接使用 mac 地址进行通信</strong></font></p><p>全世界存在各种各样的异构网络，它们使用不同的硬件地址(网络的异构性体现），要使这些异构网络能够进行通信，就需要非常复杂的硬件地址转换工作，因此由用户主机来完成这件事几乎是不可能的，使用统一的IP地址，就使得所有的主机都在同一个IP网络内进行通信。</p><p>mac地址不具备归属地特征，不能作为地址</p><p>为什么<font color=red><strong>不直接使用 IP 地址进行通信</strong></font></p><ol><li>因为并非每个主机都一个公网IP,很多主机都是使用的内网IP，依据NAT对外访问</li><li>IP地址是动态变化的</li></ol><h3 id="IP-数据报的格式"><a href="#IP-数据报的格式" class="headerlink" title="IP 数据报的格式"></a>IP 数据报的格式</h3><p><img src="/image/notebook/Computer-network/7.png" alt="IP 数据报格式"></p><ul><li>版本：占 4 位，指 IP 协议的版本。目前广泛使用的协议为 4 (即 IPv4)</li><li>首部长度：占 4 位，可表示最大十进制数值是 15，单位是 4 字节(32位)。首部长度必须是 4 字节的倍数。由于首部至少为 20 字节，所以首部长度至少为 5</li><li>区分服务：占 8 位，用来获得更好的服务。一般情况下不使用这个字段</li><li>总长度：占 16 位，指首部和数据之和的长度，单位是字节。所以数据报的最长长度位 65535 字节。通常是极少遇到的</li><li>标识：占 16 位，一个存在于 IP 软件中的计数器，每产生一个数据报，计数器就加一，并把此值赋给标识字段。当数据报因为过长而分片时，多个分片的标识符相同，便于接收方进行组装</li><li>标志：占 3 位，但是目前只有两位有意义<ul><li>MF(More Fragment)，最低位：MF = 1表示后面还有分片</li><li>DF(Don`t Fragment)，中间位：DF = 1表示不能分片</li></ul></li><li>片偏移：占13位，较长的数据报分片后，此片在原分组中的相对位置(不是序号)，以 8 个字节位单位。每个分片的长度也一定是 8 个字节的整数倍<blockquote><p>例如，一个数据报长度为 3820 字节，数据部分为 3800 字节，20字节的首部。分为 1400、1400、1000 四个片段，则每个片段的首部的偏移分别为 0、175($1400/8$)、350($2800/8$)</p></blockquote></li><li>生存时间(TTL)：占 8 位，当此数据报经过一次路由器时，TTL 会被减去1，当 TTL 等于 0 时，此数据报就会被丢弃</li><li>协议：表示数据报的协议类型。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">常见的协议</th><th style="text-align:center">ICMP</th><th style="text-align:center">IGMP</th><th style="text-align:center">IP(一种特殊的数据报)</th><th style="text-align:center">TCP</th><th style="text-align:center">UDP</th><th style="text-align:center">IPv6</th></tr></thead><tbody><tr><td style="text-align:center">协议字段值</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">4</td><td style="text-align:center">6</td><td style="text-align:center">17</td><td style="text-align:center">41</td></tr></tbody></table></div><ul><li>首部检验和：占 16 位。仅检验数据报首部的数据是否正确</li><li>源地址：占 32 位</li><li>目的地址：占 32 位</li><li>可变字段：很少被用到</li></ul><h3 id="IP-层的转发分组的流程"><a href="#IP-层的转发分组的流程" class="headerlink" title="IP 层的转发分组的流程"></a>IP 层的转发分组的流程</h3><ul><li>从数据报的首部提取目标主机的 IP 地址 D，得出目的网络地址位 N</li><li>若 N 就是与此路由器直接相连的某个网络地址，则直接交付</li><li>若路由表中有目的地址位 D 的特定主机路由，则将数据报交给下一跳的路由器</li><li>若路由表中有到达网络 N 的路由，则将数据报交给下一跳的路由器</li><li>若路由表中有默认的路由，则将数据报交给默认路由</li><li>报告分组出错</li></ul><h2 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h2><p>由于两级 IP 地址不够灵活，于是 IP 地址从原来的两级结构改为了通过子网掩码划分网络的 CIDR (无分类域间路由选择)模式，即 IP + 子网掩码的方式，不再有 A类、B类、C类的划分</p><p>即</p><script type="math/tex; mode=display">IP = 网络前缀 + 主机号</script><script type="math/tex; mode=display">网络前缀 = IP \space \& 子网掩码</script><p>通常可以使用“斜线记法”来表示 IP，即在 IP 地址后加上斜线，并写上网络前缀所占的位数</p><blockquote><p>例如 IP = 128.14.35.7/20 表示 128.14.35.7 的前 20 位作为网络前缀，剩下的作为主机号。即网络前缀为：128.14.32.0</p></blockquote><h3 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h3><p>由于使用了变长的子网掩码，导致路由表中会出现多个匹配的结果，此时应当选择匹配结果中具有最长网络前缀的路由</p><h3 id="子网的划分方法"><a href="#子网的划分方法" class="headerlink" title="子网的划分方法"></a>子网的划分方法</h3><ul><li>将需要的划分网络出的网络分割为最小的单元</li><li>不断合并最小单元，直到满足最大的网络</li><li>重复上述操作，直到所有网络都满足</li></ul><blockquote><p>例如，一个自治系统内有 5 个局域网，该自治系统分配到的 IP 地址块为 <code>218.75.230.0/24</code> 将此网络划分为 5 个子网，每个子网的设备数如下：9、28、15、13、4<br>首先将所有的子网的设备数加2后，向上取整至2的幂次倍数，然后再将所有值分割为最小值的 $k$ 次倍，假定最小值为 $2^n$，这里取 $n = 3$</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">ID</th><th style="text-align:center">设备数</th><th style="text-align:center">加2后</th><th style="text-align:center">取整后</th><th style="text-align:center">分割后</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">9</td><td style="text-align:center">11</td><td style="text-align:center">16</td><td style="text-align:center">2个8</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">28</td><td style="text-align:center">30</td><td style="text-align:center">32</td><td style="text-align:center">4个8</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">15</td><td style="text-align:center">17</td><td style="text-align:center">32</td><td style="text-align:center">4个8</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">13</td><td style="text-align:center">15</td><td style="text-align:center">16</td><td style="text-align:center">2个8</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">4</td><td style="text-align:center">6</td><td style="text-align:center">8</td><td style="text-align:center">1个8</td></tr></tbody></table></div><blockquote><p>总计需要 13 个 长度为 8 的子网<br>由于 IP 地址块为 <code>218.75.230.0/24</code>，即可以分配的位数为 $t = 32 - 24 = 8$ 位的字符，相当于可以划分出 $2^{t - n} = 32$ 个子网，每个子网可以容纳 $6$ 台设备，此时掩码为 <code>255.255.255.248</code> <script type="math/tex">248 = \begin{matrix}\underbrace{11111} \\ t个1 \end{matrix} \space \begin{matrix}\underbrace{000} \\ n个0 \end{matrix} = 11111000 = 248</script><br>可以分割整个 IP 地址块得到</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">ID</th><th style="text-align:center">网络号</th><th style="text-align:center">掩码</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">218.75.230.0</td><td style="text-align:center">255.255.255.248</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">218.75.230.8</td><td style="text-align:center">255.255.255.248</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">218.75.230.16</td><td style="text-align:center">255.255.255.248</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">218.75.230.24</td><td style="text-align:center">255.255.255.248</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">218.75.230.32</td><td style="text-align:center">255.255.255.248</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">218.75.230.40</td><td style="text-align:center">255.255.255.248</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">218.75.230.48</td><td style="text-align:center">255.255.255.248</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">218.75.230.56</td><td style="text-align:center">255.255.255.248</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">218.75.230.64</td><td style="text-align:center">255.255.255.248</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">218.75.230.72</td><td style="text-align:center">255.255.255.248</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">218.75.230.80</td><td style="text-align:center">255.255.255.248</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">218.75.230.88</td><td style="text-align:center">255.255.255.248</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">218.75.230.96</td><td style="text-align:center">255.255.255.248</td></tr></tbody></table></div><blockquote><p>由于只需要 13 个子网，这里只罗列出前 13 个，实际上可以罗列出 32 个<br>按照设备数排序后划分子网得到（注意，合并后，掩码也要合并）</p></blockquote><div class="table-container"><table><thead><tr><th style="text-align:center">ID</th><th style="text-align:center">设备数</th><th style="text-align:center">加2后</th><th style="text-align:center">取整后</th><th style="text-align:center">分割后</th><th style="text-align:center">子网号</th><th style="text-align:center">子网掩码</th></tr></thead><tbody><tr><td style="text-align:center">2</td><td style="text-align:center">28</td><td style="text-align:center">30</td><td style="text-align:center">32</td><td style="text-align:center">4个8</td><td style="text-align:center">218.75.230.0</td><td style="text-align:center">255.255.255.224</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">15</td><td style="text-align:center">17</td><td style="text-align:center">32</td><td style="text-align:center">4个8</td><td style="text-align:center">218.75.230.32</td><td style="text-align:center">255.255.255.224</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">13</td><td style="text-align:center">15</td><td style="text-align:center">16</td><td style="text-align:center">2个8</td><td style="text-align:center">218.75.230.64</td><td style="text-align:center">255.255.255.240</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">9</td><td style="text-align:center">11</td><td style="text-align:center">16</td><td style="text-align:center">2个8</td><td style="text-align:center">218.75.230.80</td><td style="text-align:center">255.255.255.240</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">4</td><td style="text-align:center">6</td><td style="text-align:center">8</td><td style="text-align:center">1个8</td><td style="text-align:center">218.75.230.96</td><td style="text-align:center">255.255.255.248</td></tr></tbody></table></div><h2 id="ICMP-网际控制报文协议-互联网控制消息协议"><a href="#ICMP-网际控制报文协议-互联网控制消息协议" class="headerlink" title="ICMP(网际控制报文协议/互联网控制消息协议)"></a>ICMP(网际控制报文协议/互联网控制消息协议)</h2><p>它用于网际协议（IP）中发送控制消息，提供可能发生在通信环境中的各种问题反馈。通过这些信息，使管理者可以对所发生的问题作出诊断，然后采取适当的措施解决</p><p><img src="/image/notebook/Computer-network/8.png" alt="ICMP报文格式"></p><p>ICMP报文类型</p><div class="table-container"><table><thead><tr><th style="text-align:center">报文类型</th><th style="text-align:center">类型值</th><th style="text-align:center">种类</th></tr></thead><tbody><tr><td style="text-align:center">终点不可达</td><td style="text-align:center">3</td><td style="text-align:center">差错报告报文</td></tr><tr><td style="text-align:center">时间超过</td><td style="text-align:center">11</td><td style="text-align:center">差错报告报文</td></tr><tr><td style="text-align:center">参数问题</td><td style="text-align:center">12</td><td style="text-align:center">差错报告报文</td></tr><tr><td style="text-align:center">改变路由</td><td style="text-align:center">5</td><td style="text-align:center">差错报告报文</td></tr><tr><td style="text-align:center">回送请求和回答</td><td style="text-align:center">8或0</td><td style="text-align:center">询问报文</td></tr><tr><td style="text-align:center">时间戳请求和回答</td><td style="text-align:center">13或14</td><td style="text-align:center">询问报文</td></tr></tbody></table></div><p>不应发送 ICMP 差错报文的类型</p><ul><li>对 ICMP 差错报告报文，不再发送 ICMP 差错报告报文</li><li>对非第一个分片的数据报片，不发送 ICMP 差错报告报文</li><li>对具有多播地址的数据报，不发送 ICMP 差错报告报文</li><li>对具有特殊地址的数据报(127.0.0.0或0.0.0.0)，不发送 ICMP 差错报告报文</li></ul><h3 id="ICMP-的应用"><a href="#ICMP-的应用" class="headerlink" title="ICMP 的应用"></a>ICMP 的应用</h3><ul><li>PING：ping 使用了 ICMP 回送请求与回送回答报文，ping 没有通过 TCP 或者 UDP</li><li>traceroute：路由跟踪，利用了 ICMP 时间超过，通过设置 TTL 来发送一系列报文，获取源主机和目标主机之间的路由线路</li></ul><h2 id="互联网的路由选择协议"><a href="#互联网的路由选择协议" class="headerlink" title="互联网的路由选择协议"></a>互联网的路由选择协议</h2><p>路由表中的路由是如何动态更新获取的</p><h3 id="理想的路由算法"><a href="#理想的路由算法" class="headerlink" title="理想的路由算法"></a>理想的路由算法</h3><ul><li>算法必须是正确的完整的</li><li>算法在计算上应简单</li><li>算法应能适应通信量和网络拓扑的变化</li><li>算法应具有稳定性</li><li>算法应是公平的</li><li>算法应是最佳的</li></ul><h3 id="分层次的路由选择协议"><a href="#分层次的路由选择协议" class="headerlink" title="分层次的路由选择协议"></a>分层次的路由选择协议</h3><ul><li>内部网关协议IGP：在一个小的网络系统(AS)内的路由协议，常见的有 RIP和OSPF协议</li><li>外部网关协议EGP：不同网络系统内的路由协议，目前使用的最多的是 BGP 的版本4(BGP-4)</li></ul><h3 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h3><p>一个基于距离向量的路由选择协议</p><p>距离指的是跳数，每经过一次路由器则跳数加一，相邻的路由器的跳数为1，跳数最多为 15，超过 15 表示不可达。</p><p>RIP 协议会按照固定的时间间隔和相邻的路由器交换自己的路由表，经过若干次交换后，所有路由器都会得到当前网络中任意一个网络的最优的下一跳路由器地址</p><p>算法逻辑：</p><ul><li>对于来自地址为 X 的相邻路由器发送来的 RIP 报文，先将报文中的所有项目中的下一跳地址都改为 X，然后将所有的距离字段都加一</li><li>对于新的报文中的每一项，假定其目的网络为 N，距离为 d<ul><li>如果自己的路由表中没有目标网络为 N 的，则直接加入到自己的路由表中（从没有数据到有数据）</li><li>如果有目标网络为 N 的，且下一跳地址为 X 的，则直接替换此项（更新原来旧的数据）</li><li>如果有目标网络为 N 的，且下一跳地址不为 X 的，则用 d 与其进行比较，选择距离小的写入路由表（选择最优的）</li></ul></li><li>若一段时间内(3分钟)没有收到相邻的路由器的 RIP 包，则视为此路由器不可达，把其距离设定为 16</li></ul><p><img src="/image/notebook/Computer-network/9.png" alt="RIP报文格式"></p><p>RIP的报文由首部和路由部分组成</p><ul><li>首部：占 4 个字节，其中的命令字段指出报文的意义，1 表示请求路由信息，2 对请求的路由信息的响应或未被请求而发出的路由更新报文。首部后面的全 0 用于凑足 4 个字节，对齐</li><li>路由部分：路由部分由若干个路由信息组成，每个路由信息需要 20 个字节，最多一次可以传输 25 个路由信息<ul><li>协议标记(地址族标识符、地址类别)表示所使用的地址协议，如果采用 IP 地址则此字段为 2</li><li>路由标记填入自治系统号 ASN(此字段考虑的是如果非 RIP 路由器发送的信息时，可以进行区别)</li><li>网络地址</li><li>子网掩码</li><li>下一跳的路由器地址</li><li>度量值：到此网络的距离</li></ul></li></ul><p>RIP 协议的优点：实现简单，开销小，使用 UDP<br>RIP 协议的问题：但是 RIP 能使用的最大距离为 15，限制了网络的规模。当网络出现故障时，要经过比较长的时间才能将此信息传递到所有的路由器(好消息传播得快，坏消息传播的慢)</p><h3 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h3><p>开放最短路径优先协议</p><p>使用分布式的链路状态协议，所有路由器都拥有整个网络的拓扑结构图</p><ul><li>使用洪泛法向本网络中的所有路由器发送信息</li><li>发送的信息是本路由器相邻的所有路由器的链路状态，以及该链路的度量（费用、距离、时延、带宽等）</li><li>只有链路状态发生变化时，路由器才向所有路由器发送此信息</li></ul><p>特点</p><ul><li>所有路由器最终都能获得本网络中的整个路由器拓扑图</li><li>链路状态路由器更新速度快，收敛快</li></ul><p>有时为了能够解决大型网络拓扑图太大的问题，OSPF 可以将网络划分为多个不同的区域，每个路由器仅知道本区域内的拓扑情况，区域之间通过区域边界路由器进行交互</p><p>OSPF 不使用 UDP 而是直接用 IP 数据报传送，减少信息的通信量</p><p><img src="/image/notebook/Computer-network/10.png" alt="OSPF报文结构"></p><ul><li>版本：当前的版本号为 2</li><li>类型<ul><li>问候(Hello)：用来发现和维持邻站的可达性，每隔 10 秒钟交换一次，如果 40 秒内没有发生交换，则认为此路由器不可达，更新数据库并且向其他路由器进行报告</li><li>数据库描述(Database Description)：向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息</li><li>链路状态请求(Link State Request)：向对方请求发送某些链路状态项目的详细信息</li><li>链路状态更新(Link State Update)：用洪泛法对全网更新</li><li>链路状态确认(Link State Acknowledgment)：对链路更新的确认</li></ul></li><li>分组长度：包括 OSPF 首部在内的分组长度，以字节为单位</li><li>路由器标识符：标志发送该分组的路由器的接口的 IP 地址</li><li>区域标识符：分组属于的区域的标识符</li><li>检验和：用来检测分组中的出错</li><li>鉴别类型：目前只有两种，0 和 1</li><li>鉴别：鉴别类型为 0 时就填入 0，鉴别类型为 1 则填入 8 个字节的口令</li></ul><p>OSPF的特点</p><ul><li>允许管理员给每条线路指派不同的代价，使得 OSPF 相对灵活</li><li>如果到达同一个网络有多条相同代价的路径，那么可以将通信量分配给这几条路径，使得负载平衡</li><li>所有在 OSPF 路由器之间交换的分组都具有鉴别的功能，保证了仅在可信赖的路由器之间交换链路状态信息</li><li>OSPF 支持可变长度的子网划分和无分类的编址 <a href="#划分子网">CIDR</a></li><li>由于网络中的链路状态经常发生变化，所以链路状态会带上一个 32 位的序号，序号越大状态越新</li></ul><h3 id="BGP"><a href="#BGP" class="headerlink" title="BGP"></a>BGP</h3><p>边界网关协议(BGP)采用路径向量(path vector)路由选择协议。协议交换路由信息节点数量级是自治系统个数的数量级。刚开始运行时，BGP的邻站是交换整个的BGP路由表。但以后只需要在发生变化时更新有变化的部分。</p><p><img src="/image/notebook/Computer-network/11.png" alt="ISP"></p><ul><li>标记：16字节长，用来鉴别收到的 BGP 报文。若不适用鉴别时，应当全为 1</li><li>长度：包括通用首部在内的整个 BGP 报文的长度，以字节为单位</li><li>类型<ul><li>OPEN：打开，用来和另一个 BGP 路由器建立关系</li><li>UPDATE：更新，用来通知某一路由的信息，以及列出要撤销的多条路由</li><li>KEEPALIVE：保活，用来周期性验证邻站的连通性</li><li>NOTIFICATION：通知，用来发送检测到的错误</li></ul></li><li>报文：<ul><li>OPEN<ul><li>版本：1字节，现在为 4</li><li>本自治系统号：2字节，全球唯一</li><li>保持时间：2字节</li><li>BGP 标识符：4个字节，通常为此路由器的 IP 地址</li><li>可选参数长度：1字节</li><li>可选参数</li></ul></li><li>UPDATE<ul><li>不可行路由长度：2字节</li><li>撤销的路由</li><li>路径属性总长度：2字节</li><li>路径属性</li><li>网络层可达性信息(NLRI)</li></ul></li><li>KEEPALIVE：无报文部分</li><li>NOTIFICATION<ul><li>差错代码：1字节</li><li>差错子代码：1字节</li><li>差错数据</li></ul></li></ul></li></ul><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>路由选择和分组转发</p><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><font color=red>IPv6 的长度为 128 位，而 IPv4 仅 32 位</font><p>IPv4至IPv6的变化：</p><ul><li>更大的地址空间</li><li>扩展的地址层次结构</li><li>灵活的首部格式</li><li>改进的选项</li><li>允许的协议继续扩充</li><li>支持即插即用，不需要 DHCP 进行 IP 分配</li><li>支持资源的预分配</li><li>IPv6 首部改为 8 字节对齐</li></ul><h2 id="IP-多播"><a href="#IP-多播" class="headerlink" title="IP 多播"></a>IP 多播</h2><p>实现一对多通信，主机只需要发送一个数据报，路由器负责复制数据报</p><ul><li>在目的地址中使用多播的标识符(D类地址)，来标识一个多播组</li><li>尽最大努力交付，不保证一定能交付</li><li>首部中的协议字段值为 2，表示使用 IGMP(网际组管理协议)</li><li>不产生 ICMP 差错报文</li><li>无法 Ping 通</li></ul><h3 id="IGMP"><a href="#IGMP" class="headerlink" title="IGMP"></a>IGMP</h3><p>略</p><h2 id="虚拟专用网络-VPN-和网络地址转换-NAT"><a href="#虚拟专用网络-VPN-和网络地址转换-NAT" class="headerlink" title="虚拟专用网络(VPN)和网络地址转换(NAT)"></a>虚拟专用网络(VPN)和网络地址转换(NAT)</h2><p>IP 地址中有一部分被指定为专有地址。当使用的是专有地址时，说明此地址并非是互联网上的地址，而是本地局域网(专用网)内的地址</p><ul><li><code>10.0.0.0</code> 至 <code>10.255.255.255</code></li><li><code>172.16.0.0</code> 至 <code>172.31.255.255</code></li><li><code>192.168.0.0</code> 至 <code>192.168.255.255</code></li></ul><h3 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h3><p>由于这些地址是专有地址，无法直接在互联网上访问到，所以可以使用 VPN 技术来实现内网的访问。VPN的数据在互联网段是加密数据，所以效果上和真正的专用网一样。</p><ul><li>内联网：两个地区的专用网进行连接</li><li>远程接入VPN：在互联网上的主机访问在专用网内的主机</li></ul><h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><p>每个专用网拥有至少一个互联网的 IP 地址，当专用网内的主机需要和互联网通信时，通过此专用网的 IP 地址和不同端口来临时当作主机的 IP，实现对互联网的访问</p><h2 id="多协议标志交换-MPLS"><a href="#多协议标志交换-MPLS" class="headerlink" title="多协议标志交换(MPLS)"></a>多协议标志交换(MPLS)</h2><p>略</p><h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><h2 id="运输层的协议概述"><a href="#运输层的协议概述" class="headerlink" title="运输层的协议概述"></a>运输层的协议概述</h2><h3 id="进程之间的通信"><a href="#进程之间的通信" class="headerlink" title="进程之间的通信"></a>进程之间的通信</h3><p>运输层使得两台主机之间的交互细化到应用程序的进程</p><p>运输层的一个很重要的功能：复用和分用</p><ul><li>复用：发送方不同的应用进程都可以使用同一个运输层协议传输数据</li><li>分用：接收方的运输层在剥去报文的首部后，能够把这些数据正确交付目的应用程序</li></ul><h3 id="两个主要协议"><a href="#两个主要协议" class="headerlink" title="两个主要协议"></a>两个主要协议</h3><ul><li>UDP(用户数据报协议)：不需要连接，不提供可靠交互。但在某些情况下却是一种最有效的工作方式</li><li>TCP(传输控制协议)：在传输数据之前必须先建立连接，数据传送结束后，要释放连接，不提供广播或多播服务。提供可靠的、面向连接的运输服务，增加了许多开销</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">应用</th><th style="text-align:center">应用层协议</th><th style="text-align:center">运输层协议</th></tr></thead><tbody><tr><td style="text-align:center">名字转换</td><td style="text-align:center">DNS(域名服务器)</td><td style="text-align:center">UDP</td></tr><tr><td style="text-align:center">文件传送</td><td style="text-align:center">TFTP(简单文件传送协议)</td><td style="text-align:center">UDP</td></tr><tr><td style="text-align:center">路由选择协议</td><td style="text-align:center">RIP(路由信息协议)</td><td style="text-align:center">UDP</td></tr><tr><td style="text-align:center">IP 地址配置</td><td style="text-align:center">DHCP(动态主机配置协议)</td><td style="text-align:center">UDP</td></tr><tr><td style="text-align:center">网络管理</td><td style="text-align:center">SNMP(简单网络管理协议)</td><td style="text-align:center">UDP</td></tr><tr><td style="text-align:center">远程文件服务器</td><td style="text-align:center">NFS(网络文件系统)</td><td style="text-align:center">UDP</td></tr><tr><td style="text-align:center">IP 电话</td><td style="text-align:center">专用协议</td><td style="text-align:center">UDP</td></tr><tr><td style="text-align:center">流式多媒体通话</td><td style="text-align:center">专用协议</td><td style="text-align:center">UDP</td></tr><tr><td style="text-align:center">多播</td><td style="text-align:center">IGMP(网际组管理协议)</td><td style="text-align:center">UDP</td></tr><tr><td style="text-align:center">电子邮件</td><td style="text-align:center">SMTP(简单邮件传送协议)</td><td style="text-align:center">TCP</td></tr><tr><td style="text-align:center">远程终端接入</td><td style="text-align:center">TELNET(远程终端协议)</td><td style="text-align:center">TCP</td></tr><tr><td style="text-align:center">万维网</td><td style="text-align:center">HTTP(超文本传送协议)</td><td style="text-align:center">TCP</td></tr><tr><td style="text-align:center">文件传送</td><td style="text-align:center">FTP(文件传送协议)</td><td style="text-align:center">TCP</td></tr></tbody></table></div><h3 id="运输层的端口"><a href="#运输层的端口" class="headerlink" title="运输层的端口"></a>运输层的端口</h3><p>将不同的应用程序绑定至不同的端口，通过端口来区别不同的应用程序。系统同时拥有 65535 个不同的端口</p><ul><li>服务器端使用的端口号<ul><li>熟知端口号：数值范围为 0-1023 的端口</li><li>登记端口号：数值范围在 1024-49151 的端口</li></ul></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">应用程序</th><th style="text-align:center">端口号</th></tr></thead><tbody><tr><td style="text-align:center">FTP</td><td style="text-align:center">21</td></tr><tr><td style="text-align:center">TELNET</td><td style="text-align:center">23</td></tr><tr><td style="text-align:center">SMTP</td><td style="text-align:center">25</td></tr><tr><td style="text-align:center">DNS</td><td style="text-align:center">53</td></tr><tr><td style="text-align:center">TFTP</td><td style="text-align:center">69</td></tr><tr><td style="text-align:center">HTTP</td><td style="text-align:center">80</td></tr><tr><td style="text-align:center">SNMP</td><td style="text-align:center">161</td></tr><tr><td style="text-align:center">SNMP(trap)</td><td style="text-align:center">162</td></tr><tr><td style="text-align:center">HTTPS</td><td style="text-align:center">443</td></tr></tbody></table></div><ul><li>客户端使用的端口号：数值范围为 49152-65535 临时的端口号</li></ul><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h3 id="UDP-概述"><a href="#UDP-概述" class="headerlink" title="UDP 概述"></a>UDP 概述</h3><ul><li>UDP 是无连接的</li><li>UDP 尽最大的努力交付</li><li>UDP 是面向报文的</li><li>UDP 没有拥塞控制</li><li>UDP 支持一对一、一对多、多对一、多对多的交互通信</li><li>UDP 的首部开销小</li></ul><h3 id="UDP-的首部格式"><a href="#UDP-的首部格式" class="headerlink" title="UDP 的首部格式"></a>UDP 的首部格式</h3><p><img src="/image/notebook/Computer-network/12.png" alt="UDP首部格式"></p><ul><li>源端口：源端口号。需要对方回信时使用，不需要时可全为 0</li><li>目的端口：目的端口号。这在终点交付报文时必须使用</li><li>长度：UDP 用户数据报的长度，其最小值为 8（仅有首部）</li><li>检验和：检验 UDP 用户数据报在传输中是否有错</li></ul><h2 id="TCP-传输控制协议"><a href="#TCP-传输控制协议" class="headerlink" title="TCP(传输控制协议)"></a>TCP(传输控制协议)</h2><h3 id="TCP特点"><a href="#TCP特点" class="headerlink" title="TCP特点"></a>TCP特点</h3><ul><li>面向连接的运输层协议</li><li>每条 TCP 只能连接两个端点，即{(IP1, 端口1), (IP2，端口2)}</li><li>提供可靠交付的服务</li><li>提供全双工通信</li><li>面向字节流</li></ul><h2 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h2><ul><li>超时重传：当发送端发送的数据后，需要等待接收端发送确认收到报告，如果在一段时间内没有收到确认收到报告，则重新发送数据</li><li>暂存已发送的副本：发送端发送了一个分组后，需要暂时保留已发送的分组的副本，同时对所有分组和确认分组进行编号，只有在收到了对应的编号的确认，才可以删除此副本</li><li>确认迟到：当收到重复的分组时，需要丢弃，但仍然需要向发送端发送确认收到</li><li>滑动窗口协议：可以连续发送多个分组，每收到一个请求就可以将滑动窗口向前滑动。而接收方采用累积确认，对按序到达的最后一个分组进行确认，不再对所有有分组进行确认</li></ul><p>以上的逻辑称为自动重传请求(ARQ)</p><h2 id="TCP-报文段的首部格式"><a href="#TCP-报文段的首部格式" class="headerlink" title="TCP 报文段的首部格式"></a>TCP 报文段的首部格式</h2><p><img src="/image/notebook/Computer-network/13.png" alt="TCP首部格式"></p><p><em>TCP报文段首部的前20个字节是固定的</em></p><ul><li>源端口和目的端口：各占2个字节，表示源端口号和目的端口号，与 UDP 相似</li><li>序号：占4个字节，表示当前数据部分中，第一个字节在整个数据流中的位置</li><li>确认号：占4个字节，是期望收到对方下一个报文段的第一个数据字节的序号。若确认号为 N，则序号 N - 1 为止的所有数据都已经收到了</li><li>数据偏移：占4位，表示TCP首部的长度，单位为 32 位(4字节)，最大值为 15，所以TCP首部最大为 60 字节</li><li>保留：占6位，保留为今后使用，但目前为0</li><li>Flag标记：占6位<ul><li>URG(紧急)：表示此数据应当紧急发送</li><li>ACK(确认)：在建立连接后的所有报文段都必须把 ACK 置为 1</li><li>PSH(推送)：很少使用，希望对方的应用程序尽快处理</li><li>RST(复位)：释放连接，拒绝打开连接</li><li>SYN(同步)：和 ACK 一起配合来实现连接的建立和释放</li><li>FIN(终止)：释放连接</li></ul></li><li>窗口：占2个字节，表示发送本报文的主机的接受数据缓存空间，指明了现在允许对方发送的数据量</li><li>检验和：占2个字节，检验和字段检验的范围包括首部和数据</li><li>紧急指针：占2个字节，仅 URG 为 1 时有意义，指出本报文段中紧急的数据字节数</li><li>选项：长度可变，最长为 40 字节，且必须是 4 字节的整数倍<ul><li>MSS：数据字段长度，默认为 536 字节</li></ul></li></ul><h2 id="TCP-可靠传输的实现"><a href="#TCP-可靠传输的实现" class="headerlink" title="TCP 可靠传输的实现"></a>TCP 可靠传输的实现</h2><h3 id="以字节为单位的滑动窗口"><a href="#以字节为单位的滑动窗口" class="headerlink" title="以字节为单位的滑动窗口"></a>以字节为单位的滑动窗口</h3><p><img src="/image/notebook/Computer-network/14.png" alt="TCP窗口"></p><p>TCP 的滑动窗口是以字节为单位的，滑动窗口内的所有数据包会一次性发送出去，窗口内的数据表示已经发送但是未被确认。假定主机 A 收到的来自主机 B 的确认包的 ACK 为 36，那么滑动窗口将会前移至 36</p><h3 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h3><p>基于 <a href="#往返时间-RTT">RTT</a>，定义一个值 <script type="math/tex">RTT_S</script>，此值基于新的 RTT 不断更新，更新公式如下：</p><script type="math/tex; mode=display">RTT_S = (1 - \alpha) \times (RTT_S) + \alpha \times RTT</script><p>通常 $\alpha = 0.125$</p><p>所以定义超时重传时间</p><script type="math/tex; mode=display">RTO = RTT_S + 4 \times RTT_D</script><p>其中 $RTT_D$ 为 $RTT$ 的偏差的加权平均值，其公式如下</p><script type="math/tex; mode=display">\begin{cases}RTT_D = RTT / 2，第一次 \\RTT_D = (1 - \beta) \times RTT_D + \beta \times |RTT_S - RTT|, 后续的情况\end{cases}</script><p>通常 $\beta = 0.25$</p><h3 id="选择确认-SACK"><a href="#选择确认-SACK" class="headerlink" title="选择确认 SACK"></a>选择确认 SACK</h3><p>略</p><h2 id="TCP-流量控制"><a href="#TCP-流量控制" class="headerlink" title="TCP 流量控制"></a>TCP 流量控制</h2><p>TCP 流量控制让发送方发送速率不要太快，要让接收方有足够的缓存来接受数据</p><p><img src="/image/notebook/Computer-network/15.png" alt="TCP流量控制"></p><p>如图中所示，通过 TCP 数据结构中的窗口，实现双方的流量的控制。接收方(R)在发送确认包的同时，将当前的缓存空间发送给发送方(T)，使得双方能够控制传输的速度。而当程序将收到的数据读出后，再将新的空间剩余发送给发送方</p><p>TCP 零窗口死锁：当图片中第五个数据包因为意外丢失时，发送方(T) 一直在等待接收方(R) 发送的新的窗口信息，而接收方(R)也一直在等待发送方(T)发送新的数据，导致了死锁<br>解决办法：为每个连接设有一个持续计时器。当连接的一方收到对方的零窗口通知时，就启动计时器，在计时器到达一定的时间内，就发送一个零窗口探测报文段，而对方如果再次回复零窗口，则重置计时器，如果回复的不是零窗口，则死锁解开</p><h3 id="TCP-的传输效率"><a href="#TCP-的传输效率" class="headerlink" title="TCP 的传输效率"></a>TCP 的传输效率</h3><p>略</p><h2 id="TCP-拥塞控制"><a href="#TCP-拥塞控制" class="headerlink" title="TCP 拥塞控制"></a>TCP 拥塞控制</h2><p>拥塞控制就是防止过多的数据注入到网络中，这样可以使得网络中的路由器或链路不致过载。</p><p>主要是两类控制：</p><ul><li>开环控制：在设计网络时就将有关拥塞的因素考虑周全，力求网络在工作时不会产生拥塞</li><li>闭环控制<ul><li>基于反馈环路，监测网络系统以便在检测到拥塞在何时何处发生</li><li>把拥塞的信息传送到可采取行动的地方</li><li>调整网络的运行以解决出现的问题</li></ul></li></ul><h3 id="实现拥塞控制的四个方法"><a href="#实现拥塞控制的四个方法" class="headerlink" title="实现拥塞控制的四个方法"></a>实现拥塞控制的四个方法</h3><h4 id="慢开始"><a href="#慢开始" class="headerlink" title="慢开始"></a>慢开始</h4><ul><li>发送方设定一个发送窗口(cwnd)，即每次发送的数据不能大于发送窗口的数据(可以认为是 TCP 的滑动窗口)</li><li>开始时，发送窗口的大小设定为一个很小的值</li><li>每当发送方收到一个来自接收方的确认包时，就增大此窗口的大小</li><li>每当出现拥塞(超时)时，就将此窗口再次调整为很小的初始值</li></ul><h4 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h4><ul><li>设定一个窗口的极大值(ssthresh)，当窗口的大小超过此极大值时，无论接受到多少个确认包，每次缓慢的增加窗口大小</li><li>出现拥塞时，将此极大值设置为当前窗口的一半</li></ul><h4 id="快重传"><a href="#快重传" class="headerlink" title="快重传"></a>快重传</h4><ul><li>要求接收方不论收到什么数据，都要发送确认包，确认包只确认连续的数据包的最后一项</li><li>发送方遇到连续三次相同的确认，但是没有出现确认超时的情况(收到了确认但是并非是正确的确认信息)，则认为在网络中出现了丢失数据包的情况，则立刻进行重传丢失的数据包</li></ul><h4 id="快恢复"><a href="#快恢复" class="headerlink" title="快恢复"></a>快恢复</h4><ul><li>在出现只丢失部分数据包的情况下，即出现快重传的情况时，不会将窗口设置为初始值，而是仅仅将窗口的大小减半，同时极大值设置为当前窗口的一半</li></ul><p><img src="/image/notebook/Computer-network/16.png" alt="TCP拥塞控制1"></p><p><img src="/image/notebook/Computer-network/17.png" alt="TCP拥塞控制2"></p><p><em>图中，0-1的过程为慢开始，1-2的过程即为拥塞避免，2-3的过程中出现了数据包确认超时，4-5的过程中发生了快重传和快恢复</em></p><h2 id="TCP-的运输连接管理"><a href="#TCP-的运输连接管理" class="headerlink" title="TCP 的运输连接管理"></a>TCP 的运输连接管理</h2><p>连接的三个阶段</p><ul><li>连接建立</li><li>数据传送</li><li>连接释放</li></ul><p>三个问题</p><ul><li>要使每一方能够确知对方的存在</li><li>要允许双方协商一些参数</li><li>能够对运输实体资源进行分配</li></ul><h3 id="TCP-的连接建立"><a href="#TCP-的连接建立" class="headerlink" title="TCP 的连接建立"></a>TCP 的连接建立</h3><p><img src="/image/notebook/Computer-network/18.png" alt="TCP三次握手"></p><ul><li>客户端(A) 和 服务器(B) 都处于 CLOSED(关闭) 状态</li><li>B 创建传输控制模块，进入 LISTEN(收听) 状态</li><li>A 创建传输控制模块，向 B 发送TCP连接请求，此报文中 SYN=1，且 seq=J，A 进入 SYN-SENT(同步已发送)</li><li>B 接收到请求，如果同意建立连接，则向 A 发送数据包，此报文中 SYN=1，ACK=1，且 ack=J+1，seq=K，进入 SYN-RCVD(同步收到)</li><li>A 收到 B 的确认后，再次给 B 发送确认数据包，此报文中 ACK=1，且ack=K+1，进入 ESTABLISHED(已建立连接)</li><li>B 收到 A 的确认后，也进入 ESTABLISHED(已建立连接)</li></ul><h3 id="TCP-的连接释放"><a href="#TCP-的连接释放" class="headerlink" title="TCP 的连接释放"></a>TCP 的连接释放</h3><p>略</p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="DNS-域名服务器"><a href="#DNS-域名服务器" class="headerlink" title="DNS(域名服务器)"></a>DNS(域名服务器)</h2><ul><li>功能：将域名转换为 IP 地址</li><li><p>域名结构：从域名的最后一个单词开始，通过 <code>.</code> 来分割，表示了“顶级域名”、“二级域名”、“三级域名”。例如对于域名：<code>mail.google.com</code>，顶级域名为：<code>com</code>，二级域名：<code>google</code>，三级域名：<code>mail</code>。无论域名内容是什么，一定是按照此逻辑进行分配。例如域名：<code>mail.zjgsu.edu.cn</code>的顶级域名为：<code>cn</code>，二级域名为：<code>edu</code>，三级域名为：<code>zjgsu</code>，四级域名：<code>mail</code></p><p>DNS 的<font color=red>递归</font>查询过程见<a href="https://hukeqing.github.io/2020/12/26/notebook/Computer-network-experiment/#%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%9C%8D%E5%8A%A1-DNS">计算机网络实验复习</a></p></li></ul><p>递归是用户只向本地DNS服务器发出请求，然后等待肯定或否定答案。而迭代是本地服务器向根DNS服务器发出请求，而根DNS服务器只是给出下一级DNS服务器的地址，然后本地DNS服务器再向下一级DNS发送查询请求直至得到最终答案</p><h2 id="FTP-文件传送协议"><a href="#FTP-文件传送协议" class="headerlink" title="FTP(文件传送协议)"></a>FTP(文件传送协议)</h2><p>提供文件的交互式访问</p><ul><li>语序客户指明文件的类型与格式</li><li>允许文件具有存储权限</li><li>输入有效的口令</li><li>屏蔽了各计算机系统的细节</li></ul><h3 id="TFTP-简单文件传送协议"><a href="#TFTP-简单文件传送协议" class="headerlink" title="TFTP(简单文件传送协议)"></a>TFTP(简单文件传送协议)</h3><p>略</p><h2 id="TELNET-远程终端协议"><a href="#TELNET-远程终端协议" class="headerlink" title="TELNET(远程终端协议)"></a>TELNET(远程终端协议)</h2><p>明文的远程终端协议，<font color=red>目前通常使用 ssh(Secure Shell 加密的网络传输协议) 来代替 TELNET</font></p><h2 id="WWW-万维网"><a href="#WWW-万维网" class="headerlink" title="WWW(万维网)"></a>WWW(万维网)</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>明文传输的超文本传输协议，由于是明文传输，很容易受到中间人攻击，植入广告</p><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>加密传输的超文本传输协议，不会被中间人攻击</p><h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><h3 id="SMTP-简单邮件传送协议"><a href="#SMTP-简单邮件传送协议" class="headerlink" title="SMTP(简单邮件传送协议)"></a>SMTP(简单邮件传送协议)</h3><h3 id="IMAP和POP3-邮件接受协议"><a href="#IMAP和POP3-邮件接受协议" class="headerlink" title="IMAP和POP3(邮件接受协议)"></a>IMAP和POP3(邮件接受协议)</h3><div class="table-container"><table><thead><tr><th style="text-align:center">操作位置</th><th style="text-align:center">操作内容</th><th style="text-align:center">IMAP</th><th style="text-align:center">POP3</th></tr></thead><tbody><tr><td style="text-align:center">收件箱</td><td style="text-align:center">阅读、标记、移动、删除等操作</td><td style="text-align:center">客户端与邮件更新同步</td><td style="text-align:center">仅在客户端内</td></tr><tr><td style="text-align:center">发件箱</td><td style="text-align:center">保存到已发送</td><td style="text-align:center">客户端与邮件更新同步</td><td style="text-align:center">仅在客户端内</td></tr><tr><td style="text-align:center">创建文件夹</td><td style="text-align:center">新建自定义文件夹</td><td style="text-align:center">客户端与邮件更新同步</td><td style="text-align:center">仅在客户端内</td></tr><tr><td style="text-align:center">草稿</td><td style="text-align:center">保存草稿</td><td style="text-align:center">客户端与邮件更新同步</td><td style="text-align:center">仅在客户端内</td></tr><tr><td style="text-align:center">垃圾文件夹</td><td style="text-align:center">接受并移入垃圾文件夹的邮件</td><td style="text-align:center">客户端与邮件更新同步</td><td style="text-align:center">仅在客户端内</td></tr><tr><td style="text-align:center">广告邮件</td><td style="text-align:center">接受并移入广告邮件夹的邮件</td><td style="text-align:center">客户端与邮件更新同步</td><td style="text-align:center">仅在客户端内</td></tr></tbody></table></div><h2 id="DHCP-动态主机配置协议"><a href="#DHCP-动态主机配置协议" class="headerlink" title="DHCP(动态主机配置协议)"></a>DHCP(动态主机配置协议)</h2><p>见<a href="https://hukeqing.github.io/2020/12/26/notebook/Computer-network-experiment/#%E5%8A%A8%E6%80%81%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE%E5%8D%8F%E8%AE%AE-DHCP">计算机网络实验复习</a></p><h1 id="重点总结"><a href="#重点总结" class="headerlink" title="重点总结"></a>重点总结</h1><ul><li><a href="#IPv6">IPv6长度为128位</a></li><li><a href="#CSMA-CD-协议-Carrier-Sense-Multiple-Access-with-Collision-Detection-载波侦听多路访问-碰撞检测">CSMACD载波侦听多路访问/碰撞检测</a></li><li><a href="#TELNET-远程终端协议">比 TELNET 更好的远程终端协议——SSH</a></li><li><a href="#电子邮件">发送邮件的协议为SMTP，接受为IMAP和POP3</a></li><li><a href="#物理层下面的传输媒体">光纤分为单模光纤和多模光纤</a></li><li><a href="#截断二进制指数退避">最短帧长</a></li><li><a href="#DNS-域名服务器">给出域名问主机名</a></li><li><a href="#数据链路层协议">最大传输单元MTU=1500字节</a></li><li><a href="#通信系统中的术语">曼切斯特编码</a></li><li><a href="#截断二进制指数退避">截断二进制指数退避算法</a></li><li><a href="#ARP-地址解析协议">ARP</a></li><li><a href="#ICMP-网际控制报文协议-互联网控制消息协议">ICMP</a></li><li><a href="#点对点协议PPP">零比特填充</a></li><li><a href="#WWW-万维网">浏览器访问植入广告原理</a></li><li><a href="#DNS-域名服务器">DNS解析过程</a></li><li><a href="#互联网的路由选择协议">路由表的构建</a></li><li><a href="#ARP-地址解析协议">为什么不使用mac地址作为通信地址</a></li><li><a href="#子网的划分方法">网络划分子网</a></li><li><a href="#IP-数据报的格式">IP数据报结构</a></li><li><a href="#可靠传输的工作原理">TCP可靠的实现</a></li><li><a href="#TCP-的连接建立">TCP三次握手</a></li><li>安全的 web 协议——HTTPS</li><li>不同 vlan 之间通讯需要第三层交换机</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>课程</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次 Navicat 连接 MySQL 一直报认证错误(Access denied)</title>
    <link href="/2021/01/01/develop-note/mysql-reset/"/>
    <url>/2021/01/01/develop-note/mysql-reset/</url>
    
    <content type="html"><![CDATA[<p><em>今天一时兴起，想在 WSL2 里下个 MySQL。方法也很简单，直接 <code>sudo apt install mysql-server</code></em><br><em>本来以为顺风顺水，结果却在 Navicat 连接 MySQL 的操作上出事了</em></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>Navicat 无法连接上 MySQL</p><h3 id="配置情况"><a href="#配置情况" class="headerlink" title="配置情况"></a>配置情况</h3><p>Navicat Premium 15.0.19<br>MySQL 8.0.22<br>WSL2(Ubuntu 20)</p><h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p>终端可以通过<code>sudo mysql</code>连上 MySQL<br>终端不可以通过<code>mysql -u root -p</code>的方式连接，显示密码错误(<code>Access denied for user &#39;root&#39;@&#39;localhost&#39;</code>)<br>终端可以通过默认用户连接(默认用户为 <code>/etc/mysql/debian.cnf</code> 文件中的 <code>debian-sys-maint</code>，密码为安装MySQL时随机生成得到的)<br>Navicat不可以通过直接连接或者通过 ssh 的方式连接，显示密码错误(<code>Access denied for user &#39;root&#39;@&#39;localhost&#39;</code>)<br>Navicat可以通过默认用户连接</p><h3 id="经过"><a href="#经过" class="headerlink" title="经过"></a>经过</h3><h4 id="尝试1"><a href="#尝试1" class="headerlink" title="尝试1"></a>尝试1</h4><p>首先是尝试了百度的结果，重置 MySQL 的 root 账户的密码<br>因为可以通过<code>sudo mysql</code>直接进入数据库，也就不需要那么多百度出来的奇奇怪怪的操作了<br>直接进入数据库，然后尝试了下面几行代码<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">use mysql;<br>alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;newPassword&#x27;;<br>exit<br></code></pre></td></tr></table></figure></p><p>然后，测试<code>mysql -u root -p</code>连接——<strong>失败</strong></p><h4 id="尝试2"><a href="#尝试2" class="headerlink" title="尝试2"></a>尝试2</h4><p>后来在MySQL官网找到了重置root密码的方法，然后赶紧拿来测试<br><a href="https://dev.mysql.com/doc/refman/8.0/en/resetting-permissions.html">官网链接</a><br>其中的一点提到</p><blockquote><p>B.3.3.2.2 Resetting the Root Password: Unix and Unix-Like Systems</p></blockquote><p>大致操作就是先终止 MySQL，然后使用 MySQL 的附加参数来设置一个初始化文件，然后使得 MySQL 去运行此文件。</p><p>然后，测试<code>mysql -u root -p</code>连接——<strong>失败</strong></p><p>其实觉得挺奇怪的，既然都能重启 MySQL 了，说明你已经拿到这个设备的 root 权限了，为什么不直接用 <code>sudo mysql</code> 进入直接run这条命令呢？</p><h4 id="尝试3"><a href="#尝试3" class="headerlink" title="尝试3"></a>尝试3</h4><p>最终我在一份不起眼的博客上找到了解决方案<br><a href="https://phoenixnap.com/kb/access-denied-for-user-root-localhost">博客连接</a><br>其中提到了一个很重要的命令<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;insert_password&#x27;;<br></code></pre></td></tr></table></figure></p><blockquote><p>This command changes the password for the user root and sets the authentication method to mysql_native_password. This is a traditional method for authentication, and it is not as secure as auth_plugin.</p></blockquote><p>其中的<code>mysql_native_password</code>是所谓的传统验证方案，也就是 Navicat 连接 MySQL 的解决方案</p><p>然后将方案1的命令稍作改正得到<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">use mysql;<br>alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified with mysql_native_password by &#x27;newPassword&#x27;;<br>exit<br></code></pre></td></tr></table></figure></p><p>然后，测试<code>mysql -u root -p</code>连接——<strong>成功！</strong></p><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>mysql5.8开始将caching_sha2_password作为默认的身份验证插件，该caching_sha2_password和 sha256_password认证插件提供比mysql_native_password插件更安全的密码加密 ，并 caching_sha2_password提供了比更好的性能sha256_password。由于这些优越的安全性和性能特性 caching_sha2_password它是MySQL 8.0首选的身份验证插件，而且也是默认的身份验证插件而不是 mysql_native_password。此更改会影响服务器和libmysqlclient 客户端库；<font color=red>目前来说和经常使用的客户端软件兼容性不好</font>。</p><p>这也是导致目前 Navicat 无法连接到 MySQL 5.8及以后版本的原因。当然如此操作后的影响便是无法直接使用<code>sudo mysql</code>的方式连接到数据库，只能通过 <code>mysql -u root -p</code>的传统密码验证的方式来登陆</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>短笔记</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络实验复习</title>
    <link href="/2020/12/26/notebook/Computer-network-experiment/"/>
    <url>/2020/12/26/notebook/Computer-network-experiment/</url>
    
    <content type="html"><![CDATA[<h1 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h1><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><p>A类线(T568A)颜色：白绿/绿/白橙/蓝/白蓝/橙/白棕/棕<br>B类线(T568B)颜色：白橙/橙/白绿/蓝/白蓝/绿/白棕/棕</p><h2 id="线"><a href="#线" class="headerlink" title="线"></a>线</h2><p>分为两种线：直连线和交叉线</p><p>直连线：线的两端使用的是相同类的线，即同时使用A类或者B类<br>交叉线：线的两端使用的是不同的线，一段为A类，一段为B类</p><h3 id="为什么有两种不同的线"><a href="#为什么有两种不同的线" class="headerlink" title="为什么有两种不同的线"></a>为什么有两种不同的线</h3><p>输入口和输出口的区别</p><p>如果使用的是直连线，则一段的输入端和另一端输入端的位置相同<br>而使用的是交叉线，则一段的输入端和另一端输入端的位置不同</p><h3 id="使用时间"><a href="#使用时间" class="headerlink" title="使用时间"></a>使用时间</h3><p>当一段为交换机，另一端不为交换机时，使用直连线<br>其他情况均使用交叉线</p><h1 id="动态主机配置协议-DHCP"><a href="#动态主机配置协议-DHCP" class="headerlink" title="动态主机配置协议(DHCP)"></a>动态主机配置协议(DHCP)</h1><p>用户利用有线或无线方式随机接入局域网，获得由DHCP服务器分配的临时IP地址</p><h2 id="分配过程"><a href="#分配过程" class="headerlink" title="分配过程"></a>分配过程</h2><ul><li>借助UDP协议、广播方式向局域网中所有DHCP服务器67端口发送DHCP搜索信息(DHCPDISCOVER)</li><li>每个DHCP服务器收到广播请求后回应一个有效IP地址，并对该IP地址进行锁定(DHCPOFFER)</li><li>客户机接受第一个回应的IP地址，并广播通知所有DHCP服务器确认接受。除分配该IP地址的服务器外，其他服务器解除对准备分配的IP地址的锁定，放回地址池(DHCPREQUEST)</li><li>被选中的DHCP服务器收到确认信息后，以广播方式答复确认信息(DHCPACK)</li></ul><h2 id="终止DHCP租借"><a href="#终止DHCP租借" class="headerlink" title="终止DHCP租借"></a>终止DHCP租借</h2><ul><li>超过服务器配置中所设置的时间，DHCP租借自动过期</li><li>未超过服务器配置中所设置的时间，客户机的TCP/IP配置中可进行手动终止。</li></ul><h1 id="域名解析服务-DNS"><a href="#域名解析服务-DNS" class="headerlink" title="域名解析服务(DNS)"></a>域名解析服务(DNS)</h1><p>域名解析系统，以符号名字代替纯数字（IP地址）对计算机进行标识。例如，将www.baidu.com解析为36.152.44.95</p><h2 id="域名分级"><a href="#域名分级" class="headerlink" title="域名分级"></a>域名分级</h2><p>例如：www.baidu.com<br>一级域名为：com<br>二级域名为：baidu<br>三级域名为：www</p><p>每一级域名的解析服务器(DNS)都知道其下一级域名的服务器的IP，同时也知道根服务器的IP</p><h2 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h2><ul><li>客户机（PC）向首选DNS服务器发起请求：“你知道www.baidu.com的IP吗？”如果首选DNS服务器知道（一般如果首选DNS服务器曾经解析过，那么会进行一段时间内的缓存，默认三天，如果正好在缓存时间内，那么首选服务器就会知道这个域名的IP）那么首选DNS 服务器就会直接给客户机返回域名的IP 地址</li><li>若首选DNS 服务器上没有相关信息，就不能直接返回域名的IP 地址，这时候，首选DNS 服务器就会去询问根DNS服务器（所有的 DNS 服务器都知道全球的 13 台DNS根服务器在哪里），根服务器可能不知道这个具体的 www.baidu.com 的IP地址，但是它知道一级域 com 的DNS服务器的IP（也就是说根服务器只负责维护所有的一级域，所以也就几百条数据在这里，虽然数据量少，但是它接受来自全球的请求，所以负载也很大）</li><li>根服务器将 com 的DNS服务器的IP地址返回给首选 DNS 服务器</li><li>首选DNS服务器再去请求 “com” DNS服务器：“你知道 www.baidu.com 的IP吗”，但是com DNS服务器也不知道 www.baidu.com 的IP，但是com 的DNS服务器知道 baidu.com 的IP</li><li>“com” 的DNS服务器将这个信息返回给首选 DNS 服务器</li><li>首选DNS服务器再去请求 “baidu.com” DNS服务器，这时候 baidu.com 服务器当然就会知道 www.baidu.com的IP地址</li><li>“baidu.com”DNS服务器将这个信息返回给首选DNS 服务器</li><li>首选DNS服务器将获取到的 www.baidu.com 的IP返回给客户机</li><li>客户机根据获取到的 www.baidu.com 的IP地址来访问WEB服务器</li><li>WEB服务器返回相关的数据</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">请求发起者</th><th style="text-align:center">请求接受者</th><th style="text-align:center">询问内容</th><th style="text-align:center">询问结果</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">PC</td><td style="text-align:center">默认DNS服务器</td><td style="text-align:center">www.baidu.com</td><td style="text-align:center">暂时不回答</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">默认DNS服务器</td><td style="text-align:center">根服务器</td><td style="text-align:center">www.baidu.com</td><td style="text-align:center">com的DNS服务器的IP</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">默认DNS服务器</td><td style="text-align:center">com 的DNS服务器</td><td style="text-align:center">www.baidu.com</td><td style="text-align:center">baidu.com 的DNS服务器的IP</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">默认DNS服务器</td><td style="text-align:center">baidu.com 的DNS服务器</td><td style="text-align:center">www.baidu.com</td><td style="text-align:center">www.baidu.com的IP</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">默认DNS服务器</td><td style="text-align:center">PC</td><td style="text-align:center"></td><td style="text-align:center">回答序号1的询问，即返回www.baidu.com的IP</td></tr></tbody></table></div><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ul><li>缓存：将查找到的新域名解析结果置于本地缓存，以提高域名解析响应速度</li><li>复制：根服务器存在多个副本，为客户机请求提供最快速的响应</li></ul><h1 id="Internet服务管理器-IIS"><a href="#Internet服务管理器-IIS" class="headerlink" title="Internet服务管理器(IIS)"></a>Internet服务管理器(IIS)</h1><h2 id="Web访问过程"><a href="#Web访问过程" class="headerlink" title="Web访问过程"></a>Web访问过程</h2><ul><li>输入想要访问的网站的域名或者IP</li><li>DNS 解析网站的域名得到 IP</li><li>访问对方的 IP 的80端口找到对方的 web 服务器上的对应的网页</li><li>将网页下载到本地</li><li>浏览器渲染页面并显示出来</li></ul><h2 id="FTP访问过程"><a href="#FTP访问过程" class="headerlink" title="FTP访问过程"></a>FTP访问过程</h2><ul><li>输入想要访问的FTP的域名或者IP</li><li>DNS 解析网站的域名得到 IP</li><li>访问对方的 IP 的21端口找到对方的 FTP 服务器上的对应的文件夹</li><li>打开FTP站点目录</li></ul><h1 id="交换机-Switch"><a href="#交换机-Switch" class="headerlink" title="交换机(Switch)"></a>交换机(Switch)</h1><p>工作在OSI参考模型的第二层，即数据链路层</p><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">名称</th><th style="text-align:center">举例</th></tr></thead><tbody><tr><td style="text-align:center">7</td><td style="text-align:center">应用层</td><td style="text-align:center">HTTP</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">表示层</td><td style="text-align:center">JPEG</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">会话层</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">传输层</td><td style="text-align:center">TCP</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">网络层</td><td style="text-align:center">IP</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">数据链路层</td><td style="text-align:center">mac</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">物理层</td></tr></tbody></table></div><p>通常交换机只能看到数据包的mac地址，并不知道数据包所要发往的IP地址</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="mac地址"><a href="#mac地址" class="headerlink" title="mac地址"></a>mac地址</h3><ul><li>mac 地址与电脑硬件(网卡)有关</li><li>是网卡的硬件地址，全球唯一</li></ul><h3 id="mac地址表"><a href="#mac地址表" class="headerlink" title="mac地址表"></a>mac地址表</h3><p>存放物理地址与交换机端口映射关系的数据库</p><h2 id="交换机工作原理"><a href="#交换机工作原理" class="headerlink" title="交换机工作原理"></a>交换机工作原理</h2><h3 id="数据转发"><a href="#数据转发" class="headerlink" title="数据转发"></a>数据转发</h3><ul><li>数据包信息到达交换机</li><li>交换机根据数据包中封装的目的主机的MAC地址信息查找MAC地址表，同时根据源主机MAC地址信息更新自己的MAC地址表<ul><li>如果表中存在该目的主机的MAC地址，则从其对应的端口将数据包发送出去</li><li>如果表中不存在该目的主机的MAC地址，则将该数据包被<font color=red>泛洪</font>到所有端口</li></ul></li><li>目的主机PC2接收到数据包后，回复响应数据包给PC1，该过程与PC1发送数据包给PC2类似，但此时，PC2是源主机，PC1是目的主机</li><li>当PC2发送的响应数据包到达交换机时，交换机在转发数据包的同时，根据源主机MAC地址更新MAC地址表（在2.2的情况下，即在MAC地址表中添加一条PC2的MAC地址信息——MAC地址自动<font color=red>学习</font>）<h3 id="自动老化功能"><a href="#自动老化功能" class="headerlink" title="自动老化功能"></a>自动老化功能</h3></li><li>存在于MAC地址表中的MAC地址，如果长时间没有从该MAC地址收到包，则该MAC地址将被删除</li><li>当再次收到该MAC地址发送的包时，把该包作为广播包处理，重新学习</li></ul><h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><p>交换机向MAC地址X转发数据包</p><h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><p>交换机收到一个数据包，查表后发现该数据包的来源地址与目的地址属于同一网段。交换机将不处理该数据包</p><p>如果交换机的每个端口都只连接一台 PC，那么交换机会正常进行转发而不会进行过滤</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><div class="note note-warning">            <p>所有<font color=green>绿色</font>内容都为需要根据实际情况填写</p>          </div><div class="table-container"><table><thead><tr><th style="text-align:center">原状态</th><th style="text-align:center">新状态</th><th style="text-align:center">命令</th></tr></thead><tbody><tr><td style="text-align:center">用户模式</td><td style="text-align:center">特权模式</td><td style="text-align:center">enable</td></tr><tr><td style="text-align:center">特权模式</td><td style="text-align:center">全局配置模式</td><td style="text-align:center">configure terminal</td></tr><tr><td style="text-align:center">全局配置模式</td><td style="text-align:center">接口配置模式</td><td style="text-align:center">interface fa0/<font color=green>1</font></td></tr><tr><td style="text-align:center">全局配置模式</td><td style="text-align:center">多个接口配置模式</td><td style="text-align:center">interface range fa0/<font color=green>1</font> - <font color=green>10</font></td></tr><tr><td style="text-align:center">全局配置模式</td><td style="text-align:center">Vlan配置模式</td><td style="text-align:center">interface vlan <font color=green>1</font></td></tr><tr><td style="text-align:center">(多个)接口配置模式/Vlan配置模式</td><td style="text-align:center">全局配置模式</td><td style="text-align:center">exit</td></tr><tr><td style="text-align:center">全局配置模式</td><td style="text-align:center">特权模式</td><td style="text-align:center">exit</td></tr><tr><td style="text-align:center">特权模式</td><td style="text-align:center">用户模式</td><td style="text-align:center">exit</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">模式</th><th style="text-align:center">用途</th><th style="text-align:center">命令行开头最后显示标志</th></tr></thead><tbody><tr><td style="text-align:center">用户模式</td><td style="text-align:center">实验课上无用</td><td style="text-align:center">&gt;</td></tr><tr><td style="text-align:center">特权模式</td><td style="text-align:center"><font color=red>查看</font>设备信息时使用</td><td style="text-align:center">#</td></tr><tr><td style="text-align:center">全局配置模式</td><td style="text-align:center"><font color=red>设置</font>设备信息时使用</td><td style="text-align:center">(config)#</td></tr></tbody></table></div><h2 id="交换机的命令列表"><a href="#交换机的命令列表" class="headerlink" title="交换机的命令列表"></a>交换机的命令列表</h2><h3 id="特权模式下"><a href="#特权模式下" class="headerlink" title="特权模式下"></a>特权模式下</h3><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">show mac-address-table</td><td style="text-align:center">查看mac地址表</td></tr><tr><td style="text-align:center">show aging-time</td><td style="text-align:center">查看自动老化时间</td></tr><tr><td style="text-align:center">show vlan brief</td><td style="text-align:center">查看 vlan 列表</td></tr></tbody></table></div><h3 id="全局配置模式"><a href="#全局配置模式" class="headerlink" title="全局配置模式"></a>全局配置模式</h3><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">hostname <font color=green>新的名字</font></td><td style="text-align:center">修改交换机名称</td></tr><tr><td style="text-align:center">mac-address-table static <font color=green>mac</font> vlan <font color=green>1</font> interface fa0/<font color=green>1</font></td><td style="text-align:center">新增一条静态路由绑定</td></tr><tr><td style="text-align:center">no mac-address-table static <font color=green>mac</font> vlan <font color=green>1</font> interface fa0/<font color=green>1</font></td><td style="text-align:center">删除一条静态路由绑定</td></tr><tr><td style="text-align:center">vlan <font color=green>1</font></td><td style="text-align:center">新建/配置一个Vlan</td></tr><tr><td style="text-align:center">no vlan <font color=green>1</font></td><td style="text-align:center">删除一个Vlan</td></tr><tr><td style="text-align:center">ip routing</td><td style="text-align:center">启用路由功能(仅三层交换机)</td></tr></tbody></table></div><h3 id="配置模式"><a href="#配置模式" class="headerlink" title="配置模式"></a>配置模式</h3><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">switchport mode access</td><td style="text-align:center">设置端口为普通端口</td></tr><tr><td style="text-align:center">switchport mode trunk</td><td style="text-align:center">设置端口为 trunk 口</td></tr><tr><td style="text-align:center">switchport access vlan <font color=green>1</font></td><td style="text-align:center">将端口设定为 vlan 1</td></tr><tr><td style="text-align:center">ip address <font color=green>IP</font> <font color=green>掩码</font></td><td style="text-align:center">设置当前Vlan的IP(仅在Vlan配置模式下使用，仅三层交换机可用)</td></tr></tbody></table></div><h1 id="路由器-Router"><a href="#路由器-Router" class="headerlink" title="路由器(Router)"></a>路由器(Router)</h1><h2 id="网络段计算公式"><a href="#网络段计算公式" class="headerlink" title="网络段计算公式"></a>网络段计算公式</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">IP <span class="hljs-meta">&amp; 掩码</span><br></code></pre></td></tr></table></figure><blockquote><p>例如，IP为192.168.1.1，掩码为255.255.255.0<br>则其网络段为<br><code>11000000.10101000.00000001.00000001 &amp;</code><br><code>11111111.11111111.11111111.00000000 =</code><br><code>11000000.10101000.00000001.00000000</code><br>即，网络段为：192.168.1.0</p></blockquote><p>交换机只能交换同一个网络段的数据包，不能交换不同网络段的数据包</p><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><div class="table-container"><table><thead><tr><th style="text-align:center">原状态</th><th style="text-align:center">新状态</th><th style="text-align:center">命令</th></tr></thead><tbody><tr><td style="text-align:center">用户模式</td><td style="text-align:center">特权模式</td><td style="text-align:center">enable</td></tr><tr><td style="text-align:center">特权模式</td><td style="text-align:center">全局配置模式</td><td style="text-align:center">configure terminal</td></tr><tr><td style="text-align:center">全局配置模式</td><td style="text-align:center">接口配置模式</td><td style="text-align:center">interface fa0/<font color=green>0</font></td></tr><tr><td style="text-align:center">全局配置模式</td><td style="text-align:center">子接口配置模式</td><td style="text-align:center">interface fa0/<font color=green>0</font>.<font color=green>1</font></td></tr><tr><td style="text-align:center">子接口配置模式</td><td style="text-align:center">全局配置模式</td><td style="text-align:center">exit</td></tr><tr><td style="text-align:center">接口配置模式</td><td style="text-align:center">全局配置模式</td><td style="text-align:center">exit</td></tr><tr><td style="text-align:center">全局配置模式</td><td style="text-align:center">特权模式</td><td style="text-align:center">exit</td></tr><tr><td style="text-align:center">特权模式</td><td style="text-align:center">用户模式</td><td style="text-align:center">exit</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">模式</th><th style="text-align:center">用途</th><th style="text-align:center">命令行开头最后显示标志</th></tr></thead><tbody><tr><td style="text-align:center">用户模式</td><td style="text-align:center">实验课上无用</td><td style="text-align:center">&gt;</td></tr><tr><td style="text-align:center">特权模式</td><td style="text-align:center"><font color=red>查看</font>设备信息时使用</td><td style="text-align:center">#</td></tr><tr><td style="text-align:center">全局配置模式</td><td style="text-align:center"><font color=red>设置</font>设备信息时使用</td><td style="text-align:center">(config)#</td></tr><tr><td style="text-align:center">接口配置模式</td><td style="text-align:center"><font color=red>设置</font>单个具体的端口使用</td><td style="text-align:center">(config-if)#</td></tr></tbody></table></div><h2 id="路由器命令列表"><a href="#路由器命令列表" class="headerlink" title="路由器命令列表"></a>路由器命令列表</h2><h3 id="特权模式下-1"><a href="#特权模式下-1" class="headerlink" title="特权模式下"></a>特权模式下</h3><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">show interface</td><td style="text-align:center">查看路由器端口信息</td></tr><tr><td style="text-align:center">show ip route</td><td style="text-align:center">查看路由信息</td></tr></tbody></table></div><h3 id="全局配置模式-1"><a href="#全局配置模式-1" class="headerlink" title="全局配置模式"></a>全局配置模式</h3><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">hostname <font color=green>新的名字</font></td><td style="text-align:center">修改路由器名称</td></tr><tr><td style="text-align:center">ip route <font color=green>目标网段</font> <font color=green>掩码</font> <font color=green>下一个跳转的IP地址</font></td><td style="text-align:center">设置静态路由转发</td></tr></tbody></table></div><h3 id="配置模式-1"><a href="#配置模式-1" class="headerlink" title="配置模式"></a>配置模式</h3><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">ip address <font color=green>IP</font> <font color=green>掩码</font></td><td style="text-align:center">设置路由器的此端口的IP和掩码</td></tr><tr><td style="text-align:center">no shutdown</td><td style="text-align:center">启用此端口</td></tr><tr><td style="text-align:center">encapsulation dot1Q <font color=green>Vlan号</font></td><td style="text-align:center">封装802.1Q(进入子端口的时候，封装此协议可以为此子端口设置IP)</td></tr></tbody></table></div><div class="note note-success">            <p>注意，别忘记给PC设置网关</p>          </div><h1 id="Ping-的返回结果含义"><a href="#Ping-的返回结果含义" class="headerlink" title="Ping 的返回结果含义"></a>Ping 的返回结果含义</h1><h2 id="Requesttimed-out-超时"><a href="#Requesttimed-out-超时" class="headerlink" title="Requesttimed out 超时"></a>Requesttimed out 超时</h2><ul><li>对方已关机</li><li>对方和我不在同一个网段</li><li>对方防火墙设置了ICMP数据包过滤</li><li>错误设置IP地址</li></ul><h2 id="Destinationhost-Unreachable-无法到达"><a href="#Destinationhost-Unreachable-无法到达" class="headerlink" title="Destinationhost Unreachable(无法到达)"></a>Destinationhost Unreachable(无法到达)</h2><ul><li>对方与自己不在同一网段内，而自己又未设置默认的路由(网关)</li><li>网线出了故障</li></ul><h2 id="BadIP-address-错误的IP"><a href="#BadIP-address-错误的IP" class="headerlink" title="BadIP address(错误的IP)"></a>BadIP address(错误的IP)</h2><ul><li>DNS服务器未设置</li><li>IP地址不存在</li></ul><h2 id="Sourcequench-received"><a href="#Sourcequench-received" class="headerlink" title="Sourcequench received"></a>Sourcequench received</h2><ul><li>对方或中途的服务器繁忙无法回应</li></ul><h2 id="Unknownhost-不知名主机"><a href="#Unknownhost-不知名主机" class="headerlink" title="Unknownhost(不知名主机)"></a>Unknownhost(不知名主机)</h2><p>该远程主机的名字不能被域名服务器（DNS）转换成IP地址</p><ul><li>域名服务器有故障</li><li>名字不正确</li><li>网络管理员的系统与远程主机之间的通信线路有故障</li></ul><h2 id="Noanswer"><a href="#Noanswer" class="headerlink" title="Noanswer"></a>Noanswer</h2><ul><li>中心主机没有工作</li><li>本地或中心主机网络配置不正确</li><li>本地或中心的路由器没有工作</li><li>通信线路有故障</li></ul><h1 id="网络协议分析"><a href="#网络协议分析" class="headerlink" title="网络协议分析"></a>网络协议分析</h1><h2 id="ARP-地址解析协议"><a href="#ARP-地址解析协议" class="headerlink" title="ARP(地址解析协议)"></a>ARP(地址解析协议)</h2><ul><li>工作在数据链路层</li><li>将IP地址转化成物理地址(mac)</li></ul><blockquote><p>在以太网协议中规定，同一局域网中的一台主机要和另一台主机进行直接通信，必须要知道目标主机的MAC地址。而在TCP/IP协议中，网络层和传输层只关心目标主机的IP地址。这就导致在以太网中使用IP协议时，数据链路层的以太网协议接到上层IP协议提供的数据中，只包含目的主机的IP地址。于是需要一种方法，根据目的主机的IP地址，获得其MAC地址。这就是ARP协议要做的事情。所谓地址解析（address resolution）就是主机在发送帧前将目标IP地址转换成目标MAC地址的过程。</p><p>另外，当发送主机和目的主机不在同一个局域网中时，即便知道对方的MAC地址，两者也不能直接通信，必须经过路由转发才可以。所以此时，发送主机通过ARP协议获得的将不是目的主机的真实MAC地址，而是一台可以通往局域网外的路由器的MAC地址。于是此后发送主机发往目的主机的所有帧，都将发往该路由器，通过它向外发送。这种情况称为委托ARP或ARP代理（ARP Proxy）。</p></blockquote><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul><li>有目的主机IP地址对应的MAC地址，直接转发</li><li>没有目的主机IP地址对应的MAC地址，在本网段发起ARP请求广播包进行查询</li><li>根据源主机的MAC地址信息，更新ARP列表</li></ul><h3 id="数据包"><a href="#数据包" class="headerlink" title="数据包"></a>数据包</h3><div class="table-container"><table><thead><tr><th style="text-align:center">长度(位)</th><th style="text-align:center">48</th><th style="text-align:center">48</th><th style="text-align:center">16</th><th style="text-align:center">16</th><th style="text-align:center">16</th><th style="text-align:center">8</th><th style="text-align:center">8</th><th style="text-align:center">16</th><th style="text-align:center">48</th><th style="text-align:center">32</th><th style="text-align:center">48</th><th style="text-align:center">32</th></tr></thead><tbody><tr><td style="text-align:center">数据类型</td><td style="text-align:center">目标以太网地址</td><td style="text-align:center">源以太网地址</td><td style="text-align:center">帧类型</td><td style="text-align:center">硬件类型</td><td style="text-align:center">协议类型</td><td style="text-align:center">硬件地址长度</td><td style="text-align:center">协议地址长度</td><td style="text-align:center">操作码</td><td style="text-align:center">源硬件地址</td><td style="text-align:center">源协议地址</td><td style="text-align:center">目标硬件地址</td><td style="text-align:center">目标协议地址</td></tr><tr><td style="text-align:center">英文名</td><td style="text-align:center">DEST ADDR</td><td style="text-align:center">SRC ADDR</td><td style="text-align:center">TYPE</td><td style="text-align:center">HARDWARE TYPE</td><td style="text-align:center">PROTOCOL TYPE</td><td style="text-align:center">HLEN</td><td style="text-align:center">PLEN</td><td style="text-align:center">OPCODE</td><td style="text-align:center">SOURCE MAC</td><td style="text-align:center">SOURCE IP</td><td style="text-align:center">TARGET MAC</td><td style="text-align:center">TARGET IP</td></tr><tr><td style="text-align:center">ARP(请求)</td><td style="text-align:center">FF:FF:FF:FF:FF:FF</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0x0001</td><td style="text-align:center">0x0800</td><td style="text-align:center">0x06</td><td style="text-align:center">0x04</td><td style="text-align:center">0x0001</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0000.0000.0000</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ARP(回复)</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">0x0001</td><td style="text-align:center">0x0800</td><td style="text-align:center">0x06</td><td style="text-align:center">0x04</td><td style="text-align:center">0x0002</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><ul><li>硬件类型：如以太网（0x0001）、分组无线网</li><li>协议类型：如网际协议(IP)（0x0800）、IPv6（0x86DD）</li><li>硬件地址长度：每种硬件地址的字节长度，一般为6（以太网）</li><li>协议地址长度：每种协议地址的字节长度，一般为4（IPv4）</li><li>操作码：1为ARP请求，2为ARP应答，3为RARP请求，4为RARP应答</li><li>源硬件地址：n个字节，n由硬件地址长度得到，一般为发送方MAC地址</li><li>源协议地址：m个字节，m由协议地址长度得到，一般为发送方IP地址</li><li>目标硬件地址：n个字节，n由硬件地址长度得到，一般为目标MAC地址</li><li>目标协议地址：m个字节，m由协议地址长度得到，一般为目标IP地址</li></ul><p>前14字节为以太网首部，后28字节为ARP请求/应答</p><h2 id="TCP-传输控制协议"><a href="#TCP-传输控制协议" class="headerlink" title="TCP(传输控制协议)"></a>TCP(传输控制协议)</h2><ul><li>工作在传输层</li><li>实现进程到进程的可靠的数据流传送服务</li><li>标识主机位置：地址(IP)</li><li>标识进程：端口</li></ul><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><ul><li>客户端（通过执行connect函数）向服务器端发送一个SYN包，请求一个主动打开。该包携带客户端为这个连接请求而设定的随机数X作为消息序列号(seq=X)</li><li>服务器端收到一个合法的SYN包后，把该包放入SYN队列中；回送一个SYN/ACK。ACK的确认码应为X+1，SYN/ACK包本身携带一个随机产生的序号Y(seq=Y,ack=X+1)</li><li>客户端收到SYN/ACK包后，发送一个ACK包，该包的序号被设定为X+1，而ACK的确认码则为Y+1。然后客户端的connect函数成功返回(seq=X+1 ack=Y+1)</li></ul><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><em>貌似不考</em></p><h3 id="数据包-1"><a href="#数据包-1" class="headerlink" title="数据包"></a>数据包</h3><div class="table-container"><table><thead><tr><th style="text-align:center">长度(位)</th><th style="text-align:center">16</th><th style="text-align:center">16</th><th style="text-align:center">32</th><th style="text-align:center">32</th><th style="text-align:center">4</th><th style="text-align:center">6</th><th style="text-align:center">6</th><th style="text-align:center">16</th><th style="text-align:center">16</th><th style="text-align:center">16</th></tr></thead><tbody><tr><td style="text-align:center">数据类型</td><td style="text-align:center">来源连接端口</td><td style="text-align:center">目的连接端口</td><td style="text-align:center">序列号码</td><td style="text-align:center">确认号码</td><td style="text-align:center">资料偏移</td><td style="text-align:center">保留</td><td style="text-align:center">标志位</td><td style="text-align:center">窗口大小</td><td style="text-align:center">校验和</td><td style="text-align:center">紧急指针</td></tr><tr><td style="text-align:center">英文名</td><td style="text-align:center">SOURCE PORT</td><td style="text-align:center">DESTINATION PORT</td><td style="text-align:center"><font color=red>SEQ</font>UENCE NUMBER</td><td style="text-align:center"><font color=red>ACK</font>NOWLEDGEMENT NUMBER</td><td style="text-align:center">OFFSET</td><td style="text-align:center">RESERVED</td><td style="text-align:center">FLAGS</td><td style="text-align:center">WINDOW</td><td style="text-align:center">CHECKSUM</td><td style="text-align:center">URGENT POINTER</td></tr><tr><td style="text-align:center">TCP第一次握手</td><td style="text-align:center">A</td><td style="text-align:center">B</td><td style="text-align:center">X</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0b000010</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">TCP第二次握手</td><td style="text-align:center">B</td><td style="text-align:center">A</td><td style="text-align:center">Y</td><td style="text-align:center">X+1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0b010010</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">TCP第三次握手</td><td style="text-align:center">A</td><td style="text-align:center">B</td><td style="text-align:center">X+1</td><td style="text-align:center">Y+1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0b010000</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><h1 id="实验操作"><a href="#实验操作" class="headerlink" title="实验操作"></a>实验操作</h1><h2 id="交换机配置静态路由"><a href="#交换机配置静态路由" class="headerlink" title="交换机配置静态路由"></a>交换机配置静态路由</h2><p>PC<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">C:\&gt;ipconfig /<span class="hljs-keyword">all</span><br></code></pre></td></tr></table></figure><br>获取FastEthernet0的物理地址(Physical Address)为<code>00E0.A3BA.8021</code></p><p>交换机<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Switch</span>(config)# mac-address-table static <span class="hljs-number">00</span>E0.A3BA.<span class="hljs-number">8021</span> vlan <span class="hljs-number">1</span> interface fa0/<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></p><p>即完成了将mac地址为<code>00E0.A3BA.8021</code>的PC与<code>fa0/1</code>端口绑定</p><h2 id="路由器设置端口"><a href="#路由器设置端口" class="headerlink" title="路由器设置端口"></a>路由器设置端口</h2><p>路由器<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">Router</span>(config)<span class="hljs-meta"># interface fa0/0</span><br><span class="hljs-built_in">Router</span>(config-<span class="hljs-keyword">if</span>)<span class="hljs-meta"># ip address 192.168.1.1 255.255.255.0</span><br></code></pre></td></tr></table></figure></p><p>完成将<code>fa0/0</code>端口的IP设置为<code>192.168.1.1</code>，掩码为<code>255.255.255.0</code></p><h2 id="三层交换机实现Vlan间通讯"><a href="#三层交换机实现Vlan间通讯" class="headerlink" title="三层交换机实现Vlan间通讯"></a>三层交换机实现Vlan间通讯</h2><div class="table-container"><table><thead><tr><th style="text-align:center">设备</th><th style="text-align:center">属性</th></tr></thead><tbody><tr><td style="text-align:center">PC1</td><td style="text-align:center">IP：192.168.10.10，掩码：255.255.255.0，网关：192.168.10.1</td></tr><tr><td style="text-align:center">PC2</td><td style="text-align:center">IP：192.168.20.10，掩码：255.255.255.0，网关：192.168.20.1</td></tr><tr><td style="text-align:center">PC3</td><td style="text-align:center">IP：192.168.10.20，掩码：255.255.255.0，网关：192.168.10.1</td></tr><tr><td style="text-align:center">PC4</td><td style="text-align:center">IP：192.168.20.20，掩码：255.255.255.0，网关：192.168.20.1</td></tr><tr><td style="text-align:center">交换机1</td><td style="text-align:center">与PC1和PC2连接，分别连在fa0/1 fa0/2口，fa0/3与三层交换机连接</td></tr><tr><td style="text-align:center">交换机2</td><td style="text-align:center">与PC3和PC4连接，分别连在fa0/1 fa0/2口，fa0/3与三层交换机连接</td></tr><tr><td style="text-align:center">三层交换机</td><td style="text-align:center">与交换机1和交换机2连接，分别连在fa0/1 fa0/2口</td></tr></tbody></table></div><p>交换机1<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">enable<br>configure terminal<br>vlan <span class="hljs-number">10</span><br><span class="hljs-keyword">exit</span><br>vlan <span class="hljs-number">20</span><br><span class="hljs-keyword">exit</span><br>interface fa0/<span class="hljs-number">1</span><br>switchport access vlan <span class="hljs-number">10</span><br><span class="hljs-keyword">exit</span><br>interface fa0/<span class="hljs-number">2</span><br>switchport access vlan <span class="hljs-number">20</span><br><span class="hljs-keyword">exit</span><br>interface fa0/<span class="hljs-number">3</span><br>switchport mode trunk<br><span class="hljs-keyword">exit</span><br></code></pre></td></tr></table></figure></p><p>交换机2<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">enable<br>configure terminal<br>vlan <span class="hljs-number">10</span><br><span class="hljs-keyword">exit</span><br>vlan <span class="hljs-number">20</span><br><span class="hljs-keyword">exit</span><br>interface fa0/<span class="hljs-number">1</span><br>switchport access vlan <span class="hljs-number">10</span><br><span class="hljs-keyword">exit</span><br>interface fa0/<span class="hljs-number">2</span><br>switchport access vlan <span class="hljs-number">20</span><br><span class="hljs-keyword">exit</span><br>interface fa0/<span class="hljs-number">3</span><br>switchport mode trunk<br><span class="hljs-keyword">exit</span><br></code></pre></td></tr></table></figure></p><p>交换机3<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk">enable<br>configure terminal<br>vlan <span class="hljs-number">10</span><br><span class="hljs-keyword">exit</span><br>vlan <span class="hljs-number">20</span><br><span class="hljs-keyword">exit</span><br>interface vlan <span class="hljs-number">10</span><br>ip address <span class="hljs-number">192.168</span>.<span class="hljs-number">10.1</span> <span class="hljs-number">255.255</span>.<span class="hljs-number">255.0</span><br><span class="hljs-keyword">exit</span><br>interface vlan <span class="hljs-number">20</span><br>ip address <span class="hljs-number">192.168</span>.<span class="hljs-number">20.1</span> <span class="hljs-number">255.255</span>.<span class="hljs-number">255.0</span><br><span class="hljs-keyword">exit</span><br>ip routing<br></code></pre></td></tr></table></figure></p><h2 id="单臂路由"><a href="#单臂路由" class="headerlink" title="单臂路由"></a>单臂路由</h2><div class="table-container"><table><thead><tr><th style="text-align:center">设备</th><th style="text-align:center">属性</th></tr></thead><tbody><tr><td style="text-align:center">PC1</td><td style="text-align:center">IP：192.168.10.10，掩码：255.255.255.0，网关：192.168.10.1</td></tr><tr><td style="text-align:center">PC2</td><td style="text-align:center">IP：192.168.20.10，掩码：255.255.255.0，网关：192.168.20.1</td></tr><tr><td style="text-align:center">交换机</td><td style="text-align:center">与PC1和PC2连接，分别连在fa0/1 fa0/2口，fa0/3与路由器连接</td></tr><tr><td style="text-align:center">路由器</td><td style="text-align:center">与交换机连接，连在fa0/0口</td></tr></tbody></table></div><p>交换机<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">enable<br>configure terminal<br>vlan <span class="hljs-number">10</span><br><span class="hljs-keyword">exit</span><br>vlan <span class="hljs-number">20</span><br><span class="hljs-keyword">exit</span><br>interface fa0/<span class="hljs-number">1</span><br>switchport access vlan <span class="hljs-number">10</span><br><span class="hljs-keyword">exit</span><br>interface fa0/<span class="hljs-number">2</span><br>switchport access vlan <span class="hljs-number">20</span><br><span class="hljs-keyword">exit</span><br>interface fa0/<span class="hljs-number">3</span><br>switchport mode trunk<br><span class="hljs-keyword">exit</span><br></code></pre></td></tr></table></figure></p><p>路由器<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs awk">enable<br>configure terminal<br>interface fa0/<span class="hljs-number">0</span><br>no shutdown<br>interface fa0/<span class="hljs-number">0.1</span><br>encapsulation dot1Q <span class="hljs-number">10</span><br>ip address <span class="hljs-number">192.168</span>.<span class="hljs-number">10.1</span> <span class="hljs-number">255.255</span>.<span class="hljs-number">255.0</span><br>no shutdown<br><span class="hljs-keyword">exit</span><br>interface fa0/<span class="hljs-number">0.2</span><br>encapsulation dot1Q <span class="hljs-number">20</span><br>ip address <span class="hljs-number">192.168</span>.<span class="hljs-number">20.1</span> <span class="hljs-number">255.255</span>.<span class="hljs-number">255.0</span><br>no shutdown<br><span class="hljs-keyword">exit</span><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习</tag>
      
      <tag>课程</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WSL1 使用 Docker 一直无法启动</title>
    <link href="/2020/12/24/develop-note/wsl-docker/"/>
    <url>/2020/12/24/develop-note/wsl-docker/</url>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>WSL1 无法正常启动 Docker，Docker一直处于 not running 状态</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>WSL1 是伪 Linux，实际上仍然是 Windows 底层，而 Docker 是基于系统底层实现的，这就导致了无法在 Windows(WSL1) 上运行 Linux 版本的 Docker<br>使用 WSL2 则可以正常使用 Docker，目前上述问题在不使用 WSL2 的情况下，暂时无法解决</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>短笔记</tag>
      
      <tag>WSL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的ACM脚印</title>
    <link href="/2020/12/20/acm/myACM/"/>
    <url>/2020/12/20/acm/myACM/</url>
    
    <content type="html"><![CDATA[<p>2020年12月20日，南京区域赛结束，同时结束的，还有我的两年多的ACM生涯<br>接下来的寒假重心会向着找实习的方向努力，当然明年还有线下的区域赛、EC-finial以及明年的省赛等等，我都会去认真准备。</p><h1 id="这篇文章会写什么"><a href="#这篇文章会写什么" class="headerlink" title="这篇文章会写什么"></a>这篇文章会写什么</h1><ul><li>关于我<ul><li>我的ACM简单的回顾</li><li>我的ACM成绩</li></ul></li><li>写给新人<ul><li>ACM到底和数学建模、挑战杯等等的其他竞赛有什么区别</li><li>ACM到底带给我什么了</li><li>为什么要打ACM</li><li>什么样的人适合去打ACM，什么样的人不适合去打ACM</li></ul></li><li>写给已经进入了ACM的人<ul><li>我在ACM的训练计划</li><li>除了ACM之外的计划</li></ul></li><li>关于ACM写题<ul><li>ACM算法的学习规划</li><li>我的一些经验之谈</li></ul></li></ul><p>这篇文章更多的是想来自我总结一下历史，如果与你的理解有出入也请见谅</p><h1 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h1><h2 id="我的ACM简单的回顾"><a href="#我的ACM简单的回顾" class="headerlink" title="我的ACM简单的回顾"></a>我的ACM简单的回顾</h2><h3 id="进入大学之前"><a href="#进入大学之前" class="headerlink" title="进入大学之前"></a>进入大学之前</h3><p>我是2018年进入的大学，在这之前，我压根没有听说过ACM，也完全不知道这类竞赛，高中也是没有打过OI，也就是真正的纯粹的小白。当然，我的高中压根就不知道有什么叫OI的比赛，可能这就是所谓的省B类学校吧</p><p>但是我有优势，我从高一开始自学了程序，我当时想自己写游戏，然后学起来Unity了，也就顺便学了C#。至于优势，大概就是对程序有了自己的理解吧。如果让我对代码理解这个事情上进行一个分级的话，我会这样分：</p><ul><li>完全不会程序（基本上就是那些完全没有学过代码的人）</li><li>学会了顺序、选择、循环语句（一般是刚刚开始学程序的人，对程序是万能的这条表示怀疑的人）</li><li>能够灵活的运用上述三种语句（突然发现仅使用这三种语句居然可以实现一切逻辑，相信代码是万能的，只是需要写代码的。通常这类人同样相信代码是高效的，认为所有的事情基本上都可以在电脑上花费一小段的时间就能得出结果）</li><li>知道了代码是非常局限的，计算机能计算的速度是非常有限的，在解决一个问题前会思考这个问题的逻辑，对这个问题进行优化以适合计算机去运行，这类人也就是一个ACMer的入门点</li></ul><p>而那时候的我，大概就是第三类的人，比起同时期的同学，只能说我拥有着非常好的起点</p><p>但是，实际上，通过一个学期的学习，基本上所有的学生都能到达这个水平</p><h3 id="大一"><a href="#大一" class="headerlink" title="大一"></a>大一</h3><p>大学的第一个学期，课程安排是学C语言，但是我其实并不需要，因为这些东西只需要我把我学C#的知识转成C就行了</p><p>而这个学期，校集训队也联系上了我，只不过因为我有提前的知识了，虽然我在那个时候还完全不知道对于代码还有第四层理解<br>当然，慢慢的我也接触到了很多算法，例如dfs、bfs之类的，只能说我在那个时候对ACM的理解还存在于ACM是提供更多的解决问题的办法而已<br>后来，学到了在ACM中最重要的东西：复杂度<br>也慢慢的开始学习到各种基础的算法：gcd、最短路、背包问题、KMP等等之类的</p><p>后来，我在大一快结束的时候，和另外两位大一参加了西安邀请赛，然后成功打铁……<br>紧接着是校赛，但是那次校赛的难度太高，导致全场只有20个人过题，我有幸过了两题。但是我和之前组队的两个大一的同学分开了队伍。<br>然后是浙江省省赛，和两个大二的人组队，然后继续打铁<br>再接下来是南昌邀请赛，我终于拿到了人生以来的第一个奖牌：铜</p><p>然后就是整整一个暑假的集训，杭电的多校、牛客的多校，题目的难度对于当时我而言，未免是过高了一些。那两个月，可谓是绝对的自闭</p><h3 id="大二"><a href="#大二" class="headerlink" title="大二"></a>大二</h3><p>大二开始，大概是因为经历了暑假的自闭式训练，拿下了一个ICPC的区域赛银牌，虽然是银川偷鸡，但基本上是我一个人完成的比赛，而且其实本来很有希望冲击金牌</p><p>大二下半学期，因为疫情的原因，荒废了很久，没有出去打比赛，只能说是不断的学习吧。<br>也趁着疫情，顺便把CodeForces上把我的两个账号都刷到了紫名</p><p>当然，因为写的题多了，代码写的多了，感觉自己写题目的习惯开始发生了改变，特别是经常打CodeForces后，感觉自己对很多思维的理解在不断的加深。大一选择了图论方向，大二开始学数据结构，然后再学了字符串，稍微了解了dp，队内也把构造题的任务分配给了我</p><h3 id="大三"><a href="#大三" class="headerlink" title="大三"></a>大三</h3><p>这个学期难得有了好多场比赛，而我们原来参加了西安邀请赛的三个人，我们重新组成了完整的队伍，也夺下了省赛银牌、CCPC威海铜牌、ICPC南京银牌这样三个牌。</p><h2 id="我的ACM成绩"><a href="#我的ACM成绩" class="headerlink" title="我的ACM成绩"></a>我的ACM成绩</h2><p>到目前为止，总共拿下了两个ICPC区域赛银牌，一个CCPC的铜牌，一个浙江省省赛银牌，一个ICPC邀请赛铜牌，Codeforces两个账号都是紫名，准备寒假冲击橙名。接下来会参加一场线下的ICPC比赛以及EC-finial。未来可能在能够拿到offer的情况下，继续回来参加ACM竞赛</p><h1 id="写给新人"><a href="#写给新人" class="headerlink" title="写给新人"></a>写给新人</h1><h2 id="ACM到底和数学建模、挑战杯等等的其他竞赛有什么区别"><a href="#ACM到底和数学建模、挑战杯等等的其他竞赛有什么区别" class="headerlink" title="ACM到底和数学建模、挑战杯等等的其他竞赛有什么区别"></a>ACM到底和数学建模、挑战杯等等的其他竞赛有什么区别</h2><p>如果你是计算机学院的，那么你需要追求的、考虑的唯一的竞赛就是ACM</p><p>ACM是一个非常全面的竞赛，如果你说你只是喜欢数学，那么ACM比数学建模之类的数学竞赛更加具有挑战性，同样，难度更高。对的，在我的认知中，ACM对数学的要求甚至远远高于数学竞赛。因为ACM和其他比赛不一样的一点，便是ACM不设置任何的知识点上界，越新的知识点，越高级的知识点，ACM都可以考。甚至任何一道数学竞赛的题，如果你在ACM中见到，都是合情合理的。在打ACM的时候，这个知识点不会的情况是很正常的，是所有参加了ACM竞赛的人可以深切感受到的。而如果你只是去打数学之类的竞赛，如果你不能到达一个很高的层次，你可能很难体会到那种，自己完全不会，完全是毫无能力的那种绝望感。而在ACM，你可以在任何一场比赛中见到，甚至是随便在点开的一场比赛。</p><p>其次，ACM是一个非常公平、公正同时也是非常严格、残酷的比赛，甚至因为它的机制，你可以认为它是你整个大学生涯中见到过，最公平，也是唯一一个能够让参赛选手心服口服的比赛。因为ACM几乎不存在任何的主观因素，你只有准确完整的解决这个问题，你才能拿到那么一点成绩分。而且ACM系列竞赛结束，如果这场比赛有任何一道题有一些问题，通常出题人都会出面道歉。这也是我第一次知道，原来负责出题的人也是要道歉的。从那样的高考制度过来，我们甚至都不会去关心出题人是谁，即使他出了岔子，也会有专门的公关来解决。ACM却没有这些无聊的内容。</p><p>数学建模也好，挑战杯也罢，评委老师评分制意味着主观可以胜过客观，甚至，到最后可能变成了PPT大赛。如果说这类竞赛的好处，我觉得除了给你提高了拿到奖学金的可能性，对于自身能力的提升以及后续的工作而言甚至意义并不大。而奖学金，能比得上你找到一个好工作后在一个月内赚的钱多吗？你难道能一辈子拿奖学金过日子吗？当然这样的人是存在的，但是我相信大多数读者也和我一样，觉得这是一种奢望。</p><h2 id="ACM到底带给我什么了"><a href="#ACM到底带给我什么了" class="headerlink" title="ACM到底带给我什么了"></a>ACM到底带给我什么了</h2><h3 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h3><p>我在ACM集训队的第一周，我所得到的知识，是我的室友们在大学四年内都可能会学不清楚、理不通的知识，而那些知识点，在我经历了两年多的ACM训练后觉得，这些只不过应该是理所当然会的、最基本的知识。这些知识点带给我的财富，是我在经历了四五个项目后，才意识到的我们与其他人的差距。ACM的知识点，只要你未来是做计算机行业的，那么它一定会在每一个角落里发挥着它的作用。</p><h3 id="思维"><a href="#思维" class="headerlink" title="思维"></a>思维</h3><p>ACM的题，对一个人的思维能力的提升有着非常恐怖的作用。特别是当你频繁的打Codeforces比赛时，你会深切的体会到自己的思维能力在以非常恐怖的速度进步。而与思维能力直接挂钩的，便是逻辑思路以及问题的敏感性。如果有人去看过杜老师的Codeforces录播视频，看过tourist的比赛视频，你会发现他们基本上并不会去论证一个方法的可行性，他们通常在读到这道题的时候，会反应过来这题“好像这样搞搞”、“在随便暴力一下”、“应该就对了”。这样的思路也正是我现在打Codeforces的一种感觉，当然我还不能到达杜老师这样对于这么难的题也可以如此轻松的想出解法，但是我仍然觉得我思考问题的思路和方向变得非常的开阔，而且思考问题的逻辑自然变得严谨合理。</p><h3 id="代码实现能力"><a href="#代码实现能力" class="headerlink" title="代码实现能力"></a>代码实现能力</h3><p>ACM的题，难度较高的题，有些需要各种数据结构的嵌套，需要各种开辟各种奇奇怪怪的数组。而你需要在短时间内完成代码的编写和调试，这无疑是对代码能力的直接挑战。例如Codeforces，5道题目只有两个小时，除掉读题（纯英文题面）和思考问题的时间，你又有多少时间可以来写代码调试代码呢？当室友还在为编译出错烦恼时，我们基本就不需要调试百行代码以下的程序，因为只需要简单的测试证明其确实没有错误即可。</p><h3 id="ACM朋友圈"><a href="#ACM朋友圈" class="headerlink" title="ACM朋友圈"></a>ACM朋友圈</h3><p>ACM届有一个最高级别的竞赛，被称为WF（world finial）——世界总决赛。这场比赛的含金量有多高？也许有人会说，最多也就是拿到金牌可以全球500强随意挑。但是，实际上只需要你碰到了这个比赛的边界，你只要有幸被邀请参加了这场比赛，不论你的名次，这个星球上的企业你已经可以随意选了，而且本科毕业就可以去工作的那种。而我们平时聊天水群，里面有的是因为ACM成绩优异而进入Google中国、微软亚洲研究院的人。而对于正常学业而言，各位也应该知道你需要读多少年的书才有胆量往这些企业中投递一份简历</p><h3 id="学长学姐"><a href="#学长学姐" class="headerlink" title="学长学姐"></a>学长学姐</h3><p>通常能坚持下来打ACM的都是能够在思维、能力、勤奋或者智商上略胜一筹的人，那么和这样的学长学姐在同一个实验室的屋檐下打比赛，你能得到的帮助和支持，远远超过参加社团带来的收益。</p><h3 id="直面清北复交"><a href="#直面清北复交" class="headerlink" title="直面清北复交"></a>直面清北复交</h3><p>ACM竞赛是所有队伍在相同地点使用相同设备在相同的时间内解决相同的题目。</p><p>而你的对手则是来自全国的大学，对，北大清华每年都会来，而且非常重视。</p><p>ACM从来就没有院赛、校赛、省赛等等一大堆乱七八糟的东西，虽然他们确实存在但是他们并不是被官方承认的。ACM只有区域赛，（比如Asia-East东亚地区），区域总决赛（比如EC-finial，东亚地区总决赛），和世界总决赛（WF）。无论在哪个比赛，你都可能会遇到任何一个学校的队伍。所以在这样的比赛中，你可以很清楚的知道自己的水平在全地区范围内的位置，对自己的能力有一个更好的评估，能够看到外面更加广阔的天空。而不是拘泥于那么小的一个地区，争夺那么毫无意义的第一名</p><h2 id="为什么要打ACM"><a href="#为什么要打ACM" class="headerlink" title="为什么要打ACM"></a>为什么要打ACM</h2><p>因为我要证明我自己</p><p>在ACM比赛中，你会真实的，亲身和北大清华等等高校在同一个体育馆里，使用相同的设备相同的时间来解决相同的问题。那么你为什么不去证明自己比他们强？我知道这通常不可能，因为他们也会派出他们最强的队伍来与你们竞技。但是我们需要的就是在这么多的强队中，证明我们自己的能力。在计算机领域内最有影响力的比赛中，证明自己而已</p><h2 id="什么样的人适合去打ACM，什么样的人不适合去打ACM"><a href="#什么样的人适合去打ACM，什么样的人不适合去打ACM" class="headerlink" title="什么样的人适合去打ACM，什么样的人不适合去打ACM"></a>什么样的人适合去打ACM，什么样的人不适合去打ACM</h2><p>ACM竞赛是一个需要大量的时间去投入，但是到很久之后才会有结果的产出。这和其他竞赛不同，数学建模通常你只需要很短的时间训练就能拿出成绩，而一个ACMer，在大三之前甚至可能都没有一点点成果。但是你在大一大二的投入终将会给你在大二下至大三上的时候带来丰富的回报。</p><p>这样的回报，需要愿意投资的人耐心投资才有可能赚得盆满钵满，一旦出现懈怠都有可能颗粒无收。<strong>耐心、专注、勤奋、自觉</strong>这些是一个ACMer必须要具备的因素。</p><h1 id="写给已经进入了ACM的人"><a href="#写给已经进入了ACM的人" class="headerlink" title="写给已经进入了ACM的人"></a>写给已经进入了ACM的人</h1><h2 id="我在ACM的训练计划"><a href="#我在ACM的训练计划" class="headerlink" title="我在ACM的训练计划"></a>我在ACM的训练计划</h2><ul><li>保持在Codeforces的个人刷题，最好是现场比赛，其次是复现比赛。Codeforces对训练一个人的思维能力有者极大的帮助作用，而且其出题非常的新颖，是我认为最适合ACMer进行个人训练的平台。Codeforces的思维题数量非常庞大，而且非常的有趣。正式的区域赛等比赛，通常思维题也会占据很大一部分比重。</li><li>队伍内保持至少一周一场往年比赛的复现赛，我们队在长达几个月的集训时间内保持了一周两场比赛且不耽误正常课程。</li><li>当你决定要写ACM题时，请不要断开，也尽可能避免使用碎片化的时间学习，这对学习的进度没有任何帮助，除非你只是突然需要回忆一个知识点。</li><li>在实验室内写题而不是在寝室或者图书馆或者其他任何地方写题。</li></ul><h2 id="除了ACM之外的计划"><a href="#除了ACM之外的计划" class="headerlink" title="除了ACM之外的计划"></a>除了ACM之外的计划</h2><p>ACM毕竟只是我们大学的一个工具，我们希望它能够服务于我们找工作、服务于我们在其他领域的发展。不可以把ACM当成是自己在大学里唯一执着的对象，甚至把它树立为人生目标，这不合实际也没有意义，反而会影响你的正常社交与生活，这不应该是一个人的目标。</p><h1 id="关于ACM写题"><a href="#关于ACM写题" class="headerlink" title="关于ACM写题"></a>关于ACM写题</h1><h2 id="ACM算法的学习规划"><a href="#ACM算法的学习规划" class="headerlink" title="ACM算法的学习规划"></a>ACM算法的学习规划</h2><p>在经历了两年多的学习之后我发现，其实很多的算法并没有太多的学习意义，或者说不必要为其投入过多的经历去学习。<br>我是负责队伍内的图论+字符串，以及构造题思维题，会数据结构，了解dp和树上问题。<br>另外一位队友负责计算几何和博弈论，以及数论，会dp，了解图论和树上问题<br>还有一位队友负责了数据结构和dp，以及树上问题，会数论，了解图论<br>基本上可以说是覆盖了所有的知识面，而且大部分知识面都是有多个人会。</p><p>我以我熟悉的图论为例，诸如“最大流”这些个算法，通常对于一个银牌队伍而言，其实学习的意义并不大。因为我至今未见到过最大流题的难度低于金牌题的（按照实际区域赛出题情况）相反，灵活的结合思维和拓扑排序，你会发现图论问题变得非常简单。很多区域赛的图论的铜牌题在你眼里变成了暴力傻逼题。这是对于一个图论选手在频繁使用图论相关的知识点的时候自然而然形成的。</p><p>我认为把学习那些过高的知识点重要性低于去熟练掌握最基本的算法的内容。</p><p>对于字符串也一样，上一次看到“回文树”是在复现赛上看到的，是一道金牌题，虽然对于会“回文树”的队伍而言相对简单很多，但是作为一道金牌题，很多时候在比赛现场可能根本没有时间去看这样一道题。</p><p>当然你的队伍是为了冲金牌的，这些知识点当然也应该成为你的必须知识点之一。</p><h2 id="我的一些经验之谈"><a href="#我的一些经验之谈" class="headerlink" title="我的一些经验之谈"></a>我的一些经验之谈</h2><ul><li>看题一定要看数据，通过数据大小猜测算法的复杂度，再去考虑可能的算法逻辑。通常为了卡掉错误的算法，正确算法的复杂度应该在$1e6-1e8$之间，前者考虑可能有很大的常数的复杂度，后者则是最差的不可能发生的情况下的复杂度。</li><li>队伍内除了在最后冲刺的时候，其他时间内务必保证多开，无论何时也不要三个人讨论同一个问题，即使你们现在被榜丢下了。甚至很多时候可以尝试三开</li><li>队伍中每个人都应该具备非常良好的代码能力，除非你们队伍中专门有数学专业的人帮忙</li></ul><p>Shiroha @2020.12.21凌晨1点30分</p>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【2020HDU多校】第二场1005（HDU6767）New Equipments——费用流</title>
    <link href="/2020/07/24/acm/2020-multi-school/HDU6767-2-1005-New-Equipments/"/>
    <url>/2020/07/24/acm/2020-multi-school/HDU6767-2-1005-New-Equipments/</url>
    
    <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6767">题目链接</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>给出 $n$ 个工人和 $m$ 件装备，装备的编号为 $1, 2, 3 … m$。<br>对于工人 $i$ ，他有三个参数 $a_i, b_i, c_i$，当为这个工人装备了第 $j$ 个装备时，需要花费 $a_i <em> j ^ 2+ b_i </em> j + c_i$ 的费用。<br>当为 $k$ 个工人装备上装备时，最小花费是多少。<br>对所有的 $k$ 的情况均需要输出</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>费用流<br>将每个员工与源点链接，取每个员工的二次函数曲线的最小值附近的 $n$ 个点，与员工相连，所有的在二次函数曲线上的点与汇点相连，员工连接到二次函数的线需要设定费用，其他线费用均为 $0$，所有线的流量均为 $1$</p><p>输出每次 spfa 过程中得到的费用即可</p><h1 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><br><span class="hljs-type">const</span> ll maxn = <span class="hljs-number">3000</span>;<br><span class="hljs-type">const</span> ll INF = <span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>;<br><br><span class="hljs-type">bool</span> flag;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>    ll from, to, cap, flow, cost;<br><br>    <span class="hljs-built_in">Edge</span>(ll u, ll v, ll c, ll f, ll cc)<br>            : <span class="hljs-built_in">from</span>(u), <span class="hljs-built_in">to</span>(v), <span class="hljs-built_in">cap</span>(c), <span class="hljs-built_in">flow</span>(f), <span class="hljs-built_in">cost</span>(cc) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MCMF</span> &#123;<br>    ll n, m;<br>    vector&lt;Edge&gt; edges;<br>    vector&lt;ll&gt; G[maxn];<br>    ll inq[maxn];  <span class="hljs-comment">//是否在队列中</span><br>    ll d[maxn];    <span class="hljs-comment">//bellmanford</span><br>    ll p[maxn];    <span class="hljs-comment">//上一条弧</span><br>    ll a[maxn];    <span class="hljs-comment">//可改进量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ll nn)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;n = nn;<br>        <span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">0</span>; i &lt;= n; ++i) G[i].<span class="hljs-built_in">clear</span>();<br>        edges.<span class="hljs-built_in">clear</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(ll from, ll to, ll cap, ll cost)</span> </span>&#123;<br>        edges.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">Edge</span>(from, to, cap, <span class="hljs-number">0</span>, cost));<br>        edges.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">Edge</span>(to, from, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -cost));<br>        m = (ll) (edges.<span class="hljs-built_in">size</span>());<br>        G[from].<span class="hljs-built_in">emplace_back</span>(m - <span class="hljs-number">2</span>);<br>        G[to].<span class="hljs-built_in">emplace_back</span>(m - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">(ll s, ll t, ll &amp;flow, ll &amp;cost)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">1</span>; i &lt;= n; ++i) d[i] = INF;<br>        <span class="hljs-built_in">memset</span>(inq, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(inq));<br>        d[s] = <span class="hljs-number">0</span>;<br>        inq[s] = <span class="hljs-number">1</span>;<br>        p[s] = <span class="hljs-number">0</span>;<br>        queue&lt;ll&gt; q;<br>        a[s] = INF;<br>        q.<span class="hljs-built_in">push</span>(s);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            ll u = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            inq[u] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">0</span>; i &lt; (ll) (G[u].<span class="hljs-built_in">size</span>()); ++i) &#123;<br>                Edge &amp;e = edges[G[u][i]];<br>                <span class="hljs-keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[e.to] &gt; d[u] + e.cost) &#123;<br>                    d[e.to] = d[u] + e.cost;<br>                    p[e.to] = G[u][i];<br>                    a[e.to] = <span class="hljs-built_in">min</span>(a[u], e.cap - e.flow);<br>                    <span class="hljs-keyword">if</span> (!inq[e.to]) &#123;<br>                        q.<span class="hljs-built_in">push</span>(e.to);<br>                        inq[e.to] = <span class="hljs-number">1</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (d[t] == INF) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        flow += a[t];<br>        cost += (ll) d[t] * (ll) a[t];<br>        cout &lt;&lt; (flag ? <span class="hljs-string">&quot; &quot;</span> : <span class="hljs-string">&quot;&quot;</span>) &lt;&lt; cost;<br>        flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (ll u = t; u != s; u = edges[p[u]].from) &#123;<br>            edges[p[u]].flow += a[t];<br>            edges[p[u] ^ <span class="hljs-number">1</span>].flow -= a[t];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function">ll <span class="hljs-title">MincostMaxflow</span><span class="hljs-params">(ll s, ll t, ll &amp;cost)</span> </span>&#123;<br>        ll flow = <span class="hljs-number">0</span>;<br>        cost = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">spfa</span>(s, t, flow, cost));<br>        <span class="hljs-keyword">return</span> flow;<br>    &#125;<br>&#125; mcmf;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    ll a, b, c;<br>    ll l, r;<br><br>    <span class="hljs-function">ll <span class="hljs-title">cal</span><span class="hljs-params">(ll x)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a * x * x + b * x + c;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">make</span><span class="hljs-params">(ll n, ll m)</span> </span>&#123;<br>        ll mid = -b / <span class="hljs-number">2</span> / a;<br>        l = mid - n / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;<br>        r = mid + n / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>        l = <span class="hljs-built_in">max</span>(<span class="hljs-number">1ll</span>, l);<br>        r = <span class="hljs-built_in">min</span>(m, r);<br>        <span class="hljs-keyword">if</span> (r == m) &#123;<br>            l = r - n - <span class="hljs-number">2</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l == <span class="hljs-number">1</span>) &#123;<br>            r = l + n + <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br>&#125; node[<span class="hljs-number">60</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    ll T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">for</span> (ll ts = <span class="hljs-number">0</span>; ts &lt; T; ++ts) &#123;<br>        flag = <span class="hljs-literal">false</span>;<br>        unordered_map&lt;ll, ll&gt; trans;<br>        ll n, m;<br>        cin &gt;&gt; n &gt;&gt; m;<br>        ll ind = <span class="hljs-number">51</span>;<br>        <span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            cin &gt;&gt; node[i].a &gt;&gt; node[i].b &gt;&gt; node[i].c;<br>            node[i].<span class="hljs-built_in">make</span>(n, m);<br>            ll l = node[i].l;<br>            ll r = node[i].r;<br>            <span class="hljs-built_in">assert</span>(r - l &lt; <span class="hljs-number">60</span>);<br>            <span class="hljs-keyword">for</span> (ll j = l; j &lt;= r; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (trans.<span class="hljs-built_in">count</span>(j)) <span class="hljs-keyword">continue</span>;<br>                trans.<span class="hljs-built_in">insert</span>(&#123;j, ind++&#125;);<br>            &#125;<br>        &#125;<br>        ll source = ind + <span class="hljs-number">10</span>, target = ind + <span class="hljs-number">11</span>;<br>        mcmf.<span class="hljs-built_in">init</span>(target + <span class="hljs-number">10</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ACM_LOCAL</span><br>        cerr &lt;&lt; target + <span class="hljs-number">10</span> &lt;&lt; endl;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;item : trans)<br>            mcmf.<span class="hljs-built_in">addEdge</span>(item.second, target, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (ll i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            mcmf.<span class="hljs-built_in">addEdge</span>(source, i, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">for</span> (ll j = node[i].l; j &lt;= node[i].r; ++j) &#123;<br>                mcmf.<span class="hljs-built_in">addEdge</span>(i, trans[j], <span class="hljs-number">1</span>, node[i].<span class="hljs-built_in">cal</span>(j));<br>            &#125;<br>        &#125;<br>        ll cost;<br>        mcmf.<span class="hljs-built_in">MincostMaxflow</span>(source, target, cost);<br>        cout &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios_base::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ACM_LOCAL</span><br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;in.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;out.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br>    <span class="hljs-type">signed</span> test_index_for_debug = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span> acm_local_for_debug;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; acm_local_for_debug) &#123;<br>        <span class="hljs-keyword">if</span> (acm_local_for_debug == <span class="hljs-string">&#x27;$&#x27;</span>) <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        cin.<span class="hljs-built_in">putback</span>(acm_local_for_debug);<br>        <span class="hljs-keyword">if</span> (test_index_for_debug &gt; <span class="hljs-number">20</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Check the stdin!!!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">auto</span> start_clock_for_debug = <span class="hljs-built_in">clock</span>();<br>        <span class="hljs-built_in">solve</span>();<br>        <span class="hljs-keyword">auto</span> end_clock_for_debug = <span class="hljs-built_in">clock</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="hljs-string">&quot; successful&quot;</span> &lt;&lt; endl;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="hljs-string">&quot; Run Time: &quot;</span><br>             &lt;&lt; <span class="hljs-built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="hljs-string">&quot;s&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-built_in">solve</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从后缀自动机到广义后缀自动机</title>
    <link href="/2020/07/23/acm/other-note/exSAM/"/>
    <url>/2020/07/23/acm/other-note/exSAM/</url>
    
    <content type="html"><![CDATA[<h1 id="广义后缀自动机"><a href="#广义后缀自动机" class="headerlink" title="广义后缀自动机"></a>广义后缀自动机</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>广义后缀自动机基于下面的知识点</p><ul><li><a href="https://oi-wiki.org/string/trie/">字典树(Trie树)</a></li><li><a href="https://oi-wiki.org/string/sam/">后缀自动机</a></li></ul><p>请务必对上述两个知识点非常熟悉之后，再来阅读本文，特别是对于<strong>后缀自动机</strong>中的<strong>后缀链接</strong>能够有一定的理解</p><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>广义后缀自动机是由刘研绎在其2015 国家队论文《后缀自动机在字典树上的拓展》上提出的一种结构，即将后缀自动机直接建立在字典树上。</p><blockquote><p>大部分可以用后缀自动机处理的字符串的问题均可扩展到 Trie 树上。——刘研绎</p></blockquote><h2 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h2><p>参考<a href="https://oi-wiki.org/string/basic/">字符串约定</a></p><p>字符串个数为 $k$ 个，即 $S_1, S_2, S_3 … S_k$</p><p>约定字典树和广义后缀自动机的根节点为 $0$ 号节点</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>后缀自动机 (suffix automaton, SAM) 是用于处理单个字符串的子串问题的强力工具。</p><p>而广义后缀自动机 (General Suffix Automaton) 则是将后缀自动机整合到字典树中来解决对于多个字符串的子串问题 </p><h2 id="常见的伪广义后缀自动机"><a href="#常见的伪广义后缀自动机" class="headerlink" title="常见的伪广义后缀自动机"></a>常见的伪广义后缀自动机</h2><ol><li>通过用特殊符号将多个串直接连接后，再建立 SAM</li><li>对每个串，重复在同一个 SAM 上进行建立，每次建立前，将 <code>last</code> 指针置零</li></ol><p>方法1和方法2的实现方式简单，而且在面对题目时通常可以达到和广义后缀自动机一样的正确性。所以在网络上很多人会选择此类写法，例如在后缀自动机一文中最后一个应用，便使用了方法1<a href="https://oi-wiki.org/string/sam/#_23">（原文链接）</a></p><p>但是无论方法1还是方法2，其时间复杂度较为危险</p><h2 id="构造广义后缀自动机"><a href="#构造广义后缀自动机" class="headerlink" title="构造广义后缀自动机"></a>构造广义后缀自动机</h2><p>根据原论文的描述，应当在多个字符串上先建立字典树，然后在字典树的基础上建立广义后缀自动机。</p><h3 id="字典树的使用"><a href="#字典树的使用" class="headerlink" title="字典树的使用"></a>字典树的使用</h3><p>首先应对多个串创建一棵字典树，这不是什么难事，如果你已经掌握了前置知识的前提下，可以很快的建立完毕。这里为了统一上下文的代码，给出一个可能的字典树代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 2000000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CHAR_NUM 30</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Trie</span>&#123;<br>    <span class="hljs-type">int</span> next[MAXN][CHAR_NUM];   <span class="hljs-comment">// 转移</span><br>    <span class="hljs-type">int</span> tot;                    <span class="hljs-comment">// 节点总数：[0, tot)</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        tot = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">insertTrie</span><span class="hljs-params">(<span class="hljs-type">int</span> cur, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (next[cur][c]) <span class="hljs-keyword">return</span> next[cur][c];<br>        <span class="hljs-keyword">return</span> next[cur][c] = tot++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> root = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch : s) root = <span class="hljs-built_in">insertTrie</span>(root, ch - <span class="hljs-string">&#x27;a&#x27;</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里我们得到了一棵依赖于 <code>next</code> 数组建立的一棵字典树。</p><h3 id="后缀自动机的建立"><a href="#后缀自动机的建立" class="headerlink" title="后缀自动机的建立"></a>后缀自动机的建立</h3><p>如果我们把这样一棵树直接认为是一个后缀自动机，则我们可以得到如下结论</p><ul><li>对于节点 <code>i</code> ，其 <code>len[i]</code> 和它在字典树中的深度相同</li><li>如果我们对字典树进行拓扑排序，我们可以得到一串根据 <code>len</code> 不递减的序列。$BFS$ 的结果相同</li></ul><p>而后缀自动机在建立的过程中，可以视为不断的插入 <code>len</code> 严格递增的值，且插值为 $1$。所以我们可以将对字典树进行拓扑排序后的结果做为一个队列，然后按照这个队列的顺序不断地插入到后缀自动机中。</p><p>由于在普通后缀自动机上，其前一个节点的 <code>len</code> 值为固定值，即为 <code>last</code> 节点的 <code>len</code>。但是在广义后缀自动机中，插入的队列是一个不严格递增的数列。所以对于每一个值，对于它的 <code>last</code> 应该是已知而且固定的，在字典树上，即为其父亲节点。</p><p>由于在字典树中，已经建立了一个近似的后缀自动机，所以只需要对整个字典树的结构进行一定的处理即可转化为广义后缀自动机。我们可以按照前面提出的队列顺序来对整个字典树上的每一个节点进行更新操作。最终我们可以得到广义后缀自动机。</p><p>对于每个点的更新操作，我们可以稍微修改一下SAM中的插入操作来得到。</p><p>对于整个插入的过程，需要注意的是，由于插入是按照 <code>len</code> 不递减的顺序插入，在进行 $clone$ 后的数据复制过程中，不可以复制其 <code>len</code> 小于当前 <code>len</code> 的数据。</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>根据上述的逻辑，可以将整个构建过程描述为如下操作</p><ol><li>将所有字符串插入到字典树中</li><li>从字典树的根节点开始进行 $BFS$，记录下顺序以及每个节点的父亲节点</li><li>将得到的 $BFS$ 序列按照顺序，对每个节点在原字典树上进行构建，注意不能将 <code>len</code> 小于当前 <code>len</code> 的数据进行操作</li></ol><h3 id="对操作次数为线性的证明"><a href="#对操作次数为线性的证明" class="headerlink" title="对操作次数为线性的证明"></a>对操作次数为线性的证明</h3><p>由于仅处理 $BFS$ 得到的序列，可以保证字典树上所有节点仅经过一次。<br>对于最坏情况，考虑字典树本身节点个数最多的情况，即任意两个字符串没有相同的前缀，则节点个数为 $\sum_{i=1}^{k}|S_i|$，即所有的字符串长度之和。<br>而在后缀自动机的更新操作的复杂度已经在<a href="https://oi-wiki.org/string/sam/#_7">后缀自动机</a>中证明<br>所以可以证明其最坏复杂度为线性</p><p>而通常伪广义后缀自动机的平均复杂度等同于广义后缀自动机的最差复杂度，面对对于大量的字符串时，伪广义后缀自动机的效率远不如标准的广义后缀自动机</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>对插入函数进行少量必要的修改即可得到所需要的函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">GSA</span>&#123;<br>    <span class="hljs-type">int</span> len[MAXN];              <span class="hljs-comment">// 节点长度</span><br>    <span class="hljs-type">int</span> link[MAXN];             <span class="hljs-comment">// 后缀链接，link</span><br>    <span class="hljs-type">int</span> next[MAXN][CHAR_NUM];   <span class="hljs-comment">// 转移</span><br>    <span class="hljs-type">int</span> tot;                    <span class="hljs-comment">// 节点总数：[0, tot)</span><br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">insertSAM</span><span class="hljs-params">(<span class="hljs-type">int</span> last, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>        <span class="hljs-type">int</span> cur = next[last][c];<br>        len[cur] = len[last] + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> p = link[last];<br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!next[p][c]) next[p][c] = cur;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>            p = link[p];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-number">-1</span>) &#123;<br>            link[cur] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> cur;<br>        &#125;<br>        <span class="hljs-type">int</span> q = next[p][c];<br>        <span class="hljs-keyword">if</span> (len[p] + <span class="hljs-number">1</span> == len[q]) &#123;<br>            link[cur] = q;<br>            <span class="hljs-keyword">return</span> cur;<br>        &#125;<br>        <span class="hljs-type">int</span> clone = tot++;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; CHAR_NUM; ++i)<br>            next[clone][i] = len[next[q][i]] != <span class="hljs-number">0</span> ? next[q][i] : <span class="hljs-number">0</span>;<br>        len[clone] = len[p] + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-number">-1</span> &amp;&amp; next[p][c] == q) &#123;<br>            next[p][c] = clone;<br>            p = link[p];<br>        &#125;<br>        link[clone] = link[q];<br>        link[cur] = clone;<br>        link[q] = clone;<br><br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>        queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i)<br>            <span class="hljs-keyword">if</span> (next[<span class="hljs-number">0</span>][i]) q.<span class="hljs-built_in">push</span>(&#123;i, <span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> item = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">auto</span> last = <span class="hljs-built_in">insertSAM</span>(item.second, item.first);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i)<br>                <span class="hljs-keyword">if</span> (next[last][i]) q.<span class="hljs-built_in">push</span>(&#123;i, last&#125;);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><ul><li>由于整个 $BFS$ 的过程得到的顺序，其父节点始终在变化，所以并不需要保存 <code>last</code> 指针。</li><li>插入操作中，<code>int cur = next[last][c];</code> 与正常后缀自动机的 <code>int cur = tot++;</code> 有差异，因为我们插入的节点已经在树型结构中完成了，所以只需要直接获取即可</li><li>在 $clone$ 后的数据拷贝中，有这样的判断 <code>next[clone][i] = len[next[q][i]] != 0 ? next[q][i] : 0;</code> 这与正常的后缀自动机的直接赋值 <code>next[clone][i] = next[q][i];</code> 有一定差异，此次是为了避免更新了 <code>len</code> 大于当前节点的值。由于数组中 <code>len</code> 当且仅当这个值被 $BFS$ 遍历并插入到后缀自动机后才会被赋值</li></ul><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol><li>广义后缀自动机与后缀自动机的结构一致，在后缀自动机上的性质绝大部分均可在广义后缀自动机上生效（<a href="https://oi-wiki.org/string/sam/#_9">后缀自动机的性质</a>）</li><li>当广义后缀自动机建立后，通常字典树结构将会被破坏，即通常不可以用广义后缀自动机来解决字典树问题。当然也可以选择准备双倍的空间，将后缀自动机建立在另外一个空间上。</li></ol><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="所有字符中不同子串个数"><a href="#所有字符中不同子串个数" class="headerlink" title="所有字符中不同子串个数"></a>所有字符中不同子串个数</h3><p>可以根据后缀自动机的性质得到，以点 $i$ 为结束节点的子串个数等于 $len[i] - len[link[i]]$<br>所以可以遍历所有的节点求和得到</p><p>例题：<a href="https://www.luogu.com.cn/problem/P6139">【模板】广义后缀自动机（广义 SAM）</a></p><p>??? note “参考代码”<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 2000000            <span class="hljs-comment">// 双倍字符串长度</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CHAR_NUM 30             <span class="hljs-comment">// 字符集个数，注意修改下方的 (-&#x27;a&#x27;)</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">exSAM</span> &#123;<br>    <span class="hljs-type">int</span> len[MAXN];              <span class="hljs-comment">// 节点长度</span><br>    <span class="hljs-type">int</span> link[MAXN];             <span class="hljs-comment">// 后缀链接，link</span><br>    <span class="hljs-type">int</span> next[MAXN][CHAR_NUM];   <span class="hljs-comment">// 转移</span><br>    <span class="hljs-type">int</span> tot;                    <span class="hljs-comment">// 节点总数：[0, tot)</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        tot = <span class="hljs-number">1</span>;<br>        link[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">insertSAM</span><span class="hljs-params">(<span class="hljs-type">int</span> last, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>        <span class="hljs-type">int</span> cur = next[last][c];<br>        <span class="hljs-keyword">if</span> (len[cur]) <span class="hljs-keyword">return</span> cur;<br>        len[cur] = len[last] + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> p = link[last];<br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!next[p][c]) next[p][c] = cur;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>            p = link[p];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-number">-1</span>) &#123;<br>            link[cur] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> cur;<br>        &#125;<br>        <span class="hljs-type">int</span> q = next[p][c];<br>        <span class="hljs-keyword">if</span> (len[p] + <span class="hljs-number">1</span> == len[q]) &#123;<br>            link[cur] = q;<br>            <span class="hljs-keyword">return</span> cur;<br>        &#125;<br>        <span class="hljs-type">int</span> clone = tot++;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; CHAR_NUM; ++i)<br>            next[clone][i] = len[next[q][i]] != <span class="hljs-number">0</span> ? next[q][i] : <span class="hljs-number">0</span>;<br>        len[clone] = len[p] + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-number">-1</span> &amp;&amp; next[p][c] == q) &#123;<br>            next[p][c] = clone;<br>            p = link[p];<br>        &#125;<br>        link[clone] = link[q];<br>        link[cur] = clone;<br>        link[q] = clone;<br><br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">insertTrie</span><span class="hljs-params">(<span class="hljs-type">int</span> cur, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (next[cur][c]) <span class="hljs-keyword">return</span> next[cur][c];<br>        <span class="hljs-keyword">return</span> next[cur][c] = tot++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> root = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch : s) root = <span class="hljs-built_in">insertTrie</span>(root, ch - <span class="hljs-string">&#x27;a&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> root = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) root = <span class="hljs-built_in">insertTrie</span>(root, s[i] - <span class="hljs-string">&#x27;a&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>        queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i)<br>            <span class="hljs-keyword">if</span> (next[<span class="hljs-number">0</span>][i]) q.<span class="hljs-built_in">push</span>(&#123;i, <span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> item = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">auto</span> last = <span class="hljs-built_in">insertSAM</span>(item.second, item.first);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i)<br>                <span class="hljs-keyword">if</span> (next[last][i]) q.<span class="hljs-built_in">push</span>(&#123;i, last&#125;);<br>        &#125;<br>    &#125;<br>&#125; exSam;<br><br><span class="hljs-type">char</span> s[<span class="hljs-number">1000100</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    exSam.<span class="hljs-built_in">init</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cin &gt;&gt; s;<br>        <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(s);<br>        exSam.<span class="hljs-built_in">insert</span>(s, len);<br>    &#125;<br>    exSam.<span class="hljs-built_in">build</span>();<br><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; exSam.tot; ++i) &#123;<br>        ans += exSam.len[i] - exSam.len[exSam.link[i]];<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="多个字符串间的最长公共子串"><a href="#多个字符串间的最长公共子串" class="headerlink" title="多个字符串间的最长公共子串"></a>多个字符串间的最长公共子串</h3><p>我们需要对每个节点建立一个长度为 $k$ 的数组 <code>flag</code>（对于本题而言，可以仅为标记数组，若需要求出此子串的个数，则需要改成计数数组）<br>在字典树插入字符串时，对所有节点进行计数，保存在当前字符串所在的数组<br>然后按照 <code>len</code> 递减的顺序遍历，通过后缀链接将当前节点的 <code>flag</code> 与其他节点的合并<br>遍历所有的节点，找到一个 <code>len</code> 最大且满足对于所有的 <code>k</code> ，其 <code>flag</code> 的值均为非 $0$ 的节点，此节点的 $len$ 即为解</p><p>例题：<a href="https://www.spoj.com/problems/LCS2/">SPOJ Longest Common Substring II</a></p><p>??? note “参考代码”</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 2000000            <span class="hljs-comment">// 双倍字符串长度</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CHAR_NUM 30             <span class="hljs-comment">// 字符集个数，注意修改下方的 (-&#x27;a&#x27;)</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUM 15                  <span class="hljs-comment">// 字符串个数</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">exSAM</span> &#123;<br>    <span class="hljs-type">int</span> len[MAXN];              <span class="hljs-comment">// 节点长度</span><br>    <span class="hljs-type">int</span> link[MAXN];             <span class="hljs-comment">// 后缀链接，link</span><br>    <span class="hljs-type">int</span> next[MAXN][CHAR_NUM];   <span class="hljs-comment">// 转移</span><br>    <span class="hljs-type">int</span> tot;                    <span class="hljs-comment">// 节点总数：[0, tot)</span><br><br>    <span class="hljs-type">int</span> lenSorted[MAXN];        <span class="hljs-comment">// 按照 len 排序后的数组，仅排序 [1, tot) 部分，最终下标范围 [0, tot - 1)</span><br>    <span class="hljs-type">int</span> sizeC[MAXN][NUM];       <span class="hljs-comment">// 表示某个字符串的子串个数</span><br>    <span class="hljs-type">int</span> curString;              <span class="hljs-comment">// 字符串实际个数</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 计数排序使用的辅助空间数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> lc[MAXN];               <span class="hljs-comment">// 统计个数</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        tot = <span class="hljs-number">1</span>;<br>        link[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">insertSAM</span><span class="hljs-params">(<span class="hljs-type">int</span> last, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>        <span class="hljs-type">int</span> cur = next[last][c];<br>        len[cur] = len[last] + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> p = link[last];<br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!next[p][c]) next[p][c] = cur;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>            p = link[p];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-number">-1</span>) &#123;<br>            link[cur] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> cur;<br>        &#125;<br>        <span class="hljs-type">int</span> q = next[p][c];<br>        <span class="hljs-keyword">if</span> (len[p] + <span class="hljs-number">1</span> == len[q]) &#123;<br>            link[cur] = q;<br>            <span class="hljs-keyword">return</span> cur;<br>        &#125;<br>        <span class="hljs-type">int</span> clone = tot++;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; CHAR_NUM; ++i)<br>            next[clone][i] = len[next[q][i]] != <span class="hljs-number">0</span> ? next[q][i] : <span class="hljs-number">0</span>;<br>        len[clone] = len[p] + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (p != <span class="hljs-number">-1</span> &amp;&amp; next[p][c] == q) &#123;<br>            next[p][c] = clone;<br>            p = link[p];<br>        &#125;<br>        link[clone] = link[q];<br>        link[cur] = clone;<br>        link[q] = clone;<br><br>        <span class="hljs-keyword">return</span> cur;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">insertTrie</span><span class="hljs-params">(<span class="hljs-type">int</span> cur, <span class="hljs-type">int</span> c)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!next[cur][c]) next[cur][c] = tot++;<br>        sizeC[next[cur][c]][curString]++;<br>        <span class="hljs-keyword">return</span> next[cur][c];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> string &amp;s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> root = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch : s) root = <span class="hljs-built_in">insertTrie</span>(root, ch - <span class="hljs-string">&#x27;a&#x27;</span>);<br>        curString++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> root = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) root = <span class="hljs-built_in">insertTrie</span>(root, s[i] - <span class="hljs-string">&#x27;a&#x27;</span>);<br>        curString++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>        queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i)<br>            <span class="hljs-keyword">if</span> (next[<span class="hljs-number">0</span>][i]) q.<span class="hljs-built_in">push</span>(&#123;i, <span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">auto</span> item = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">auto</span> last = <span class="hljs-built_in">insertSAM</span>(item.second, item.first);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i)<br>                <span class="hljs-keyword">if</span> (next[last][i]) q.<span class="hljs-built_in">push</span>(&#123;i, last&#125;);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sortLen</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; tot; ++i) lc[i] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; tot; ++i) lc[len[i]]++;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; tot; ++i) lc[i] += lc[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; tot; ++i) lenSorted[--lc[len[i]]] = i;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getSizeLen</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = tot - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; curString; ++j)<br>                sizeC[link[lenSorted[i]]][j] += sizeC[lenSorted[i]][j];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;     i      len      link       &quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; ++i)<br>            cout &lt;&lt; <span class="hljs-string">&quot;  &quot;</span> &lt;&lt; (<span class="hljs-type">char</span>) (<span class="hljs-string">&#x27;a&#x27;</span> + i);<br>        cout &lt;&lt; endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; tot; ++i) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;i: &quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">3</span>) &lt;&lt; i<br>                 &lt;&lt; <span class="hljs-string">&quot; len: &quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">3</span>) &lt;&lt; len[i]<br>                 &lt;&lt; <span class="hljs-string">&quot; link: &quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">3</span>) &lt;&lt; link[i]<br>                 &lt;&lt; <span class="hljs-string">&quot; Next: &quot;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; CHAR_NUM; ++j) &#123;<br>                cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">3</span>) &lt;&lt; next[i][j];<br>            &#125;<br>            cout &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125; exSam;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    exSam.<span class="hljs-built_in">init</span>();<br>    string s;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; s) &#123;<br>        exSam.<span class="hljs-built_in">insert</span>(s);<br>    &#125;<br>    exSam.<span class="hljs-built_in">build</span>();<br>    exSam.<span class="hljs-built_in">sortLen</span>();<br>    exSam.<span class="hljs-built_in">getSizeLen</span>();<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; exSam.tot; ++i) &#123;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; exSam.curString; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (!exSam.sizeC[i][j]) &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (flag) ans = <span class="hljs-built_in">max</span>(ans, exSam.len[i]);<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020牛客暑期多校训练营（第三场）D-Points Construction Problem——构造</title>
    <link href="/2020/07/18/acm/2020-multi-school/NowCoder-3-D-Points%20Construction%20Problem/"/>
    <url>/2020/07/18/acm/2020-multi-school/NowCoder-3-D-Points%20Construction%20Problem/</url>
    
    <content type="html"><![CDATA[<h1 id="D-Points-Construction-Problem"><a href="#D-Points-Construction-Problem" class="headerlink" title="D-Points Construction Problem"></a>D-Points Construction Problem</h1><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p><strong>第一点：千万不要考虑矩阵，千万不要考虑矩阵，千万不要考虑矩阵。因为完全可以是两个三个矩阵和几条链组成，这实在过于难考虑</strong></p><p>这道题最难以考虑的地方就是矩阵的构造。这里给出一个思路去解决这个问题。<br>当然可能这个方法不是最正确的，但是结果是最优（毕竟AC了）</p><h2 id="计算缺失边数"><a href="#计算缺失边数" class="headerlink" title="计算缺失边数"></a>计算缺失边数</h2><p>这个应该相对简单，即公式 <code>(n * 4 - m) / 2</code> 的结果</p><h2 id="类矩阵结构"><a href="#类矩阵结构" class="headerlink" title="类矩阵结构"></a>类矩阵结构</h2><p><strong>这里我们仅考虑非单链的结构，即可以出现矩阵的结构，即 $缺失边数 \geq 4$的情况</strong></p><p>我们首先给出一个矩阵的核心部分，暂时称其为“核”<br><img src="/image/acm/2020-multi-school/NowCoder-3-D-Points Construction Problem/1.png" alt="核"><br>这个核有一个特性：4个点能够增加4条边，记作： $4 \rightarrow 4$</p><p>这是一个矩阵的基础，而且一个矩阵仅需要一个核。</p><p>接下来最贪心的方法就是放下这样两个蓝色的点<br><img src="/image/acm/2020-multi-school/NowCoder-3-D-Points Construction Problem/2.png" alt="23"><br>这个结构能够实现用2个点增加3条边，记作： $2 \rightarrow 3$</p><p>同样，我们也可以在上面放下这样的结构</p><p><img src="/image/acm/2020-multi-school/NowCoder-3-D-Points Construction Problem/3.png" alt="23"><br>同样被记作： $2 \rightarrow 3$</p><p><strong>值得注意的是：核结构 $4 \rightarrow 4$ 是所有类矩阵结构的前提，但是由于其产生的连边数量非常少，所以尽可能的减少其使用，即整个图结构仅使用一次 $4 \rightarrow 4$。而 $2 \rightarrow 3$ 则没有次数限制，可以向上也可以向右</strong></p><p>在上图的基础上，我们还可以提出一个结构：<br><img src="/image/acm/2020-multi-school/NowCoder-3-D-Points Construction Problem/4.png" alt="12"><br>这个橙色的点非常的巧妙，其实现了一个点新增了两条边，记作 $1 \rightarrow 2$</p><p>很明显，$1 \rightarrow 2$ 结构是最优的，结构越多则越能用较少的点来实现缺失的边的需求。所以我们需要尽可能的增加 $1 \rightarrow 2$ 的结构</p><p>但是，此结构有数量限制，其数量受到 $2 \rightarrow 3$ 的数量限制。</p><p>再考虑到矩阵的结构能够带来更多的 $1 \rightarrow 2$ 结构，所以我们选择采用如下的贪心策略</p><ol><li>先放一个$2*2$的矩阵</li><li>向上/右扩展</li><li>用 $1 \rightarrow 2$ 结构填充矩阵</li><li>向右/上扩展</li><li>用 $1 \rightarrow 2$ 结构填充矩阵</li><li>重复 $2-6$ 直到缺失边全部被满足</li><li>如果使用的点数超出提供的，则无解，否则将多余的点数放在遥远的天边，然后输出</li></ol><h2 id="剩余不满足结构"><a href="#剩余不满足结构" class="headerlink" title="剩余不满足结构"></a>剩余不满足结构</h2><p>由于上述策略可能会出现遗留下 $1至2$ 条缺失边，则我们可以把点放在矩阵的左下角，即图中的×</p><p><img src="/image/acm/2020-multi-school/NowCoder-3-D-Points Construction Problem/5.png" alt="x"></p><p>则可以满足一条缺失边或者两条缺失边的要求</p><h1 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">bool</span> flag[<span class="hljs-number">60</span>][<span class="hljs-number">60</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">while</span> (n--)<br>        cout &lt;&lt; n * <span class="hljs-number">100</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; n * <span class="hljs-number">100</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">60</span>; ++i)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">60</span>; ++j)<br>            <span class="hljs-keyword">if</span> (flag[i][j])<br>                cout &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; j + <span class="hljs-number">1</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; T; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, m;<br>        cin &gt;&gt; n &gt;&gt; m;<br>        <span class="hljs-type">int</span> target = (n * <span class="hljs-number">4</span> - m) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> ((n * <span class="hljs-number">4</span> - m) &amp; <span class="hljs-number">1</span>) &#123;<br>            n = <span class="hljs-number">-1</span>;<br>            <span class="hljs-built_in">print</span>(n);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-built_in">memset</span>(flag, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(flag));<br><br>        <span class="hljs-keyword">if</span> (target &lt; <span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-type">int</span> x = <span class="hljs-number">2</span>;<br>            flag[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>            n--;<br><br>            <span class="hljs-keyword">while</span> (target &amp;&amp; n &gt;= <span class="hljs-number">0</span>) &#123;<br>                flag[x][<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>                x++;<br>                target--;<br>                n--;<br>            &#125;<br>            <span class="hljs-built_in">print</span>(n);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        flag[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = flag[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = flag[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = flag[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = <span class="hljs-literal">true</span>;<br>        n -= <span class="hljs-number">4</span>;<br>        target -= <span class="hljs-number">4</span>;<br><br>        <span class="hljs-type">int</span> l = <span class="hljs-number">3</span>, r = <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">while</span> (target &gt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-comment">// 右扩展</span><br>            flag[<span class="hljs-number">1</span>][l] = <span class="hljs-literal">true</span>;<br>            flag[<span class="hljs-number">2</span>][l] = <span class="hljs-literal">true</span>;<br>            l++;<br>            target -= <span class="hljs-number">3</span>;<br>            n -= <span class="hljs-number">2</span>;<br><br>            <span class="hljs-type">int</span> len = <span class="hljs-number">3</span>;<br>            <span class="hljs-keyword">while</span> (len &lt; r &amp;&amp; target &gt; <span class="hljs-number">1</span>) &#123;<br>                flag[len][l - <span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>                target -= <span class="hljs-number">2</span>;<br>                n--;<br>                len++;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (target &gt; <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-comment">// 上扩展</span><br>                flag[r][<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>                flag[r][<span class="hljs-number">2</span>] = <span class="hljs-literal">true</span>;<br>                r++;<br>                target -= <span class="hljs-number">3</span>;<br>                n -= <span class="hljs-number">2</span>;<br><br>                len = <span class="hljs-number">3</span>;<br>                <span class="hljs-keyword">while</span> (len &lt; l &amp;&amp; target &gt; <span class="hljs-number">1</span>) &#123;<br>                    flag[r - <span class="hljs-number">1</span>][len] = <span class="hljs-literal">true</span>;<br>                    target -= <span class="hljs-number">2</span>;<br>                    n--;<br>                    len++;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (target == <span class="hljs-number">2</span>) &#123;<br>            n -= <span class="hljs-number">2</span>;<br>            flag[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>            flag[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target == <span class="hljs-number">1</span>) &#123;<br>            n -= <span class="hljs-number">1</span>;<br>            flag[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-built_in">print</span>(n);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios_base::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ACM_LOCAL</span><br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;in.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;out.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br>    <span class="hljs-type">int</span> test_index_for_debug = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span> acm_local_for_debug;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; acm_local_for_debug) &#123;<br>        <span class="hljs-keyword">if</span> (acm_local_for_debug == <span class="hljs-string">&#x27;$&#x27;</span>) <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        cin.<span class="hljs-built_in">putback</span>(acm_local_for_debug);<br>        <span class="hljs-keyword">if</span> (test_index_for_debug &gt; <span class="hljs-number">20</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Check the stdin!!!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">auto</span> start_clock_for_debug = <span class="hljs-built_in">clock</span>();<br>        <span class="hljs-built_in">solve</span>();<br>        <span class="hljs-keyword">auto</span> end_clock_for_debug = <span class="hljs-built_in">clock</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="hljs-string">&quot; successful&quot;</span> &lt;&lt; endl;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="hljs-string">&quot; Run Time: &quot;</span><br>             &lt;&lt; <span class="hljs-built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="hljs-string">&quot;s&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-built_in">solve</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>NowCoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020牛客暑期多校训练营（第三场）E-Two Matchings——复杂思维与简单dp</title>
    <link href="/2020/07/18/acm/2020-multi-school/NowCoder-3-E-Two%20Matchings/"/>
    <url>/2020/07/18/acm/2020-multi-school/NowCoder-3-E-Two%20Matchings/</url>
    
    <content type="html"><![CDATA[<h1 id="E-Two-Matchings"><a href="#E-Two-Matchings" class="headerlink" title="E-Two Matchings"></a>E-Two Matchings</h1><p><del>比赛期间写博文，队友我家挖祖坟</del></p><p><del>数论只会g c d，队友AC我挂机</del></p><p><a href="https://ac.nowcoder.com/acm/contest/5668/E">题目连接</a></p><p><strong>注意本文中的部分字母和原文稍有不同，请注意！</strong></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>定义序列 $a$ ，满足如下要求</p><ul><li>长度为 $n$ 的序列 $a$ 由 $1, 2, 3… n$ 组成</li><li>$a_{a_i} = i$</li><li>$a_i \neq i$</li></ul><p>定义一个字符串的费用为$\sum_{i=1}^{n}w_i - w_{a_i}/2$ ， $w$ 为给出的权值数组</p><p>求两个满足上述对序列 $a$ 的描述的序列 $p, q$，同时还要满足 $p_i \neq q_i$ 对于每一个 $i$ 都成立</p><p>则这两个序列的费用和的最小值是多少</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>根据条件</p><ul><li>长度为 $n$ 的序列 $a$ 由 $1, 2, 3… n$ 组成</li><li>$a_{a_i} = i$</li><li>$a_i \neq i$</li></ul><p>可以得到序列是由基础序列 $1, 2, 3…n$ 通过进行两两对调得到，且每个值进行且只进行一次对调。（这里就不仔细证明了，应该……在打这个比赛的人应该都能理解吧）</p><p>而我们需要得到的就是两个费用最小的串，即最小串和次小串</p><p><strong>注意，接下来的讨论仅讨论排序后的下标，即如果写着 $1$ 则指代 sort 后的数组 $w$ 中最小的值</strong></p><h2 id="最小值"><a href="#最小值" class="headerlink" title="最小值"></a>最小值</h2><p>首先是最小的值，那很明显，把 <code>w</code> 数组排序后，间隔着相减就可以得到，例如下面已经排序后的<strong>下标</strong>序列：</p>$$1, 2, 3, 4, 5, 6$$<p>我们可以得到其最小的解为</p>$$(2 - 1) + (4 - 3) + (6 - 5)$$<p>我们暂时不去处理这个解，保留原样</p><h2 id="次小值"><a href="#次小值" class="headerlink" title="次小值"></a>次小值</h2><p>接下来是次优解，首先应当保证其每一位的值不相同</p><p>由于我们已经将最小值的组合取完了，则次优解就有了非常多的限制</p><p>我们可以“旋转”这个数列得到</p>$$2, 3, 4, 5, 6, 1\rightarrow (3 - 2) + (5 - 4) + (6 - 1)$$<p>把这个“旋转”暂时称为 $6-rotation$，指代 $6$ 个元素的旋转</p><p>而此时即为次优的解。</p><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>我们以六个数字的数列来证明上述操作</p><p>首先用 $-$ 表示这个值作为其所在的交换中的较小值， $+$ 表示这值作为其所在的交换中的较大值</p><p>例如最小值可以表示为</p><div class="table-container"><table><thead><tr><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>-</td><td>+</td><td>-</td><td>+</td><td>-</td><td>+</td></tr></tbody></table></div><p>我们并不需要具体考虑哪个值与哪个值交换，因为最终的求和结果是一样的，即上面的值与下面的符号结合后相加就是最终结果。</p><p>除去最小解后，我们只有以下两种组合方法</p><div class="table-container"><table><thead><tr><th>index</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>min</td><td>-</td><td>+</td><td>-</td><td>+</td><td>-</td><td>+</td></tr><tr><td>plan 1</td><td>-</td><td>-</td><td>+</td><td>-</td><td>+</td><td>+</td></tr><tr><td>plan 2</td><td>-</td><td>-</td><td>-</td><td>+</td><td>+</td><td>+</td></tr><tr><td>error</td><td>-</td><td>-</td><td>+</td><td>+</td><td>-</td><td>+</td></tr></tbody></table></div><p>这里举例一个错误的方案，虽然看起来此方案是与最小值方案不同，但是注意一下最后两个值，无论这个错误方案怎么组合，$5-6$<br>必然要发生组合并发生交换，则与最小值的方案出现重复，则不行。</p><p>那么我们比较一下这两个方案哪个更优</p>$$\frac{方案1}{方案2} = \frac{-1-2+3-4+5+6}{-1-2-3+4+5+6} = \frac{-1}{1} $$<p><strong>（使用分数线仅用于视觉上更好的体现上下的对比效果，并无除法运算思想，下同）</strong></p><p>注意，这里不能取 $abs$ 因为在配对的时候我们已经保证了右边的加号匹配左边的减号，即必定为正数</p><p>很明显，方案1更优，即上方的次优解</p><p>（感谢 <a href="https://www.nowcoder.com/profile/248983965">@yyymmmi</a><br>和 <a href="https://www.nowcoder.com/profile/841902884">@hnust_zhangpeng</a> 指出错误，现已更正）</p><h2 id="合并最小值和次小值"><a href="#合并最小值和次小值" class="headerlink" title="合并最小值和次小值"></a>合并最小值和次小值</h2><p>我们将两个解相加发现最终结果为</p>$$[(2 - 1) + (4 - 3) + (6 - 5)] + [(3 - 2) + (5 - 4) + (6 - 1)] =2 * (6 - 1)$$<h2 id="长度不及-6-的时候"><a href="#长度不及-6-的时候" class="headerlink" title="长度不及 $6$ 的时候"></a>长度不及 $6$ 的时候</h2><p>而对于长度仅为 $4$ 的串，只能 $4-rotation$ ，即</p>$$1, 2, 3, 4 \rightarrow (4-rotation)\rightarrow 2, 3, 4, 1 \rightarrow (3 - 2) + (4 - 1)$$<p>此时的最终结果为（过程忽略）</p>$$2 * (4 - 1)$$<h2 id="长度为-8-的时候"><a href="#长度为-8-的时候" class="headerlink" title="长度为$8$的时候"></a>长度为$8$的时候</h2><p>那么我们再往长度增长的方向考虑，当 $n = 8$ 时，我们有两个方案，</p><ol><li>两个 $4-rotation$ （ $1234$ 和 $5678$ ）来旋转它</li><li>两个 $4-rotation$ （ $1278$ 和 $3456$ ）来旋转它</li><li>一个 $8-rotation$ 来旋转它</li></ol><p><strong>注意，此题是不存在 $2-rotation$ 的，因为这毫无意义，所以 $n = 8$ 时，没有一个 $6-rotation$ 和一个 $2-rotation$ 这样的组合。</strong></p><p>先比较一下两个 $4-rotation$：</p>$$\frac{方案1}{方案2} = \frac{2 * [(4 - 1) + (8 - 5)]}{2 * [(8 - 1) + (6 - 3)]} = \frac{12}{20}$$<p>我们选择使用方案 $1$</p><p>接下来是方案 $1$ 和方案 $3$ 的比较</p>$$\frac{方案1}{方案3} = \frac{2 * [(4 - 1) + (8 - 5)]}{2 * [(8 - 1)]} = \frac{12}{14}$$<p>此时证明得到方案 $1$ 在三个方案内最优，此时 $n =8$ 时的答案为：</p>$$2 * [(4 - 1) + (8 - 5)]$$<p>同时我们得到了一个结论：仅存在 $4-rotation$ 和 $6-rotation$ 两种旋转，如果存在 $8-rotation$ 则可以将此 $8-rotation$ 分解为两个<br>$4-rotation$ 可以更优。</p><h2 id="长度更长的时候"><a href="#长度更长的时候" class="headerlink" title="长度更长的时候"></a>长度更长的时候</h2><p>当 $n \geq 10$ 时，即可以将整个串分解成多个 $4-rotation$ 和多个 $6-rotation$ 组成。</p><p>那么得到了 $dp$ 的递推公式：<code>dp[i] = min(dp[i - 4] + v[i - 1] - v[i - 4], dp[i - 6] + v[i - 1] - v[i - 6])</code></p><p>注意 $dp$ 的初始值有三个：$n = 4, n = 6, n = 8 \space (防止n = 8的时候出现2-rotation)$</p><h1 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dp[<span class="hljs-number">200100</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; T; ++ts) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; v;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> tmp;<br>            cin &gt;&gt; tmp;<br>            v.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br>        <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br><br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        dp[<span class="hljs-number">4</span>] = v[<span class="hljs-number">3</span>] - v[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">6</span>] = v[<span class="hljs-number">5</span>] - v[<span class="hljs-number">0</span>];<br>        dp[<span class="hljs-number">8</span>] = v[<span class="hljs-number">7</span>] - v[<span class="hljs-number">4</span>] + dp[<span class="hljs-number">4</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">10</span>; i &lt;= n; i += <span class="hljs-number">2</span>)<br>            dp[i] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">4</span>] + v[i - <span class="hljs-number">1</span>] - v[i - <span class="hljs-number">4</span>], dp[i - <span class="hljs-number">6</span>] + v[i - <span class="hljs-number">1</span>] - v[i - <span class="hljs-number">6</span>]);<br>        cout &lt;&lt; dp[n] * <span class="hljs-number">2</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios_base::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ACM_LOCAL</span><br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;in.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;out.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br>    <span class="hljs-type">int</span> test_index_for_debug = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span> acm_local_for_debug;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; acm_local_for_debug) &#123;<br>        <span class="hljs-keyword">if</span> (acm_local_for_debug == <span class="hljs-string">&#x27;$&#x27;</span>) <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        cin.<span class="hljs-built_in">putback</span>(acm_local_for_debug);<br>        <span class="hljs-keyword">if</span> (test_index_for_debug &gt; <span class="hljs-number">20</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Check the stdin!!!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">auto</span> start_clock_for_debug = <span class="hljs-built_in">clock</span>();<br>        <span class="hljs-built_in">solve</span>();<br>        <span class="hljs-keyword">auto</span> end_clock_for_debug = <span class="hljs-built_in">clock</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="hljs-string">&quot; successful&quot;</span> &lt;&lt; endl;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="hljs-string">&quot; Run Time: &quot;</span><br>             &lt;&lt; <span class="hljs-built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="hljs-string">&quot;s&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-built_in">solve</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><del>事后发现其实代码有越界的问题……但是它AC了</del> </p>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>NowCoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020牛客暑期多校训练营（第二场）I-Interval——最大流转对偶图求最短路</title>
    <link href="/2020/07/16/acm/2020-multi-school/NowCoder-2-I-Interval/"/>
    <url>/2020/07/16/acm/2020-multi-school/NowCoder-2-I-Interval/</url>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/5667/I">题目链接</a></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给出一个区间 $[l ,r]$ ，允许进行如下操作：</p><ol><li>将 $[l, r]$ 转为 $[l - 1, r]$ 或者 $[l + 1, r]$ </li><li>将 $[l, r]$ 转为 $[l, r - 1]$ 或者 $[l, r + 1]$</li></ol><p>且保证 $l \leq r \space and \space l &gt; 0 \space r \leq n$</p><p>但是给出了一系列的限制 $l, r, dir, c$ ，表示当前区间为 $[l, r]$ 时，限制当前的区间不能进行操作 $1$（<code>dir = L</code>）或者操作 $2$ （<code>dir = R</code>），而启用这个限制则需要 $c$ 的费用，你可以选择是否启用这个限制</p><p>询问最少需要花费多少来实现<strong>不能</strong>将区间 $[1, n]$ 转变为 $l = r$ 的区间。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>从 $1, n$ 能否转变为 $l = r$ 可以通过最短路来求算。但是无法求知当最短路无法到达时（即题目要求的<strong>不能</strong>转变）最少需要多少的限制条件，而这些条件又是什么。所以采用最大流来解决</p><h2 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h2><p>画出网格图<br>将所有可以转换的两个状态之间用边连接，如果有提供限制的，将流量限制为费用，如果没有限制的，则设置为 $INF$<br>对于整个矩阵而言，只需要一半的点用于建图，所以将汇点放在另外一半点中。所有 $l = r$ 的点与汇点连接，而源点为 $[1, n]$<br>对于样例可以得到如下图</p><blockquote><p>样例：<br>3 4<br>1 3 L 10<br>1 3 R 3<br>1 2 L 1<br>1 2 R 1</p></blockquote><p><img src="/image/acm/2020-multi-school/NowCoder-2-I-Interval/1.png" alt="图1"></p><p><strong>补充，图片漏画了$[2, 3] \rightarrow [2, 2]$的连线，其流量为 $INF$</strong></p><p>可以直接通过最大流求出答案</p><p>但是会TLE</p><h2 id="对偶图"><a href="#对偶图" class="headerlink" title="对偶图"></a>对偶图</h2><p><a href="https://en.wikipedia.org/wiki/Dual_graph">对偶图Wikipedia（https://en.wikipedia.org/wiki/Dual_graph）</a></p><p>通过对偶图，可以快速的将一张网格网络图求最大流转为求最短路</p><p>关于对偶图的解释请自行查阅资料</p><p>在原图上绘制对偶图得到</p><p><img src="/image/acm/2020-multi-school/NowCoder-2-I-Interval/2.png" alt="对偶图"></p><p>将对偶图中有用的元素将其分离出来得到</p><p><img src="/image/acm/2020-multi-school/NowCoder-2-I-Interval/3.png" alt="对偶图"></p><p>（图中未注明边权的边均为 $0$）</p><p>可以通过最短路快速得到解</p><h1 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">510</span>;<br><br><span class="hljs-type">int</span> n, m;<br>ll dis[maxn * maxn];<br><span class="hljs-type">char</span> si;<br>vector&lt;pair&lt;ll, <span class="hljs-type">int</span>&gt;&gt; G[maxn * maxn];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> cost)</span> </span>&#123;<br>    G[u].<span class="hljs-built_in">push_back</span>(&#123;cost, v&#125;);<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t)</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dis));<br>    dis[s] = <span class="hljs-number">0</span>;<br>    priority_queue&lt;pair&lt;ll, <span class="hljs-type">int</span>&gt;, vector&lt;pair&lt;ll, <span class="hljs-type">int</span>&gt;&gt;, greater&lt;pair&lt;ll, <span class="hljs-type">int</span>&gt;&gt;&gt; q;<br>    q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0ll</span>, s&#125;);<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        ll u = q.<span class="hljs-built_in">top</span>().second, c = q.<span class="hljs-built_in">top</span>().first;<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (dis[u] &lt; c)<span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i : G[u]) &#123;<br>            ll cc = i.first, v = i.second;<br>            <span class="hljs-keyword">if</span> (dis[v] &gt; dis[u] + cc) &#123;<br>                dis[v] = dis[u] + cc;<br>                q.<span class="hljs-built_in">push</span>(&#123;dis[v], v&#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dis[t];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">id</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x * (n + <span class="hljs-number">3</span>) + y;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        <span class="hljs-type">int</span> u, v, w;<br>        <span class="hljs-type">char</span> c;<br>        cin &gt;&gt; u &gt;&gt; v &gt;&gt; c &gt;&gt; w;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;L&#x27;</span>) &#123;<br>            <span class="hljs-built_in">addedge</span>(<span class="hljs-built_in">id</span>(u, v), <span class="hljs-built_in">id</span>(u, v + <span class="hljs-number">1</span>), w);<br>            <span class="hljs-built_in">addedge</span>(<span class="hljs-built_in">id</span>(u, v + <span class="hljs-number">1</span>), <span class="hljs-built_in">id</span>(u, v), w);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">addedge</span>(<span class="hljs-built_in">id</span>(u, v), <span class="hljs-built_in">id</span>(u - <span class="hljs-number">1</span>, v), w);<br>            <span class="hljs-built_in">addedge</span>(<span class="hljs-built_in">id</span>(u - <span class="hljs-number">1</span>, v), <span class="hljs-built_in">id</span>(u, v), w);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-built_in">addedge</span>(<span class="hljs-built_in">id</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-built_in">id</span>(<span class="hljs-number">0</span>, i), <span class="hljs-number">0</span>);<br>        <span class="hljs-built_in">addedge</span>(<span class="hljs-built_in">id</span>(i, n + <span class="hljs-number">1</span>), <span class="hljs-built_in">id</span>(n + <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>), <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">dijkstra</span>(<span class="hljs-built_in">id</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-built_in">id</span>(n + <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">if</span> (dis[<span class="hljs-built_in">id</span>(n + <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>)] &gt;= <span class="hljs-number">0x3f3f3f3f3f3f3f3f</span>)<br>        cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span><br>        cout &lt;&lt; dis[<span class="hljs-built_in">id</span>(n + <span class="hljs-number">1</span>, n + <span class="hljs-number">1</span>)] &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios_base::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ACM_LOCAL</span><br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;in.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;out.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br>    <span class="hljs-type">int</span> test_index_for_debug = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span> acm_local_for_debug;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; acm_local_for_debug) &#123;<br>        <span class="hljs-keyword">if</span> (acm_local_for_debug == <span class="hljs-string">&#x27;$&#x27;</span>) <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        cin.<span class="hljs-built_in">putback</span>(acm_local_for_debug);<br>        <span class="hljs-keyword">if</span> (test_index_for_debug &gt; <span class="hljs-number">20</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Check the stdin!!!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">auto</span> start_clock_for_debug = <span class="hljs-built_in">clock</span>();<br>        <span class="hljs-built_in">solve</span>();<br>        <span class="hljs-keyword">auto</span> end_clock_for_debug = <span class="hljs-built_in">clock</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="hljs-string">&quot; successful&quot;</span> &lt;&lt; endl;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="hljs-string">&quot; Run Time: &quot;</span><br>             &lt;&lt; <span class="hljs-built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="hljs-string">&quot;s&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-built_in">solve</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>NowCoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020牛客暑期多校训练营（第二场）H-Happy Triangle——动态开点线段树+STL+区间化点</title>
    <link href="/2020/07/15/acm/2020-multi-school/NowCoder-2-H-Happy%20Triangle/"/>
    <url>/2020/07/15/acm/2020-multi-school/NowCoder-2-H-Happy%20Triangle/</url>
    
    <content type="html"><![CDATA[<p>在WA了好多发之后，终于找到了我不小心写错的bug……<del>我是SB</del></p><p>我的写法与网络上很多人的差异较大，但是个人觉得比其他人的更容易理解。第一次写动态开点的线段树，直接稍微改动了一下原本自己习惯的线段树板子，所以可能与其他板子不同。同时因为是改了线段树的板子，所以反而更容易看懂。其次就是个人感觉我的写法比题解要简单很多，而且码量很小</p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>对于一个可重复集合，进行Q次操作。集合起始的时候为空，操作类型如下</p><ul><li>往集合中加入一个元素</li><li>从集合中删除一个元素（保证其存在）</li><li>给定一个元素 $x$ ，问集合中是否存在另外两个元素$a, b$（允许值相同但是不允许元素相同），使得$a, b, x$三条边可以组成一个非退化三角形（即满足任意两边之和大于第三边，或任意两边之差小于第三边）。</li></ul><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="分析三角形公式"><a href="#分析三角形公式" class="headerlink" title="分析三角形公式"></a>分析三角形公式</h2><p>首先根据公式$a + b &gt; c$ 转为 $c - b&lt;a$ （假定$a \leq b \leq c$），那么我们可以得到，下面的结论：</p><p>假定存在 $a \leq b$ 满足 $a, b, c$ 三边能够组成三角形，那么对于 $a \leq a’ \leq b$ 必定存在 $a’, b, c$ 可以组成三角形（由 $c - b&lt;a \leq a’$ 证得）</p><p>那么我们可以指定如下规定：</p><ul><li>对于输入的 $x$ ，我们找到两条长度分别为 $a, b$ 的边，使得 $a, b, x$ 能够组成三角形，且不存在 $a’$ 满足 $a &lt; a’ \leq b$，这里我们暂时称 $a, b$ 相邻（这点非常重要！！！）</li></ul><p>即 $a, b$ 在整个集合排序后，在数组中的下标差为 $1$ </p><p>接下来考虑如何找到 $a, b$。题解中提到类似分类讨论，但是我觉得没有必要。我们仅考虑通过 $a, b$ 的运算后的结果与 $x$ 来比较，最终得到我们的结果是否符合。根据 $a, b, x$ 的大小关系讨论三种情况：（前提 $a \leq b$）</p><ol><li>$x$ 为最大值时，我们只需要保证 $a + b &gt; x$ 即可</li><li>$a \leq x \leq b$ 时，我们需要保证 $a + x &gt; b$ ，转换后得到 $b - a &lt; x$</li><li>$x \leq a \leq b$ 时，我们需要保证 $x + a &gt; b$ ，转换后得到 $b - a &lt; x$</li></ol><p>总结：我们只需要保证我们选出来的$a, b$ 保证 $a + b &gt; x \space and \space b - a &lt; x$。由于 $a \leq b$ 所以$b \geq x / 2$（请先记住这个结论，将会在之后用到）</p><p>接下来是解决 $a + b$ 和 $b - a$ 的数据存储和更新问题（由于询问是在线询问，而 $a, b$ 相邻，所以随着插入新的数据，这两个值都会发生变化）。</p><h2 id="对于-a-b-的处理："><a href="#对于-a-b-的处理：" class="headerlink" title="对于 $a + b$ 的处理："></a>对于 $a + b$ 的处理：</h2><p>我们将所有当前在集合中的数据进行排序，可以使用 <code>multiset</code> 来实现，但是我个人不太喜欢 <code>multi</code> 的数据结构，所以我选择了 <code>map</code> ，<code>first</code> 保存数据的值，<code>second</code> 保存了数据重复的个数。<strong>从此开始，我们暂时不讨论重复值的情况</strong>。对于排序好的数据，我们可以通过二分数值来得到 $x / 2$ 在数组中的哪个位置。由于 $a \leq b$ ，所以只有两种可能</p><ul><li>$a &lt; x/2 \space and \space b &gt; x / 2$</li><li>$a, b \geq x / 2$</li></ul><p>后者很好解决，只需要取值的时候，数组下标大于 $x/2$ 所在的下标位置即可。而前者因为 $a, b$ 相邻，所以我们可以使用 <code>upper_bound</code> 轻松解决（<code>b = *map.upper_bound(x / 2), a = *(map.upper_bound(x / 2) - 1)</code>）</p><p>至此，在保证数据有序的情况下，我们已经第一步缩小了数据范围，得到了一个数组下标范围 <code>[map.upper_bound(x / 2), map.end()]</code>。注意，这里的右区间始终为最大值（$INF$）</p><h2 id="对于-b-a-的处理"><a href="#对于-b-a-的处理" class="headerlink" title="对于 $b - a$ 的处理"></a>对于 $b - a$ 的处理</h2><p>由于求算 $b - a$ 的过程本身需要排序，而上面对 $a + b$ 的处理的时候已经排完序了。所以我们能够较快的得到 $b - a$ 的值（ $a, b$ 相邻）但是此时的更新的操作过于复杂，而且我们并不需要知道哪个区间的值能够满足条件（即小于 $x$ ），我们可以只需要知道我们已经缩小后的区间内，是否<strong>存在</strong> $a, b$ 满足 $b - a &lt; x$，即 $min(b - a) &lt; x$。</p><p>区间最小值，单点更新，此时我们想到了线段树（主要是我不知道有没有动态树状数组这个感觉不太可能存在的东西，于是就写了线段树，实际上需要将线段树的空间动态化，不然空间会爆炸）。</p><p>对于整个集合，假如有 $n$ 个不同的元素，则只会产生 $n - 1$ 个不同的插值（由于 $a, b$ 相邻，每个元素只会产生一个，假定最后一个元素不产生）</p><p>那么我们建立一棵长度为 $1e9$ 的线段树，对于每个不同的==值（x）==，将其产生的差值保存在节点 $x -x$ 下，其他没有值的节点，则保持 $INF$</p><p>举一个例子，假如我们有如下值在集合中</p><blockquote><p>1, 3, 4, 10, 123, 423</p></blockquote><p>则此时得到的差值为</p><blockquote><p>2, 1, 6, 113, 300</p></blockquote><p>则我们对如下数组<code>a</code>建立线段树</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">a[<span class="hljs-number">1</span>] <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-comment">;</span><br>a[<span class="hljs-number">3</span>] <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>a[<span class="hljs-number">4</span>] <span class="hljs-operator">=</span> <span class="hljs-number">6</span><span class="hljs-comment">;</span><br>a[<span class="hljs-number">10</span>] <span class="hljs-operator">=</span> <span class="hljs-number">113</span><span class="hljs-comment">;</span><br>a[<span class="hljs-number">123</span>] <span class="hljs-operator">=</span> <span class="hljs-number">300</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>由于输入的 $1 \leq x \leq 1e9$，所以我们开不起这么大的线段树，而实际上最多只会有 $1e5$ 个叶子节点，所以线段树最多的节点个数为 $1e5 \space lg 1e5 &lt; 1e7$，所以只需要准备 $1e7$ 个节点，然后动态开点即可满足整个线段树的需要。</p><p>至于这里为什么选择将每个差值产生的较小者（即 $a$ ）作为下标的存储位置。由于之后会遇到前面 $a + b$ 得到的区间恰好从 $a, b$ 中间穿过，如果保存的是在 $b$ 下，则会出现 $a + b &lt; x$ 但是仍然被选出来作为 $min(b - a)$。</p><p>接下来是线段树的更新操作。</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>由于值保存在较小值处，所以需要更新较小值的值，和当前新插入的节点的下的值</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>由于删除操作难以实现，不如直接把被删除的点的值设置为 $INF$，以及，被删掉的点前面一个点的值需要更新</p><p>注意一下各种边界情况。</p><h2 id="查询的操作"><a href="#查询的操作" class="headerlink" title="查询的操作"></a>查询的操作</h2><p>首先从已经排序好的数组中，得到 $x / 2$ 所在数组中的区间，然后拿着这个区间去找线段树，询问区间最小值，将最小值与 $x$ 比较，如果最小值比 $x$ 小，则输出 <code>Yes</code> ，否则输出 <code>No</code></p><h2 id="处理重复的数据"><a href="#处理重复的数据" class="headerlink" title="处理重复的数据"></a>处理重复的数据</h2><p>这里就相当简单了，对于相同的数据，只需要保证 $a + a &gt; x$ 即可满足 $a, a, x$ 能够组成三角形。我选择再创建了一个 <code>set</code> 将所有满足个数大于等于 $2$ 的值均保存在数组中，然后去寻找是否存在 <code>set</code> 中是否存在 $a$ 满足 $a &gt; x / 2$，则可以得到解</p><h1 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 8000000</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e9</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegTree</span> &#123;<br>    <span class="hljs-type">int</span> tot;<br>    <span class="hljs-type">int</span> sub[MAXN]; <span class="hljs-comment">// 保存了差值</span><br>    <span class="hljs-type">int</span> lson[MAXN], rson[MAXN];<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAXN; ++i)<br>            sub[i] = INT_MAX;<br>        <span class="hljs-built_in">memset</span>(lson, <span class="hljs-number">0xff</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * MAXN);<br>        <span class="hljs-built_in">memset</span>(rson, <span class="hljs-number">0xff</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * MAXN);<br>        tot = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">up</span><span class="hljs-params">(<span class="hljs-type">int</span> cur)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (lson[cur] == <span class="hljs-number">-1</span> &amp;&amp; rson[cur] == <span class="hljs-number">-1</span>) sub[cur] = INT_MAX;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (lson[cur] == <span class="hljs-number">-1</span>) sub[cur] = sub[rson[cur]];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rson[cur] == <span class="hljs-number">-1</span>) sub[cur] = sub[lson[cur]];<br>        <span class="hljs-keyword">else</span> sub[cur] = <span class="hljs-built_in">min</span>(sub[lson[cur]], sub[rson[cur]]);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">getLson</span><span class="hljs-params">(<span class="hljs-type">int</span> cur)</span> </span>&#123;<br>        <span class="hljs-built_in">assert</span>(tot &lt; MAXN);<br>        <span class="hljs-keyword">if</span> (lson[cur] == <span class="hljs-number">-1</span>)<br>            lson[cur] = tot++;<br>        <span class="hljs-keyword">return</span> lson[cur];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">getRson</span><span class="hljs-params">(<span class="hljs-type">int</span> cur)</span> </span>&#123;<br>        <span class="hljs-built_in">assert</span>(tot &lt; MAXN);<br>        <span class="hljs-keyword">if</span> (rson[cur] == <span class="hljs-number">-1</span>)<br>            rson[cur] = tot++;<br>        <span class="hljs-keyword">return</span> rson[cur];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> value, <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, <span class="hljs-type">int</span> r = maxn)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x == l &amp;&amp; l == r) &#123;<br>            sub[cur] = value;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1u</span>;<br>        <span class="hljs-keyword">if</span> (x &lt;= mid) &#123;<br>            <span class="hljs-built_in">update</span>(x, value, <span class="hljs-built_in">getLson</span>(cur), l, mid);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">update</span>(x, value, <span class="hljs-built_in">getRson</span>(cur), mid + <span class="hljs-number">1</span>, r);<br>        &#125;<br>        <span class="hljs-built_in">up</span>(cur);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, <span class="hljs-type">int</span> r = maxn)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (x == l &amp;&amp; y == r) <span class="hljs-keyword">return</span> sub[cur];<br>        <span class="hljs-type">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1u</span>;<br>        <span class="hljs-keyword">if</span> (y &lt;= mid) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(x, y, <span class="hljs-built_in">getLson</span>(cur), l, mid);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt; mid) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(x, y, <span class="hljs-built_in">getRson</span>(cur), mid + <span class="hljs-number">1</span>, r);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(<span class="hljs-built_in">query</span>(x, mid, <span class="hljs-built_in">getLson</span>(cur), l, mid),<br>                       <span class="hljs-built_in">query</span>(mid + <span class="hljs-number">1</span>, y, <span class="hljs-built_in">getRson</span>(cur), mid + <span class="hljs-number">1</span>, r));<br>        &#125;<br>    &#125;<br>&#125; segTree;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> q;<br>    cin &gt;&gt; q;<br>    segTree.<span class="hljs-built_in">init</span>();<br>    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; pool; <span class="hljs-comment">// 当前集合中的数据</span><br>    set&lt;<span class="hljs-type">int</span>&gt; multi;<span class="hljs-comment">// 用于处理重复数据</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; ++i) &#123;<br>        <span class="hljs-type">int</span> op, x;<br>        cin &gt;&gt; op &gt;&gt; x;<br>        <span class="hljs-keyword">switch</span> (op) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: &#123;<br>                <span class="hljs-keyword">auto</span> iter = pool.<span class="hljs-built_in">find</span>(x);<br>                <span class="hljs-keyword">if</span> (iter != pool.<span class="hljs-built_in">end</span>()) &#123;<br>                    iter-&gt;second++;<br>                    <span class="hljs-keyword">if</span> (iter-&gt;second == <span class="hljs-number">2</span>)<br>                        multi.<span class="hljs-built_in">insert</span>(x);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    pool.<span class="hljs-built_in">insert</span>(&#123;x, <span class="hljs-number">1</span>&#125;);<br>                    <span class="hljs-keyword">auto</span> cur = pool.<span class="hljs-built_in">find</span>(x);<br>                    <span class="hljs-keyword">auto</span> lower = cur, up = cur;<br>                    up++;<br>                    <span class="hljs-keyword">if</span> (lower != pool.<span class="hljs-built_in">begin</span>()) &#123;<br>                        lower--;<br>                        segTree.<span class="hljs-built_in">update</span>(lower-&gt;first, x - lower-&gt;first);<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (up != pool.<span class="hljs-built_in">end</span>()) &#123;<br>                        segTree.<span class="hljs-built_in">update</span>(x, up-&gt;first - x);<br>                    &#125;<br>                &#125;<br>            &#125;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: &#123;<br>                <span class="hljs-keyword">auto</span> cur = pool.<span class="hljs-built_in">find</span>(x);<br>                <span class="hljs-keyword">if</span> (cur == pool.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">break</span>;<br>                cur-&gt;second--;<br>                <span class="hljs-keyword">if</span> (cur-&gt;second == <span class="hljs-number">1</span>) &#123;<br>                    multi.<span class="hljs-built_in">erase</span>(x);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cur-&gt;second == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">auto</span> lower = cur, up = cur;<br>                    up++;<br><br>                    segTree.<span class="hljs-built_in">update</span>(x, INT_MAX);<br>                    <span class="hljs-keyword">if</span> (lower != pool.<span class="hljs-built_in">begin</span>()) &#123;<br>                        lower--;<br>                        <span class="hljs-keyword">if</span> (up != pool.<span class="hljs-built_in">end</span>())<br>                            segTree.<span class="hljs-built_in">update</span>(lower-&gt;first, up-&gt;first - lower-&gt;first);<br>                        <span class="hljs-keyword">else</span><br>                            segTree.<span class="hljs-built_in">update</span>(lower-&gt;first, INT_MAX);<br>                    &#125;<br><br>                    pool.<span class="hljs-built_in">erase</span>(cur);<br>                &#125;<br>            &#125;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: &#123;<br>                <span class="hljs-keyword">auto</span> iter = pool.<span class="hljs-built_in">upper_bound</span>(x / <span class="hljs-number">2</span>);<br>                <span class="hljs-keyword">if</span> (iter == pool.<span class="hljs-built_in">end</span>()) &#123;  <span class="hljs-comment">// 没有值比 x / 2 更大了，则不存在 a + b &gt; x 了</span><br>                    cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">auto</span> lower = iter;<br>                <span class="hljs-keyword">if</span> (lower != pool.<span class="hljs-built_in">begin</span>()) &#123;<br>                    lower--;<br>                    <span class="hljs-keyword">if</span> (lower-&gt;first + iter-&gt;first &lt;= x) &#123;<br>                        lower++;<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-keyword">auto</span> mu = multi.<span class="hljs-built_in">lower_bound</span>(iter-&gt;first);<br>                <span class="hljs-keyword">if</span> (mu != multi.<span class="hljs-built_in">end</span>()) &#123;<br>                    cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-type">int</span> res = segTree.<span class="hljs-built_in">query</span>(lower-&gt;first, maxn);<br>                    <span class="hljs-keyword">if</span> (res &lt; x)<br>                        cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<br>                    <span class="hljs-keyword">else</span><br>                        cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>                &#125;<br>            &#125;<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios_base::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ACM_LOCAL</span><br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;in.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;out.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br>    <span class="hljs-type">int</span> test_index_for_debug = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span> acm_local_for_debug;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; acm_local_for_debug) &#123;<br>        <span class="hljs-keyword">if</span> (acm_local_for_debug == <span class="hljs-string">&#x27;$&#x27;</span>) <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        cin.<span class="hljs-built_in">putback</span>(acm_local_for_debug);<br>        <span class="hljs-keyword">if</span> (test_index_for_debug &gt; <span class="hljs-number">20</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Check the stdin!!!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">auto</span> start_clock_for_debug = <span class="hljs-built_in">clock</span>();<br>        <span class="hljs-built_in">solve</span>();<br>        <span class="hljs-keyword">auto</span> end_clock_for_debug = <span class="hljs-built_in">clock</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="hljs-string">&quot; successful&quot;</span> &lt;&lt; endl;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="hljs-string">&quot; Run Time: &quot;</span><br>             &lt;&lt; <span class="hljs-built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="hljs-string">&quot;s&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-built_in">solve</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>NowCoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020牛客暑期多校训练营（第一场）H-Minimum-cost Flow——网络流</title>
    <link href="/2020/07/14/acm/2020-multi-school/NowCoder-1-H-Minimum-cost%20Flow/"/>
    <url>/2020/07/14/acm/2020-multi-school/NowCoder-1-H-Minimum-cost%20Flow/</url>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/5666/H">题目链接</a></p><h1 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h1><p>给出一个费用流图，每条边的流量上限相同且不固定。有$q$个询问，每个询问中给出每条边的流量上限（分数，且保证$\leq 1$）。当图中的流量为 $1$ 个单位的时候，求出此时的费用。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>首先是询问个数，有$1e5$次询问，则需要预处理整个图，然后O(1)作答才可以过。然后注意到题目中给出的数据规模，图的边数只有$100$条</p><p>首先由于边的流量均为分数（$\frac{u}{v}$），而总流量为 $1$ 个单位。我们先扩大$\frac{v}{u}$倍，将每条边的流量固定为 $1$ 个单位，此时流量为 $\frac{v}{u}$ 个单位</p><p>考虑在最大流使用 SPFA 查找路径时，当查找到一条路径时，此路径的流量一定为 $1$ （根据上述的设定）。由于采用的本身便是最短路查找路径，得到的路径的费用为当前网络图下的最低费用。</p><p>所以可以稍微修改费用流板子中的一部分代码，使得每次得到路径并结算费用时，将每次得到的路径费用记录下来并保存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">100</span>;      <span class="hljs-comment">//点数</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>    <span class="hljs-type">int</span> from, to, cap, flow, cost;<br><br>    <span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> f, <span class="hljs-type">int</span> cc)<br>            : <span class="hljs-built_in">from</span>(u), <span class="hljs-built_in">to</span>(v), <span class="hljs-built_in">cap</span>(c), <span class="hljs-built_in">flow</span>(f), <span class="hljs-built_in">cost</span>(cc) &#123;&#125;<br>&#125;;<br><br>vector&lt;ll&gt; res;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MCMF</span> &#123;<br>    <span class="hljs-type">int</span> n, m;<br>    vector&lt;Edge&gt; edges;<br>    vector&lt;<span class="hljs-type">int</span>&gt; G[maxn];<br>    <span class="hljs-type">int</span> inq[maxn];  <span class="hljs-comment">//是否在队列中</span><br>    <span class="hljs-type">int</span> d[maxn];    <span class="hljs-comment">//bellmanford</span><br>    <span class="hljs-type">int</span> p[maxn];    <span class="hljs-comment">//上一条弧</span><br>    <span class="hljs-type">int</span> a[maxn];    <span class="hljs-comment">//可改进量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;n = n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) G[i].<span class="hljs-built_in">clear</span>();<br>        edges.<span class="hljs-built_in">clear</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to, <span class="hljs-type">int</span> cap, <span class="hljs-type">int</span> cost)</span> </span>&#123;<br>        edges.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">Edge</span>(from, to, cap, <span class="hljs-number">0</span>, cost));<br>        edges.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">Edge</span>(to, from, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -cost));<br>        m = <span class="hljs-built_in">int</span>(edges.<span class="hljs-built_in">size</span>());<br>        G[from].<span class="hljs-built_in">emplace_back</span>(m - <span class="hljs-number">2</span>);<br>        G[to].<span class="hljs-built_in">emplace_back</span>(m - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> &amp;flow, ll &amp;cost)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) d[i] = INF;<br>        <span class="hljs-built_in">memset</span>(inq, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(inq));<br>        d[s] = <span class="hljs-number">0</span>;<br>        inq[s] = <span class="hljs-number">1</span>;<br>        p[s] = <span class="hljs-number">0</span>;<br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        a[s] = INF;<br>        q.<span class="hljs-built_in">push</span>(s);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            inq[u] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">int</span>(G[u].<span class="hljs-built_in">size</span>()); ++i) &#123;<br>                Edge &amp;e = edges[G[u][i]];<br>                <span class="hljs-keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[e.to] &gt; d[u] + e.cost) &#123;<br>                    d[e.to] = d[u] + e.cost;<br>                    p[e.to] = G[u][i];<br>                    a[e.to] = <span class="hljs-built_in">min</span>(a[u], e.cap - e.flow);<br>                    <span class="hljs-keyword">if</span> (!inq[e.to]) &#123;<br>                        q.<span class="hljs-built_in">push</span>(e.to);<br>                        inq[e.to] = <span class="hljs-number">1</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (d[t] == INF) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        flow += a[t];<br>        cost += (ll) d[t] * (ll) a[t];<br>        res.<span class="hljs-built_in">push_back</span>(d[t]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> u = t; u != s; u = edges[p[u]].from) &#123;<br>            edges[p[u]].flow += a[t];<br>            edges[p[u] ^ <span class="hljs-number">1</span>].flow -= a[t];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MincostMaxflow</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, ll &amp;cost)</span> </span>&#123;<br>        <span class="hljs-type">int</span> flow = <span class="hljs-number">0</span>;<br>        cost = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">spfa</span>(s, t, flow, cost));<br>        <span class="hljs-keyword">return</span> flow;<br>    &#125;<br>&#125; mcmf;<br></code></pre></td></tr></table></figure><p>通过 res 数组记录下所有得到的路径的费用</p><p>而后分解流量。对于每一次询问，从 res 数组中从开始取值每次取出一条路径来提供 $1$ 个单位的流量，直到满足流量要求，则停止取值并输出答案。</p><p>虽然 $1 \leq u, v \leq 1e9$，可能需要循环遍历 $1e9$ 次才能出结果，但是由于图中每条边的容量都是 $1$，所以对于每一条路径，它只有被完全占用和完全空闲两种状态，而边数只有 $100$ 条，即整个网络的最大流量只能是 $100$ 个单位，即最多遍历 $100$ 次，则复杂度不超过 $100 <em> 1e5 = 1e7$，当 $MAX_FLOW </em> u &lt; v$ 时，则无解，输出 $-1$</p><p>注意一下乘法运算只需要考虑分子部分，分母部分不需要参与运算，在最后需要分子分母都除以 $gcd$ 以保证最简</p><h1 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">100</span>;      <span class="hljs-comment">//点数</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>    <span class="hljs-type">int</span> from, to, cap, flow, cost;<br><br>    <span class="hljs-built_in">Edge</span>(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> f, <span class="hljs-type">int</span> cc)<br>            : <span class="hljs-built_in">from</span>(u), <span class="hljs-built_in">to</span>(v), <span class="hljs-built_in">cap</span>(c), <span class="hljs-built_in">flow</span>(f), <span class="hljs-built_in">cost</span>(cc) &#123;&#125;<br>&#125;;<br><br>vector&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; res;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MCMF</span> &#123;<br>    <span class="hljs-type">int</span> n, m;<br>    vector&lt;Edge&gt; edges;<br>    vector&lt;<span class="hljs-type">int</span>&gt; G[maxn];<br>    <span class="hljs-type">int</span> inq[maxn];  <span class="hljs-comment">//是否在队列中</span><br>    <span class="hljs-type">int</span> d[maxn];    <span class="hljs-comment">//bellmanford</span><br>    <span class="hljs-type">int</span> p[maxn];    <span class="hljs-comment">//上一条弧</span><br>    <span class="hljs-type">int</span> a[maxn];    <span class="hljs-comment">//可改进量</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>-&gt;n = n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) G[i].<span class="hljs-built_in">clear</span>();<br>        edges.<span class="hljs-built_in">clear</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to, <span class="hljs-type">int</span> cap, <span class="hljs-type">int</span> cost)</span> </span>&#123;<br>        edges.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">Edge</span>(from, to, cap, <span class="hljs-number">0</span>, cost));<br>        edges.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-built_in">Edge</span>(to, from, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, -cost));<br>        m = <span class="hljs-built_in">int</span>(edges.<span class="hljs-built_in">size</span>());<br>        G[from].<span class="hljs-built_in">emplace_back</span>(m - <span class="hljs-number">2</span>);<br>        G[to].<span class="hljs-built_in">emplace_back</span>(m - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, <span class="hljs-type">int</span> &amp;flow, ll &amp;cost)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) d[i] = INF;<br>        <span class="hljs-built_in">memset</span>(inq, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(inq));<br>        d[s] = <span class="hljs-number">0</span>;<br>        inq[s] = <span class="hljs-number">1</span>;<br>        p[s] = <span class="hljs-number">0</span>;<br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        a[s] = INF;<br>        q.<span class="hljs-built_in">push</span>(s);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            inq[u] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">int</span>(G[u].<span class="hljs-built_in">size</span>()); ++i) &#123;<br>                Edge &amp;e = edges[G[u][i]];<br>                <span class="hljs-keyword">if</span> (e.cap &gt; e.flow &amp;&amp; d[e.to] &gt; d[u] + e.cost) &#123;<br>                    d[e.to] = d[u] + e.cost;<br>                    p[e.to] = G[u][i];<br>                    a[e.to] = <span class="hljs-built_in">min</span>(a[u], e.cap - e.flow);<br>                    <span class="hljs-keyword">if</span> (!inq[e.to]) &#123;<br>                        q.<span class="hljs-built_in">push</span>(e.to);<br>                        inq[e.to] = <span class="hljs-number">1</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (d[t] == INF) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        flow += a[t];<br>        cost += (ll) d[t] * (ll) a[t];<br>        res.<span class="hljs-built_in">push_back</span>(d[t]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> u = t; u != s; u = edges[p[u]].from) &#123;<br>            edges[p[u]].flow += a[t];<br>            edges[p[u] ^ <span class="hljs-number">1</span>].flow -= a[t];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MincostMaxflow</span><span class="hljs-params">(<span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t, ll &amp;cost)</span> </span>&#123;<br>        <span class="hljs-type">int</span> flow = <span class="hljs-number">0</span>;<br>        cost = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">spfa</span>(s, t, flow, cost));<br>        <span class="hljs-keyword">return</span> flow;<br>    &#125;<br>&#125; mcmf;<br><br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cout.<span class="hljs-built_in">precision</span>(<span class="hljs-number">10</span>);<br>    cout &lt;&lt; fixed;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; n &gt;&gt; m) &#123;<br>        mcmf.<span class="hljs-built_in">init</span>(n + <span class="hljs-number">10</span>);<br>        res.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-type">int</span> u, v, f;<br>            cin &gt;&gt; u &gt;&gt; v &gt;&gt; f;<br>            mcmf.<span class="hljs-built_in">addEdge</span>(u, v, <span class="hljs-number">1</span>, f);<br>        &#125;<br>        ll cost = <span class="hljs-number">0</span>;<br>        ll mf = mcmf.<span class="hljs-built_in">MincostMaxflow</span>(<span class="hljs-number">1</span>, n, cost);<br>        <span class="hljs-type">int</span> q;<br>        cin &gt;&gt; q;<br>        <span class="hljs-keyword">while</span> (q--) &#123;<br>            ll u, v;<br>            cin &gt;&gt; u &gt;&gt; v;<br>            <span class="hljs-keyword">if</span> (mf * u &lt; v) &#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;NaN&quot;</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            ll sum = <span class="hljs-number">0</span>;<br>            ll ans = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> item : res) &#123;<br>                <span class="hljs-keyword">if</span> (sum + u &lt;= v) &#123;<br>                    sum += u;<br>                    ans += item * u;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    ans += (v - sum) * item;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            ll g = __gcd(ans, v);<br>            cout &lt;&lt; ans / g &lt;&lt; <span class="hljs-string">&#x27;/&#x27;</span> &lt;&lt; v / g &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios_base::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ACM_LOCAL</span><br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;in.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;out.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br>    <span class="hljs-type">int</span> test_index_for_debug = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span> acm_local_for_debug;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; acm_local_for_debug) &#123;<br>        <span class="hljs-keyword">if</span> (acm_local_for_debug == <span class="hljs-string">&#x27;$&#x27;</span>) <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        cin.<span class="hljs-built_in">putback</span>(acm_local_for_debug);<br>        <span class="hljs-keyword">if</span> (test_index_for_debug &gt; <span class="hljs-number">20</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Check the stdin!!!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">auto</span> start_clock_for_debug = <span class="hljs-built_in">clock</span>();<br>        <span class="hljs-built_in">solve</span>();<br>        <span class="hljs-keyword">auto</span> end_clock_for_debug = <span class="hljs-built_in">clock</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="hljs-string">&quot; successful&quot;</span> &lt;&lt; endl;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="hljs-string">&quot; Run Time: &quot;</span><br>             &lt;&lt; <span class="hljs-built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="hljs-string">&quot;s&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-built_in">solve</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>NowCoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Educational Codeforces Round 80 D. Minimax Problem——二分+二进制处理</title>
    <link href="/2020/02/03/acm/codeforces/EducationalCodeforcesRound80-D.-Minimax%20Problem/"/>
    <url>/2020/02/03/acm/codeforces/EducationalCodeforcesRound80-D.-Minimax%20Problem/</url>
    
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1288/problem/D">题目链接</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>有n个维度为m的向量，取其中两个进行合并，合并时每个维度取两者之间的较大者，得到的新的向量中，维度值最小者最大为多少</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>首先最需要注意的是m的取值，m最大只有8，那么我们可以二分答案，对于每一个二分值，进行下面的操作，将整个矩阵的每一个元素，如果这个元素大于二分值，则变成1，反正则变成0，把每一个向量压缩为单个二进制数，这样我们最多只会得到$2^8 = 256$种不同的二进制数，然后暴力的遍历所有可能的二进制数的组合，得到是否满足当前二分值</p><h1 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> NUM = <span class="hljs-number">3e5</span> + <span class="hljs-number">100</span>;<br><br><span class="hljs-type">int</span> data[NUM][<span class="hljs-number">10</span>];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> value, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m, pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &amp;ans)</span> </span>&#123;<br>    map&lt;<span class="hljs-type">unsigned</span>, <span class="hljs-type">int</span>&gt; s;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-type">unsigned</span> temp = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>            temp &lt;&lt;= <span class="hljs-number">1u</span>;<br>            temp |= data[i][j] &gt; value;<br>        &#125;<br>        s.<span class="hljs-built_in">insert</span>(&#123;temp, i&#125;);<br>    &#125;<br>    <span class="hljs-type">unsigned</span> tar = <span class="hljs-number">-1u</span> &gt;&gt; (<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">8</span> - m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter1 = s.<span class="hljs-built_in">begin</span>(); iter1 != s.<span class="hljs-built_in">end</span>(); ++iter1) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> iter2 = iter1; iter2 != s.<span class="hljs-built_in">end</span>(); ++iter2) &#123;<br>            <span class="hljs-keyword">if</span> ((iter1-&gt;first | iter2-&gt;first) == tar) &#123;<br>                ans.first = iter1-&gt;second;<br>                ans.second = iter2-&gt;second;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-type">int</span> l = INT_MAX, r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>            cin &gt;&gt; data[i][j];<br>            l = <span class="hljs-built_in">min</span>(l, data[i][j]);<br>            r = <span class="hljs-built_in">max</span>(r, data[i][j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> mid, cnt = r - l;<br>    pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-keyword">while</span> (cnt &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> step = cnt / <span class="hljs-number">2</span>;<br>        mid = l + step;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid, n, m, ans)) &#123;<br>            l = mid + <span class="hljs-number">1</span>;<br>            cnt -= step + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span><br>            cnt /= <span class="hljs-number">2</span>;<br>    &#125;<br>    cout &lt;&lt; ans.first + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; ans.second + <span class="hljs-number">1</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios_base::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ACM_LOCAL</span><br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;in.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;out.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> test_index_for_debug = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span> acm_local_for_debug;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; acm_local_for_debug) &#123;<br>        cin.<span class="hljs-built_in">putback</span>(acm_local_for_debug);<br>        <span class="hljs-keyword">if</span> (test_index_for_debug &gt; <span class="hljs-number">20</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Check the stdin!!!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">auto</span> start_clock_for_debug = <span class="hljs-built_in">clock</span>();<br>        <span class="hljs-built_in">solve</span>();<br>        <span class="hljs-keyword">auto</span> end_clock_for_debug = <span class="hljs-built_in">clock</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="hljs-string">&quot; successful&quot;</span> &lt;&lt; endl;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="hljs-string">&quot; Run Time: &quot;</span><br>             &lt;&lt; <span class="hljs-built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="hljs-string">&quot;s&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-built_in">solve</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【bzoj2049】[Sdoi2008]Cave 洞穴勘测——线段树上bfs求可撤销并查集</title>
    <link href="/2020/01/08/acm/other-note/bzoj2049-Sdoi2008-Cave/"/>
    <url>/2020/01/08/acm/other-note/bzoj2049-Sdoi2008-Cave/</url>
    
    <content type="html"><![CDATA[<h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><p>2049: [Sdoi2008]Cave 洞穴勘测</p><p>Time Limit: 10 Sec  Memory Limit: 259 MB<br>Submit: 12030  Solved: 6024</p><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>辉辉热衷于洞穴勘测。某天，他按照地图来到了一片被标记为JSZX的洞穴群地区。经过初步勘测，辉辉发现这片区域由n个洞穴（分别编号为1到n）以及若干通道组成，并且每条通道连接了恰好两个洞穴。假如两个洞穴可以通过一条或者多条通道按一定顺序连接起来，那么这两个洞穴就是连通的，按顺序连接在一起的这些通道则被称之为这两个洞穴之间的一条路径。洞穴都十分坚固无法破坏，然而通道不太稳定，时常因为外界影响而发生改变，比如，根据有关仪器的监测结果，123号洞穴和127号洞穴之间有时会出现一条通道，有时这条通道又会因为某种稀奇古怪的原因被毁。辉辉有一台监测仪器可以实时将通道的每一次改变状况在辉辉手边的终端机上显示：如果监测到洞穴u和洞穴v之间出现了一条通道，终端机上会显示一条指令 Connect u v 如果监测到洞穴u和洞穴v之间的通道被毁，终端机上会显示一条指令 Destroy u v 经过长期的艰苦卓绝的手工推算，辉辉发现一个奇怪的现象：无论通道怎么改变，任意时刻任意两个洞穴之间至多只有一条路径。因而，辉辉坚信这是由于某种本质规律的支配导致的。因而，辉辉更加夜以继日地坚守在终端机之前，试图通过通道的改变情况来研究这条本质规律。然而，终于有一天，辉辉在堆积成山的演算纸中崩溃了……他把终端机往地面一砸（终端机也足够坚固无法破坏），转而求助于你，说道：“你老兄把这程序写写吧”。辉辉希望能随时通过终端机发出指令 Query u v，向监测仪询问此时洞穴u和洞穴v是否连通。现在你要为他编写程序回答每一次询问。已知在第一条指令显示之前，JSZX洞穴群中没有任何通道存在。</p><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>第一行为两个正整数n和m，分别表示洞穴的个数和终端机上出现过的指令的个数。以下m行，依次表示终端机上出现的各条指令。每行开头是一个表示指令种类的字符串s（”Connect”、”Destroy”或者”Query”，区分大小写），之后有两个整数u和v (1≤u, v≤n且u≠v) 分别表示两个洞穴的编号。</p><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>对每个Query指令，输出洞穴u和洞穴v是否互相连通：是输出”Yes”，否则输出”No”。（不含双引号）</p><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>样例输入1 cave.in<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">200</span><span class="hljs-number">5</span><br><span class="hljs-attribute">Query</span><span class="hljs-number">123</span><span class="hljs-number">127</span><br><span class="hljs-attribute">Connect</span><span class="hljs-number">123</span><span class="hljs-number">127</span><br><span class="hljs-attribute">Query</span><span class="hljs-number">123</span><span class="hljs-number">127</span><br><span class="hljs-attribute">Destroy</span><span class="hljs-number">127</span><span class="hljs-number">123</span><br><span class="hljs-attribute">Query</span><span class="hljs-number">123</span><span class="hljs-number">127</span><br></code></pre></td></tr></table></figure></p><p>样例输入2 cave.in<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">3</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">Connect</span><span class="hljs-number">1</span><span class="hljs-number">2</span><br><span class="hljs-attribute">Connect</span><span class="hljs-number">3</span><span class="hljs-number">1</span><br><span class="hljs-attribute">Query</span><span class="hljs-number">2</span><span class="hljs-number">3</span><br><span class="hljs-attribute">Destroy</span><span class="hljs-number">1</span><span class="hljs-number">3</span><br><span class="hljs-attribute">Query</span><span class="hljs-number">2</span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure></p><h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>样例输出1 cave.out<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">No</span><br><span class="hljs-keyword">Yes</span><br><span class="hljs-keyword">No</span><br></code></pre></td></tr></table></figure></p><p>样例输出2 cave.out<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">Yes</span><br><span class="hljs-keyword">No</span><br></code></pre></td></tr></table></figure></p><h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h2><p>数据说明 10%的数据满足n≤1000, m≤20000 20%的数据满足n≤2000, m≤40000 30%的数据满足n≤3000, m≤60000 40%的数据满足n≤4000, m≤80000 50%的数据满足n≤5000, m≤100000 60%的数据满足n≤6000, m≤120000 70%的数据满足n≤7000, m≤140000 80%的数据满足n≤8000, m≤160000 90%的数据满足n≤9000, m≤180000 100%的数据满足n≤10000, m≤200000 保证所有Destroy指令将摧毁的是一条存在的通道本题输入、输出规模比较大，建议c\c++选手使用scanf和printf进行I\O操作以免超时</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>一条边的存在的时间其实就是一段连续的时间（我们这里指定每一行命令就是一个单位的时间），这样我们就可以把问题离线化。</p><p>那么我们可以用线段树来保存整个状态，这并不是什么难事，我们在线段树的每一个节点上保存一个边的集合，表示这个节点下所有的子节点都包含了这条边。</p><p>那么我们对于任意一个叶子节点，从根节点到叶子节点的全过程遍历到的所有的边组成的集合就是当前的图</p><p>由于如果每次询问都是从根节点出发的话效率太低，我们采用直接在线段树上移动的方式来解决效率问题。</p><p>通过可撤销并查集的性质，来实现在线段树上移动</p><h1 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br> <br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">10100</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXM = <span class="hljs-number">200100</span>;<br> <br><span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; pii;<br> <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UFS</span> &#123;<br>    <span class="hljs-type">int</span> f[MAXN];<br>    stack&lt;pii&gt; s;<br> <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">finds</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (x ^ f[x])<br>            x = f[x];<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unite</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        x = <span class="hljs-built_in">finds</span>(x);<br>        y = <span class="hljs-built_in">finds</span>(y);<br>        <span class="hljs-keyword">if</span> (x != y) &#123;<br>            s.<span class="hljs-built_in">push</span>(&#123;x, f[x]&#125;);<br>            f[x] = y;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> b, <span class="hljs-type">int</span> e)</span> </span>&#123; <span class="hljs-comment">// 初始化函数，范围为 [b, e)</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = b; i &lt; e; i++)<br>            f[i] = i;<br>    &#125;<br> <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">undo</span><span class="hljs-params">()</span> </span>&#123;<br>        f[s.<span class="hljs-built_in">top</span>().first] = s.<span class="hljs-built_in">top</span>().second;<br>        s.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>&#125;;<br> <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SegTree</span> &#123;<br>    vector&lt;pii&gt; data[MAXM &lt;&lt; <span class="hljs-number">2</span>];<br> <br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">lson</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123; <span class="hljs-keyword">return</span> k &lt;&lt; <span class="hljs-number">1</span>; &#125;<br> <br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">rson</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123; <span class="hljs-keyword">return</span> (k &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>; &#125;<br> <br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">fat</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123; <span class="hljs-keyword">return</span> (l + r) &gt;&gt; <span class="hljs-number">1</span>; &#125;<br>    <span class="hljs-comment">// add 函数对应于正常的线段树的 insert，但是稍微有些不同</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">const</span> pii &amp;value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == x &amp;&amp; r == y) &#123;<br>            data[k].<span class="hljs-built_in">push_back</span>(value);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> mid = <span class="hljs-built_in">fat</span>(l, r);<br>        <span class="hljs-keyword">if</span> (y &lt;= mid) &#123;<br>            <span class="hljs-built_in">add</span>(<span class="hljs-built_in">lson</span>(k), l, mid, x, y, value);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt; mid) &#123;<br>            <span class="hljs-built_in">add</span>(<span class="hljs-built_in">rson</span>(k), mid + <span class="hljs-number">1</span>, r, x, y, value);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">add</span>(<span class="hljs-built_in">lson</span>(k), l, mid, x, mid, value);<br>            <span class="hljs-built_in">add</span>(<span class="hljs-built_in">rson</span>(k), mid + <span class="hljs-number">1</span>, r, mid + <span class="hljs-number">1</span>, y, value);<br>        &#125;<br>    &#125;<br>&#125;;<br> <br>UFS ufs;<br>SegTree segTree;<br>vector&lt;pair&lt;pii, <span class="hljs-type">int</span>&gt; &gt; que;<br><span class="hljs-type">int</span> tar;<br><span class="hljs-comment">// 通过 dfs 的方式在线段树上移动</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-comment">// 当完成一次询问之后，需要跳出当前的叶子，即回溯。通过 goto 来使得回溯的过程会自动进入正确的叶子节点</span><br>    rejudge:<br>    <span class="hljs-type">int</span> target = que[tar].second;<br>    <span class="hljs-keyword">if</span> (target == r &amp;&amp; l == r) &#123;<br>        <span class="hljs-keyword">if</span> (ufs.<span class="hljs-built_in">finds</span>(que[tar].first.first) == ufs.<span class="hljs-built_in">finds</span>(que[tar].first.second))<br>            cout &lt;&lt; <span class="hljs-string">&quot;Yes&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span><br>            cout &lt;&lt; <span class="hljs-string">&quot;No&quot;</span> &lt;&lt; endl;<br>        tar++;<br>        <span class="hljs-keyword">return</span> tar == que.<span class="hljs-built_in">size</span>();<span class="hljs-comment">// true 表示所有的询问已经结束，退出 dfs</span><br>    &#125;<br>    <span class="hljs-type">int</span> mid = SegTree::<span class="hljs-built_in">fat</span>(l, r);<br>    <span class="hljs-keyword">if</span> (target &lt;= mid) &#123;<br><span class="hljs-comment">//        for (auto &amp;item: segTree.data[SegTree::lson(k)])</span><br><span class="hljs-comment">//            ufs.unite(item.first, item.second);</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; segTree.data[SegTree::<span class="hljs-built_in">lson</span>(k)].<span class="hljs-built_in">size</span>(); ++i)<br>            ufs.<span class="hljs-built_in">unite</span>(segTree.data[SegTree::<span class="hljs-built_in">lson</span>(k)][i].first, segTree.data[SegTree::<span class="hljs-built_in">lson</span>(k)][i].second);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(SegTree::<span class="hljs-built_in">lson</span>(k), l, mid))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-comment">//        for (auto &amp;item: segTree.data[SegTree::lson(k)])</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; segTree.data[SegTree::<span class="hljs-built_in">lson</span>(k)].<span class="hljs-built_in">size</span>(); ++i)<br>            ufs.<span class="hljs-built_in">undo</span>();<br>        <span class="hljs-keyword">if</span> (que[tar].second &gt; r)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">goto</span> rejudge;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//        for (auto &amp;item: segTree.data[SegTree::rson(k)])</span><br><span class="hljs-comment">//            ufs.unite(item.first, item.second);</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; segTree.data[SegTree::<span class="hljs-built_in">rson</span>(k)].<span class="hljs-built_in">size</span>(); ++i)<br>            ufs.<span class="hljs-built_in">unite</span>(segTree.data[SegTree::<span class="hljs-built_in">rson</span>(k)][i].first, segTree.data[SegTree::<span class="hljs-built_in">rson</span>(k)][i].second);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(SegTree::<span class="hljs-built_in">rson</span>(k), mid + <span class="hljs-number">1</span>, r))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-comment">//        for (auto &amp;item: segTree.data[SegTree::rson(k)])</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; segTree.data[SegTree::<span class="hljs-built_in">rson</span>(k)].<span class="hljs-built_in">size</span>(); ++i)<br>            ufs.<span class="hljs-built_in">undo</span>();<br>        <span class="hljs-keyword">if</span> (que[tar].second &gt; r)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">goto</span> rejudge;<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    map&lt;pii, <span class="hljs-type">int</span>&gt; mp;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        string s;<br>        <span class="hljs-type">int</span> u, v;<br>        cin &gt;&gt; s &gt;&gt; u &gt;&gt; v;<br>        <span class="hljs-keyword">if</span> (u &gt; v) <span class="hljs-built_in">swap</span>(u, v);<br>        <span class="hljs-keyword">switch</span> (s[<span class="hljs-number">0</span>]) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;Q&#x27;</span>:<br><span class="hljs-comment">//                que.push_back(&#123;&#123;u, v&#125;, i + 1&#125;);</span><br>                que.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-built_in">make_pair</span>(u, v), i + <span class="hljs-number">1</span>));<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;C&#x27;</span>:<br><span class="hljs-comment">//                mp.insert(&#123;&#123;u, v&#125;, i + 1&#125;);</span><br>                mp.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-built_in">make_pair</span>(u, v), i + <span class="hljs-number">1</span>));<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;D&#x27;</span>: &#123;<br><span class="hljs-comment">//                auto iter = mp.find(&#123;u, v&#125;);</span><br>                map&lt;pii, <span class="hljs-type">int</span>&gt;::iterator iter = mp.<span class="hljs-built_in">find</span>(<span class="hljs-built_in">make_pair</span>(u, v));<br><span class="hljs-comment">//                segTree.add(1, 1, m, iter-&gt;second, i, &#123;u, v&#125;);</span><br>                segTree.<span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, m, iter-&gt;second, i, <span class="hljs-built_in">make_pair</span>(u, v));<br>                mp.<span class="hljs-built_in">erase</span>(iter);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    map&lt;pii, <span class="hljs-type">int</span>&gt;::iterator iter = mp.<span class="hljs-built_in">begin</span>();<br>    <span class="hljs-keyword">while</span> (iter != mp.<span class="hljs-built_in">end</span>()) &#123;<br>        segTree.<span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, m, iter-&gt;second, m, iter-&gt;first);<br>        iter++;<br>    &#125;<br>    ufs.<span class="hljs-built_in">init</span>(<span class="hljs-number">0</span>, n + <span class="hljs-number">1</span>);<br>    tar = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//    for (auto &amp;item: segTree.data[1])</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; segTree.data[<span class="hljs-number">1</span>].<span class="hljs-built_in">size</span>(); ++i)<br>        ufs.<span class="hljs-built_in">unite</span>(segTree.data[<span class="hljs-number">1</span>][i].first, segTree.data[<span class="hljs-number">1</span>][i].second);<br><span class="hljs-comment">//        ufs.unite(item.first, item.second);</span><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, m);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios_base::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-comment">//    cin.tie(nullptr);</span><br><span class="hljs-comment">//    cout.tie(nullptr);</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ACM_LOCAL</span><br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;in.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;out.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> test_index_for_debug = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span> acm_local_for_debug;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; acm_local_for_debug) &#123;<br>        <span class="hljs-keyword">if</span> (acm_local_for_debug == <span class="hljs-string">&#x27;$&#x27;</span>) <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        cin.<span class="hljs-built_in">putback</span>(acm_local_for_debug);<br>        <span class="hljs-keyword">if</span> (test_index_for_debug &gt; <span class="hljs-number">20</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Check the stdin!!!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">auto</span> start_clock_for_debug = <span class="hljs-built_in">clock</span>();<br>        <span class="hljs-built_in">solve</span>();<br>        <span class="hljs-keyword">auto</span> end_clock_for_debug = <span class="hljs-built_in">clock</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="hljs-string">&quot; successful&quot;</span> &lt;&lt; endl;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="hljs-string">&quot; Run Time: &quot;</span><br>             &lt;&lt; <span class="hljs-built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="hljs-string">&quot;s&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-built_in">solve</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>BZOJ</tag>
      
      <tag>SDOI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 606 E. Two Fairs——图论</title>
    <link href="/2020/01/08/acm/codeforces/CodeforcesRound606-E.-Two%20Fairs/"/>
    <url>/2020/01/08/acm/codeforces/CodeforcesRound606-E.-Two%20Fairs/</url>
    
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1277/problem/E">题目链接</a></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你一张无向图，求出有多少对点对（x, y）满足从点x到点y的所有路径必同时经过点a和点b</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="单点"><a href="#单点" class="headerlink" title="单点"></a>单点</h2><p>首先考虑假如点a和点b是同一个点的情况</p><p>我从任意的一点出发，把所有与点a/b相连的路视为不存在，通过bfs遍历所有可能到达的点。那么这些点之间可以满足不经过点a/b能联通。反之，如果能将其他所有的点均进行bfs，组成类似并查集的数据结构，那么我可以很快得到，所有非同一集合内的点之间必须通过点a/b。</p><p>下一个问题：<strong>如何保证所有点都完成了遍历（bfs）</strong></p><p>我们可以不断的在vis数组中找没有被vis的点，然后不断的bfs，但是这样效率很低</p><p>换一种思路</p><p><strong>我们可以直接从点a/b出发</strong>，设定bfs起点为点a/b，那么就可以一次性的完成整个图的bfs遍历，并且使用类似并查集的结构将他们保存下来。</p><h2 id="两点"><a href="#两点" class="headerlink" title="两点"></a>两点</h2><p>我们可以这样定义，如果存在点对（x，y），假设与点b联通的路均视为不连通，满足x与a联通，但是不与y联通，同时，假设与点a联通的路均视为不连通，满足y与b联通，但是不与x联通，那么我们可以得到这样点x的集合和点y的集合，那么这两个集合内各取一点即为一组合理的点对</p><h1 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">201000</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXM = <span class="hljs-number">1001000</span>;<br><br><span class="hljs-comment">// 无权有向图</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Graph</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>        <span class="hljs-type">int</span> to, next;<br>    &#125; edge[MAXM];<br>    <span class="hljs-type">int</span> head[MAXN];<br>    <span class="hljs-type">int</span> tot;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        tot = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">memset</span>(head, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * (n + <span class="hljs-number">1</span>));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to)</span> </span>&#123;<br>        edge[tot].to = to;<br>        edge[tot].next = head[from];<br>        head[from] = tot++;<br>    &#125;<br>&#125; graph;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; T; ++ts) &#123;<br>        <span class="hljs-type">int</span> n, m, a, b;<br>        cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b;<br>        graph.<span class="hljs-built_in">init</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>            <span class="hljs-type">int</span> u, v;<br>            cin &gt;&gt; u &gt;&gt; v;<br>            graph.<span class="hljs-built_in">add_edge</span>(u, v);<br>            graph.<span class="hljs-built_in">add_edge</span>(v, u);<br>        &#125;<br>        <span class="hljs-type">bool</span> vis[MAXN];<br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        <span class="hljs-type">int</span> a_cnt = n - <span class="hljs-number">2</span>, b_cnt = n - <span class="hljs-number">2</span>;<br><br>        <span class="hljs-built_in">memset</span>(vis, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">bool</span>) * (n + <span class="hljs-number">1</span>));<br>        q.<span class="hljs-built_in">push</span>(a);<br>        vis[a] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> cur = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = graph.head[cur]; i != <span class="hljs-number">-1</span>; i = graph.edge[i].next) &#123;<br>                <span class="hljs-keyword">if</span> (!vis[graph.edge[i].to] &amp;&amp; graph.edge[i].to != b) &#123;<br>                    vis[graph.edge[i].to] = <span class="hljs-literal">true</span>;<br>                    q.<span class="hljs-built_in">push</span>(graph.edge[i].to);<br>                    a_cnt--;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-built_in">memset</span>(vis, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">bool</span>) * (n + <span class="hljs-number">1</span>));<br>        q.<span class="hljs-built_in">push</span>(b);<br>        vis[b] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> cur = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = graph.head[cur]; i != <span class="hljs-number">-1</span>; i = graph.edge[i].next) &#123;<br>                <span class="hljs-keyword">if</span> (!vis[graph.edge[i].to] &amp;&amp; graph.edge[i].to != a) &#123;<br>                    vis[graph.edge[i].to] = <span class="hljs-literal">true</span>;<br>                    q.<span class="hljs-built_in">push</span>(graph.edge[i].to);<br>                    b_cnt--;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        cout &lt;&lt; <span class="hljs-number">1ll</span> * a_cnt * b_cnt &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios_base::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ACM_LOCAL</span><br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;in.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;out.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> test_index_for_debug = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span> acm_local_for_debug;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; acm_local_for_debug) &#123;<br>        cin.<span class="hljs-built_in">putback</span>(acm_local_for_debug);<br>        <span class="hljs-keyword">if</span> (test_index_for_debug &gt; <span class="hljs-number">20</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Check the stdin!!!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">auto</span> start_clock_for_debug = <span class="hljs-built_in">clock</span>();<br>        <span class="hljs-built_in">solve</span>();<br>        <span class="hljs-keyword">auto</span> end_clock_for_debug = <span class="hljs-built_in">clock</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="hljs-string">&quot; successful&quot;</span> &lt;&lt; endl;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="hljs-string">&quot; Run Time: &quot;</span><br>             &lt;&lt; <span class="hljs-built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="hljs-string">&quot;s&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-built_in">solve</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round 612 (Div. 2) C. Garland——DP</title>
    <link href="/2020/01/06/acm/codeforces/CodeforcesRound612-C.-Garland/"/>
    <url>/2020/01/06/acm/codeforces/CodeforcesRound612-C.-Garland/</url>
    
    <content type="html"><![CDATA[<p><a href="http://codeforces.com/contest/1287/problem/C">题目链接</a><br>贪心模拟了半天，最后放弃了</p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你一串从$1-n$的序列，其中部分未知（表示为0），补全序列使得相邻数值奇偶性相反的数量最少<br>相邻数值的奇偶性相反：两个相邻的两个数值，其中一个为奇数另外一个为偶数</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>一开始用了贪心，结果卡在第十二个样例，然后改成dp<br>定义dp数组如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> dp[<span class="hljs-number">120</span>][<span class="hljs-number">60</span>][<span class="hljs-number">2</span>];<br><span class="hljs-comment">// dp[i][j][0/1] 表示第i+1个位置放了偶/奇数，且到第i+1处总共放了j个奇数，有多少个奇偶性相反</span><br></code></pre></td></tr></table></figure><p>得到状态转移方程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">dp[i][j][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>, dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>dp[i][j][<span class="hljs-number">0</span>] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, dp[i - <span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure><p>当然这得看这个位置本身是不是已经有了数值，如果为0则两个都需要，如果已经有数值了就按照原来的数值进行dp</p><h1 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">120</span>][<span class="hljs-number">60</span>][<span class="hljs-number">2</span>], value[<span class="hljs-number">120</span>];<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cin &gt;&gt; value[i];<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>    <span class="hljs-keyword">if</span> (value[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span><br>        dp[<span class="hljs-number">0</span>][value[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">1</span>][value[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-built_in">min</span>(i + <span class="hljs-number">1</span>, (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>); ++j) &#123;<br>            <span class="hljs-keyword">if</span> ((value[i] &amp; <span class="hljs-number">1</span> || value[i] == <span class="hljs-number">0</span>) &amp;&amp; j &gt; <span class="hljs-number">0</span>)<br>                dp[i][j][<span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>, dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">if</span> (!(value[i] &amp; <span class="hljs-number">1</span>))<br>                dp[i][j][<span class="hljs-number">0</span>] = <span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>][j][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, dp[i - <span class="hljs-number">1</span>][j][<span class="hljs-number">0</span>]);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-built_in">min</span>(dp[n - <span class="hljs-number">1</span>][(n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>][<span class="hljs-number">1</span>], dp[n - <span class="hljs-number">1</span>][(n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>][<span class="hljs-number">0</span>]) &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios_base::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ACM_LOCAL</span><br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;in.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;out.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> test_index_for_debug = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span> acm_local_for_debug;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; acm_local_for_debug) &#123;<br>        cin.<span class="hljs-built_in">putback</span>(acm_local_for_debug);<br>        <span class="hljs-keyword">if</span> (test_index_for_debug &gt; <span class="hljs-number">20</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Check the stdin!!!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">auto</span> start_clock_for_debug = <span class="hljs-built_in">clock</span>();<br>        <span class="hljs-built_in">solve</span>();<br>        <span class="hljs-keyword">auto</span> end_clock_for_debug = <span class="hljs-built_in">clock</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="hljs-string">&quot; successful&quot;</span> &lt;&lt; endl;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="hljs-string">&quot; Run Time: &quot;</span><br>             &lt;&lt; <span class="hljs-built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="hljs-string">&quot;s&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-built_in">solve</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【洛谷】P2444 [POI2000]病毒——AC自动机</title>
    <link href="/2020/01/05/acm/luogu/P2444/"/>
    <url>/2020/01/05/acm/luogu/P2444/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2444">题目链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>二进制病毒审查委员会最近发现了如下的规律：某些确定的二进制串是病毒的代码。如果某段代码中不存在任何一段病毒代码，那么我们就称这段代码是安全的。现在委员会已经找出了所有的病毒代码段，试问，是否存在一个无限长的安全的二进制代码。</p><p>示例：</p><p>例如如果{011, 11, 00000}为病毒代码段，那么一个可能的无限长安全代码就是010101…。如果{01, 11, 000000}为病毒代码段，那么就不存在一个无限长的安全代码。</p><p>任务：</p><p>请写一个程序：</p><p>1.在文本文件WIR.IN中读入病毒代码；</p><p>2.判断是否存在一个无限长的安全代码；</p><p>3.将结果输出到文件WIR.OUT中。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>在文本文件WIR.IN的第一行包括一个整数n(n\le 2000)(n≤2000)，表示病毒代码段的数目。以下的n行每一行都包括一个非空的01字符串——就是一个病毒代码段。所有病毒代码段的总长度不超过30000。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>在文本文件WIR.OUT的第一行输出一个单词：</p><p>TAK——假如存在这样的代码；</p><p>NIE——如果不存在。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>3<br>01<br>11<br>00000</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>NIE</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>想办法让那串无限长的字符串不断的在树上失配，然后不断的走fail指针最后进入一个循环即可</p><p>即在树上dfs，保证不经过任何字符串尾节点使得找到一个树上环</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * AC 自动机：多个模式串去匹配一个串，求有多少个模式串与主串有匹配内容</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 使用操作：</span><br><span class="hljs-comment"> * 1、把每一个模式串插入到树中 insert</span><br><span class="hljs-comment"> * 2、build</span><br><span class="hljs-comment"> * 3、使用 query 询问有多少个模式串匹配</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> CHAR_NUM = <span class="hljs-number">2</span>;<span class="hljs-comment">//仅小写</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">2100</span>;<span class="hljs-comment">//模式串个数</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXM = <span class="hljs-number">30100</span>;<span class="hljs-comment">//模式串最长长度</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> NUM = MAXN * MAXM;<span class="hljs-comment">//空间=个数*长度，稳</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Trie</span> &#123;<br>    <span class="hljs-type">int</span> c[NUM][CHAR_NUM], val[NUM], fail[NUM], cnt;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">char</span> *s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(s);<br>        <span class="hljs-type">int</span> now = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br><span class="hljs-comment">//            int v = s[i] - &#x27;a&#x27;;</span><br>            <span class="hljs-type">int</span> v = s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">if</span> (!c[now][v])c[now][v] = ++cnt;<br>            now = c[now][v];<br>        &#125;<br>        val[now]++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; CHAR_NUM; i++)<span class="hljs-keyword">if</span> (c[<span class="hljs-number">0</span>][i])fail[c[<span class="hljs-number">0</span>][i]] = <span class="hljs-number">0</span>, q.<span class="hljs-built_in">push</span>(c[<span class="hljs-number">0</span>][i]);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; CHAR_NUM; i++)<br>                <span class="hljs-keyword">if</span> (c[u][i])fail[c[u][i]] = c[fail[u]][i], q.<span class="hljs-built_in">push</span>(c[u][i]);<br>                <span class="hljs-keyword">else</span> c[u][i] = c[fail[u]][i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">char</span> *s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(s);<br>        <span class="hljs-type">int</span> now = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br><span class="hljs-comment">//            now = c[now][s[i] - &#x27;a&#x27;];</span><br>            now = c[now][s[i] - <span class="hljs-string">&#x27;0&#x27;</span>];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t = now; t &amp;&amp; ~val[t]; t = fail[t])ans += val[t], val[t] = <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125; AC;<br><br><span class="hljs-type">char</span> s[<span class="hljs-number">30100</span>];<br><span class="hljs-type">bool</span> vis[NUM];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> cur)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; CHAR_NUM; ++i) &#123;<br>        <span class="hljs-type">int</span> x = AC.c[cur][i];<br>        <span class="hljs-keyword">if</span> (!AC.val[x]) &#123;<br>            <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>            <span class="hljs-type">int</span> t = x;<br>            <span class="hljs-keyword">while</span> (t) &#123;<br>                <span class="hljs-keyword">if</span> (AC.val[t]) &#123;<br>                    flag = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                t = AC.fail[t];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (flag)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (vis[x])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            vis[x] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(x)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            vis[x] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cin &gt;&gt; s;<br>        AC.<span class="hljs-built_in">insert</span>(s);<br>    &#125;<br>    AC.<span class="hljs-built_in">build</span>();<br>    vis[<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (flag) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;TAK&quot;</span> &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;NIE&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios_base::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ACM_LOCAL</span><br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;in.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;out.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> test_index_for_debug = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span> acm_local_for_debug;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; acm_local_for_debug) &#123;<br>        cin.<span class="hljs-built_in">putback</span>(acm_local_for_debug);<br>        <span class="hljs-keyword">if</span> (test_index_for_debug &gt; <span class="hljs-number">20</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Check the stdin!!!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">auto</span> start_clock_for_debug = <span class="hljs-built_in">clock</span>();<br>        <span class="hljs-built_in">solve</span>();<br>        <span class="hljs-keyword">auto</span> end_clock_for_debug = <span class="hljs-built_in">clock</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="hljs-string">&quot; successful&quot;</span> &lt;&lt; endl;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="hljs-string">&quot; Run Time: &quot;</span><br>             &lt;&lt; <span class="hljs-built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="hljs-string">&quot;s&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-built_in">solve</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Luogu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【HDU5934】Bomb——有向图强连通分量+重建图</title>
    <link href="/2019/10/13/acm/other-note/HDU5934-Bomb/"/>
    <url>/2019/10/13/acm/other-note/HDU5934-Bomb/</url>
    
    <content type="html"><![CDATA[<h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>二维平面上有 n 个爆炸桶，$i-th$爆炸桶位置为 $(x_i, y_i)$ 爆炸范围为 $r_i$ ，且需要 $c_i$ 的价格引爆，求把所有桶引爆所需的钱。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>通过求有向图的强连通分量，求出所有爆炸块（满足引爆一个块内的任意一个爆炸桶就可以摧毁这个块内的爆炸桶），然后把所有爆炸块视为一个爆炸桶，价值为爆炸块内的价值最小值，然后重建有向图，将新建的有向图所有入度为 0 的点的价值相加，就是答案。</p><h1 id="AC-Code"><a href="#AC-Code" class="headerlink" title="AC-Code"></a>AC-Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1100</span>;  <span class="hljs-comment">// 点数</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXM = <span class="hljs-number">1000100</span>; <span class="hljs-comment">// 边数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>    <span class="hljs-type">int</span> to, next;<br>&#125; edge[MAXM]; <span class="hljs-comment">// 只有这里写的是 MAXM</span><br><br><span class="hljs-type">int</span> head[MAXN], tot;<br><span class="hljs-type">int</span> Low[MAXN], DFN[MAXN], Stack[MAXN], Belong[MAXN]; <span class="hljs-comment">//Belong 数组的值是 1 ～ scc</span><br><span class="hljs-type">int</span> Index, top;<br><span class="hljs-type">int</span> scc; <span class="hljs-comment">// 强连通分量的个数</span><br><span class="hljs-type">bool</span> Instack[MAXN];<br><span class="hljs-type">int</span> num[MAXN]; <span class="hljs-comment">// 各个强连通分量包含点的个数，数组编号 1 ～ scc</span><br><span class="hljs-comment">// num 数组不一定需要，结合实际情况</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addedge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    edge[tot].to = v;<br>    edge[tot].next = head[u];<br>    head[u] = tot++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-type">int</span> v;<br>    Low[u] = DFN[u] = ++Index;<br>    Stack[top++] = u;<br>    Instack[u] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[u]; i != <span class="hljs-number">-1</span>; i = edge[i].next) &#123;<br>        v = edge[i].to;<br>        <span class="hljs-keyword">if</span> (!DFN[v]) &#123;<br>            <span class="hljs-built_in">Tarjan</span>(v);<br>            <span class="hljs-keyword">if</span> (Low[u] &gt; Low[v])<br>                Low[u] = Low[v];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Instack[v] &amp;&amp; Low[u] &gt; DFN[v])<br>            Low[u] = DFN[v];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (Low[u] == DFN[u]) &#123;<br>        scc++;<br>        <span class="hljs-keyword">do</span> &#123;<br>            v = Stack[--top];<br>            Instack[v] = <span class="hljs-literal">false</span>;<br>            Belong[v] = scc;<br>            num[scc]++;<br>        &#125; <span class="hljs-keyword">while</span> (v != u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(DFN, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(DFN));<br>    <span class="hljs-built_in">memset</span>(Instack, <span class="hljs-literal">false</span>, <span class="hljs-built_in">sizeof</span>(Instack));<br>    <span class="hljs-built_in">memset</span>(num, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(num));<br>    Index = scc = top = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>        <span class="hljs-keyword">if</span> (!DFN[i])<br>            <span class="hljs-built_in">Tarjan</span>(i);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    tot = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(head, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(head));<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> x, y, r, c;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">in_boom</span><span class="hljs-params">(<span class="hljs-type">const</span> node &amp;other)</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">hypot</span>(<span class="hljs-built_in">abs</span>(x - other.x), <span class="hljs-built_in">abs</span>(y - other.y)) &lt;= r;<br>    &#125;<br>&#125;;<br><br>node nodeList[<span class="hljs-number">1100</span>];<br><span class="hljs-type">int</span> n;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_graph1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (i == j) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (nodeList[i].<span class="hljs-built_in">in_boom</span>(nodeList[j]))<br>                <span class="hljs-built_in">addedge</span>(i, j);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Graph</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-type">int</span> deg;<br>        <span class="hljs-type">int</span> value;<br>    &#125;;<br>    Node node[MAXN];<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n + <span class="hljs-number">5</span>; ++i) &#123;<br>            node[i].deg = <span class="hljs-number">0</span>;<br>            node[i].value = INT_MAX;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (from != to)<br>            node[to].deg++;<br>    &#125;<br>&#125;;<br><br>Graph graph;<br><span class="hljs-type">int</span> ans;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tp_init</span><span class="hljs-params">()</span> </span>&#123;<br>    graph.<span class="hljs-built_in">init</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        graph.node[Belong[i]].value = <span class="hljs-built_in">min</span>(graph.node[Belong[i]].value, nodeList[i].c);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (i == j) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (nodeList[i].<span class="hljs-built_in">in_boom</span>(nodeList[j]))<br>                graph.<span class="hljs-built_in">add_edge</span>(Belong[i], Belong[j]);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tp</span><span class="hljs-params">()</span> </span>&#123;<br>    ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">tp_init</span>();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= scc; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (graph.node[i].deg == <span class="hljs-number">0</span>) &#123;<br>            ans += graph.node[i].value;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> t;<br>    cin &gt;&gt; t;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; t; ++ts) &#123;<br>        cin &gt;&gt; n;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>            cin &gt;&gt; nodeList[i].x &gt;&gt; nodeList[i].y &gt;&gt; nodeList[i].r &gt;&gt; nodeList[i].c;<br>        &#125;<br>        <span class="hljs-built_in">init_graph1</span>();<br>        <span class="hljs-built_in">solve</span>(n);<br>        <span class="hljs-built_in">tp</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;Case #&quot;</span> &lt;&lt; ts + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios_base::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ACM_LOCAL</span><br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;in.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;out.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> test_index_for_debug = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span> acm_local_for_debug;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; acm_local_for_debug) &#123;<br>        cin.<span class="hljs-built_in">putback</span>(acm_local_for_debug);<br>        <span class="hljs-keyword">if</span> (test_index_for_debug &gt; <span class="hljs-number">20</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Check the stdin!!!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">auto</span> start_clock_for_debug = <span class="hljs-built_in">clock</span>();<br>        <span class="hljs-built_in">solve</span>();<br>        <span class="hljs-keyword">auto</span> end_clock_for_debug = <span class="hljs-built_in">clock</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="hljs-string">&quot; successful&quot;</span> &lt;&lt; endl;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="hljs-string">&quot; Run Time: &quot;</span><br>             &lt;&lt; <span class="hljs-built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="hljs-string">&quot;s&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-built_in">solve</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces Round#589 (Div. 2) D、Complete Tripartite</title>
    <link href="/2019/09/30/acm/codeforces/CodeforcesRound589-D-Complete%20Tripartite/"/>
    <url>/2019/09/30/acm/codeforces/CodeforcesRound589-D-Complete%20Tripartite/</url>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1228/problem/D">题目链接</a></p><h1 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h1><p>把一个图分成三块，要求任意两块之间是完全图，块内部没有连线</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>首先根据块内没有连线可以直接分成两块<br>假定点1是属于块1的，那么所有与点1连接的点，都不属于块1；反之则是块1的<br>然后在所有不属于块1的点内随意找一点k，设定其属于块2，那么所有与点k连接的点且不属于块1，则是块3。</p><p>块分完了，然后是判断每个块是否满足条件，我通过下面三条来判断</p><blockquote><p>1、每个块都有点<br>2、每个块内部没有连线，即没有一条线的两个端点在同一个块内<br>3、每个块内的点的度等于其他两个块的点个数和也等于n减去当前块内的点数</p></blockquote><h1 id="AC-Code"><a href="#AC-Code" class="headerlink" title="AC Code"></a>AC Code</h1><p>（暴力就完事）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 101000</span><br><br><span class="hljs-type">int</span> fa[MAXN];<span class="hljs-comment">// 保存了点属于哪个块</span><br><span class="hljs-type">int</span> deg[MAXN];<span class="hljs-comment">// 保存了点的度</span><br>pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; edge[MAXN * <span class="hljs-number">3</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-type">int</span> f2 = <span class="hljs-number">2</span>; <span class="hljs-comment">// f2 用来找块2</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        <span class="hljs-type">int</span> u, v;<br>        cin &gt;&gt; u &gt;&gt; v;<br>        deg[u]++;<br>        deg[v]++;<br>        edge[i] = &#123;u, v&#125;;<br>        <span class="hljs-keyword">if</span> (u == <span class="hljs-number">1</span>) &#123;<br>            fa[v] = <span class="hljs-number">1</span>;<br>            f2 = v;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v == <span class="hljs-number">1</span>) &#123;<br>            fa[u] = <span class="hljs-number">1</span>;<br>            f2 = u;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 找出第三块</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (edge[i].first == f2 &amp;&amp; fa[edge[i].second] == <span class="hljs-number">1</span>)<br>            fa[edge[i].second] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (edge[i].second == f2 &amp;&amp; fa[edge[i].first] == <span class="hljs-number">1</span>)<br>            fa[edge[i].first] = <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> cnt[<span class="hljs-number">3</span>] = &#123;n, n, n&#125;;<span class="hljs-comment">// 保存了每个块内点的个数</span><br>    <span class="hljs-comment">// 需要变成完全图需要多少条边</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        cnt[fa[i + <span class="hljs-number">1</span>]]--;<br>    <span class="hljs-comment">// 块内的入度是否符合条件</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (deg[i + <span class="hljs-number">1</span>] != cnt[fa[i + <span class="hljs-number">1</span>]]) &#123;<br>            cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 每个块是否为空</span><br>    <span class="hljs-keyword">if</span> (cnt[<span class="hljs-number">0</span>] == n || cnt[<span class="hljs-number">1</span>] == n || cnt[<span class="hljs-number">2</span>] == n) &#123;<br>        cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 内部连线</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (fa[edge[i].first] == fa[edge[i].second]) &#123;<br>            cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i)<br>        cout &lt;&lt; fa[i + <span class="hljs-number">1</span>] + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    cout &lt;&lt; fa[n] + <span class="hljs-number">1</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios_base::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ACM_LOCAL</span><br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;in.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;out.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> test_index_for_debug = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span> acm_local_for_debug;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; acm_local_for_debug) &#123;<br>        cin.<span class="hljs-built_in">putback</span>(acm_local_for_debug);<br>        <span class="hljs-keyword">if</span> (test_index_for_debug &gt; <span class="hljs-number">20</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">runtime_error</span>(<span class="hljs-string">&quot;Check the stdin!!!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">auto</span> start_clock_for_debug = <span class="hljs-built_in">clock</span>();<br>        <span class="hljs-built_in">solve</span>();<br>        <span class="hljs-keyword">auto</span> end_clock_for_debug = <span class="hljs-built_in">clock</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="hljs-string">&quot; successful&quot;</span> &lt;&lt; endl;<br>        cerr &lt;&lt; <span class="hljs-string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="hljs-string">&quot; Run Time: &quot;</span><br>             &lt;&lt; <span class="hljs-built_in">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="hljs-string">&quot;s&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; endl;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-built_in">solve</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><br>总之一句话，暴力就完事了。反正边不多，我已经懒得优化了</p>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>Codeforces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【2019沈阳网络赛】G、Special necklace——自闭的物理题</title>
    <link href="/2019/09/14/acm/2019-XCPC-online/Online-Shenyang-G-Special-necklace/"/>
    <url>/2019/09/14/acm/2019-XCPC-online/Online-Shenyang-G-Special-necklace/</url>
    
    <content type="html"><![CDATA[<p><strong>这道题让我差点怀疑自己高考没考过物理</strong></p><p>题意中</p><blockquote><p>he measures the resistance of any two endpoints of it, the resistance values are all $2a$</p></blockquote><p>指的是在三角形中电阻为 $2a$ 而不是边上的电阻为 $2a$<br>实际上每条边的电阻R为</p><p>$\frac{1}{R} + \frac{1}{2R} = 2a$</p><p>可以求得$R = 3a$</p><p>所以可以得到递推公式</p><p>$a<em>{n+1} = \frac{1}{ \frac{1}{ \frac{1}{ \frac{1}{a</em>{n}} + \frac{4}{3}} + 3} + \frac{1}{3}}$</p><p>通过python打表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">res = <span class="hljs-number">5</span> / <span class="hljs-number">3</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%.20f&#x27;</span> % res)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>):<br>    res = <span class="hljs-number">1</span> / ((<span class="hljs-number">1</span> / (<span class="hljs-number">1</span> / (<span class="hljs-number">1</span> / res + <span class="hljs-number">4</span> / <span class="hljs-number">3</span>) + <span class="hljs-number">3</span>)) + <span class="hljs-number">1</span> / <span class="hljs-number">3</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%.20f&#x27;</span> % res)<br></code></pre></td></tr></table></figure><p>得到</p><blockquote><p>1.66666666666666674068<br>1.61904761904761906877<br>1.61805555555555535818<br>1.61803444782168193150<br>1.61803399852180329610<br>1.61803398895790206957<br>1.61803398875432269399<br>1.61803398874998927148<br>1.61803398874989712297<br>1.61803398874989490253<br>1.61803398874989468048<br>1.61803398874989468048<br>1.61803398874989468048<br>1.61803398874989468048<br>1.61803398874989468048<br>1.61803398874989468048<br>1.61803398874989468048<br>1.61803398874989468048<br>1.61803398874989468048<br>1.61803398874989468048<br>1.61803398874989468048</p></blockquote><p>这是 $a = 1$ 的情况，最后乘上 a 就行<br>很明显了，直接打表就行，借助一下字符串流</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">double</span>&gt; res;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>    res.push_back(<span class="hljs-number">1.66666666666666674068</span>);<br>    res.push_back(<span class="hljs-number">1.61904761904761906877</span>);<br>    res.push_back(<span class="hljs-number">1.61805555555555535818</span>);<br>    res.push_back(<span class="hljs-number">1.61803444782168193150</span>);<br>    res.push_back(<span class="hljs-number">1.61803399852180329610</span>);<br>    res.push_back(<span class="hljs-number">1.61803398895790206957</span>);<br>    res.push_back(<span class="hljs-number">1.61803398875432269399</span>);<br>    res.push_back(<span class="hljs-number">1.61803398874998927148</span>);<br>    res.push_back(<span class="hljs-number">1.61803398874989712297</span>);<br>    res.push_back(<span class="hljs-number">1.61803398874989468048</span>);<br>    res.push_back(<span class="hljs-number">1.61803398874989468048</span>);<br>    res.push_back(<span class="hljs-number">1.61803398874989468048</span>);<br>    res.push_back(<span class="hljs-number">1.61803398874989468048</span>);<br>    res.push_back(<span class="hljs-number">1.61803398874989468048</span>);<br>    res.push_back(<span class="hljs-number">1.61803398874989468048</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">solve</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> t;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; t;<br>    init();<br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        <span class="hljs-built_in">string</span> str;<br>        <span class="hljs-type">double</span> a;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; str &gt;&gt; a;<br>        <span class="hljs-keyword">if</span> (str.length() &gt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="hljs-number">10</span>) &lt;&lt; res.back() * a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-built_in">stringstream</span> <span class="hljs-title function_">ss</span><span class="hljs-params">(str)</span>;<br>        <span class="hljs-type">int</span> n;<br>        ss &gt;&gt; n;<br>        <span class="hljs-keyword">if</span> (n &gt; res.size() - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="hljs-number">10</span>) &lt;&lt; res.back() * a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="hljs-number">10</span>) &lt;&lt; res[n - <span class="hljs-number">1</span>] * a &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    ios_base::sync_with_stdio(<span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">cin</span>.tie(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">cout</span>.tie(<span class="hljs-number">0</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ACM_LOCAL</span><br>    freopen(<span class="hljs-string">&quot;in.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, <span class="hljs-built_in">stdin</span>);<br>    freopen(<span class="hljs-string">&quot;out.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-built_in">stdout</span>);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> test_index_for_debug = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span> acm_local_for_debug;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; acm_local_for_debug) &#123;<br>        <span class="hljs-built_in">cin</span>.putback(acm_local_for_debug);<br>        <span class="hljs-keyword">if</span> (test_index_for_debug &gt; <span class="hljs-number">20</span>) &#123;<br>            throw runtime_error(<span class="hljs-string">&quot;Check the stdin!!!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">auto</span> start_clock_for_debug = clock();<br>        solve();<br>        <span class="hljs-keyword">auto</span> end_clock_for_debug = clock();<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="hljs-string">&quot; successful&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        <span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="hljs-string">&quot; Run Time: &quot;</span><br>             &lt;&lt; <span class="hljs-type">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="hljs-string">&quot;s&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;--------------------------------------------------&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    solve();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>XCPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【2019南昌网络赛】B-Fire-Fighting Hero</title>
    <link href="/2019/09/09/acm/2019-XCPC-online/Online-Nanchang-B-Fire-Fighting-Hero/"/>
    <url>/2019/09/09/acm/2019-XCPC-online/Online-Nanchang-B-Fire-Fighting-Hero/</url>
    
    <content type="html"><![CDATA[<p><a href="https://nanti.jisuanke.com/t/41349">题目链接</a></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>英雄方面很简单，跑一遍 Dijkstra 就行了，但是灭火团队就有点麻烦了。</p><p>这里可以借助一下最大流的建边来解决这个问题：<br>我们可以另外找一个点作为起点，然后建立从那个点到每一个团队的起点的边，权值为0，这样就完成了多起点的最短路</p><p>恰好我的板子是封装好的 Dijkstra ，我就直接建立两个结构体解决问题，因为点的数量只有 1000 个，空间上已经没有什么顾虑了</p><h1 id="AC-Code"><a href="#AC-Code" class="headerlink" title="AC-Code"></a>AC-Code</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 1100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXM 1000000</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x3fffffff              <span class="hljs-comment">//防止后面溢出，这个不能太大</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Graph</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> &#123;</span><br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> to, next;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> cost;<br>    &#125; edge[MAXM];<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> head[MAXN];<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> tot;<br><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> n)</span> &#123;<br>        tot = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">memset</span>(head, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span>) * (n + <span class="hljs-number">1</span>));<br>    &#125;<br><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">add_edge</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> from, <span class="hljs-type">long</span> <span class="hljs-type">long</span> to, <span class="hljs-type">long</span> <span class="hljs-type">long</span> value)</span> &#123;<br>        edge[tot].to = to;<br>        edge[tot].cost = value;<br>        edge[tot].next = head[from];<br>        head[from] = tot++;<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Dijkstra</span> &#123;</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> low_cost[MAXN];<br>    <span class="hljs-type">bool</span> vis[MAXN];<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> pre[MAXN];<br><br>    <span class="hljs-type">void</span> <span class="hljs-title function_">solve</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> b, <span class="hljs-type">long</span> <span class="hljs-type">long</span> e, <span class="hljs-type">long</span> <span class="hljs-type">long</span> start, Graph &amp;graph)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = b; i &lt; e; i++) &#123;<br>            low_cost[i] = INF;<br>            vis[i] = <span class="hljs-literal">false</span>;<br>            pre[i] = <span class="hljs-number">-1</span>;<br>        &#125;<br>        low_cost[start] = <span class="hljs-number">0</span>;<br>        vis[start] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> cur_edge = graph.head[start];<br>        <span class="hljs-keyword">while</span> (cur_edge != <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!vis[graph.edge[cur_edge].to] &amp;&amp;<br>                low_cost[start] + graph.edge[cur_edge].cost &lt; low_cost[graph.edge[cur_edge].to]) &#123;<br>                low_cost[graph.edge[cur_edge].to] = low_cost[start] + graph.edge[cur_edge].cost;<br>                pre[graph.edge[cur_edge].to] = start;<br>            &#125;<br>            cur_edge = graph.edge[cur_edge].next;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> j = b; j &lt; e - <span class="hljs-number">1</span>; j++) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> k = <span class="hljs-number">-1</span>;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> Min = INF;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = b; i &lt; e; i++) &#123;<br>                <span class="hljs-keyword">if</span> (!vis[i] &amp;&amp; low_cost[i] &lt; Min) &#123;<br>                    Min = low_cost[i];<br>                    k = i;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-number">-1</span>)<br>                <span class="hljs-keyword">break</span>;<br>            vis[k] = <span class="hljs-literal">true</span>;<br>            cur_edge = graph.head[k];<br>            <span class="hljs-keyword">while</span> (cur_edge != <span class="hljs-number">-1</span>) &#123;<br>                <span class="hljs-keyword">if</span> (!vis[graph.edge[cur_edge].to] &amp;&amp;<br>                    low_cost[k] + graph.edge[cur_edge].cost &lt; low_cost[graph.edge[cur_edge].to]) &#123;<br>                    low_cost[graph.edge[cur_edge].to] = low_cost[k] + graph.edge[cur_edge].cost;<br>                    pre[graph.edge[cur_edge].to] = k;<br>                &#125;<br>                cur_edge = graph.edge[cur_edge].next;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br><br>Graph graph;<br>Dijkstra dijkstra1, dijkstra2;<br><span class="hljs-type">int</span> k_node[MAXN];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">solve</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> t;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; t;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> v, e, s, k, c;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ts = <span class="hljs-number">0</span>; ts &lt; t; ++ts) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; v &gt;&gt; e &gt;&gt; s &gt;&gt; k &gt;&gt; c;<br>        graph.init(v + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; k_node[i];<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> from, to, value;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = <span class="hljs-number">0</span>; i &lt; e; ++i) &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; from &gt;&gt; to &gt;&gt; value;<br>            graph.add_edge(from, to, value);<br>            graph.add_edge(to, from, value);<br>        &#125;<br>        dijkstra1.solve(<span class="hljs-number">1</span>, v + <span class="hljs-number">1</span>, s, graph);<span class="hljs-comment">//第一次跑dijkstra</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; ++i) &#123;<br>            graph.add_edge(<span class="hljs-number">0</span>, k_node[i], <span class="hljs-number">0</span>); <span class="hljs-comment">// 这里设定超级源点为0，建立从0到每一个团队起点的边，权值为0</span><br>        &#125;<br>        dijkstra2.solve(<span class="hljs-number">0</span>, v + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, graph);<span class="hljs-comment">//第二次跑dijkstra</span><br><br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> s_min_max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = <span class="hljs-number">1</span>; i &lt; v + <span class="hljs-number">1</span>; ++i)<br>            s_min_max = max(s_min_max, dijkstra1.low_cost[i]);<br><br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> k_min_max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = <span class="hljs-number">1</span>; i &lt; v + <span class="hljs-number">1</span>; ++i)<br>            k_min_max = max(k_min_max, dijkstra2.low_cost[i]);<br><br>        <span class="hljs-keyword">if</span> (s_min_max &lt;= c * k_min_max)<span class="hljs-comment">//考虑到精度问题，这里用乘法代替</span><br>            <span class="hljs-built_in">cout</span> &lt;&lt; s_min_max &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">cout</span> &lt;&lt; k_min_max &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    ios_base::sync_with_stdio(<span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">cin</span>.tie(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">cout</span>.tie(<span class="hljs-number">0</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ACM_LOCAL</span><br>    freopen(<span class="hljs-string">&quot;in.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, <span class="hljs-built_in">stdin</span>);<br>    freopen(<span class="hljs-string">&quot;out.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-built_in">stdout</span>);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> test_index_for_debug = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">char</span> acm_local_for_debug;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; acm_local_for_debug) &#123;<br>        <span class="hljs-built_in">cin</span>.putback(acm_local_for_debug);<br>        <span class="hljs-keyword">if</span> (test_index_for_debug &gt; <span class="hljs-number">100</span>) &#123;<br>            throw runtime_error(<span class="hljs-string">&quot;Check the stdin!!!&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">auto</span> start_clock_for_debug = clock();<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        solve();<br>        <span class="hljs-keyword">auto</span> end_clock_for_debug = clock();<br>        <span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Test &quot;</span> &lt;&lt; test_index_for_debug++ &lt;&lt; <span class="hljs-string">&quot; Run Time: &quot;</span><br>             &lt;&lt; <span class="hljs-type">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="hljs-string">&quot;s&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;\n--------------------------------------------------&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    solve();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>XCPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【2019HDU多校】第九场1006/HDU6685-Rikka with Coin——位运算打表</title>
    <link href="/2019/08/21/acm/2019-multi-school/HDU6685-9-1006-Rikka-with-Coin/"/>
    <url>/2019/08/21/acm/2019-multi-school/HDU6685-9-1006-Rikka-with-Coin/</url>
    
    <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6685">题目链接</a></p><h1 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h1><p>使用10、20、50、100元面额的硬币能分别组成题目给出的面额，需要最少的硬币个数</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>一开始队友想用一堆if-else解决问题，然后WA了无数发……</p><p>我想到了一种比较简单的打表法来解决这个问题，而这个表长度只有==13个int==</p><p>==在开始分析之前，我们先不考虑出现 -1 的解。即出现某种情况 mod 10不等于0，因为这个判断非常简单==</p><h2 id="定律"><a href="#定律" class="headerlink" title="定律"></a>定律</h2><p>开始推这个表之前先确定一个显而易见的定律</p><p><strong>若存在两种方案的需要的硬币数一样，且第一种的方案能组成的面额第二种都可以组成，则第一种方案不可取。</strong></p><p>证明：如果我使用了第一组方案，则我必定可以使用第二种方案，即使第二种方案不能组成其他更多的面额，这样的选择也是完全没有错误的</p><h2 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h2><p>根据定律，可以得到下面这些推论</p><p><strong>1、不存在一种方案包含两个10元、同理有两个50元也不存在</strong></p><p>证明：如果存在一个方案包含两个10元，则我们可以选择用一个10元和一个20元代替这个方案。我们可以确定，两个10元只能组成10、20这两个面额。而10元和20元可以组成10元、20元、30元三个面额。根据定律，则确定此方案不可行。同理，两个50元可以用50+100代替</p><p><strong>2、仅使用4个非100元的硬币，只有两种组成方案：10、20、20、50和20、20、20、50</strong></p><p>证明：对于4个硬币，方案10、20、20、50可以组成10-100的所有情况，所以任何其他方案如果合理，则必须能组成有超过100元的情况。根据推论1，则50元不可以重复，所以能组成的最大的值就是用20、20、20、50组成110。</p><p><strong>3、不存在使用5个非100元的硬币的情况</strong></p><p>证明：首先如果使用了5个硬币，根据推论1，可以得到的组合仅两种：10、20、20、20、50即120元，和20、20、20、20、50即130元。那么无论这个组合怎么样，通过推论2的结论，都不如10、20、20、50、100这个组合，因为这个组合能完成10-200以内的所有解。那么根据定律，上述两个组合都是错误的组合。</p><p><strong>4、大于110元的面额必须要通过一个或者数个100元的硬币来组成</strong></p><p>证明：这个很简单，通过推理3可以直接推出。所以对于大于110元的面额都应不断的-100直到满足上述情况</p><h2 id="打表"><a href="#打表" class="headerlink" title="打表"></a>打表</h2><p>那么我们知道了最多只有4个非100元的硬币，那么我们就可以得到所有的组合情况（省略0）</p><blockquote><p>1<br>2<br>5<br>1 2<br>1 5<br>2 2<br>2 5<br>1 2 2<br>1 2 5<br>2 2 2<br>2 2 5<br>1 2 2 5<br>2 2 2 5</p></blockquote><p>那么我们可以把这些情况能组成的数字打表出来</p><blockquote><p>1<br>2<br>5<br>1 2 3<br>1 5 6<br>2 4<br>2 5 7<br>1 2 3 4 5<br>1 2 3 5 6 7 8<br>2 4 6<br>2 4 5 7 9<br>1 2 3 4 5 6 7 8 9 10<br>2 4 6 7 9 11</p></blockquote><p>借助位运算，我们可以这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>((<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>))<br><span class="hljs-built_in">print</span>((<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">6</span>))<br><span class="hljs-built_in">print</span>((<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span>((<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">7</span>))<br><span class="hljs-built_in">print</span>((<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>))<br><span class="hljs-built_in">print</span>((<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">6</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">7</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">8</span>))<br><span class="hljs-built_in">print</span>((<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">6</span>))<br><span class="hljs-built_in">print</span>((<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">7</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">9</span>))<br><span class="hljs-built_in">print</span>((<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">6</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">7</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">8</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">9</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">10</span>))<br><span class="hljs-built_in">print</span>((<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">2</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">6</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">7</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">9</span>) + (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">11</span>))<br></code></pre></td></tr></table></figure><p>可以尝试理解这个表的原理，==即将每一个bite作为表的一个元素==</p><p>可以看到最大值只有110元。而注意到面额最大的硬币为100。而110元可以用非100元组成也可以通过10元+100元组成，同理100元也有两种组合方式。所以需要考虑四个情况：<br>1、100元用100元组成、110元用100元组成<br>2、100元用100元组成、110元用非100元组成<br>3、100元用非100元组成、110元用100元组成<br>4、100元用非100元组成、110元用非100元组成</p><p>那么都考虑一下，取较小者</p><h1 id="AC-Code"><a href="#AC-Code" class="headerlink" title="AC-Code"></a>AC-Code</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; res;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>    res.push_back(<span class="hljs-number">0</span>);<br>    res.push_back(<span class="hljs-number">2</span>);<br>    res.push_back(<span class="hljs-number">4</span>);<br>    res.push_back(<span class="hljs-number">32</span>);<br>    res.push_back(<span class="hljs-number">14</span>);<br>    res.push_back(<span class="hljs-number">98</span>);<br>    res.push_back(<span class="hljs-number">20</span>);<br>    res.push_back(<span class="hljs-number">164</span>);<br>    res.push_back(<span class="hljs-number">62</span>);<br>    res.push_back(<span class="hljs-number">494</span>);<br>    res.push_back(<span class="hljs-number">84</span>);<br>    res.push_back(<span class="hljs-number">692</span>);<br>    res.push_back(<span class="hljs-number">2046</span>);<br>    res.push_back(<span class="hljs-number">2804</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">get_ans</span><span class="hljs-params">(<span class="hljs-type">int</span> as)</span> &#123;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; res.size(); ++i) &#123;<br>        <span class="hljs-keyword">if</span> ((res[i] ^ as) + (res[i] &amp; as) == res[i]) &#123;<br>            t = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">switch</span> (t) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">10</span>:<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">11</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">12</span>:<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">13</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1000</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ACM_LOCAL</span><br>    freopen(<span class="hljs-string">&quot;in.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, <span class="hljs-built_in">stdin</span>);<br>    freopen(<span class="hljs-string">&quot;out.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-built_in">stdout</span>);<br>    <span class="hljs-keyword">auto</span> start_clock_for_debug = clock();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    ios::sync_with_stdio(<span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">cin</span>.tie(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">cin</span>.tie(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-type">int</span> t;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; t;<br>    init();<br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        <span class="hljs-type">int</span> n;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; n;<br><br>        <span class="hljs-type">int</span> hun[<span class="hljs-number">4</span>];<br>        <span class="hljs-type">int</span> cnt[<span class="hljs-number">4</span>][<span class="hljs-number">15</span>];<br>        <span class="hljs-built_in">memset</span>(cnt, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(cnt));<br>        <span class="hljs-built_in">memset</span>(hun, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(hun));<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            <span class="hljs-type">int</span> tmp;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; tmp;<br><br>            <span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">continue</span>;<br><br>            <span class="hljs-keyword">if</span> (tmp % <span class="hljs-number">10</span>) &#123;<br>                flag = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-comment">// 100 + 110</span><br>            <span class="hljs-type">int</span> tmp0 = tmp;<br>            <span class="hljs-keyword">if</span> (tmp0 % <span class="hljs-number">100</span> &gt; <span class="hljs-number">10</span> and tmp0 &gt; <span class="hljs-number">100</span>) &#123;<br>                hun[<span class="hljs-number">0</span>] = max(tmp0 / <span class="hljs-number">100</span>, hun[<span class="hljs-number">0</span>]);<br>                tmp0 %= <span class="hljs-number">100</span>;<br>                cnt[<span class="hljs-number">0</span>][tmp0 / <span class="hljs-number">10</span>]++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (tmp0 &gt; <span class="hljs-number">100</span>) &#123;<br>                hun[<span class="hljs-number">0</span>] = max((tmp0 - <span class="hljs-number">100</span>) / <span class="hljs-number">100</span>, hun[<span class="hljs-number">0</span>]);<br>                tmp0 %= <span class="hljs-number">100</span>;<br>                cnt[<span class="hljs-number">0</span>][tmp0 / <span class="hljs-number">10</span> + <span class="hljs-number">10</span>]++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cnt[<span class="hljs-number">0</span>][tmp0 / <span class="hljs-number">10</span>]++;<br>            &#125;<br>            <span class="hljs-comment">// 100</span><br>            <span class="hljs-type">int</span> tmp1 = tmp;<br>            <span class="hljs-keyword">if</span> (tmp1 % <span class="hljs-number">100</span> == <span class="hljs-number">0</span> and tmp1 &gt; <span class="hljs-number">100</span>) &#123;<br>                hun[<span class="hljs-number">1</span>] = max((tmp1 - <span class="hljs-number">100</span>) / <span class="hljs-number">100</span>, hun[<span class="hljs-number">1</span>]);<br>                cnt[<span class="hljs-number">1</span>][<span class="hljs-number">10</span>]++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                hun[<span class="hljs-number">1</span>] = max(tmp1 / <span class="hljs-number">100</span>, hun[<span class="hljs-number">1</span>]);<br>                cnt[<span class="hljs-number">1</span>][(tmp1 % <span class="hljs-number">100</span>) / <span class="hljs-number">10</span>]++;<br>            &#125;<br>            <span class="hljs-comment">// 110</span><br>            <span class="hljs-type">int</span> tmp2 = tmp;<br>            <span class="hljs-keyword">if</span> (tmp2 % <span class="hljs-number">100</span> == <span class="hljs-number">10</span> and tmp2 &gt; <span class="hljs-number">100</span>) &#123;<br>                hun[<span class="hljs-number">2</span>] = max((tmp2 - <span class="hljs-number">100</span>) / <span class="hljs-number">100</span>, hun[<span class="hljs-number">2</span>]);<br>                cnt[<span class="hljs-number">2</span>][<span class="hljs-number">11</span>]++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                hun[<span class="hljs-number">2</span>] = max(tmp2 / <span class="hljs-number">100</span>, hun[<span class="hljs-number">2</span>]);<br>                cnt[<span class="hljs-number">2</span>][(tmp2 % <span class="hljs-number">100</span>) / <span class="hljs-number">10</span>]++;<br>            &#125;<br>            <span class="hljs-comment">// None</span><br>            <span class="hljs-type">int</span> tmp3 = tmp;<br>            hun[<span class="hljs-number">3</span>] = max(tmp3 / <span class="hljs-number">100</span>, hun[<span class="hljs-number">3</span>]);<br>            cnt[<span class="hljs-number">3</span>][(tmp3 % <span class="hljs-number">100</span>) / <span class="hljs-number">10</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (flag) &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> ans;<br>        <span class="hljs-type">int</span> get_ans[<span class="hljs-number">4</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; ++j) &#123;<br>            ans = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt; <span class="hljs-number">13</span>; ++k) &#123;<br>                <span class="hljs-keyword">if</span> (cnt[j][k]) &#123;<br>                    ans += <span class="hljs-number">1</span> &lt;&lt; k;<br>                &#125;<br>            &#125;<br>            get_ans[j] = get_ans(ans) + hun[j];<br>        &#125;<br>        sort(get_ans, get_ans + <span class="hljs-number">4</span>);<br>        <span class="hljs-built_in">cout</span> &lt;&lt; get_ans[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ACM_LOCAL</span><br>    <span class="hljs-keyword">auto</span> end_clock_for_debug = clock();<br>    <span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">&quot;Run Time: &quot;</span> &lt;&lt; <span class="hljs-type">double</span>(end_clock_for_debug - start_clock_for_debug) / CLOCKS_PER_SEC &lt;&lt; <span class="hljs-string">&quot;s&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【2019牛客暑期多校第三场】J题LRU management</title>
    <link href="/2019/07/26/acm/2019-multi-school/NowCoder-3-J-LRU-management/"/>
    <url>/2019/07/26/acm/2019-multi-school/NowCoder-3-J-LRU-management/</url>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/883/J">题目链接</a></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>好吧，这道题我其实看都没看过，队友跟我说了说这道题是模拟题，卡时间。然后我就上了……<br>大致就是维护一个线性表，然后有两种操作：插入、查询<br>插入时，如果这个值（string）之前出现过，则把之前那个值（string）放到线性表的表尾（删去原来那个），但是保存的值（int）仍是之前那个值（int）。如果没有出现过，则把它插入到表尾。如果插入后发现线性表长度超过 m ，则弹出表头的元素。<br>查询时，如果有这个值（string），然后根据要求查询这个值（string）的上一个或者下一个，再返回它的值（int），如果没有（没有上一个或者下一个也是）则输出：Invalid</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>一开始觉得这个……应该就是拿STL可以暴力过的（当然不能太暴力）我选择了 unordered_map + list<br>听说用 map 会 T，没试过……<br>unordered_map 是哈希表，而 map 是红黑树，相对而言， map 的查询、插入、删除的时间比较稳定，都是 O(logN)，而 unordered_map 的时间不确定性比较大，运气好就是 O(1) 的查询，运气差就是 O(N)</p><blockquote><p>复杂度<br>平均为常数，最坏情况与容器大小成线性。<br>摘自<a href="https://zh.cppreference.com/w/cpp/container/unordered_map/count">cppreference</a></p></blockquote><p>unordered_map 用 string 作为索引，保存了 list 的迭代器<br>list 保存了值的顺序情况，包括了 string 和 int 两个变量<br>但是我第一发居然T了，然后加了快读就AC了，感觉就是被卡常了……</p><h1 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">list</span>&lt;<span class="hljs-built_in">pair</span> &lt; <span class="hljs-type">int</span>, <span class="hljs-built_in">string</span>&gt;&gt;<br>::iterator pl;<br><span class="hljs-built_in">unordered_map</span> &lt;<span class="hljs-built_in">string</span>, pl&gt; ump;<br><span class="hljs-built_in">list</span> &lt;<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-built_in">string</span>&gt;&gt; lists;<br><span class="hljs-type">char</span> catchmessage[<span class="hljs-number">100</span>];<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ioss</span> &#123;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> LEN = <span class="hljs-number">20000000</span>;<br>    <span class="hljs-type">char</span> obuf[LEN], *oh = obuf;<br>    <span class="hljs-built_in">std</span>::streambuf *fb;<br><br>    ioss() &#123;<br>        ios::sync_with_stdio(<span class="hljs-literal">false</span>);<br>        <span class="hljs-built_in">cin</span>.tie(<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-built_in">cout</span>.tie(<span class="hljs-literal">NULL</span>);<br>        fb = <span class="hljs-built_in">cout</span>.rdbuf();<br>    &#125;<br><br>    <span class="hljs-keyword">inline</span> <span class="hljs-type">char</span> <span class="hljs-title function_">gc</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-type">static</span> <span class="hljs-type">char</span> buf[LEN], *s, *t, buf2[LEN];<br>        <span class="hljs-keyword">return</span> (s == t) &amp;&amp; (t = (s = buf) + fread(buf, <span class="hljs-number">1</span>, LEN, <span class="hljs-built_in">stdin</span>)), s == t ? <span class="hljs-number">-1</span> : *s++;<br>    &#125;<br><br>    <span class="hljs-keyword">inline</span> ioss &amp;operator&gt;&gt;(<span class="hljs-type">long</span> <span class="hljs-type">long</span> &amp;x) &#123;<br>        <span class="hljs-type">static</span> <span class="hljs-type">char</span> ch, sgn, *p;<br>        ch = gc(), sgn = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(ch); ch = gc()) &#123;<br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-number">-1</span>)<br>                <span class="hljs-keyword">return</span> *this;<br>            sgn |= ch == <span class="hljs-string">&#x27;-&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (x = <span class="hljs-number">0</span>; <span class="hljs-built_in">isdigit</span>(ch); ch = gc())<br>            x = x * <span class="hljs-number">10</span> + (ch ^ <span class="hljs-string">&#x27;0&#x27;</span>);<br>        sgn &amp;&amp; (x = -x);<br>        <span class="hljs-keyword">return</span> *this;<br>    &#125;<br><br>    <span class="hljs-keyword">inline</span> ioss &amp;operator&gt;&gt;(<span class="hljs-type">int</span> &amp;x) &#123;<br>        <span class="hljs-type">static</span> <span class="hljs-type">char</span> ch, sgn, *p;<br>        ch = gc(), sgn = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isdigit</span>(ch); ch = gc()) &#123;<br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-number">-1</span>)<br>                <span class="hljs-keyword">return</span> *this;<br>            sgn |= ch == <span class="hljs-string">&#x27;-&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (x = <span class="hljs-number">0</span>; <span class="hljs-built_in">isdigit</span>(ch); ch = gc())<br>            x = x * <span class="hljs-number">10</span> + (ch ^ <span class="hljs-string">&#x27;0&#x27;</span>);<br>        sgn &amp;&amp; (x = -x);<br>        <span class="hljs-keyword">return</span> *this;<br>    &#125;<br><br>    <span class="hljs-keyword">inline</span> ioss &amp;operator&gt;&gt;(<span class="hljs-type">char</span> &amp;x) &#123;<br>        <span class="hljs-type">static</span> <span class="hljs-type">char</span> ch;<br>        <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isalpha</span>(ch); ch = gc()) &#123;<br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-number">-1</span>)<br>                <span class="hljs-keyword">return</span> *this;<br>        &#125;<br>        x = ch;<br>        <span class="hljs-keyword">return</span> *this;<br>    &#125;<br><br>    <span class="hljs-keyword">inline</span> ioss &amp;operator&gt;&gt;(<span class="hljs-built_in">string</span> &amp;x) &#123;<br>        <span class="hljs-type">static</span> <span class="hljs-type">char</span> ch, *p, buf2[LEN];<br>        <span class="hljs-keyword">for</span> (; !<span class="hljs-built_in">isalpha</span>(ch) &amp;&amp; !<span class="hljs-built_in">isdigit</span>(ch); ch = gc())<br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-number">-1</span>)<br>                <span class="hljs-keyword">return</span> *this;<br>        p = buf2;<br>        <span class="hljs-keyword">for</span> (; <span class="hljs-built_in">isalpha</span>(ch) || <span class="hljs-built_in">isdigit</span>(ch); ch = gc())<br>            *p = ch, p++;<br>        *p = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        x = buf2;<br>        <span class="hljs-keyword">return</span> *this;<br>    &#125;<br><br>    <span class="hljs-keyword">inline</span> ioss &amp;operator&lt;&lt;(<span class="hljs-built_in">string</span> &amp;c) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;p: c)<br>            this-&gt;operator&lt;&lt;(p);<br>        <span class="hljs-keyword">return</span> *this;<br>    &#125;<br><br>    <span class="hljs-keyword">inline</span> ioss &amp;operator&lt;&lt;(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *c) &#123;<br>        <span class="hljs-keyword">while</span> (*c != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>            this-&gt;operator&lt;&lt;(*c);<br>            c++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *this;<br>    &#125;<br><br>    <span class="hljs-keyword">inline</span> ioss &amp;operator&lt;&lt;(<span class="hljs-type">const</span> <span class="hljs-type">char</span> &amp;c) &#123;<br>        oh == obuf + LEN ? (fb-&gt;sputn(obuf, LEN), oh = obuf) : <span class="hljs-number">0</span>;<br>        *oh++ = c;<br>        <span class="hljs-keyword">return</span> *this;<br>    &#125;<br><br>    <span class="hljs-keyword">inline</span> ioss &amp;operator&lt;&lt;(<span class="hljs-type">int</span> x) &#123;<br>        <span class="hljs-type">static</span> <span class="hljs-type">int</span> buf[<span class="hljs-number">30</span>], cnt;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>)<br>            this-&gt;operator&lt;&lt;(<span class="hljs-string">&#x27;-&#x27;</span>), x = -x;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>)<br>            this-&gt;operator&lt;&lt;(<span class="hljs-string">&#x27;0&#x27;</span>);<br>        <span class="hljs-keyword">for</span> (cnt = <span class="hljs-number">0</span>; x; x /= <span class="hljs-number">10</span>)<br>            buf[++cnt] = x % <span class="hljs-number">10</span> | <span class="hljs-number">48</span>;<br>        <span class="hljs-keyword">while</span> (cnt)<br>            this-&gt;operator&lt;&lt;((<span class="hljs-type">char</span>) buf[cnt--]);<br>        <span class="hljs-keyword">return</span> *this;<br>    &#125;<br><br>    <span class="hljs-keyword">inline</span> ioss &amp;operator&lt;&lt;(<span class="hljs-type">long</span> <span class="hljs-type">long</span> x) &#123;<br>        <span class="hljs-type">static</span> <span class="hljs-type">int</span> buf[<span class="hljs-number">30</span>], cnt;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>)<br>            this-&gt;operator&lt;&lt;(<span class="hljs-string">&#x27;-&#x27;</span>), x = -x;<br>        <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>)<br>            this-&gt;operator&lt;&lt;(<span class="hljs-string">&#x27;0&#x27;</span>);<br>        <span class="hljs-keyword">for</span> (cnt = <span class="hljs-number">0</span>; x; x /= <span class="hljs-number">10</span>)<br>            buf[++cnt] = x % <span class="hljs-number">10</span> | <span class="hljs-number">48</span>;<br>        <span class="hljs-keyword">while</span> (cnt)<br>            this-&gt;operator&lt;&lt;((<span class="hljs-type">char</span>) buf[cnt--]);<br>        <span class="hljs-keyword">return</span> *this;<br>    &#125;<br><br>    ~ioss() &#123;<br>        fb-&gt;sputn(obuf, oh - obuf);<br>    &#125;<br>&#125; io;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ACM_LOCAL</span><br>    freopen(<span class="hljs-string">&quot;./in.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, <span class="hljs-built_in">stdin</span>);<br>    freopen(<span class="hljs-string">&quot;./out.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-built_in">stdout</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    ios::sync_with_stdio(<span class="hljs-literal">false</span>);<br>    <span class="hljs-type">int</span> t;<br>    io &gt;&gt; t;<br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        ump.clear();<br>        lists.clear();<br>        <span class="hljs-type">int</span> q, m;<br>        io &gt;&gt; q &gt;&gt; m;<br>        <span class="hljs-built_in">string</span> s;<br>        <span class="hljs-type">int</span> op, val;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) &#123;<br>            pl cur;<br>            io &gt;&gt; op &gt;&gt; s &gt;&gt; val;<br>            <span class="hljs-keyword">if</span> (op) &#123;<br>                <span class="hljs-keyword">if</span> (!ump.count(s)) &#123;<br>                    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Invalid&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                cur = ump[s];<br>                <span class="hljs-keyword">if</span> (val == <span class="hljs-number">1</span>) &#123;<br>                    cur++;<br>                    <span class="hljs-keyword">if</span> (cur == lists.end()) &#123;<br>                        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Invalid&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val == <span class="hljs-number">-1</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (cur == lists.begin()) &#123;<br>                        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Invalid&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    cur--;<br>                &#125;<br>                <span class="hljs-built_in">cout</span> &lt;&lt; (*cur).first &lt;&lt; <span class="hljs-built_in">endl</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (!ump.count(s)) &#123;<br>                    <span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-built_in">string</span>&gt; newnode = <span class="hljs-built_in">make_pair</span>(val, s);<br>                    lists.push_back(newnode);<br>                    pl tmp = lists.end();<br>                    tmp--;<br>                    ump.insert(<span class="hljs-built_in">make_pair</span>(s, tmp));<br>                    <span class="hljs-keyword">if</span> (lists.size() &gt; m) &#123;<br>                        ump.erase(lists.front().second);<br>                        lists.pop_front();<br>                    &#125;<br>                    <span class="hljs-built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="hljs-built_in">endl</span>;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                cur = ump[s];<br>                <span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-built_in">string</span>&gt; newnode = <span class="hljs-built_in">make_pair</span>((*cur).first, s);<br>                lists.push_back(newnode);<br>                pl tmp = lists.end();<br>                tmp--;<br>                ump[s] = tmp;<br>                lists.erase(cur);<br>                <span class="hljs-built_in">cout</span> &lt;&lt; newnode.first &lt;&lt; <span class="hljs-built_in">endl</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>NowCoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【2019多校第一场补题 / HDU6582】2019多校第一场E题1005Path——最短路径+网络流</title>
    <link href="/2019/07/23/acm/2019-multi-school/HDU6578-1-1005-Path/"/>
    <url>/2019/07/23/acm/2019-multi-school/HDU6578-1-1005-Path/</url>
    
    <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6582">HDU6582链接</a></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>在一张有向图中，有一个起点和一个终点，你需要删去部分路径，使得起点到终点的最短距离增加（并不要求需要使得距离变成最大值），且删除的路径长度最短。求删去的路径总长为多少</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>一开始理解错题意了，以为是在保证路径变成最长的路径之后，求删去的路径和最小是多少。然后就自闭了很久，还WA了好几发。后来看到题目中是 longer 而不是 longest 。突然醒悟。直接最短路径 +网络流就行，中间重新建图。<br>大致的过程是先跑最短路径（我用了SPFA算法，因为当数据量较大时，图为稀疏图，所以用邻接表形式），然后求出起点到每一个点的距离（保存在数组 dist 中）。然后删掉所有的边，对满足下面等式的边进行重建（网络流的边，即同时需要搭建反向的边，只不过流量为0），然后跑网络流（我用了ISAP算法，仍然是邻接表）</p><blockquote><p>$dist[a] - dist[b] = edge[a to b]$<br>$a to b$ 指代这条边起点为 $a$ 终点为 $b$，且满足 $edge[b to a] = - edge[a to b]$</p></blockquote><h1 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 20100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXM 20100</span><br><br><span class="hljs-type">bool</span> visited[MAXN];          <span class="hljs-comment">//标记数组</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dist[MAXN];        <span class="hljs-comment">//源点到顶点i的最短距离</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> path[MAXN];        <span class="hljs-comment">//记录最短路的路径</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> enqueue_num[MAXN]; <span class="hljs-comment">//记录入队次数</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> vertex_num;        <span class="hljs-comment">//顶点数</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> edge_num;          <span class="hljs-comment">//边数</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> source;            <span class="hljs-comment">//源点</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span> &#123;</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> to, next, cap, flow;<br>&#125; edge[MAXM];<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> head[MAXN];<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> tot;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> gap[MAXN], dep[MAXN], cur[MAXN];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>    tot = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(head, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span>(head));<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">addedge</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> u, <span class="hljs-type">long</span> <span class="hljs-type">long</span> v, <span class="hljs-type">long</span> <span class="hljs-type">long</span> w)</span> &#123;<br>    edge[tot].to = v;<br>    edge[tot].cap = w;<br>    edge[tot].next = head[u];<br>    edge[tot].flow = <span class="hljs-number">0</span>;<br>    head[u] = tot++;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">SPFA</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">memset</span>(visited, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(visited));<br>    <span class="hljs-built_in">memset</span>(enqueue_num, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(enqueue_num));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = <span class="hljs-number">0</span>; i &lt; vertex_num; i++) &#123;<br>        dist[i] = __LONG_LONG_MAX__;<br>        path[i] = source;<br>    &#125;<br><br>    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; Q;<br>    Q.push(source);<br>    dist[source] = <span class="hljs-number">0</span>;<br>    visited[source] = <span class="hljs-literal">true</span>;<br>    enqueue_num[source]++;<br>    <span class="hljs-keyword">while</span> (!Q.empty()) &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> u = Q.front();<br>        Q.pop();<br>        visited[u] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> curnode = head[u]; curnode != <span class="hljs-number">-1</span>; curnode = edge[curnode].next) &#123;<br>            <span class="hljs-keyword">if</span> (dist[u] + edge[curnode].cap &lt; dist[edge[curnode].to]) &#123;<br>                dist[edge[curnode].to] = dist[u] + edge[curnode].cap;<br>                path[edge[curnode].to] = u;<br>                <span class="hljs-keyword">if</span> (!visited[edge[curnode].to]) &#123;<br>                    Q.push(edge[curnode].to);<br>                    enqueue_num[edge[curnode].to]++;<br>                    <span class="hljs-keyword">if</span> (enqueue_num[edge[curnode].to] &gt;= vertex_num)<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    visited[edge[curnode].to] = <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> Q[MAXN];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">BFS</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> start, <span class="hljs-type">long</span> <span class="hljs-type">long</span> end)</span> &#123;<br>    <span class="hljs-built_in">memset</span>(dep, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span>(dep));<br>    <span class="hljs-built_in">memset</span>(gap, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(gap));<br>    gap[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> front = <span class="hljs-number">0</span>, rear = <span class="hljs-number">0</span>;<br>    dep[end] = <span class="hljs-number">0</span>;<br>    Q[rear++] = end;<br>    <span class="hljs-keyword">while</span> (front != rear) &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> u = Q[front++];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = head[u]; i != <span class="hljs-number">-1</span>; i = edge[i].next) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> v = edge[i].to;<br>            <span class="hljs-keyword">if</span> (dep[v] != <span class="hljs-number">-1</span>)<br>                <span class="hljs-keyword">continue</span>;<br>            Q[rear++] = v;<br>            dep[v] = dep[u] + <span class="hljs-number">1</span>;<br>            gap[dep[v]]++;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> S[MAXN];<br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">sap</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> start, <span class="hljs-type">long</span> <span class="hljs-type">long</span> end, <span class="hljs-type">long</span> <span class="hljs-type">long</span> N)</span> &#123;<br>    BFS(start, end);<br>    <span class="hljs-built_in">memcpy</span>(cur, head, <span class="hljs-keyword">sizeof</span>(head));<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> top = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> u = start;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (dep[start] &lt; N) &#123;<br>        <span class="hljs-keyword">if</span> (u == end) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> Min = __LONG_LONG_MAX__;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> inser;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = <span class="hljs-number">0</span>; i &lt; top; i++) &#123;<br>                <span class="hljs-keyword">if</span> (Min &gt; edge[S[i]].cap - edge[S[i]].flow) &#123;<br>                    Min = edge[S[i]].cap - edge[S[i]].flow;<br>                    inser = i;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = <span class="hljs-number">0</span>; i &lt; top; i++) &#123;<br>                edge[S[i]].flow += Min;<br>                edge[S[i] ^ <span class="hljs-number">1</span>].flow -= Min;<br>            &#125;<br>            ans += Min;<br>            top = inser;<br>            u = edge[S[top] ^ <span class="hljs-number">1</span>].to;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> v;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = cur[u]; i != <span class="hljs-number">-1</span>; i = edge[i].next) &#123;<br>            v = edge[i].to;<br>            <span class="hljs-keyword">if</span> (edge[i].cap - edge[i].flow &amp;&amp; dep[v] + <span class="hljs-number">1</span> == dep[u]) &#123;<br>                flag = <span class="hljs-literal">true</span>;<br>                cur[u] = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (flag) &#123;<br>            S[top++] = cur[u];<br>            u = v;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> Min = N;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = head[u]; i != <span class="hljs-number">-1</span>; i = edge[i].next)<br>            <span class="hljs-keyword">if</span> (edge[i].cap - edge[i].flow &amp;&amp; dep[edge[i].to] &lt; Min) &#123;<br>                Min = dep[edge[i].to];<br>                cur[u] = i;<br>            &#125;<br>        gap[dep[u]]--;<br>        <span class="hljs-keyword">if</span> (!gap[dep[u]])<br>            <span class="hljs-keyword">return</span> ans;<br>        dep[u] = Min + <span class="hljs-number">1</span>;<br>        gap[dep[u]]++;<br>        <span class="hljs-keyword">if</span> (u != start)<br>            u = edge[S[--top] ^ <span class="hljs-number">1</span>].to;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> n, m;<br><span class="hljs-type">int</span> a[MAXN], b[MAXN], c[MAXN];<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">reISAP</span><span class="hljs-params">()</span> &#123;<br>    init();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">if</span> (c[i] == dist[b[i]] - dist[a[i]]) &#123;<br>            addedge(a[i], b[i], c[i]);<br>            addedge(b[i], a[i], <span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ACM_LOCAL</span><br>    freopen(<span class="hljs-string">&quot;./in.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, <span class="hljs-built_in">stdin</span>);<br>    freopen(<span class="hljs-string">&quot;./out.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-built_in">stdout</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    ios::sync_with_stdio(<span class="hljs-literal">false</span>);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> t;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; t;<br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>        source = <span class="hljs-number">1</span>;<br>        vertex_num = n + <span class="hljs-number">1</span>;<br>        init();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; c[i];<br>            addedge(a[i], b[i], c[i]);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!SPFA()) &#123;<br>            <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&#x27;0&#x27;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        reISAP();<br>        <span class="hljs-built_in">cout</span> &lt;&lt; sap(<span class="hljs-number">1</span>, n, n) &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>理解了题意之后感觉就是一道板子题……<br><del>人尽皆知**题</del> </p>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【2019多校第一场补题 / HDU6578】2019多校第一场A题1001Blank——dp</title>
    <link href="/2019/07/23/acm/2019-multi-school/HDU6578-1-1001-Blank/"/>
    <url>/2019/07/23/acm/2019-multi-school/HDU6578-1-1001-Blank/</url>
    
    <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6578">HDU6578链接</a></p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>有一串字符串，仅由 ${0, 1, 2, 3}$ 组成，长度为 $n$，同时满足 $m$ 个条件。每个条件由三个整数组成：$l、r、x$ 表示在这个字符串的 $[l, r]$ 这个区间内，有且仅有 $x$ 个不同的字符，求问可能的组合有多少种（mod 998244353）</p><h1 id="分析题意"><a href="#分析题意" class="headerlink" title="分析题意"></a>分析题意</h1><p>因为前几天刚刚写了牛客暑期多校第二场，其中有一道题：ABBA（<a href="https://blog.csdn.net/m0_43448982/article/details/96778336">我的题解</a>）感觉有点接近，所以第一想法就是dp了。但是这道题的字符多，不能像ABBA一样压缩至一维。所以只能想想看当时牛客官方给的题解的方法了。<br>考虑到之后需要判断条件是否满足，所以我第一感觉就是得定义一个超多维度的dp数组：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">110</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dp[MAXN][MAXN][MAXN][MAXN][MAXN];<br></code></pre></td></tr></table></figure><br>各个维度的定义如下：</p><blockquote><p>对于 dp[a][b][c][d][t]<br>表示整个字符串长度为 t ，最后一次出现 0 的位置为 a，最后一次出现 1 的位置为 b ，最后一次出现 2 的位置为 c ，最后一次出现 3 的位置为d</p></blockquote><p>然后可以得到状态转移方程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">dp[t + <span class="hljs-number">1</span>][b][c][d][t + <span class="hljs-number">1</span>] += dp[a][b][c][d][t];<br>dp[a][t + <span class="hljs-number">1</span>][c][d][t + <span class="hljs-number">1</span>] += dp[a][b][c][d][t];<br>dp[a][b][t + <span class="hljs-number">1</span>][d][t + <span class="hljs-number">1</span>] += dp[a][b][c][d][t];<br>dp[a][b][c][t + <span class="hljs-number">1</span>][t + <span class="hljs-number">1</span>] += dp[a][b][c][d][t];<br></code></pre></td></tr></table></figure><br>当然这个数组肯定是没法开的，所以把 t 压缩了，变成滚动dp<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">110</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dp[MAXN][MAXN][MAXN][MAXN][<span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><br>然后通过滚动的方式来实现。<br>但是这并不是卡死这种方法的原因。<br>根据上面这些，可以写出整个dp过程，大概就是这样：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t = <span class="hljs-number">1</span>; t &lt;= n; t++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a = <span class="hljs-number">0</span>; a &lt;= t; a++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b = <span class="hljs-number">0</span>; b &lt;= t; b++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c = <span class="hljs-number">0</span>; c &lt;= t; c++)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d = <span class="hljs-number">0</span>; d &lt;= t; d++)<br>                    dp[a][b][c][d][t &amp; <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a = <span class="hljs-number">0</span>; a &lt;= t; a++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b = <span class="hljs-number">0</span>; b &lt;= t; b++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> c = <span class="hljs-number">0</span>; c &lt;= t; c++)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d = <span class="hljs-number">0</span>; d &lt;= t; d++) &#123;<br>                    dp[t + <span class="hljs-number">1</span>][b][c][d][t &amp; <span class="hljs-number">1</span>] += dp[a][b][c][d][t ^ <span class="hljs-number">1</span>];<br>                    dp[a][t + <span class="hljs-number">1</span>][c][d][t &amp; <span class="hljs-number">1</span>] += dp[a][b][c][d][t ^ <span class="hljs-number">1</span>];<br>                    dp[a][b][t + <span class="hljs-number">1</span>][d][t &amp; <span class="hljs-number">1</span>] += dp[a][b][c][d][t ^ <span class="hljs-number">1</span>];<br>                    dp[a][b][c][t + <span class="hljs-number">1</span>][t &amp; <span class="hljs-number">1</span>] += dp[a][b][c][d][t ^ <span class="hljs-number">1</span>];<br>                &#125;<br>&#125;<br></code></pre></td></tr></table></figure><br>这个复杂的……这还没加上判断是否满足条件……<br>无论是时间是还是空间上，估计都悬（时间上应该是一定过不了了）<br>然后只能继续压缩。<br>考虑到最后无论哪种状态下，$a, b, c, d$ 四个变量中，必定有一个且仅有一个变量的值为 t 。而且在这道题中，字符 ${0, 1, 2, 3}$ 完全等价。所以我们再压缩一维<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">110</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dp[MAXN][MAXN][MAXN][<span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><br>此时的意义如下：</p><blockquote><p>对于变量 dp[x][y][z]<br>表示字符 ${0, 1, 2, 3}$ 中，其中一个最后出现的位置为当前的字符最后（由于这个条件恒成立，所以并未被记录在数组中），剩下的三个字符分别出现在$x, y, z$处，且保证 $i &lt; x \leq y \leq z (i 为当前字符长度)$ （仅当 $x = y = 0$ 时满足前面一个等于号，后面的等于号同理。而字符串长度至少为1，且此时$x、y、z$均为0，所以不存在 $i = x$ 的情况。）而后面的长度为 2 的维度指代当前状态和 上一个状态（滚动dp）</p></blockquote><p>可以得到状态转移方程：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// i 为当前字符串长度，cur 为当前状态，last 为上一个状态</span><br>dp[x][y][z][cur] += dp[x][y][z][last];<span class="hljs-comment">// 加入的字符与上一个加入的字符相同</span><br>dp[i - <span class="hljs-number">1</span>][y][z][cur] += dp[x][y][z][last];<br>dp[i - <span class="hljs-number">1</span>][x][z][cur] += dp[x][y][z][last];<br>dp[i - <span class="hljs-number">1</span>][x][y][cur] += dp[x][y][z][last];<br></code></pre></td></tr></table></figure><br>得到整个 dp 过程：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c">dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> cur = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> last = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt;= i; x++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt;= x; y++)<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> z = <span class="hljs-number">0</span>; z &lt;= y; z++)<br>                dp[x][y][z][cur] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; i; x++)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt;= x; y++)<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> z = <span class="hljs-number">0</span>; z &lt;= y; z++) &#123;<br>            dp[x][y][z][cur] += dp[x][y][z][last];<br>            dp[i - <span class="hljs-number">1</span>][y][z][cur] += dp[x][y][z][last];<br>            dp[i - <span class="hljs-number">1</span>][x][z][cur] += dp[x][y][z][last];<br>            dp[i - <span class="hljs-number">1</span>][x][y][cur] += dp[x][y][z][last];<br><br>            dp[x][y][z][cur] %= mod;                        <span class="hljs-comment">// 别忘了 mod</span><br>            dp[i - <span class="hljs-number">1</span>][y][z][cur] %= mod;<br>            dp[i - <span class="hljs-number">1</span>][x][z][cur] %= mod;<br>            dp[i - <span class="hljs-number">1</span>][x][y][cur] %= mod;<br>        &#125;<br>swap(cur, last);<br></code></pre></td></tr></table></figure><br>考虑条件<br>需要判断一个区间内是否满足有多个不同的字符<br>我们可以根据区间右端为基准，当前dp的字符串长度到达一个条件的右端的时候，通过 $x、y、z$ 的值来判断是否到达了要求，如果没有则将此 dp 的赋值为0。如果懒得思考可以直接分类讨论一下就行了。虽然代码会比较长。</p><h1 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">110</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> dp[MAXN][MAXN][MAXN][<span class="hljs-number">2</span>];<br><span class="hljs-comment">// dp[i][j][k] 表示上一次出现不同数字的位置分别是 i、j、k、当前位置</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Conditions</span> &#123;</span><br>    <span class="hljs-type">int</span> l, x;<br><br>    Conditions(<span class="hljs-type">int</span> ll, <span class="hljs-type">int</span> xx) : l(ll), x(xx) &#123;&#125;<br>&#125;;<br><br><span class="hljs-built_in">vector</span> &lt;Conditions&gt; conditions[MAXN];    <span class="hljs-comment">// 用来保存要求</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ACM_LOCAL</span><br>    freopen(<span class="hljs-string">&quot;./in.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, <span class="hljs-built_in">stdin</span>);<br>    freopen(<span class="hljs-string">&quot;./out.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, <span class="hljs-built_in">stdout</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    ios::sync_with_stdio(<span class="hljs-literal">false</span>);<br>    <span class="hljs-type">int</span> t;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; t;<br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        <span class="hljs-type">int</span> n, m;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m;<br>        <span class="hljs-type">int</span> a, b, c;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAXN; i++) &#123;<br>            conditions[i].clear();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>            <span class="hljs-built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>            conditions[b].push_back(Conditions(a, c));        <span class="hljs-comment">// 要求按照 r 的不同来保存</span><br>        &#125;<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> last = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt;= i; x++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt;= x; y++) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> z = <span class="hljs-number">0</span>; z &lt;= y; z++) &#123;<br>                        dp[x][y][z][cur] = <span class="hljs-number">0</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; i; x++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt;= x; y++) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> z = <span class="hljs-number">0</span>; z &lt;= y; z++) &#123;<br>                        dp[x][y][z][cur] += dp[x][y][z][last];<br>                        dp[i - <span class="hljs-number">1</span>][y][z][cur] += dp[x][y][z][last];<br>                        dp[i - <span class="hljs-number">1</span>][x][z][cur] += dp[x][y][z][last];<br>                        dp[i - <span class="hljs-number">1</span>][x][y][cur] += dp[x][y][z][last];<br><br>                        dp[x][y][z][cur] %= mod;<br>                        dp[i - <span class="hljs-number">1</span>][y][z][cur] %= mod;<br>                        dp[i - <span class="hljs-number">1</span>][x][z][cur] %= mod;<br>                        dp[i - <span class="hljs-number">1</span>][x][y][cur] %= mod;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s = <span class="hljs-number">0</span>; s &lt; conditions[i].size(); s++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; i; x++) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt;= x; y++) &#123;<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> z = <span class="hljs-number">0</span>; z &lt;= y; z++) &#123;<br>                            <span class="hljs-type">int</span> cnt = <span class="hljs-number">1</span> + (x &gt;= conditions[i][s].l ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>) + (y &gt;= conditions[i][s].l ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>) +<br>                                      (z &gt;= conditions[i][s].l ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);    <span class="hljs-comment">// 判断剩下三个位置是否满足条件</span><br>                            <span class="hljs-keyword">if</span> (cnt != conditions[i][s].x)<br>                                dp[x][y][z][cur] = <span class="hljs-number">0</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            swap(cur, last);<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;                        <span class="hljs-comment">// 求算最终答案。需要把所有的情况都加起来</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; n; x++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt;= x; y++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> z = <span class="hljs-number">0</span>; z &lt;= y; z++) &#123;<br>                    ans += dp[x][y][z][last];<br>                    ans %= mod;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C/C++ 实现下标为负数的数组</title>
    <link href="/2019/07/22/cpp/cpp-negative-array/"/>
    <url>/2019/07/22/cpp/cpp-negative-array/</url>
    
    <content type="html"><![CDATA[<p>C/C++语言中规定，数组下标为 $[0, n)$<br>但是我们可以通过指针的方式来自定义数组下标<br>例如如下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>];<br><span class="hljs-type">int</span> *pa = a + <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>此时，数组 pa 就是一个下标范围在 -5 到 4 的数组</p>]]></content>
    
    
    <categories>
      
      <category>杂项</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【2019牛客暑期多校第一场】E题ABBA</title>
    <link href="/2019/07/21/acm/2019-multi-school/NowCoder-1-E-ABBA/"/>
    <url>/2019/07/21/acm/2019-multi-school/NowCoder-1-E-ABBA/</url>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/881/E">题目链接</a></p><h1 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h1><p>有$(n + m)$个字母A和$(n + m)$个字母B，组成一个长度为 $2*(n + m)$的字符串，并且使得字符串中有$n$个“AB”和$m$个“BA”，求出可能的组合数（mod 1e9+7）<br>例如，n = 1 m = 2时，可以有这样的字符串（并不是全部的字符串）：<br>ABBABA<br>ABBBAA<br>BBABAA<br>上面三个字符串均满足条件</p><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>考虑递推，假设已经有一个字符串满足一定的“先决条件”（此处应当理解为数学归纳法，及假设n - 1时满足）<br>下面考虑==在字符串最后加入一个字符==的情况。仅有两种可能：加A或者加B(<del>这不是白说吗</del>)<br>但是考虑一下极端情况，我们可以得到一些简单的且明显的条件（N~A~表示已经在字符串中的A个数，N~B~同理）<br>假如字符串的组成类似这样：</p><blockquote><p>AAAAABBBBBBBB</p></blockquote><p>则此字符串中，只能组合出 AB 而不可能组合出 BA<br>此时，我们假设 $n$ 为 5<br>而这个字符只能且必定要组合成 5 个AB，也就是说，我们接下来加入字符，只能加入 A 而不能加入 B<br>此时我们往前推，如果出现了这样一个字符串，则在之前，必定出现如下状态：</p><blockquote><p>AAAAA</p></blockquote><p>也即是 5 个A的情况，此时我们可以得到一个确定的关系式：</p><blockquote><p>N~B~ = 0 and N~A~ &lt;= n</p></blockquote><p>推广到有B的情况，最优的情况就是<strong>所有的B都是用来组成BA</strong>，那么可以得到我们真正需要的关系式：</p><blockquote><p>N~A~ - N~B~ &lt;= n</p></blockquote><p>同理，相对于 B 而言，我们可以得到</p><blockquote><p>N~B~ - N~A~ &lt;= m</p></blockquote><p>合并上述两式</p><blockquote><p>-n &lt; N~A~ - N~B~ &lt;= m</p></blockquote><p>所以根据下标为 N~A~ - N~B~ 建立DP数组，下标范围为 -n 到 m （均包含）DP的内容为方案数量（mod 1e9 + 7），递推公式为<br>$dp[i] = dp[i - 1] + dp [i + 1]$<br>其中，dp[i - 1]指的是加入一个B（增加一个B使得N~A~ - N~B~变小）。而dp[i + 1]指的是加入一个A<br>当考虑到无论是正向dp还是逆向dp，均有值优先于dp[i]先更新（dp[i - 1]和dp[i + 1]会比dp[i]先更新），所以采用两个dp数组的方式，初始值dp[0]=1。每两次dp完后，dp[0]的值及为答案。</p><h1 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 2100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MOD (int)(1e9 + 7)</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br>ll dp[MAXN][<span class="hljs-number">2</span>];<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">trans</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-keyword">return</span> x + <span class="hljs-number">1000</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ACM_LOCAL</span><br>    freopen(<span class="hljs-string">&quot;debug.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, <span class="hljs-built_in">stdin</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    ios::sync_with_stdio(<span class="hljs-literal">false</span>);<br>    <span class="hljs-type">int</span> n, m;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; n &gt;&gt; m) &#123;<br>        <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(dp));<br>        dp[n][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> last = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * (n + m); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = -n; j &lt;= m; j++) &#123;<br>                <span class="hljs-keyword">if</span> (j != -n) &#123;<br>                    dp[j + n][cur] += dp[j - <span class="hljs-number">1</span> + n][last];<br>                    dp[j + n][cur] %= MOD;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (j != m) &#123;<br>                    dp[j + n][cur] += dp[j + <span class="hljs-number">1</span> + n][last];<br>                    dp[j + n][cur] %= MOD;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = -n; j &lt;= m; j++) &#123;<br>                dp[j + n][last] = <span class="hljs-number">0</span>;<br>            &#125;<br>            swap(cur, last);<br>        &#125;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; dp[n][last] &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>NowCoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HDU2883 kebab——最大流</title>
    <link href="/2019/07/11/acm/other-note/HDU2883-kebab-max-flow/"/>
    <url>/2019/07/11/acm/other-note/HDU2883-kebab-max-flow/</url>
    
    <content type="html"><![CDATA[<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=2883">题目链接</a></p><p><strong>把“时间粒子”作为最大流的计算结果</strong></p><p>设置超级源点为 0<br>顾客点范围为 1 - 204<br>时间点       205 - 610<br>超级汇点     615<br>超级源点与所有顾客连线，容量为需求的烤肉数 * 需求的每块烤肉的时间（即此顾客需要占用的总时间粒子）<br>顾客与时间点进行连线，仅当此时间点在顾客等待的时间段内，容量为INF<br>每个时间点与汇点连线，容量为 m </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 最大流 SAP 算法，用 GAP 优化后</span><br><span class="hljs-comment"> * 先把流量限制赋值到 maps 数组</span><br><span class="hljs-comment"> * 然后调用 SAP 函数求解</span><br><span class="hljs-comment"> * 可选：导出路径</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 620</span><br><br><span class="hljs-type">int</span> maps[MAXN][MAXN]; <span class="hljs-comment">// 存图</span><br><span class="hljs-type">int</span> pre[MAXN];        <span class="hljs-comment">// 记录当前点的前驱</span><br><span class="hljs-type">int</span> level[MAXN];      <span class="hljs-comment">// 记录距离标号</span><br><span class="hljs-type">int</span> gap[MAXN];        <span class="hljs-comment">// gap常数优化</span><br><br><span class="hljs-comment">// vector&lt;int&gt; roads[MAXN]; // 导出的路径（逆序）</span><br><span class="hljs-comment">// int curRoads;            // 导出的路径数</span><br><br><span class="hljs-comment">// 入口参数vs源点，vt汇点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SAP</span><span class="hljs-params">(<span class="hljs-type">int</span> vs, <span class="hljs-type">int</span> vt)</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(pre, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(pre));<br>    <span class="hljs-built_in">memset</span>(level, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(level));<br>    <span class="hljs-built_in">memset</span>(gap, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(gap));<br>    gap[<span class="hljs-number">0</span>] = vt;<br>    <span class="hljs-type">int</span> v, u = pre[vs] = vs, maxflow = <span class="hljs-number">0</span>, aug = INT_MAX;<br>    <span class="hljs-comment">// curRoads = 0;</span><br>    <span class="hljs-keyword">while</span> (level[vs] &lt; vt) &#123;<br>        <span class="hljs-comment">// 寻找可行弧</span><br>        <span class="hljs-keyword">for</span> (v = <span class="hljs-number">1</span>; v &lt;= vt; v++) &#123;<br>            <span class="hljs-keyword">if</span> (maps[u][v] &gt; <span class="hljs-number">0</span> &amp;&amp; level[u] == level[v] + <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (v &lt;= vt) &#123;<br>            pre[v] = u;<br>            u = v;<br>            <span class="hljs-keyword">if</span> (v == vt) &#123;<br>                <span class="hljs-comment">// int neck = 0;        // Dnic 多路增广优化，下次增广时，从瓶颈边(后面)开始</span><br>                aug = INT_MAX;<br>                <span class="hljs-comment">// 寻找当前找到的一条路径上的最大流  (瓶颈边)</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = v; i != vs; i = pre[i]) &#123;<br>                    <span class="hljs-comment">// roads[curRoads].push_back(i);    // 导出路径——可选</span><br>                    <span class="hljs-keyword">if</span> (aug &gt; maps[pre[i]][i]) &#123;<br>                        aug = maps[pre[i]][i];<br>                        <span class="hljs-comment">// neck = i;        // Dnic 多路增广优化，下次增广时，从瓶颈边(后面)开始</span><br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// roads[curRoads++].push_back(vs);         // 导出路径——可选</span><br>                maxflow += aug;<br>                <span class="hljs-comment">// 更新残留网络</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = v; i != vs; i = pre[i]) &#123;<br>                    maps[pre[i]][i] -= aug;<br>                    maps[i][pre[i]] += aug;<br>                &#125;<br>                <span class="hljs-comment">// 从源点开始继续搜</span><br>                u = vs;<br>                <span class="hljs-comment">// u = neck;    // Dnic 多路增广优化，下次增广时，从瓶颈边(后面)开始</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 找不到可行弧</span><br>            <span class="hljs-type">int</span> minlevel = vt;<br>            <span class="hljs-comment">// 寻找与当前点相连接的点中最小的距离标号</span><br>            <span class="hljs-keyword">for</span> (v = <span class="hljs-number">1</span>; v &lt;= vt; v++) &#123;<br>                <span class="hljs-keyword">if</span> (maps[u][v] &gt; <span class="hljs-number">0</span> &amp;&amp; minlevel &gt; level[v]) &#123;<br>                    minlevel = level[v];<br>                &#125;<br>            &#125;<br>            gap[level[u]]--; <span class="hljs-comment">// (更新gap数组）当前标号的数目减1；</span><br>            <span class="hljs-keyword">if</span> (gap[level[u]] == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 出现断层</span><br>            level[u] = minlevel + <span class="hljs-number">1</span>;<br>            gap[level[u]]++;<br>            u = pre[u];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxflow;<br>&#125;<br><br><span class="hljs-comment">// 超级源点     0</span><br><span class="hljs-comment">// 顾客点       1 - 204</span><br><span class="hljs-comment">// 时间点       205 - 610</span><br><span class="hljs-comment">// 超级汇点     615</span><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MaxPeople = <span class="hljs-number">210</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> Ed = <span class="hljs-number">615</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">costman</span> &#123;<br>    <span class="hljs-type">int</span> b, e, need, time;<br>&#125;;<br>set&lt;<span class="hljs-type">int</span>&gt; timelist;<br>costman costmanlist[MaxPeople];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(maps, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(maps));<br>    set&lt;<span class="hljs-type">int</span>&gt;::iterator iterl = timelist.<span class="hljs-built_in">begin</span>();<br>    set&lt;<span class="hljs-type">int</span>&gt;::iterator iterr = timelist.<span class="hljs-built_in">begin</span>();<br>    iterr++;<br>    <span class="hljs-type">int</span> curiter = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        maps[<span class="hljs-number">0</span>][i + <span class="hljs-number">1</span>] = costmanlist[i].need * costmanlist[i].time;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (iterr != timelist.<span class="hljs-built_in">end</span>()) &#123;<br>        maps[<span class="hljs-number">205</span> + curiter][Ed] = ((*iterr) - (*iterl)) * m;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (costmanlist[i].b &lt;= *iterl &amp;&amp; costmanlist[i].e &gt;= *iterr) &#123;<br>                maps[i + <span class="hljs-number">1</span>][curiter + <span class="hljs-number">205</span>] = INT_MAX;<br>            &#125;<br>        &#125;<br>        iterl++;<br>        iterr++;<br>        curiter++;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ACM_LOCAL</span><br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;./in.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, stdin);<br>    <span class="hljs-built_in">freopen</span>(<span class="hljs-string">&quot;./out.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, stdout);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; n &gt;&gt; m) &#123;<br>        timelist.<span class="hljs-built_in">clear</span>();<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            cin &gt;&gt; costmanlist[i].b &gt;&gt; costmanlist[i].need &gt;&gt; costmanlist[i].e &gt;&gt; costmanlist[i].time;<br>            sum += costmanlist[i].need * costmanlist[i].time;<br>            timelist.<span class="hljs-built_in">insert</span>(costmanlist[i].b);<br>            timelist.<span class="hljs-built_in">insert</span>(costmanlist[i].e);<br>        &#125;<br>        <span class="hljs-built_in">init</span>();<br>        cout &lt;&lt; (sum == <span class="hljs-built_in">SAP</span>(<span class="hljs-number">0</span>, Ed) ? <span class="hljs-string">&quot;Yes&quot;</span> : <span class="hljs-string">&quot;No&quot;</span>) &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
      <tag>HDU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2019年-西北大学集训队选拔赛——D温暖的签到题</title>
    <link href="/2019/07/11/acm/other-note/NWUTrainingTeamTrial-D%20warm%20sign-in/"/>
    <url>/2019/07/11/acm/other-note/NWUTrainingTeamTrial-D%20warm%20sign-in/</url>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/892/D">题目链接</a></p><p>一道珂朵莉树题，非常有意思</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NUM</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node</span> &#123;</span><br>    <span class="hljs-type">int</span> l;<br>    <span class="hljs-type">int</span> sta;<span class="hljs-comment">//第一个值</span><br>    <span class="hljs-type">int</span> r;<span class="hljs-comment">//长度</span><br><br>    ll <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;        <span class="hljs-comment">// 区间求和</span><br>        <span class="hljs-keyword">if</span> (l &lt; this-&gt;l) l = this-&gt;l;<br>        <span class="hljs-keyword">if</span> (r &gt; this-&gt;r) r = this-&gt;r;<br>        <span class="hljs-keyword">return</span> (((l - this-&gt;l) + sta + (r - this-&gt;l) + sta)) * ((ll) r - l + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-built_in">map</span>&lt;<span class="hljs-type">int</span>, node&gt; mp;    <span class="hljs-comment">// 利用map自动排序，形成一个一维的块链，每一个块为一个给定规则的数据组成</span><br><br>ll <span class="hljs-title function_">cal</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;        <span class="hljs-comment">// 计算区间和，直接调用块内的自定义函数求和</span><br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-type">int</span>, node&gt;::iterator itl = mp.upper_bound(l);<br>    itl--;<br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-type">int</span>, node&gt;::iterator itr = mp.upper_bound(r);<br>    ll ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (itl != itr) &#123;<br>        ans += (*itl).second.sum(l, r);<br>        itl++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;        <span class="hljs-comment">// 更新块，删除被覆盖的块，形成新块</span><br>    <span class="hljs-keyword">if</span> (r == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-type">int</span>, node&gt;::iterator itl = mp.upper_bound(l);<br>    itl--;<br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-type">int</span>, node&gt;::iterator itr = mp.upper_bound(r);<br>    itr--;<br>    node templ = (*itl).second;<br>    node tempr = (*itr).second;<br>    tempr.sta = tempr.sta + (r + <span class="hljs-number">1</span> - tempr.l);<br>    templ.r = l - <span class="hljs-number">1</span>;<br>    tempr.l = r + <span class="hljs-number">1</span>;<br>    itr++;<br>    <span class="hljs-keyword">while</span> (itl != itr) &#123;<br>        <span class="hljs-keyword">auto</span> tmp = itl++;<br>        mp.erase(tmp);<br>    &#125;<br>    node newnode;<br>    newnode.l = l;<br>    newnode.r = r;<br>    newnode.sta = <span class="hljs-number">1</span>;<br>    mp[l] = newnode;<br>    <span class="hljs-keyword">if</span> (templ.l &lt;= templ.r) &#123;<br>        mp[templ.l] = templ;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (tempr.l &lt;= tempr.r) &#123;<br>        mp[tempr.l] = tempr;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-type">int</span> opt, l, r;<br>    node tot;<br>    tot.l = <span class="hljs-number">1</span>;<br>    tot.r = n;<br>    tot.sta = <span class="hljs-number">1</span>;<br>    mp[<span class="hljs-number">1</span>] = tot;<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;opt, &amp;l, &amp;r);<br>        <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">1</span>)<br>            update(l, r);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, cal(l, r));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM&amp;算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ACM</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
